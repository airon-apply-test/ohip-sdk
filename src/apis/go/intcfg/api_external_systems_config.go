/*
OPERA Cloud Integration Configuration API

APIs catering to Integration Configuration in OPERA Cloud.  Operations such as get Hotel Interface Types, or get UDF mappings can be found in this module.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ExternalSystemsConfigApiService ExternalSystemsConfigApi service
type ExternalSystemsConfigApiService service

type ApiClearCacheRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiClearCacheRequest) Authorization(authorization string) ApiClearCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiClearCacheRequest) XAppKey(xAppKey string) ApiClearCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiClearCacheRequest) XHotelid(xHotelid string) ApiClearCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiClearCacheRequest) XExternalsystem(xExternalsystem string) ApiClearCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiClearCacheRequest) AcceptLanguage(acceptLanguage string) ApiClearCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiClearCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ClearCacheExecute(r)
}

/*
ClearCache Operation to clear cache.

 <p><strong>OperationId:</strong>clearCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClearCacheRequest
*/
func (a *ExternalSystemsConfigApiService) ClearCache(ctx context.Context) ApiClearCacheRequest {
	return ApiClearCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) ClearCacheExecute(r ApiClearCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.ClearCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/config/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	type_ *string
	options *[]string
	configurationId *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteDeliveryMethodsRequest) Authorization(authorization string) ApiDeleteDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteDeliveryMethodsRequest) XAppKey(xAppKey string) ApiDeleteDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteDeliveryMethodsRequest) XHotelid(xHotelid string) ApiDeleteDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiDeleteDeliveryMethodsRequest) HotelId(hotelId string) ApiDeleteDeliveryMethodsRequest {
	r.hotelId = &hotelId
	return r
}

// Settings for Text Message Delivery of Queue Reservation status
func (r ApiDeleteDeliveryMethodsRequest) Type_(type_ string) ApiDeleteDeliveryMethodsRequest {
	r.type_ = &type_
	return r
}

// SFTP delivery configurations
func (r ApiDeleteDeliveryMethodsRequest) Options(options []string) ApiDeleteDeliveryMethodsRequest {
	r.options = &options
	return r
}

// Unique id associated with this configuration
func (r ApiDeleteDeliveryMethodsRequest) ConfigurationId(configurationId []int32) ApiDeleteDeliveryMethodsRequest {
	r.configurationId = &configurationId
	return r
}

// External system code.
func (r ApiDeleteDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ApiDeleteDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteDeliveryMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDeliveryMethodsExecute(r)
}

/*
DeleteDeliveryMethods Operation to remove delivery methods.

 <p><strong>OperationId:</strong>deleteDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) DeleteDeliveryMethods(ctx context.Context) ApiDeleteDeliveryMethodsRequest {
	return ApiDeleteDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeleteDeliveryMethodsExecute(r ApiDeleteDeliveryMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeleteDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.options != nil {
		t := *r.options
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "options", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "options", t, "multi")
		}
	}
	if r.configurationId != nil {
		t := *r.configurationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteHotelInterfaceRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	logo *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteHotelInterfaceRequest) Authorization(authorization string) ApiDeleteHotelInterfaceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteHotelInterfaceRequest) XAppKey(xAppKey string) ApiDeleteHotelInterfaceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteHotelInterfaceRequest) XHotelid(xHotelid string) ApiDeleteHotelInterfaceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Interface Logo. On the database, this is also referred as DBF Logo. This is a three letter code followed by an underscore(_). This tells us which DBF files and log files with the prefix that IFC7 is going to create.
func (r ApiDeleteHotelInterfaceRequest) Logo(logo string) ApiDeleteHotelInterfaceRequest {
	r.logo = &logo
	return r
}

// External system code.
func (r ApiDeleteHotelInterfaceRequest) XExternalsystem(xExternalsystem string) ApiDeleteHotelInterfaceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteHotelInterfaceRequest) AcceptLanguage(acceptLanguage string) ApiDeleteHotelInterfaceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteHotelInterfaceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelInterfaceExecute(r)
}

/*
DeleteHotelInterface Operation to remove hotel interface.

 <p><strong>OperationId:</strong>deleteHotelInterface</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return ApiDeleteHotelInterfaceRequest
*/
func (a *ExternalSystemsConfigApiService) DeleteHotelInterface(ctx context.Context, hotelId string) ApiDeleteHotelInterfaceRequest {
	return ApiDeleteHotelInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeleteHotelInterfaceExecute(r ApiDeleteHotelInterfaceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeleteHotelInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hotelInerface"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.logo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logo", r.logo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInterfaceRightRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	right *int32
	code *string
	description *string
	interfaceRightDescription *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteInterfaceRightRequest) Authorization(authorization string) ApiDeleteInterfaceRightRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteInterfaceRightRequest) XAppKey(xAppKey string) ApiDeleteInterfaceRightRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteInterfaceRightRequest) XHotelid(xHotelid string) ApiDeleteInterfaceRightRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code to which the Interface Right belongs to.
func (r ApiDeleteInterfaceRightRequest) HotelId(hotelId string) ApiDeleteInterfaceRightRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteInterfaceRightRequest) Id(id string) ApiDeleteInterfaceRightRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeleteInterfaceRightRequest) IdExtension(idExtension int32) ApiDeleteInterfaceRightRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeleteInterfaceRightRequest) IdContext(idContext string) ApiDeleteInterfaceRightRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeleteInterfaceRightRequest) Type_(type_ string) ApiDeleteInterfaceRightRequest {
	r.type_ = &type_
	return r
}

// Internal code for each allowed right of a Hotel Interface record.
func (r ApiDeleteInterfaceRightRequest) Right(right int32) ApiDeleteInterfaceRightRequest {
	r.right = &right
	return r
}

// User defined code for an Interface Right.
func (r ApiDeleteInterfaceRightRequest) Code(code string) ApiDeleteInterfaceRightRequest {
	r.code = &code
	return r
}

// User defined description for an Interface Right.
func (r ApiDeleteInterfaceRightRequest) Description(description string) ApiDeleteInterfaceRightRequest {
	r.description = &description
	return r
}

// System Description of an allowed Interface Right.
func (r ApiDeleteInterfaceRightRequest) InterfaceRightDescription(interfaceRightDescription string) ApiDeleteInterfaceRightRequest {
	r.interfaceRightDescription = &interfaceRightDescription
	return r
}

// External system code.
func (r ApiDeleteInterfaceRightRequest) XExternalsystem(xExternalsystem string) ApiDeleteInterfaceRightRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteInterfaceRightRequest) AcceptLanguage(acceptLanguage string) ApiDeleteInterfaceRightRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteInterfaceRightRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteInterfaceRightExecute(r)
}

/*
DeleteInterfaceRight Operation to remove interface right.

 <p><strong>OperationId:</strong>deleteInterfaceRight</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteInterfaceRightRequest
*/
func (a *ExternalSystemsConfigApiService) DeleteInterfaceRight(ctx context.Context) ApiDeleteInterfaceRightRequest {
	return ApiDeleteInterfaceRightRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeleteInterfaceRightExecute(r ApiDeleteInterfaceRightRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeleteInterfaceRight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.right != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right", r.right, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.interfaceRightDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceRightDescription", r.interfaceRightDescription, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePublisherRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	hotelId string
	externalSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	subscriberHotelId *string
	code *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeletePublisherRequest) Authorization(authorization string) ApiDeletePublisherRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeletePublisherRequest) XAppKey(xAppKey string) ApiDeletePublisherRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeletePublisherRequest) XHotelid(xHotelid string) ApiDeletePublisherRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiDeletePublisherRequest) SubscriberHotelId(subscriberHotelId string) ApiDeletePublisherRequest {
	r.subscriberHotelId = &subscriberHotelId
	return r
}

func (r ApiDeletePublisherRequest) Code(code string) ApiDeletePublisherRequest {
	r.code = &code
	return r
}

// External system code.
func (r ApiDeletePublisherRequest) XExternalsystem(xExternalsystem string) ApiDeletePublisherRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeletePublisherRequest) AcceptLanguage(acceptLanguage string) ApiDeletePublisherRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeletePublisherRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePublisherExecute(r)
}

/*
DeletePublisher Operation to remove publisher.

 <p><strong>OperationId:</strong>deletePublisher</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Id used to find a property in OPERA.
 @param externalSystemCode Unique OPERA Code used to find External System in OPERA.
 @return ApiDeletePublisherRequest
*/
func (a *ExternalSystemsConfigApiService) DeletePublisher(ctx context.Context, hotelId string, externalSystemCode string) ApiDeletePublisherRequest {
	return ApiDeletePublisherRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		externalSystemCode: externalSystemCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeletePublisherExecute(r ApiDeletePublisherRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeletePublisher")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{externalSystemCode}/hotels/{hotelId}/publishers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.subscriberHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subscriberHotelId", r.subscriberHotelId, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	croCode *string
	usages *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDeliveryMethodsRequest) Authorization(authorization string) ApiGetDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDeliveryMethodsRequest) XAppKey(xAppKey string) ApiGetDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDeliveryMethodsRequest) XHotelid(xHotelid string) ApiGetDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property code.
func (r ApiGetDeliveryMethodsRequest) HotelId(hotelId string) ApiGetDeliveryMethodsRequest {
	r.hotelId = &hotelId
	return r
}

// CRO code.
func (r ApiGetDeliveryMethodsRequest) CroCode(croCode string) ApiGetDeliveryMethodsRequest {
	r.croCode = &croCode
	return r
}

// Settings for Text Message Delivery of Queue Reservation status
func (r ApiGetDeliveryMethodsRequest) Usages(usages []string) ApiGetDeliveryMethodsRequest {
	r.usages = &usages
	return r
}

// If true this will include inactive records(This is only applicable for general SMTP delivery method ).
func (r ApiGetDeliveryMethodsRequest) IncludeInactive(includeInactive bool) ApiGetDeliveryMethodsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ApiGetDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ApiGetDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDeliveryMethodsRequest) Execute() (*FetchedDeliveryMethods, *http.Response, error) {
	return r.ApiService.GetDeliveryMethodsExecute(r)
}

/*
GetDeliveryMethods Operation to fetch delivery methods.

 <p><strong>OperationId:</strong>getDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) GetDeliveryMethods(ctx context.Context) ApiGetDeliveryMethodsRequest {
	return ApiGetDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedDeliveryMethods
func (a *ExternalSystemsConfigApiService) GetDeliveryMethodsExecute(r ApiGetDeliveryMethodsRequest) (*FetchedDeliveryMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedDeliveryMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.usages != nil {
		t := *r.usages
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usages", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usages", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalDatabaseAvailablePropertiesRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	databaseId string
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	interfaceCodes *[]string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExternalDatabaseAvailablePropertiesRequest) Authorization(authorization string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExternalDatabaseAvailablePropertiesRequest) XAppKey(xAppKey string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExternalDatabaseAvailablePropertiesRequest) XHotelid(xHotelid string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag that indicates to include inactive records.
func (r ApiGetExternalDatabaseAvailablePropertiesRequest) IncludeInactive(includeInactive bool) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r ApiGetExternalDatabaseAvailablePropertiesRequest) InterfaceCodes(interfaceCodes []string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.interfaceCodes = &interfaceCodes
	return r
}

func (r ApiGetExternalDatabaseAvailablePropertiesRequest) HotelIds(hotelIds []string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ApiGetExternalDatabaseAvailablePropertiesRequest) XExternalsystem(xExternalsystem string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExternalDatabaseAvailablePropertiesRequest) AcceptLanguage(acceptLanguage string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExternalDatabaseAvailablePropertiesRequest) Execute() (*FetchedExternalDatabaseAvailableProperties, *http.Response, error) {
	return r.ApiService.GetExternalDatabaseAvailablePropertiesExecute(r)
}

/*
GetExternalDatabaseAvailableProperties Operation to fetch external database available properties.

 <p><strong>OperationId:</strong>getExternalDatabaseAvailableProperties</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId OPERA Id for Databsase
 @param interfaceId OPERA Id for interface
 @return ApiGetExternalDatabaseAvailablePropertiesRequest
*/
func (a *ExternalSystemsConfigApiService) GetExternalDatabaseAvailableProperties(ctx context.Context, databaseId string, interfaceId string) ApiGetExternalDatabaseAvailablePropertiesRequest {
	return ApiGetExternalDatabaseAvailablePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return FetchedExternalDatabaseAvailableProperties
func (a *ExternalSystemsConfigApiService) GetExternalDatabaseAvailablePropertiesExecute(r ApiGetExternalDatabaseAvailablePropertiesRequest) (*FetchedExternalDatabaseAvailableProperties, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedExternalDatabaseAvailableProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetExternalDatabaseAvailableProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/databases/{databaseId}/availableResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"databaseId"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.databaseId) < 1 {
		return localVarReturnValue, nil, reportError("databaseId must have at least 1 elements")
	}
	if strlen(r.databaseId) > 2000 {
		return localVarReturnValue, nil, reportError("databaseId must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.interfaceCodes != nil {
		t := *r.interfaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceCodes", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfaceControllerRegistryRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	machine *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfaceControllerRegistryRequest) Authorization(authorization string) ApiGetHotelInterfaceControllerRegistryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfaceControllerRegistryRequest) XAppKey(xAppKey string) ApiGetHotelInterfaceControllerRegistryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfaceControllerRegistryRequest) XHotelid(xHotelid string) ApiGetHotelInterfaceControllerRegistryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for Character Strings, length 0 to 40.
func (r ApiGetHotelInterfaceControllerRegistryRequest) Machine(machine string) ApiGetHotelInterfaceControllerRegistryRequest {
	r.machine = &machine
	return r
}

// External system code.
func (r ApiGetHotelInterfaceControllerRegistryRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfaceControllerRegistryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfaceControllerRegistryRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfaceControllerRegistryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfaceControllerRegistryRequest) Execute() (*FetchedHotelInterfaceControllerRegistry, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceControllerRegistryExecute(r)
}

/*
GetHotelInterfaceControllerRegistry Operation to fetch hotel interface controller registry.

 <p><strong>OperationId:</strong>getHotelInterfaceControllerRegistry</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHotelInterfaceControllerRegistryRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceControllerRegistry(ctx context.Context) ApiGetHotelInterfaceControllerRegistryRequest {
	return ApiGetHotelInterfaceControllerRegistryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceControllerRegistry
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceControllerRegistryExecute(r ApiGetHotelInterfaceControllerRegistryRequest) (*FetchedHotelInterfaceControllerRegistry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceControllerRegistry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceControllerRegistry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceControllerRegistry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.machine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "machine", r.machine, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfaceErrorsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	interfaceTypes *[]string
	logoCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfaceErrorsRequest) Authorization(authorization string) ApiGetHotelInterfaceErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfaceErrorsRequest) XAppKey(xAppKey string) ApiGetHotelInterfaceErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfaceErrorsRequest) XHotelid(xHotelid string) ApiGetHotelInterfaceErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetHotelInterfaceErrorsRequest) Limit(limit int32) ApiGetHotelInterfaceErrorsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetHotelInterfaceErrorsRequest) Offset(offset int32) ApiGetHotelInterfaceErrorsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetHotelInterfaceErrorsRequest) HotelIds(hotelIds []string) ApiGetHotelInterfaceErrorsRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ApiGetHotelInterfaceErrorsRequest) InterfaceTypes(interfaceTypes []string) ApiGetHotelInterfaceErrorsRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ApiGetHotelInterfaceErrorsRequest) LogoCodes(logoCodes []string) ApiGetHotelInterfaceErrorsRequest {
	r.logoCodes = &logoCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ApiGetHotelInterfaceErrorsRequest) IncludeInactive(includeInactive bool) ApiGetHotelInterfaceErrorsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetHotelInterfaceErrorsRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfaceErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfaceErrorsRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfaceErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfaceErrorsRequest) Execute() (*FetchedHotelInterfaceErrors, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceErrorsExecute(r)
}

/*
GetHotelInterfaceErrors Operation to fetch hotel interface errors.

 <p><strong>OperationId:</strong>getHotelInterfaceErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHotelInterfaceErrorsRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceErrors(ctx context.Context) ApiGetHotelInterfaceErrorsRequest {
	return ApiGetHotelInterfaceErrorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceErrors
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceErrorsExecute(r ApiGetHotelInterfaceErrorsRequest) (*FetchedHotelInterfaceErrors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceErrors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceErrors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logoCodes != nil {
		t := *r.logoCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfaceFailedMessagesRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	interfaceTypes *[]string
	logoCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfaceFailedMessagesRequest) Authorization(authorization string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfaceFailedMessagesRequest) XAppKey(xAppKey string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfaceFailedMessagesRequest) XHotelid(xHotelid string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetHotelInterfaceFailedMessagesRequest) Limit(limit int32) ApiGetHotelInterfaceFailedMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetHotelInterfaceFailedMessagesRequest) Offset(offset int32) ApiGetHotelInterfaceFailedMessagesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetHotelInterfaceFailedMessagesRequest) HotelIds(hotelIds []string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ApiGetHotelInterfaceFailedMessagesRequest) InterfaceTypes(interfaceTypes []string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ApiGetHotelInterfaceFailedMessagesRequest) LogoCodes(logoCodes []string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.logoCodes = &logoCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ApiGetHotelInterfaceFailedMessagesRequest) IncludeInactive(includeInactive bool) ApiGetHotelInterfaceFailedMessagesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetHotelInterfaceFailedMessagesRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfaceFailedMessagesRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfaceFailedMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfaceFailedMessagesRequest) Execute() (*FetchedHotelInterfaceFailedMessages, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceFailedMessagesExecute(r)
}

/*
GetHotelInterfaceFailedMessages Operation to fetch hotel interface failed messages.

 <p><strong>OperationId:</strong>getHotelInterfaceFailedMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHotelInterfaceFailedMessagesRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceFailedMessages(ctx context.Context) ApiGetHotelInterfaceFailedMessagesRequest {
	return ApiGetHotelInterfaceFailedMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceFailedMessages
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceFailedMessagesExecute(r ApiGetHotelInterfaceFailedMessagesRequest) (*FetchedHotelInterfaceFailedMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceFailedMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceFailedMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceFailedMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logoCodes != nil {
		t := *r.logoCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfaceSchemasRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	interfaceTypes *[]string
	logoCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfaceSchemasRequest) Authorization(authorization string) ApiGetHotelInterfaceSchemasRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfaceSchemasRequest) XAppKey(xAppKey string) ApiGetHotelInterfaceSchemasRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfaceSchemasRequest) XHotelid(xHotelid string) ApiGetHotelInterfaceSchemasRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetHotelInterfaceSchemasRequest) Limit(limit int32) ApiGetHotelInterfaceSchemasRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetHotelInterfaceSchemasRequest) Offset(offset int32) ApiGetHotelInterfaceSchemasRequest {
	r.offset = &offset
	return r
}

func (r ApiGetHotelInterfaceSchemasRequest) HotelIds(hotelIds []string) ApiGetHotelInterfaceSchemasRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ApiGetHotelInterfaceSchemasRequest) InterfaceTypes(interfaceTypes []string) ApiGetHotelInterfaceSchemasRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ApiGetHotelInterfaceSchemasRequest) LogoCodes(logoCodes []string) ApiGetHotelInterfaceSchemasRequest {
	r.logoCodes = &logoCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ApiGetHotelInterfaceSchemasRequest) IncludeInactive(includeInactive bool) ApiGetHotelInterfaceSchemasRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetHotelInterfaceSchemasRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfaceSchemasRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfaceSchemasRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfaceSchemasRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfaceSchemasRequest) Execute() (*FetchedHotelInterfaceSchemas, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceSchemasExecute(r)
}

/*
GetHotelInterfaceSchemas Operation to fetch hotel interface schemas.

 <p><strong>OperationId:</strong>getHotelInterfaceSchemas</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHotelInterfaceSchemasRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceSchemas(ctx context.Context) ApiGetHotelInterfaceSchemasRequest {
	return ApiGetHotelInterfaceSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceSchemas
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceSchemasExecute(r ApiGetHotelInterfaceSchemasRequest) (*FetchedHotelInterfaceSchemas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceSchemas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceSchemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logoCodes != nil {
		t := *r.logoCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfacesRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	interfaceTypes *[]string
	logosCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfacesRequest) Authorization(authorization string) ApiGetHotelInterfacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfacesRequest) XAppKey(xAppKey string) ApiGetHotelInterfacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfacesRequest) XHotelid(xHotelid string) ApiGetHotelInterfacesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetHotelInterfacesRequest) HotelIds(hotelIds []string) ApiGetHotelInterfacesRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ApiGetHotelInterfacesRequest) InterfaceTypes(interfaceTypes []string) ApiGetHotelInterfacesRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ApiGetHotelInterfacesRequest) LogosCodes(logosCodes []string) ApiGetHotelInterfacesRequest {
	r.logosCodes = &logosCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ApiGetHotelInterfacesRequest) IncludeInactive(includeInactive bool) ApiGetHotelInterfacesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetHotelInterfacesRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfacesRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfacesRequest) Execute() (*FetchedHotelInterfaces, *http.Response, error) {
	return r.ApiService.GetHotelInterfacesExecute(r)
}

/*
GetHotelInterfaces Operation to fetch hotel interfaces.

 <p><strong>OperationId:</strong>getHotelInterfaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHotelInterfacesRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaces(ctx context.Context) ApiGetHotelInterfacesRequest {
	return ApiGetHotelInterfacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaces
func (a *ExternalSystemsConfigApiService) GetHotelInterfacesExecute(r ApiGetHotelInterfacesRequest) (*FetchedHotelInterfaces, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelInterfaceTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logosCodes != nil {
		t := *r.logosCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logosCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logosCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceRightsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceRightsRequest) Authorization(authorization string) ApiGetInterfaceRightsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceRightsRequest) XAppKey(xAppKey string) ApiGetInterfaceRightsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceRightsRequest) XHotelid(xHotelid string) ApiGetInterfaceRightsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiGetInterfaceRightsRequest) HotelId(hotelId string) ApiGetInterfaceRightsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInterfaceRightsRequest) Id(id string) ApiGetInterfaceRightsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiGetInterfaceRightsRequest) IdExtension(idExtension int32) ApiGetInterfaceRightsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInterfaceRightsRequest) IdContext(idContext string) ApiGetInterfaceRightsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInterfaceRightsRequest) Type_(type_ string) ApiGetInterfaceRightsRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiGetInterfaceRightsRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceRightsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceRightsRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceRightsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceRightsRequest) Execute() ([]InterfaceRightType, *http.Response, error) {
	return r.ApiService.GetInterfaceRightsExecute(r)
}

/*
GetInterfaceRights Operation to fetch interface rights.

 <p><strong>OperationId:</strong>getInterfaceRights</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInterfaceRightsRequest
*/
func (a *ExternalSystemsConfigApiService) GetInterfaceRights(ctx context.Context) ApiGetInterfaceRightsRequest {
	return ApiGetInterfaceRightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceRightType
func (a *ExternalSystemsConfigApiService) GetInterfaceRightsExecute(r ApiGetInterfaceRightsRequest) ([]InterfaceRightType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceRightType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetInterfaceRights")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublishersRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	externalSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPublishersRequest) Authorization(authorization string) ApiGetPublishersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPublishersRequest) XAppKey(xAppKey string) ApiGetPublishersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPublishersRequest) XHotelid(xHotelid string) ApiGetPublishersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetPublishersRequest) HotelId(hotelId string) ApiGetPublishersRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ApiGetPublishersRequest) XExternalsystem(xExternalsystem string) ApiGetPublishersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPublishersRequest) AcceptLanguage(acceptLanguage string) ApiGetPublishersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPublishersRequest) Execute() (*FetchedPublishers, *http.Response, error) {
	return r.ApiService.GetPublishersExecute(r)
}

/*
GetPublishers Operation to fetch publishers.

 <p><strong>OperationId:</strong>getPublishers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalSystemCode Unique OPERA Code used to find External System in OPERA.
 @return ApiGetPublishersRequest
*/
func (a *ExternalSystemsConfigApiService) GetPublishers(ctx context.Context, externalSystemCode string) ApiGetPublishersRequest {
	return ApiGetPublishersRequest{
		ApiService: a,
		ctx: ctx,
		externalSystemCode: externalSystemCode,
	}
}

// Execute executes the request
//  @return FetchedPublishers
func (a *ExternalSystemsConfigApiService) GetPublishersExecute(r ApiGetPublishersRequest) (*FetchedPublishers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedPublishers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetPublishers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{externalSystemCode}/publishers"
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUDFMappingsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	type_ *string
	uDFName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUDFMappingsRequest) Authorization(authorization string) ApiGetUDFMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUDFMappingsRequest) XAppKey(xAppKey string) ApiGetUDFMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUDFMappingsRequest) XHotelid(xHotelid string) ApiGetUDFMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A reference to the type of object defined by the Type for Reservation and Profile Type.
func (r ApiGetUDFMappingsRequest) Type_(type_ string) ApiGetUDFMappingsRequest {
	r.type_ = &type_
	return r
}

// Name of the user-defined function (UDF) field.
func (r ApiGetUDFMappingsRequest) UDFName(uDFName string) ApiGetUDFMappingsRequest {
	r.uDFName = &uDFName
	return r
}

// External system code.
func (r ApiGetUDFMappingsRequest) XExternalsystem(xExternalsystem string) ApiGetUDFMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUDFMappingsRequest) AcceptLanguage(acceptLanguage string) ApiGetUDFMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUDFMappingsRequest) Execute() (*FetchedUDFMappings, *http.Response, error) {
	return r.ApiService.GetUDFMappingsExecute(r)
}

/*
GetUDFMappings Operation to send a response to the Look up of UDFs.

Operation to send a response to the Look-up of UDFs. <p><strong>OperationId:</strong>getUDFMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUDFMappingsRequest
*/
func (a *ExternalSystemsConfigApiService) GetUDFMappings(ctx context.Context) ApiGetUDFMappingsRequest {
	return ApiGetUDFMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedUDFMappings
func (a *ExternalSystemsConfigApiService) GetUDFMappingsExecute(r ApiGetUDFMappingsRequest) (*FetchedUDFMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedUDFMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetUDFMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/udfMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.uDFName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uDFName", r.uDFName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPingRequest) Authorization(authorization string) ApiPingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPingRequest) XAppKey(xAppKey string) ApiPingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPingRequest) XHotelid(xHotelid string) ApiPingRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiPingRequest) XExternalsystem(xExternalsystem string) ApiPingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPingRequest) AcceptLanguage(acceptLanguage string) ApiPingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPingRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping Operation to ping.

 <p><strong>OperationId:</strong>ping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingRequest
*/
func (a *ExternalSystemsConfigApiService) Ping(ctx context.Context) ApiPingRequest {
	return ApiPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *ExternalSystemsConfigApiService) PingExecute(r ApiPingRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.Ping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/config/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	createDeliveryMethods *PostDeliveryMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostDeliveryMethodsRequest) Authorization(authorization string) ApiPostDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostDeliveryMethodsRequest) XAppKey(xAppKey string) ApiPostDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostDeliveryMethodsRequest) XHotelid(xHotelid string) ApiPostDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create the delivery method for a property/HUB/Chain and its configurations.
func (r ApiPostDeliveryMethodsRequest) CreateDeliveryMethods(createDeliveryMethods PostDeliveryMethodsRequest) ApiPostDeliveryMethodsRequest {
	r.createDeliveryMethods = &createDeliveryMethods
	return r
}

// External system code.
func (r ApiPostDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ApiPostDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ApiPostDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostDeliveryMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDeliveryMethodsExecute(r)
}

/*
PostDeliveryMethods Operation to create delivery methods.

 <p><strong>OperationId:</strong>postDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) PostDeliveryMethods(ctx context.Context) ApiPostDeliveryMethodsRequest {
	return ApiPostDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) PostDeliveryMethodsExecute(r ApiPostDeliveryMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PostDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.createDeliveryMethods == nil {
		return localVarReturnValue, nil, reportError("createDeliveryMethods is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createDeliveryMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPublishersRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	hotelId string
	externalSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	createPublishers *PostPublishersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostPublishersRequest) Authorization(authorization string) ApiPostPublishersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostPublishersRequest) XAppKey(xAppKey string) ApiPostPublishersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostPublishersRequest) XHotelid(xHotelid string) ApiPostPublishersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create publishers.
func (r ApiPostPublishersRequest) CreatePublishers(createPublishers PostPublishersRequest) ApiPostPublishersRequest {
	r.createPublishers = &createPublishers
	return r
}

// External system code.
func (r ApiPostPublishersRequest) XExternalsystem(xExternalsystem string) ApiPostPublishersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostPublishersRequest) AcceptLanguage(acceptLanguage string) ApiPostPublishersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostPublishersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPublishersExecute(r)
}

/*
PostPublishers Operation to create publishers.

 <p><strong>OperationId:</strong>postPublishers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Id used to find a property in OPERA.
 @param externalSystemCode Unique OPERA Code used to find External System in OPERA.
 @return ApiPostPublishersRequest
*/
func (a *ExternalSystemsConfigApiService) PostPublishers(ctx context.Context, hotelId string, externalSystemCode string) ApiPostPublishersRequest {
	return ApiPostPublishersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		externalSystemCode: externalSystemCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) PostPublishersExecute(r ApiPostPublishersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PostPublishers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{externalSystemCode}/hotels/{hotelId}/publishers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.createPublishers == nil {
		return localVarReturnValue, nil, reportError("createPublishers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createPublishers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	changeDeliveryMethods *PutDeliveryMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutDeliveryMethodsRequest) Authorization(authorization string) ApiPutDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutDeliveryMethodsRequest) XAppKey(xAppKey string) ApiPutDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutDeliveryMethodsRequest) XHotelid(xHotelid string) ApiPutDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the delivery method for a property/HUB/Chain and its configurations.
func (r ApiPutDeliveryMethodsRequest) ChangeDeliveryMethods(changeDeliveryMethods PutDeliveryMethodsRequest) ApiPutDeliveryMethodsRequest {
	r.changeDeliveryMethods = &changeDeliveryMethods
	return r
}

// External system code.
func (r ApiPutDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ApiPutDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ApiPutDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutDeliveryMethodsRequest) Execute() (*ChangedDeliveryMethods, *http.Response, error) {
	return r.ApiService.PutDeliveryMethodsExecute(r)
}

/*
PutDeliveryMethods Operation to change delivery methods.

 <p><strong>OperationId:</strong>putDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) PutDeliveryMethods(ctx context.Context) ApiPutDeliveryMethodsRequest {
	return ApiPutDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedDeliveryMethods
func (a *ExternalSystemsConfigApiService) PutDeliveryMethodsExecute(r ApiPutDeliveryMethodsRequest) (*ChangedDeliveryMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedDeliveryMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PutDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.changeDeliveryMethods == nil {
		return localVarReturnValue, nil, reportError("changeDeliveryMethods is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeDeliveryMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutInterfaceRightRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	changeInterfaceRight *PutInterfaceRightRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutInterfaceRightRequest) Authorization(authorization string) ApiPutInterfaceRightRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutInterfaceRightRequest) XAppKey(xAppKey string) ApiPutInterfaceRightRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutInterfaceRightRequest) XHotelid(xHotelid string) ApiPutInterfaceRightRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating a Hotel Interface Right. It will create the Hotel Interface Right if it does not exist on the database.
func (r ApiPutInterfaceRightRequest) ChangeInterfaceRight(changeInterfaceRight PutInterfaceRightRequest) ApiPutInterfaceRightRequest {
	r.changeInterfaceRight = &changeInterfaceRight
	return r
}

// External system code.
func (r ApiPutInterfaceRightRequest) XExternalsystem(xExternalsystem string) ApiPutInterfaceRightRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutInterfaceRightRequest) AcceptLanguage(acceptLanguage string) ApiPutInterfaceRightRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutInterfaceRightRequest) Execute() (*ChangedInterfaceRight, *http.Response, error) {
	return r.ApiService.PutInterfaceRightExecute(r)
}

/*
PutInterfaceRight Operation to change interface right.

 <p><strong>OperationId:</strong>putInterfaceRight</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutInterfaceRightRequest
*/
func (a *ExternalSystemsConfigApiService) PutInterfaceRight(ctx context.Context) ApiPutInterfaceRightRequest {
	return ApiPutInterfaceRightRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedInterfaceRight
func (a *ExternalSystemsConfigApiService) PutInterfaceRightExecute(r ApiPutInterfaceRightRequest) (*ChangedInterfaceRight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedInterfaceRight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PutInterfaceRight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.changeInterfaceRight == nil {
		return localVarReturnValue, nil, reportError("changeInterfaceRight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeInterfaceRight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUDFMappingRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	changeUDFMapping *PutUDFMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutUDFMappingRequest) Authorization(authorization string) ApiPutUDFMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutUDFMappingRequest) XAppKey(xAppKey string) ApiPutUDFMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutUDFMappingRequest) XHotelid(xHotelid string) ApiPutUDFMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Self-contained Request object that is used when Updating UDFMapping.
func (r ApiPutUDFMappingRequest) ChangeUDFMapping(changeUDFMapping PutUDFMappingRequest) ApiPutUDFMappingRequest {
	r.changeUDFMapping = &changeUDFMapping
	return r
}

// External system code.
func (r ApiPutUDFMappingRequest) XExternalsystem(xExternalsystem string) ApiPutUDFMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutUDFMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutUDFMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutUDFMappingRequest) Execute() (*ChangedUDFMapping, *http.Response, error) {
	return r.ApiService.PutUDFMappingExecute(r)
}

/*
PutUDFMapping Operation to send a response to the Change in UDF.

Operation to send a response to the Change in UDF. <p><strong>OperationId:</strong>putUDFMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutUDFMappingRequest
*/
func (a *ExternalSystemsConfigApiService) PutUDFMapping(ctx context.Context) ApiPutUDFMappingRequest {
	return ApiPutUDFMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedUDFMapping
func (a *ExternalSystemsConfigApiService) PutUDFMappingExecute(r ApiPutUDFMappingRequest) (*ChangedUDFMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedUDFMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PutUDFMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/udfMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.changeUDFMapping == nil {
		return localVarReturnValue, nil, reportError("changeUDFMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeUDFMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
