/*
OPERA Cloud Room Configuration API

APIs to cater for room configuration, such as configuring room types, room Classes, creating new room features, or updating housekeeping room maintenance reasons.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigApiService HotelConfigApi service
type HotelConfigApiService service

type HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	reasonCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelRoomMaintenanceReasonsToBeChanged *ChangeHotelRoomMaintenanceReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) Authorization(authorization string) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) XAppKey(xAppKey string) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) XHotelid(xHotelid string) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying room maintenance reasons for a hotel.
func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) HotelRoomMaintenanceReasonsToBeChanged(hotelRoomMaintenanceReasonsToBeChanged ChangeHotelRoomMaintenanceReasonsRequest) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	r.hotelRoomMaintenanceReasonsToBeChanged = &hotelRoomMaintenanceReasonsToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeHotelRoomMaintenanceReasonsExecute(r)
}

/*
ChangeHotelRoomMaintenanceReasons Change Hotel Room Maintenance Reasons

Use this API to update Hotel Room Maintenance Reasons. <p><strong>OperationId:</strong>changeHotelRoomMaintenanceReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reasonCode Unique Code of reason.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest
*/
func (a *HotelConfigApiService) ChangeHotelRoomMaintenanceReasons(ctx context.Context, reasonCode string, hotelId string) HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest {
	return HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest{
		ApiService: a,
		ctx: ctx,
		reasonCode: reasonCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeHotelRoomMaintenanceReasonsExecute(r HotelConfigApiChangeHotelRoomMaintenanceReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeHotelRoomMaintenanceReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomMaintenanceReasons/{reasonCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"reasonCode"+"}", url.PathEscape(parameterValueToString(r.reasonCode, "reasonCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reasonCode) < 1 {
		return localVarReturnValue, nil, reportError("reasonCode must have at least 1 elements")
	}
	if strlen(r.reasonCode) > 2000 {
		return localVarReturnValue, nil, reportError("reasonCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelRoomMaintenanceReasonsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeHousekeepingRoomSchedulesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomScheduleId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingRoomSchedulesToBeChanged *ChangeHousekeepingRoomSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) Authorization(authorization string) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) XAppKey(xAppKey string) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) XHotelid(xHotelid string) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing housekeeping tasks and housekeeping codes associated to a room type.
func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) HousekeepingRoomSchedulesToBeChanged(housekeepingRoomSchedulesToBeChanged ChangeHousekeepingRoomSchedulesRequest) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	r.housekeepingRoomSchedulesToBeChanged = &housekeepingRoomSchedulesToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeHousekeepingRoomSchedulesExecute(r)
}

/*
ChangeHousekeepingRoomSchedules Change housekeeping room schedules

Use this API to update housekeeping room schedules. <p><strong>OperationId:</strong>changeHousekeepingRoomSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomScheduleId Unique ID of room scheduled.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeHousekeepingRoomSchedulesRequest
*/
func (a *HotelConfigApiService) ChangeHousekeepingRoomSchedules(ctx context.Context, roomScheduleId string, hotelId string) HotelConfigApiChangeHousekeepingRoomSchedulesRequest {
	return HotelConfigApiChangeHousekeepingRoomSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		roomScheduleId: roomScheduleId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeHousekeepingRoomSchedulesExecute(r HotelConfigApiChangeHousekeepingRoomSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeHousekeepingRoomSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingRoomSchedules/{roomScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomScheduleId"+"}", url.PathEscape(parameterValueToString(r.roomScheduleId, "roomScheduleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomScheduleId) < 1 {
		return localVarReturnValue, nil, reportError("roomScheduleId must have at least 1 elements")
	}
	if strlen(r.roomScheduleId) > 2000 {
		return localVarReturnValue, nil, reportError("roomScheduleId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingRoomSchedulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeHousekeepingSectionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	code string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingSectionsToBeChanged *ChangeHousekeepingSectionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeHousekeepingSectionsRequest) Authorization(authorization string) HotelConfigApiChangeHousekeepingSectionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeHousekeepingSectionsRequest) XAppKey(xAppKey string) HotelConfigApiChangeHousekeepingSectionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeHousekeepingSectionsRequest) XHotelid(xHotelid string) HotelConfigApiChangeHousekeepingSectionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Modify housekeeping section codes in resort configurations.
func (r HotelConfigApiChangeHousekeepingSectionsRequest) HousekeepingSectionsToBeChanged(housekeepingSectionsToBeChanged ChangeHousekeepingSectionsRequest) HotelConfigApiChangeHousekeepingSectionsRequest {
	r.housekeepingSectionsToBeChanged = &housekeepingSectionsToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeHousekeepingSectionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeHousekeepingSectionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeHousekeepingSectionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeHousekeepingSectionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeHousekeepingSectionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeHousekeepingSectionsExecute(r)
}

/*
ChangeHousekeepingSections Change Housekeeping Sections

Use this API to update Housekeeping Sections. <p><strong>OperationId:</strong>changeHousekeepingSections</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique Code of house keeping sections.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeHousekeepingSectionsRequest
*/
func (a *HotelConfigApiService) ChangeHousekeepingSections(ctx context.Context, code string, hotelId string) HotelConfigApiChangeHousekeepingSectionsRequest {
	return HotelConfigApiChangeHousekeepingSectionsRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeHousekeepingSectionsExecute(r HotelConfigApiChangeHousekeepingSectionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeHousekeepingSections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingSections/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingSectionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeTemplateFloorsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	templateFloorsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateFloorsToBeChanged *ChangeTemplateFloorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeTemplateFloorsRequest) Authorization(authorization string) HotelConfigApiChangeTemplateFloorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeTemplateFloorsRequest) XAppKey(xAppKey string) HotelConfigApiChangeTemplateFloorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeTemplateFloorsRequest) XHotelid(xHotelid string) HotelConfigApiChangeTemplateFloorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing floors at the template level.
func (r HotelConfigApiChangeTemplateFloorsRequest) TemplateFloorsToBeChanged(templateFloorsToBeChanged ChangeTemplateFloorsRequest) HotelConfigApiChangeTemplateFloorsRequest {
	r.templateFloorsToBeChanged = &templateFloorsToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeTemplateFloorsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeTemplateFloorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeTemplateFloorsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeTemplateFloorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeTemplateFloorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTemplateFloorsExecute(r)
}

/*
ChangeTemplateFloors Change template floors

Use this API to update template floors. <p><strong>OperationId:</strong>changeTemplateFloors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateFloorsId Unique ID of template floors.
 @return HotelConfigApiChangeTemplateFloorsRequest
*/
func (a *HotelConfigApiService) ChangeTemplateFloors(ctx context.Context, templateFloorsId string) HotelConfigApiChangeTemplateFloorsRequest {
	return HotelConfigApiChangeTemplateFloorsRequest{
		ApiService: a,
		ctx: ctx,
		templateFloorsId: templateFloorsId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeTemplateFloorsExecute(r HotelConfigApiChangeTemplateFloorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeTemplateFloors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateFloors/{templateFloorsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateFloorsId"+"}", url.PathEscape(parameterValueToString(r.templateFloorsId, "templateFloorsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.templateFloorsId) < 1 {
		return localVarReturnValue, nil, reportError("templateFloorsId must have at least 1 elements")
	}
	if strlen(r.templateFloorsId) > 2000 {
		return localVarReturnValue, nil, reportError("templateFloorsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateFloorsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiDeleteRoomTypeTemplatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomTypeTemplatesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) Authorization(authorization string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) XAppKey(xAppKey string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) XHotelid(xHotelid string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) RoomType(roomType string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiDeleteRoomTypeTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomTypeTemplatesExecute(r)
}

/*
DeleteRoomTypeTemplates Delete new Room Type templates 

Use this API to delete new Room Type templates. <p><strong>OperationId:</strong>deleteRoomTypeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeTemplatesId Unique ID of room type.
 @return HotelConfigApiDeleteRoomTypeTemplatesRequest
*/
func (a *HotelConfigApiService) DeleteRoomTypeTemplates(ctx context.Context, roomTypeTemplatesId string) HotelConfigApiDeleteRoomTypeTemplatesRequest {
	return HotelConfigApiDeleteRoomTypeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeTemplatesId: roomTypeTemplatesId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) DeleteRoomTypeTemplatesExecute(r HotelConfigApiDeleteRoomTypeTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.DeleteRoomTypeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomTypes/{roomTypeTemplatesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeTemplatesId"+"}", url.PathEscape(parameterValueToString(r.roomTypeTemplatesId, "roomTypeTemplatesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeTemplatesId) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeTemplatesId must have at least 1 elements")
	}
	if strlen(r.roomTypeTemplatesId) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeTemplatesId must have less than 2000 elements")
	}

	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiDeleteRoomTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomTypeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiDeleteRoomTypesRequest) Authorization(authorization string) HotelConfigApiDeleteRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiDeleteRoomTypesRequest) XAppKey(xAppKey string) HotelConfigApiDeleteRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiDeleteRoomTypesRequest) XHotelid(xHotelid string) HotelConfigApiDeleteRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r HotelConfigApiDeleteRoomTypesRequest) RoomType(roomType string) HotelConfigApiDeleteRoomTypesRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r HotelConfigApiDeleteRoomTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiDeleteRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiDeleteRoomTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiDeleteRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiDeleteRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomTypesExecute(r)
}

/*
DeleteRoomTypes Delete Room Types

Use this API to delete a Room Type from a property. <p><strong>OperationId:</strong>deleteRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeId Unique ID of room types.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiDeleteRoomTypesRequest
*/
func (a *HotelConfigApiService) DeleteRoomTypes(ctx context.Context, roomTypeId string, hotelId string) HotelConfigApiDeleteRoomTypesRequest {
	return HotelConfigApiDeleteRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeId: roomTypeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) DeleteRoomTypesExecute(r HotelConfigApiDeleteRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.DeleteRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypes/{roomTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeId"+"}", url.PathEscape(parameterValueToString(r.roomTypeId, "roomTypeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeId) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeId must have at least 1 elements")
	}
	if strlen(r.roomTypeId) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetHotelRoomMaintenanceReasonsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	roomMaintenanceReasonCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) Authorization(authorization string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) XAppKey(xAppKey string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) XHotelid(xHotelid string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) Limit(limit int32) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) Offset(offset int32) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) RoomMaintenanceReasonCodes(roomMaintenanceReasonCodes []string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.roomMaintenanceReasonCodes = &roomMaintenanceReasonCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) WildCard(wildCard string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.wildCard = &wildCard
	return r
}

// Inactive flag - whether or not to display inactive records
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) Execute() (*HotelRoomMaintenanceReasonsDetails, *http.Response, error) {
	return r.ApiService.GetHotelRoomMaintenanceReasonsExecute(r)
}

/*
GetHotelRoomMaintenanceReasons Get Hotel Room Maintenance Reasons

Use this API to get Hotel Room Maintenance Reasons. <p><strong>OperationId:</strong>getHotelRoomMaintenanceReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetHotelRoomMaintenanceReasonsRequest
*/
func (a *HotelConfigApiService) GetHotelRoomMaintenanceReasons(ctx context.Context, hotelId string) HotelConfigApiGetHotelRoomMaintenanceReasonsRequest {
	return HotelConfigApiGetHotelRoomMaintenanceReasonsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelRoomMaintenanceReasonsDetails
func (a *HotelConfigApiService) GetHotelRoomMaintenanceReasonsExecute(r HotelConfigApiGetHotelRoomMaintenanceReasonsRequest) (*HotelRoomMaintenanceReasonsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelRoomMaintenanceReasonsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetHotelRoomMaintenanceReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomMaintenanceReasons"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.roomMaintenanceReasonCodes != nil {
		t := *r.roomMaintenanceReasonCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomMaintenanceReasonCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomMaintenanceReasonCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetHousekeepingRoomSchedulesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypeCodes *[]string
	housekeepingRoomScheduleCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) Authorization(authorization string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) XAppKey(xAppKey string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) XHotelid(xHotelid string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) HousekeepingRoomScheduleCodes(housekeepingRoomScheduleCodes []string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.housekeepingRoomScheduleCodes = &housekeepingRoomScheduleCodes
	return r
}

// External system code.
func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetHousekeepingRoomSchedulesRequest) Execute() (*HousekeepingRoomSchedulesDetails, *http.Response, error) {
	return r.ApiService.GetHousekeepingRoomSchedulesExecute(r)
}

/*
GetHousekeepingRoomSchedules Get housekeeping room schedules

Use this API to get housekeeping room schedules. <p><strong>OperationId:</strong>getHousekeepingRoomSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetHousekeepingRoomSchedulesRequest
*/
func (a *HotelConfigApiService) GetHousekeepingRoomSchedules(ctx context.Context, hotelId string) HotelConfigApiGetHousekeepingRoomSchedulesRequest {
	return HotelConfigApiGetHousekeepingRoomSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingRoomSchedulesDetails
func (a *HotelConfigApiService) GetHousekeepingRoomSchedulesExecute(r HotelConfigApiGetHousekeepingRoomSchedulesRequest) (*HousekeepingRoomSchedulesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingRoomSchedulesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetHousekeepingRoomSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingRoomSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.housekeepingRoomScheduleCodes != nil {
		t := *r.housekeepingRoomScheduleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomScheduleCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomScheduleCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetHousekeepingSectionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	housekeepingSectionsCodes *[]string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetHousekeepingSectionsRequest) Authorization(authorization string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetHousekeepingSectionsRequest) XAppKey(xAppKey string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetHousekeepingSectionsRequest) XHotelid(xHotelid string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if the Section Code is active.
func (r HotelConfigApiGetHousekeepingSectionsRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetHousekeepingSectionsRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r HotelConfigApiGetHousekeepingSectionsRequest) HousekeepingSectionsCodes(housekeepingSectionsCodes []string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.housekeepingSectionsCodes = &housekeepingSectionsCodes
	return r
}

// Description of the Section.
func (r HotelConfigApiGetHousekeepingSectionsRequest) Description(description string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.description = &description
	return r
}

// External system code.
func (r HotelConfigApiGetHousekeepingSectionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetHousekeepingSectionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetHousekeepingSectionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetHousekeepingSectionsRequest) Execute() (*HousekeepingSectionsDetails, *http.Response, error) {
	return r.ApiService.GetHousekeepingSectionsExecute(r)
}

/*
GetHousekeepingSections Get Housekeeping Sections

Use this API to get Housekeeping Sections. <p><strong>OperationId:</strong>getHousekeepingSections</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetHousekeepingSectionsRequest
*/
func (a *HotelConfigApiService) GetHousekeepingSections(ctx context.Context, hotelId string) HotelConfigApiGetHousekeepingSectionsRequest {
	return HotelConfigApiGetHousekeepingSectionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingSectionsDetails
func (a *HotelConfigApiService) GetHousekeepingSectionsExecute(r HotelConfigApiGetHousekeepingSectionsRequest) (*HousekeepingSectionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingSectionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetHousekeepingSections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingSections"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.housekeepingSectionsCodes != nil {
		t := *r.housekeepingSectionsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingSectionsCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingSectionsCodes", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomTypeTemplatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	physical *bool
	pseudo *bool
	summaryInfo *bool
	roomTypeCodes *[]string
	roomClassCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomTypeTemplatesRequest) Authorization(authorization string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomTypeTemplatesRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomTypeTemplatesRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Include inactive Room type in search result?
func (r HotelConfigApiGetRoomTypeTemplatesRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Is it a physical sleep room type.
func (r HotelConfigApiGetRoomTypeTemplatesRequest) Physical(physical bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomTypeTemplatesRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.pseudo = &pseudo
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) SummaryInfo(summaryInfo bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

// External system code.
func (r HotelConfigApiGetRoomTypeTemplatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomTypeTemplatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) Execute() (*RoomTypeTemplatesDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypeTemplatesExecute(r)
}

/*
GetRoomTypeTemplates Get Room Type Templates

This API accepts the room type template request search criteria and gets the Room Type templates. <p><strong>OperationId:</strong>getRoomTypeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetRoomTypeTemplatesRequest
*/
func (a *HotelConfigApiService) GetRoomTypeTemplates(ctx context.Context) HotelConfigApiGetRoomTypeTemplatesRequest {
	return HotelConfigApiGetRoomTypeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoomTypeTemplatesDetails
func (a *HotelConfigApiService) GetRoomTypeTemplatesExecute(r HotelConfigApiGetRoomTypeTemplatesRequest) (*RoomTypeTemplatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypeTemplatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomTypeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accessible *bool
	includeInactive *bool
	limit *int32
	offset *int32
	physical *bool
	pseudo *bool
	summaryInfo *bool
	roomTypeCodes *[]string
	roomClassCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomTypesRequest) Authorization(authorization string) HotelConfigApiGetRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomTypesRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomTypesRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if accessible room type should be fetched.
func (r HotelConfigApiGetRoomTypesRequest) Accessible(accessible bool) HotelConfigApiGetRoomTypesRequest {
	r.accessible = &accessible
	return r
}

// Flag to indicate if inactive room types should be included.
func (r HotelConfigApiGetRoomTypesRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetRoomTypesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetRoomTypesRequest) Limit(limit int32) HotelConfigApiGetRoomTypesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetRoomTypesRequest) Offset(offset int32) HotelConfigApiGetRoomTypesRequest {
	r.offset = &offset
	return r
}

// Is it a physical sleep room type.
func (r HotelConfigApiGetRoomTypesRequest) Physical(physical bool) HotelConfigApiGetRoomTypesRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomTypesRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomTypesRequest {
	r.pseudo = &pseudo
	return r
}

// Flag to indicate if summary or detailed information should be fetched.
func (r HotelConfigApiGetRoomTypesRequest) SummaryInfo(summaryInfo bool) HotelConfigApiGetRoomTypesRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r HotelConfigApiGetRoomTypesRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomTypesRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r HotelConfigApiGetRoomTypesRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomTypesRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

// External system code.
func (r HotelConfigApiGetRoomTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomTypesRequest) Execute() (*RoomTypesDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypesExecute(r)
}

/*
GetRoomTypes Get hotel room types

Use this API to return room types for a specific property based on search criteria such as roomClassCodes, roomTypeCodes, physical, pseudo, etc.<p><strong>OperationId:</strong>getRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetRoomTypesRequest
*/
func (a *HotelConfigApiService) GetRoomTypes(ctx context.Context, hotelId string) HotelConfigApiGetRoomTypesRequest {
	return HotelConfigApiGetRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomTypesDetails
func (a *HotelConfigApiService) GetRoomTypesExecute(r HotelConfigApiGetRoomTypesRequest) (*RoomTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.accessible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessible", r.accessible, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	physical *bool
	pseudo *bool
	roomClassCodes *[]string
	roomTypeCodes *[]string
	room *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomsRequest) Authorization(authorization string) HotelConfigApiGetRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomsRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomsRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetRoomsRequest) Limit(limit int32) HotelConfigApiGetRoomsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetRoomsRequest) Offset(offset int32) HotelConfigApiGetRoomsRequest {
	r.offset = &offset
	return r
}

// Is it a physical room type.
func (r HotelConfigApiGetRoomsRequest) Physical(physical bool) HotelConfigApiGetRoomsRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomsRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomsRequest {
	r.pseudo = &pseudo
	return r
}

func (r HotelConfigApiGetRoomsRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomsRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r HotelConfigApiGetRoomsRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomsRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

// Room to be searched.
func (r HotelConfigApiGetRoomsRequest) Room(room string) HotelConfigApiGetRoomsRequest {
	r.room = &room
	return r
}

// External system code.
func (r HotelConfigApiGetRoomsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomsRequest) Execute() (*RoomsDetails, *http.Response, error) {
	return r.ApiService.GetRoomsExecute(r)
}

/*
GetRooms Get hotel rooms

Use this API to return rooms for a specific property based on search criteria such as roomClassCodes, roomTypeCodes, room, etc.<p><strong>OperationId:</strong>getRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetRoomsRequest
*/
func (a *HotelConfigApiService) GetRooms(ctx context.Context, hotelId string) HotelConfigApiGetRoomsRequest {
	return HotelConfigApiGetRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomsDetails
func (a *HotelConfigApiService) GetRoomsExecute(r HotelConfigApiGetRoomsRequest) (*RoomsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetTemplateFloorsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	floors *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetTemplateFloorsRequest) Authorization(authorization string) HotelConfigApiGetTemplateFloorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetTemplateFloorsRequest) XAppKey(xAppKey string) HotelConfigApiGetTemplateFloorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetTemplateFloorsRequest) XHotelid(xHotelid string) HotelConfigApiGetTemplateFloorsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetTemplateFloorsRequest) Floors(floors []string) HotelConfigApiGetTemplateFloorsRequest {
	r.floors = &floors
	return r
}

// External system code.
func (r HotelConfigApiGetTemplateFloorsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetTemplateFloorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetTemplateFloorsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetTemplateFloorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetTemplateFloorsRequest) Execute() (*TemplateFloorsDetails, *http.Response, error) {
	return r.ApiService.GetTemplateFloorsExecute(r)
}

/*
GetTemplateFloors Get template floors

Use this API to get template floors. <p><strong>OperationId:</strong>getTemplateFloors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetTemplateFloorsRequest
*/
func (a *HotelConfigApiService) GetTemplateFloors(ctx context.Context) HotelConfigApiGetTemplateFloorsRequest {
	return HotelConfigApiGetTemplateFloorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateFloorsDetails
func (a *HotelConfigApiService) GetTemplateFloorsExecute(r HotelConfigApiGetTemplateFloorsRequest) (*TemplateFloorsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateFloorsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetTemplateFloors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateFloors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.floors != nil {
		t := *r.floors
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floors", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floors", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostHotelRoomMaintenanceReasonsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelRoomMaintenanceReasonsCriteria *PostHotelRoomMaintenanceReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) Authorization(authorization string) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) XAppKey(xAppKey string) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) XHotelid(xHotelid string) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new room maintenance reasons for a hotel.
func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) HotelRoomMaintenanceReasonsCriteria(hotelRoomMaintenanceReasonsCriteria PostHotelRoomMaintenanceReasonsRequest) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	r.hotelRoomMaintenanceReasonsCriteria = &hotelRoomMaintenanceReasonsCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelRoomMaintenanceReasonsExecute(r)
}

/*
PostHotelRoomMaintenanceReasons Create Hotel Room Maintenance Reasons

Use this API to create Hotel Room Maintenance Reasons. <p><strong>OperationId:</strong>postHotelRoomMaintenanceReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostHotelRoomMaintenanceReasonsRequest
*/
func (a *HotelConfigApiService) PostHotelRoomMaintenanceReasons(ctx context.Context, hotelId string) HotelConfigApiPostHotelRoomMaintenanceReasonsRequest {
	return HotelConfigApiPostHotelRoomMaintenanceReasonsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostHotelRoomMaintenanceReasonsExecute(r HotelConfigApiPostHotelRoomMaintenanceReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostHotelRoomMaintenanceReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomMaintenanceReasons"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelRoomMaintenanceReasonsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostHousekeepingRoomSchedulesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingRoomSchedulesCriteria *PostHousekeepingRoomSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) Authorization(authorization string) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) XAppKey(xAppKey string) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) XHotelid(xHotelid string) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for associating housekeeping tasks and housekeeping codes to a room type.
func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) HousekeepingRoomSchedulesCriteria(housekeepingRoomSchedulesCriteria PostHousekeepingRoomSchedulesRequest) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	r.housekeepingRoomSchedulesCriteria = &housekeepingRoomSchedulesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostHousekeepingRoomSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHousekeepingRoomSchedulesExecute(r)
}

/*
PostHousekeepingRoomSchedules Create housekeeping room schedules

Use this API to create housekeeping room schedules. <p><strong>OperationId:</strong>postHousekeepingRoomSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostHousekeepingRoomSchedulesRequest
*/
func (a *HotelConfigApiService) PostHousekeepingRoomSchedules(ctx context.Context, hotelId string) HotelConfigApiPostHousekeepingRoomSchedulesRequest {
	return HotelConfigApiPostHousekeepingRoomSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostHousekeepingRoomSchedulesExecute(r HotelConfigApiPostHousekeepingRoomSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostHousekeepingRoomSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingRoomSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingRoomSchedulesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostHousekeepingSectionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingSectionsCriteria *PostHousekeepingSectionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostHousekeepingSectionsRequest) Authorization(authorization string) HotelConfigApiPostHousekeepingSectionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostHousekeepingSectionsRequest) XAppKey(xAppKey string) HotelConfigApiPostHousekeepingSectionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostHousekeepingSectionsRequest) XHotelid(xHotelid string) HotelConfigApiPostHousekeepingSectionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Add housekeeping section codes configurations for resort.
func (r HotelConfigApiPostHousekeepingSectionsRequest) HousekeepingSectionsCriteria(housekeepingSectionsCriteria PostHousekeepingSectionsRequest) HotelConfigApiPostHousekeepingSectionsRequest {
	r.housekeepingSectionsCriteria = &housekeepingSectionsCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostHousekeepingSectionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostHousekeepingSectionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostHousekeepingSectionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostHousekeepingSectionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostHousekeepingSectionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHousekeepingSectionsExecute(r)
}

/*
PostHousekeepingSections Create Housekeeping Sections

Use this API to create Housekeeping Sections. <p><strong>OperationId:</strong>postHousekeepingSections</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostHousekeepingSectionsRequest
*/
func (a *HotelConfigApiService) PostHousekeepingSections(ctx context.Context, hotelId string) HotelConfigApiPostHousekeepingSectionsRequest {
	return HotelConfigApiPostHousekeepingSectionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostHousekeepingSectionsExecute(r HotelConfigApiPostHousekeepingSectionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostHousekeepingSections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingSections"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingSectionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostRoomTypeTemplatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypeTemplatesCriteria *PostRoomTypeTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostRoomTypeTemplatesRequest) Authorization(authorization string) HotelConfigApiPostRoomTypeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostRoomTypeTemplatesRequest) XAppKey(xAppKey string) HotelConfigApiPostRoomTypeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostRoomTypeTemplatesRequest) XHotelid(xHotelid string) HotelConfigApiPostRoomTypeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Room Type Template.
func (r HotelConfigApiPostRoomTypeTemplatesRequest) RoomTypeTemplatesCriteria(roomTypeTemplatesCriteria PostRoomTypeTemplatesRequest) HotelConfigApiPostRoomTypeTemplatesRequest {
	r.roomTypeTemplatesCriteria = &roomTypeTemplatesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostRoomTypeTemplatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostRoomTypeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostRoomTypeTemplatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostRoomTypeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostRoomTypeTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomTypeTemplatesExecute(r)
}

/*
PostRoomTypeTemplates Create Room Type Templates

This API is used to Use this API to create new Room Type templates. <p><strong>OperationId:</strong>postRoomTypeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostRoomTypeTemplatesRequest
*/
func (a *HotelConfigApiService) PostRoomTypeTemplates(ctx context.Context) HotelConfigApiPostRoomTypeTemplatesRequest {
	return HotelConfigApiPostRoomTypeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostRoomTypeTemplatesExecute(r HotelConfigApiPostRoomTypeTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostRoomTypeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypeTemplatesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostRoomTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypesCriteria *PostRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostRoomTypesRequest) Authorization(authorization string) HotelConfigApiPostRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostRoomTypesRequest) XAppKey(xAppKey string) HotelConfigApiPostRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostRoomTypesRequest) XHotelid(xHotelid string) HotelConfigApiPostRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Creating a new Room Type.
func (r HotelConfigApiPostRoomTypesRequest) RoomTypesCriteria(roomTypesCriteria PostRoomTypesRequest) HotelConfigApiPostRoomTypesRequest {
	r.roomTypesCriteria = &roomTypesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostRoomTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostRoomTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomTypesExecute(r)
}

/*
PostRoomTypes Create a new room type

Use this API to create new room types for a property. A list of new room types can be passed as part of the request to Use this API to create multiple rooms in one request. <p><strong>OperationId:</strong>postRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostRoomTypesRequest
*/
func (a *HotelConfigApiService) PostRoomTypes(ctx context.Context, hotelId string) HotelConfigApiPostRoomTypesRequest {
	return HotelConfigApiPostRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostRoomTypesExecute(r HotelConfigApiPostRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostTemplateFloorsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateFloorsCriteria *PostTemplateFloorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostTemplateFloorsRequest) Authorization(authorization string) HotelConfigApiPostTemplateFloorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostTemplateFloorsRequest) XAppKey(xAppKey string) HotelConfigApiPostTemplateFloorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostTemplateFloorsRequest) XHotelid(xHotelid string) HotelConfigApiPostTemplateFloorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating floors at the template level.
func (r HotelConfigApiPostTemplateFloorsRequest) TemplateFloorsCriteria(templateFloorsCriteria PostTemplateFloorsRequest) HotelConfigApiPostTemplateFloorsRequest {
	r.templateFloorsCriteria = &templateFloorsCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostTemplateFloorsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostTemplateFloorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostTemplateFloorsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostTemplateFloorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostTemplateFloorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateFloorsExecute(r)
}

/*
PostTemplateFloors Create template floors

Use this API to create template floors. <p><strong>OperationId:</strong>postTemplateFloors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostTemplateFloorsRequest
*/
func (a *HotelConfigApiService) PostTemplateFloors(ctx context.Context) HotelConfigApiPostTemplateFloorsRequest {
	return HotelConfigApiPostTemplateFloorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostTemplateFloorsExecute(r HotelConfigApiPostTemplateFloorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostTemplateFloors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateFloors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateFloorsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPutRoomTypeTemplatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomTypeTemplatesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypeTemplatesToBeChanged *PutRoomTypeTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPutRoomTypeTemplatesRequest) Authorization(authorization string) HotelConfigApiPutRoomTypeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPutRoomTypeTemplatesRequest) XAppKey(xAppKey string) HotelConfigApiPutRoomTypeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPutRoomTypeTemplatesRequest) XHotelid(xHotelid string) HotelConfigApiPutRoomTypeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Modifying existing Room Type Templates.
func (r HotelConfigApiPutRoomTypeTemplatesRequest) RoomTypeTemplatesToBeChanged(roomTypeTemplatesToBeChanged PutRoomTypeTemplatesRequest) HotelConfigApiPutRoomTypeTemplatesRequest {
	r.roomTypeTemplatesToBeChanged = &roomTypeTemplatesToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiPutRoomTypeTemplatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPutRoomTypeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPutRoomTypeTemplatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPutRoomTypeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPutRoomTypeTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomTypeTemplatesExecute(r)
}

/*
PutRoomTypeTemplates Change Room Type Templates

This API is used to update a Room Type template. Use this API to updates can be made concurrently to multiple templates by passing Collection of Room Type templates with the new values. <p><strong>OperationId:</strong>putRoomTypeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeTemplatesId Unique ID of room type.
 @return HotelConfigApiPutRoomTypeTemplatesRequest
*/
func (a *HotelConfigApiService) PutRoomTypeTemplates(ctx context.Context, roomTypeTemplatesId string) HotelConfigApiPutRoomTypeTemplatesRequest {
	return HotelConfigApiPutRoomTypeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeTemplatesId: roomTypeTemplatesId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PutRoomTypeTemplatesExecute(r HotelConfigApiPutRoomTypeTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PutRoomTypeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomTypes/{roomTypeTemplatesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeTemplatesId"+"}", url.PathEscape(parameterValueToString(r.roomTypeTemplatesId, "roomTypeTemplatesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeTemplatesId) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeTemplatesId must have at least 1 elements")
	}
	if strlen(r.roomTypeTemplatesId) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeTemplatesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypeTemplatesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPutRoomTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomTypeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypesToBeChanged *PutRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPutRoomTypesRequest) Authorization(authorization string) HotelConfigApiPutRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPutRoomTypesRequest) XAppKey(xAppKey string) HotelConfigApiPutRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPutRoomTypesRequest) XHotelid(xHotelid string) HotelConfigApiPutRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Modifying Room Type.
func (r HotelConfigApiPutRoomTypesRequest) RoomTypesToBeChanged(roomTypesToBeChanged PutRoomTypesRequest) HotelConfigApiPutRoomTypesRequest {
	r.roomTypesToBeChanged = &roomTypesToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiPutRoomTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPutRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPutRoomTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPutRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPutRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomTypesExecute(r)
}

/*
PutRoomTypes Update a Room Type

Use this API to update a Room Type from a property. A list of room types that need to be modified can also passed as part of the request. <p><strong>OperationId:</strong>putRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeId Unique ID of room types.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPutRoomTypesRequest
*/
func (a *HotelConfigApiService) PutRoomTypes(ctx context.Context, roomTypeId string, hotelId string) HotelConfigApiPutRoomTypesRequest {
	return HotelConfigApiPutRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeId: roomTypeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PutRoomTypesExecute(r HotelConfigApiPutRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PutRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypes/{roomTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeId"+"}", url.PathEscape(parameterValueToString(r.roomTypeId, "roomTypeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeId) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeId must have at least 1 elements")
	}
	if strlen(r.roomTypeId) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	reasonCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) Authorization(authorization string) HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) XAppKey(xAppKey string) HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) XHotelid(xHotelid string) HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveHotelRoomMaintenanceReasonsExecute(r)
}

/*
RemoveHotelRoomMaintenanceReasons Delete Hotel Room Maintenance Reasons

Use this API to delete Hotel Room Maintenance Reasons. <p><strong>OperationId:</strong>removeHotelRoomMaintenanceReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reasonCode Unique Code of reason.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest
*/
func (a *HotelConfigApiService) RemoveHotelRoomMaintenanceReasons(ctx context.Context, reasonCode string, hotelId string) HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest {
	return HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest{
		ApiService: a,
		ctx: ctx,
		reasonCode: reasonCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveHotelRoomMaintenanceReasonsExecute(r HotelConfigApiRemoveHotelRoomMaintenanceReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveHotelRoomMaintenanceReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomMaintenanceReasons/{reasonCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"reasonCode"+"}", url.PathEscape(parameterValueToString(r.reasonCode, "reasonCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reasonCode) < 1 {
		return localVarReturnValue, nil, reportError("reasonCode must have at least 1 elements")
	}
	if strlen(r.reasonCode) > 2000 {
		return localVarReturnValue, nil, reportError("reasonCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveHousekeepingRoomSchedulesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomScheduleId string
	roomTypeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) Authorization(authorization string) HotelConfigApiRemoveHousekeepingRoomSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) XAppKey(xAppKey string) HotelConfigApiRemoveHousekeepingRoomSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) XHotelid(xHotelid string) HotelConfigApiRemoveHousekeepingRoomSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveHousekeepingRoomSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveHousekeepingRoomSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveHousekeepingRoomSchedulesExecute(r)
}

/*
RemoveHousekeepingRoomSchedules Delete housekeeping room schedules

Use this API to delete housekeeping room schedules. <p><strong>OperationId:</strong>removeHousekeepingRoomSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomScheduleId Unique ID of room scheduled.
 @param roomTypeCode Unique ID of room Type Code.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiRemoveHousekeepingRoomSchedulesRequest
*/
func (a *HotelConfigApiService) RemoveHousekeepingRoomSchedules(ctx context.Context, roomScheduleId string, roomTypeCode string, hotelId string) HotelConfigApiRemoveHousekeepingRoomSchedulesRequest {
	return HotelConfigApiRemoveHousekeepingRoomSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		roomScheduleId: roomScheduleId,
		roomTypeCode: roomTypeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveHousekeepingRoomSchedulesExecute(r HotelConfigApiRemoveHousekeepingRoomSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveHousekeepingRoomSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypeCodes/{roomTypeCode}/housekeepingRoomSchedules/{roomScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomScheduleId"+"}", url.PathEscape(parameterValueToString(r.roomScheduleId, "roomScheduleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomScheduleId) < 1 {
		return localVarReturnValue, nil, reportError("roomScheduleId must have at least 1 elements")
	}
	if strlen(r.roomScheduleId) > 2000 {
		return localVarReturnValue, nil, reportError("roomScheduleId must have less than 2000 elements")
	}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveHousekeepingSectionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	code string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveHousekeepingSectionsRequest) Authorization(authorization string) HotelConfigApiRemoveHousekeepingSectionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveHousekeepingSectionsRequest) XAppKey(xAppKey string) HotelConfigApiRemoveHousekeepingSectionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveHousekeepingSectionsRequest) XHotelid(xHotelid string) HotelConfigApiRemoveHousekeepingSectionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiRemoveHousekeepingSectionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveHousekeepingSectionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveHousekeepingSectionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveHousekeepingSectionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveHousekeepingSectionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveHousekeepingSectionsExecute(r)
}

/*
RemoveHousekeepingSections Delete Housekeeping Sections

Use this API to delete Housekeeping Sections. <p><strong>OperationId:</strong>removeHousekeepingSections</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique Code of house keeping sections.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiRemoveHousekeepingSectionsRequest
*/
func (a *HotelConfigApiService) RemoveHousekeepingSections(ctx context.Context, code string, hotelId string) HotelConfigApiRemoveHousekeepingSectionsRequest {
	return HotelConfigApiRemoveHousekeepingSectionsRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveHousekeepingSectionsExecute(r HotelConfigApiRemoveHousekeepingSectionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveHousekeepingSections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingSections/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveTemplateFloorsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	templateFloorsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveTemplateFloorsRequest) Authorization(authorization string) HotelConfigApiRemoveTemplateFloorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveTemplateFloorsRequest) XAppKey(xAppKey string) HotelConfigApiRemoveTemplateFloorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveTemplateFloorsRequest) XHotelid(xHotelid string) HotelConfigApiRemoveTemplateFloorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiRemoveTemplateFloorsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveTemplateFloorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveTemplateFloorsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveTemplateFloorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveTemplateFloorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTemplateFloorsExecute(r)
}

/*
RemoveTemplateFloors Delete template floors

Use this API to delete template floors. <p><strong>OperationId:</strong>removeTemplateFloors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateFloorsId Unique ID of template floors.
 @return HotelConfigApiRemoveTemplateFloorsRequest
*/
func (a *HotelConfigApiService) RemoveTemplateFloors(ctx context.Context, templateFloorsId string) HotelConfigApiRemoveTemplateFloorsRequest {
	return HotelConfigApiRemoveTemplateFloorsRequest{
		ApiService: a,
		ctx: ctx,
		templateFloorsId: templateFloorsId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveTemplateFloorsExecute(r HotelConfigApiRemoveTemplateFloorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveTemplateFloors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateFloors/{templateFloorsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateFloorsId"+"}", url.PathEscape(parameterValueToString(r.templateFloorsId, "templateFloorsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.templateFloorsId) < 1 {
		return localVarReturnValue, nil, reportError("templateFloorsId must have at least 1 elements")
	}
	if strlen(r.templateFloorsId) > 2000 {
		return localVarReturnValue, nil, reportError("templateFloorsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
