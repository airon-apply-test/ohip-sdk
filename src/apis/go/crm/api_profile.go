/*
OPERA Cloud Customer Relationship Management API

APIs to cater for Customer Relationship Management (profile) functionality in OPERA Cloud.  There are different types of profiles in OPERA Cloud, including Guest, Company, Travel Agent, Source, Group, and Contact profile types.  A profile can store and display a wide range of information about the guest, company, travel agent etc., depending upon the type of profile.  For example, a guest profile can store the guest name, address, contact information, details on billing, membership benefits, preferences and much more.  All profiles in OPERA when created are assigned a ProfileID.  This ID will be used throughout the CRM APIs.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProfileApiService ProfileApi service
type ProfileApiService service

type ApiDeleteProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteProfileRequest) Authorization(authorization string) ApiDeleteProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteProfileRequest) XAppKey(xAppKey string) ApiDeleteProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteProfileRequest) XHotelid(xHotelid string) ApiDeleteProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteProfileRequest) XExternalsystem(xExternalsystem string) ApiDeleteProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteProfileRequest) AcceptLanguage(acceptLanguage string) ApiDeleteProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileExecute(r)
}

/*
DeleteProfile Forget or delete a profile by ID

Use deleteProfile to inactivate and remove a profile from OPERA. The profile will stay in the Database, until a nightly purge process is run to remove profile details from the OPERA database. <p><strong>OperationId:</strong>deleteProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId OPERA internal profile ID which is used to uniquely identify the profile in OPERA. This ID is a primary identification of a profile in OPERA.
 @return ApiDeleteProfileRequest
*/
func (a *ProfileApiService) DeleteProfile(ctx context.Context, profileId string) ApiDeleteProfileRequest {
	return ApiDeleteProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) DeleteProfileExecute(r ApiDeleteProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.DeleteProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompanyProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	corporateID string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompanyProfileRequest) Authorization(authorization string) ApiGetCompanyProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompanyProfileRequest) XAppKey(xAppKey string) ApiGetCompanyProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompanyProfileRequest) XHotelid(xHotelid string) ApiGetCompanyProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Delivery methods associated with the profile.
func (r ApiGetCompanyProfileRequest) FetchInstructions(fetchInstructions []string) ApiGetCompanyProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetCompanyProfileRequest) XExternalsystem(xExternalsystem string) ApiGetCompanyProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompanyProfileRequest) AcceptLanguage(acceptLanguage string) ApiGetCompanyProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompanyProfileRequest) Execute() (*Company, *http.Response, error) {
	return r.ApiService.GetCompanyProfileExecute(r)
}

/*
GetCompanyProfile Get company profile by corporate ID

Use this to retrieve a specific Company, Travel Agent, Group or Source profile. You must know the corporate ID of the profile for the request API. <p><strong>OperationId:</strong>getCompanyProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporateID Unique OPERA Corporate ID used to find company/agent/group/source profile in OPERA.
 @return ApiGetCompanyProfileRequest
*/
func (a *ProfileApiService) GetCompanyProfile(ctx context.Context, corporateID string) ApiGetCompanyProfileRequest {
	return ApiGetCompanyProfileRequest{
		ApiService: a,
		ctx: ctx,
		corporateID: corporateID,
	}
}

// Execute executes the request
//  @return Company
func (a *ProfileApiService) GetCompanyProfileExecute(r ApiGetCompanyProfileRequest) (*Company, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Company
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetCompanyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{corporateID}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporateID"+"}", url.PathEscape(parameterValueToString(r.corporateID, "corporateID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.corporateID) < 1 {
		return localVarReturnValue, nil, reportError("corporateID must have at least 1 elements")
	}
	if strlen(r.corporateID) > 2000 {
		return localVarReturnValue, nil, reportError("corporateID must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGuestProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	guestId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGuestProfileRequest) Authorization(authorization string) ApiGetGuestProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGuestProfileRequest) XAppKey(xAppKey string) ApiGetGuestProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGuestProfileRequest) XHotelid(xHotelid string) ApiGetGuestProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Delivery methods associated with the profile.
func (r ApiGetGuestProfileRequest) FetchInstructions(fetchInstructions []string) ApiGetGuestProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetGuestProfileRequest) XExternalsystem(xExternalsystem string) ApiGetGuestProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGuestProfileRequest) AcceptLanguage(acceptLanguage string) ApiGetGuestProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGuestProfileRequest) Execute() (*Guest, *http.Response, error) {
	return r.ApiService.GetGuestProfileExecute(r)
}

/*
GetGuestProfile Get guest profile by guest ID

Use this API to retrieve all data stored for a guest Profile, such as their address, phone number, preferences. You must already know the guests Profile ID. If you don’t know the profile ID, first use the API getGuests to find the profile ID. <p><strong>OperationId:</strong>getGuestProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guestId Unique OPERA internal ID used to find guest/contact/employee profile in OPERA.
 @return ApiGetGuestProfileRequest
*/
func (a *ProfileApiService) GetGuestProfile(ctx context.Context, guestId string) ApiGetGuestProfileRequest {
	return ApiGetGuestProfileRequest{
		ApiService: a,
		ctx: ctx,
		guestId: guestId,
	}
}

// Execute executes the request
//  @return Guest
func (a *ProfileApiService) GetGuestProfileExecute(r ApiGetGuestProfileRequest) (*Guest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Guest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetGuestProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guests/{guestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"guestId"+"}", url.PathEscape(parameterValueToString(r.guestId, "guestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guestId) < 1 {
		return localVarReturnValue, nil, reportError("guestId must have at least 1 elements")
	}
	if strlen(r.guestId) > 2000 {
		return localVarReturnValue, nil, reportError("guestId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	logViewProfile *bool
	showInactiveRoomOwners *bool
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	instructionParameterType *[]string
	value *[]string
	allowedAction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileRequest) Authorization(authorization string) ApiGetProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileRequest) XAppKey(xAppKey string) ApiGetProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileRequest) XHotelid(xHotelid string) ApiGetProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ApiGetProfileRequest) HotelId(hotelId string) ApiGetProfileRequest {
	r.hotelId = &hotelId
	return r
}

// This element tells when the view profile should be logged.
func (r ApiGetProfileRequest) LogViewProfile(logViewProfile bool) ApiGetProfileRequest {
	r.logViewProfile = &logViewProfile
	return r
}

// Flag to show inactive Room Owners.
func (r ApiGetProfileRequest) ShowInactiveRoomOwners(showInactiveRoomOwners bool) ApiGetProfileRequest {
	r.showInactiveRoomOwners = &showInactiveRoomOwners
	return r
}

// Providing this flag marks the profile as recently accessed.
func (r ApiGetProfileRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ApiGetProfileRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Delivery methods associated with the profile.
func (r ApiGetProfileRequest) FetchInstructions(fetchInstructions []string) ApiGetProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Simple type enumerating the different parameters accepted by a profile Instructions. Parameter names have the name of the instruction expecting it, and the parameter name itself.
func (r ApiGetProfileRequest) InstructionParameterType(instructionParameterType []string) ApiGetProfileRequest {
	r.instructionParameterType = &instructionParameterType
	return r
}

// Value of Profile Instruction Parameter
func (r ApiGetProfileRequest) Value(value []string) ApiGetProfileRequest {
	r.value = &value
	return r
}

// Flag indicating whether Profile is Enrolled to Primary Membership Program.
func (r ApiGetProfileRequest) AllowedAction(allowedAction []string) ApiGetProfileRequest {
	r.allowedAction = &allowedAction
	return r
}

// External system code.
func (r ApiGetProfileRequest) XExternalsystem(xExternalsystem string) ApiGetProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.GetProfileExecute(r)
}

/*
GetProfile Get profile by ID

Use this API to retrieve a specific profile&apos;s detail information using OPERA&apos;s profileId. You can retrieve any type of profile including guest, travel agent, company, source, group, or contact. If you do not know OPERA profileID, use getProfiles or getProfileByExtId API first to get OPERA profileId.<p><strong>OperationId:</strong>getProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique OPERA internal profile ID which is used to find any type of profile from OPERA. This ID is a primary identification of a profile in OPERA.
 @return ApiGetProfileRequest
*/
func (a *ProfileApiService) GetProfile(ctx context.Context, profileId string) ApiGetProfileRequest {
	return ApiGetProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileApiService) GetProfileExecute(r ApiGetProfileRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.logViewProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logViewProfile", r.logViewProfile, "")
	}
	if r.showInactiveRoomOwners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactiveRoomOwners", r.showInactiveRoomOwners, "")
	}
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.instructionParameterType != nil {
		t := *r.instructionParameterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", t, "multi")
		}
	}
	if r.value != nil {
		t := *r.value
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "value", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "value", t, "multi")
		}
	}
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileByExtIdRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileExternalId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	logViewProfile *bool
	showInactiveRoomOwners *bool
	fetchInstructions *[]string
	instructionParameterType *[]string
	value *[]string
	allowedAction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileByExtIdRequest) Authorization(authorization string) ApiGetProfileByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileByExtIdRequest) XAppKey(xAppKey string) ApiGetProfileByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileByExtIdRequest) XHotelid(xHotelid string) ApiGetProfileByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ApiGetProfileByExtIdRequest) HotelId(hotelId string) ApiGetProfileByExtIdRequest {
	r.hotelId = &hotelId
	return r
}

// This element tells when the view profile should be logged.
func (r ApiGetProfileByExtIdRequest) LogViewProfile(logViewProfile bool) ApiGetProfileByExtIdRequest {
	r.logViewProfile = &logViewProfile
	return r
}

// Flag to show inactive Room Owners.
func (r ApiGetProfileByExtIdRequest) ShowInactiveRoomOwners(showInactiveRoomOwners bool) ApiGetProfileByExtIdRequest {
	r.showInactiveRoomOwners = &showInactiveRoomOwners
	return r
}

// Delivery methods associated with the profile.
func (r ApiGetProfileByExtIdRequest) FetchInstructions(fetchInstructions []string) ApiGetProfileByExtIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Simple type enumerating the different parameters accepted by a profile Instructions. Parameter names have the name of the instruction expecting it, and the parameter name itself.
func (r ApiGetProfileByExtIdRequest) InstructionParameterType(instructionParameterType []string) ApiGetProfileByExtIdRequest {
	r.instructionParameterType = &instructionParameterType
	return r
}

// Value of Profile Instruction Parameter
func (r ApiGetProfileByExtIdRequest) Value(value []string) ApiGetProfileByExtIdRequest {
	r.value = &value
	return r
}

// Flag indicating whether Profile is Enrolled to Primary Membership Program.
func (r ApiGetProfileByExtIdRequest) AllowedAction(allowedAction []string) ApiGetProfileByExtIdRequest {
	r.allowedAction = &allowedAction
	return r
}

// External system code.
func (r ApiGetProfileByExtIdRequest) XExternalsystem(xExternalsystem string) ApiGetProfileByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileByExtIdRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileByExtIdRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.GetProfileByExtIdExecute(r)
}

/*
GetProfileByExtId Get profile by external ID

When a reservation is booked via an external system, you would use this API to retrieve a reservation using the external ID in the request <p><strong>OperationId:</strong>getProfileByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileExternalId External System's ID used to get the profile.
 @param extSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @return ApiGetProfileByExtIdRequest
*/
func (a *ProfileApiService) GetProfileByExtId(ctx context.Context, profileExternalId string, extSystemCode string) ApiGetProfileByExtIdRequest {
	return ApiGetProfileByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		profileExternalId: profileExternalId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileApiService) GetProfileByExtIdExecute(r ApiGetProfileByExtIdRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetProfileByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/profiles/{profileExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileExternalId"+"}", url.PathEscape(parameterValueToString(r.profileExternalId, "profileExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileExternalId) < 1 {
		return localVarReturnValue, nil, reportError("profileExternalId must have at least 1 elements")
	}
	if strlen(r.profileExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("profileExternalId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.logViewProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logViewProfile", r.logViewProfile, "")
	}
	if r.showInactiveRoomOwners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactiveRoomOwners", r.showInactiveRoomOwners, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.instructionParameterType != nil {
		t := *r.instructionParameterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", t, "multi")
		}
	}
	if r.value != nil {
		t := *r.value
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "value", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "value", t, "multi")
		}
	}
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileRelationshipsRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	relationshipPrimaryProfile *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileRelationshipsRequest) Authorization(authorization string) ApiGetProfileRelationshipsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileRelationshipsRequest) XAppKey(xAppKey string) ApiGetProfileRelationshipsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileRelationshipsRequest) XHotelid(xHotelid string) ApiGetProfileRelationshipsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Type of Profile to be fetched from OPERA.
func (r ApiGetProfileRelationshipsRequest) RelationshipPrimaryProfile(relationshipPrimaryProfile bool) ApiGetProfileRelationshipsRequest {
	r.relationshipPrimaryProfile = &relationshipPrimaryProfile
	return r
}

// External system code.
func (r ApiGetProfileRelationshipsRequest) XExternalsystem(xExternalsystem string) ApiGetProfileRelationshipsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileRelationshipsRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileRelationshipsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileRelationshipsRequest) Execute() (*ProfileRelationships, *http.Response, error) {
	return r.ApiService.GetProfileRelationshipsExecute(r)
}

/*
GetProfileRelationships FetchProfileRelationships method provides the ability to retrieve a profile relationships for a profile based on the unique internal profile ID specified.

 <p><strong>OperationId:</strong>getProfileRelationships</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ApiGetProfileRelationshipsRequest
*/
func (a *ProfileApiService) GetProfileRelationships(ctx context.Context, profileId string) ApiGetProfileRelationshipsRequest {
	return ApiGetProfileRelationshipsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileRelationships
func (a *ProfileApiService) GetProfileRelationshipsExecute(r ApiGetProfileRelationshipsRequest) (*ProfileRelationships, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileRelationships
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetProfileRelationships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.relationshipPrimaryProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relationshipPrimaryProfile", r.relationshipPrimaryProfile, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeInactive *bool
	hotelId *string
	includeHasHierarchyOnly *bool
	includePrimaryOwnersOnly *bool
	includePurgeProfiles *bool
	limit *int32
	offset *int32
	searchType *string
	summaryInfo *bool
	searchString *string
	includeAnonymized *bool
	profileType *[]string
	profileIds *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	corporateIds *[]string
	profileName *string
	givenName *string
	incognitoName *string
	incognitoGivenName *string
	city *string
	postalCode *string
	state *string
	countryCode *string
	streetAddress *string
	keyword *string
	communication *string
	membership *string
	membershipType *string
	membershipLevel *string
	aRNumber *string
	businessSegment *[]string
	accountsReceivables *bool
	corporateProfiles *bool
	excludeIncompleteProfiles *bool
	negotiatedRates *bool
	relatedProfileExcludeInactive *bool
	realtedProfileIncludeHasHierarchyOnly *bool
	relatedProfileNegotiatedRates *bool
	relatedProfileType *string
	relatedProfileName *string
	protectedProfiles *bool
	identificationNo *string
	fetchInstructions *[]string
	allowedAction *[]string
	vipCodes *[]string
	predefinedFilterId *float32
	predefinedFilterCode *string
	prioritieCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfilesRequest) Authorization(authorization string) ApiGetProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfilesRequest) XAppKey(xAppKey string) ApiGetProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfilesRequest) XHotelid(xHotelid string) ApiGetProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether to exclude Inactive Profiles, when true indicates that only profiles with active status will be displayed.
func (r ApiGetProfilesRequest) ExcludeInactive(excludeInactive bool) ApiGetProfilesRequest {
	r.excludeInactive = &excludeInactive
	return r
}

// Hotel Code, It is used to filter hotel specific children to this specific hotel code.
func (r ApiGetProfilesRequest) HotelId(hotelId string) ApiGetProfilesRequest {
	r.hotelId = &hotelId
	return r
}

// Include profiles that have one or more relationships in the search.
func (r ApiGetProfilesRequest) IncludeHasHierarchyOnly(includeHasHierarchyOnly bool) ApiGetProfilesRequest {
	r.includeHasHierarchyOnly = &includeHasHierarchyOnly
	return r
}

// Include primary owners in the search.
func (r ApiGetProfilesRequest) IncludePrimaryOwnersOnly(includePrimaryOwnersOnly bool) ApiGetProfilesRequest {
	r.includePrimaryOwnersOnly = &includePrimaryOwnersOnly
	return r
}

// Include purged profiles in the search.
func (r ApiGetProfilesRequest) IncludePurgeProfiles(includePurgeProfiles bool) ApiGetProfilesRequest {
	r.includePurgeProfiles = &includePurgeProfiles
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetProfilesRequest) Limit(limit int32) ApiGetProfilesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetProfilesRequest) Offset(offset int32) ApiGetProfilesRequest {
	r.offset = &offset
	return r
}

// When search type is PatronTrackingSystemMemberProfiles, the FetchProfiles will return the Membership Number of the searched Membership Type regardless of primary flag or sequence of the profile memberships.
func (r ApiGetProfilesRequest) SearchType(searchType string) ApiGetProfilesRequest {
	r.searchType = &searchType
	return r
}

// When true response will return summary information otherwise detailed information.
func (r ApiGetProfilesRequest) SummaryInfo(summaryInfo bool) ApiGetProfilesRequest {
	r.summaryInfo = &summaryInfo
	return r
}

// Search string to be used for super search.
func (r ApiGetProfilesRequest) SearchString(searchString string) ApiGetProfilesRequest {
	r.searchString = &searchString
	return r
}

// Indicates whether to include Anonymized Profiles.
func (r ApiGetProfilesRequest) IncludeAnonymized(includeAnonymized bool) ApiGetProfilesRequest {
	r.includeAnonymized = &includeAnonymized
	return r
}

// The types of Profile handled by the web service.
func (r ApiGetProfilesRequest) ProfileType(profileType []string) ApiGetProfilesRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetProfilesRequest) ProfileIds(profileIds []string) ApiGetProfilesRequest {
	r.profileIds = &profileIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetProfilesRequest) ExternalReferenceIds(externalReferenceIds []string) ApiGetProfilesRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetProfilesRequest) ExternalSystemCodes(externalSystemCodes []string) ApiGetProfilesRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetProfilesRequest) CorporateIds(corporateIds []string) ApiGetProfilesRequest {
	r.corporateIds = &corporateIds
	return r
}

// Family name, last name or Company Name.
func (r ApiGetProfilesRequest) ProfileName(profileName string) ApiGetProfilesRequest {
	r.profileName = &profileName
	return r
}

// Given name, first name or names.
func (r ApiGetProfilesRequest) GivenName(givenName string) ApiGetProfilesRequest {
	r.givenName = &givenName
	return r
}

// Family name, last name or Company Name.
func (r ApiGetProfilesRequest) IncognitoName(incognitoName string) ApiGetProfilesRequest {
	r.incognitoName = &incognitoName
	return r
}

// Given name, first name or names.
func (r ApiGetProfilesRequest) IncognitoGivenName(incognitoGivenName string) ApiGetProfilesRequest {
	r.incognitoGivenName = &incognitoGivenName
	return r
}

// City (e.g., Dublin), town, or postal station (i.e., a postal service territory, often used in a military address).
func (r ApiGetProfilesRequest) City(city string) ApiGetProfilesRequest {
	r.city = &city
	return r
}

// Post Office Code number.
func (r ApiGetProfilesRequest) PostalCode(postalCode string) ApiGetProfilesRequest {
	r.postalCode = &postalCode
	return r
}

// State or Province name (e.g., Texas).
func (r ApiGetProfilesRequest) State(state string) ApiGetProfilesRequest {
	r.state = &state
	return r
}

// Code for a country or a nationality.
func (r ApiGetProfilesRequest) CountryCode(countryCode string) ApiGetProfilesRequest {
	r.countryCode = &countryCode
	return r
}

// First Line of Street Address. For profile search it matches the first Address line.
func (r ApiGetProfilesRequest) StreetAddress(streetAddress string) ApiGetProfilesRequest {
	r.streetAddress = &streetAddress
	return r
}

// Keyword associated to the profile.
func (r ApiGetProfilesRequest) Keyword(keyword string) ApiGetProfilesRequest {
	r.keyword = &keyword
	return r
}

// Any communication method associated to the profile such as phone, fax, eMail id.
func (r ApiGetProfilesRequest) Communication(communication string) ApiGetProfilesRequest {
	r.communication = &communication
	return r
}

// Membership number associated to the profile.
func (r ApiGetProfilesRequest) Membership(membership string) ApiGetProfilesRequest {
	r.membership = &membership
	return r
}

// Member Type of searching profile.
func (r ApiGetProfilesRequest) MembershipType(membershipType string) ApiGetProfilesRequest {
	r.membershipType = &membershipType
	return r
}

// Membership level associated to the profile.
func (r ApiGetProfilesRequest) MembershipLevel(membershipLevel string) ApiGetProfilesRequest {
	r.membershipLevel = &membershipLevel
	return r
}

// Account Receivable associated to the profile.
func (r ApiGetProfilesRequest) ARNumber(aRNumber string) ApiGetProfilesRequest {
	r.aRNumber = &aRNumber
	return r
}

// Business/Market Segment associated to the profile.
func (r ApiGetProfilesRequest) BusinessSegment(businessSegment []string) ApiGetProfilesRequest {
	r.businessSegment = &businessSegment
	return r
}

// When true indicates that only profiles with AR account fetched.
func (r ApiGetProfilesRequest) AccountsReceivables(accountsReceivables bool) ApiGetProfilesRequest {
	r.accountsReceivables = &accountsReceivables
	return r
}

// When true indicates that only profiles with client id are searched for.
func (r ApiGetProfilesRequest) CorporateProfiles(corporateProfiles bool) ApiGetProfilesRequest {
	r.corporateProfiles = &corporateProfiles
	return r
}

// When true indicates that only profiles with an Address Line 1 and Country or at least one Communications Type will be displayed.
func (r ApiGetProfilesRequest) ExcludeIncompleteProfiles(excludeIncompleteProfiles bool) ApiGetProfilesRequest {
	r.excludeIncompleteProfiles = &excludeIncompleteProfiles
	return r
}

// When true indicates that this option has to be included in advanced search.
func (r ApiGetProfilesRequest) NegotiatedRates(negotiatedRates bool) ApiGetProfilesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// Indicates whether to exclude Inactive Profiles, when true indicates that only profiles with active status will be displayed.
func (r ApiGetProfilesRequest) RelatedProfileExcludeInactive(relatedProfileExcludeInactive bool) ApiGetProfilesRequest {
	r.relatedProfileExcludeInactive = &relatedProfileExcludeInactive
	return r
}

// Include profiles that have one or more relationships in the search.
func (r ApiGetProfilesRequest) RealtedProfileIncludeHasHierarchyOnly(realtedProfileIncludeHasHierarchyOnly bool) ApiGetProfilesRequest {
	r.realtedProfileIncludeHasHierarchyOnly = &realtedProfileIncludeHasHierarchyOnly
	return r
}

// When true indicates that this option has to be included in advanced search.
func (r ApiGetProfilesRequest) RelatedProfileNegotiatedRates(relatedProfileNegotiatedRates bool) ApiGetProfilesRequest {
	r.relatedProfileNegotiatedRates = &relatedProfileNegotiatedRates
	return r
}

// The types of Profile handled by the web service.
func (r ApiGetProfilesRequest) RelatedProfileType(relatedProfileType string) ApiGetProfilesRequest {
	r.relatedProfileType = &relatedProfileType
	return r
}

// Family name, last name or Company Name.
func (r ApiGetProfilesRequest) RelatedProfileName(relatedProfileName string) ApiGetProfilesRequest {
	r.relatedProfileName = &relatedProfileName
	return r
}

// Indicates whether to exclude Protected Profiles.
func (r ApiGetProfilesRequest) ProtectedProfiles(protectedProfiles bool) ApiGetProfilesRequest {
	r.protectedProfiles = &protectedProfiles
	return r
}

// Any identification number associated with the profile such as Passport Number, StateID.
func (r ApiGetProfilesRequest) IdentificationNo(identificationNo string) ApiGetProfilesRequest {
	r.identificationNo = &identificationNo
	return r
}

// Room Ownership information associated with the profile.
func (r ApiGetProfilesRequest) FetchInstructions(fetchInstructions []string) ApiGetProfilesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether Profile is Enrolled to Primary Membership Program.
func (r ApiGetProfilesRequest) AllowedAction(allowedAction []string) ApiGetProfilesRequest {
	r.allowedAction = &allowedAction
	return r
}

func (r ApiGetProfilesRequest) VipCodes(vipCodes []string) ApiGetProfilesRequest {
	r.vipCodes = &vipCodes
	return r
}

// Unique ID of the Filter used to filter profiles.
func (r ApiGetProfilesRequest) PredefinedFilterId(predefinedFilterId float32) ApiGetProfilesRequest {
	r.predefinedFilterId = &predefinedFilterId
	return r
}

// Filter code.
func (r ApiGetProfilesRequest) PredefinedFilterCode(predefinedFilterCode string) ApiGetProfilesRequest {
	r.predefinedFilterCode = &predefinedFilterCode
	return r
}

func (r ApiGetProfilesRequest) PrioritieCodes(prioritieCodes []string) ApiGetProfilesRequest {
	r.prioritieCodes = &prioritieCodes
	return r
}

// External system code.
func (r ApiGetProfilesRequest) XExternalsystem(xExternalsystem string) ApiGetProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfilesRequest) AcceptLanguage(acceptLanguage string) ApiGetProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfilesRequest) Execute() (*ProfileSummaries, *http.Response, error) {
	return r.ApiService.GetProfilesExecute(r)
}

/*
GetProfiles Search for profile(s)

Use this API when you want to search for a profile as part of a booking process or to manage a profile data. The response will include a list of profiles that exist in OPERA, based on your search criteria.  For example, you want to see if a profile for Mr David Smith exists - you can search by various criteria, such as first name, last name, email.  The response will include a list of any profiles that exist for Mr David Smith.  If a profile matches the criteria, and you want to get more details of that profile, proceed to use getProfile with the profileId in the request. Maximum response data limit is 1000 records, so use more query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data.<p><strong>OperationId:</strong>getProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProfilesRequest
*/
func (a *ProfileApiService) GetProfiles(ctx context.Context) ApiGetProfilesRequest {
	return ApiGetProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileSummaries
func (a *ProfileApiService) GetProfilesExecute(r ApiGetProfilesRequest) (*ProfileSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.excludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInactive", r.excludeInactive, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.includeHasHierarchyOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHasHierarchyOnly", r.includeHasHierarchyOnly, "")
	}
	if r.includePrimaryOwnersOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePrimaryOwnersOnly", r.includePrimaryOwnersOnly, "")
	}
	if r.includePurgeProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePurgeProfiles", r.includePurgeProfiles, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.searchString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchString", r.searchString, "")
	}
	if r.includeAnonymized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAnonymized", r.includeAnonymized, "")
	}
	if r.profileType != nil {
		t := *r.profileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", t, "multi")
		}
	}
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.corporateIds != nil {
		t := *r.corporateIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIds", t, "multi")
		}
	}
	if r.profileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileName", r.profileName, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.incognitoName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incognitoName", r.incognitoName, "")
	}
	if r.incognitoGivenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incognitoGivenName", r.incognitoGivenName, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.membership != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membership", r.membership, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.membershipLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", r.membershipLevel, "")
	}
	if r.aRNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aRNumber", r.aRNumber, "")
	}
	if r.businessSegment != nil {
		t := *r.businessSegment
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "businessSegment", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "businessSegment", t, "multi")
		}
	}
	if r.accountsReceivables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountsReceivables", r.accountsReceivables, "")
	}
	if r.corporateProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateProfiles", r.corporateProfiles, "")
	}
	if r.excludeIncompleteProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeIncompleteProfiles", r.excludeIncompleteProfiles, "")
	}
	if r.negotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "negotiatedRates", r.negotiatedRates, "")
	}
	if r.relatedProfileExcludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileExcludeInactive", r.relatedProfileExcludeInactive, "")
	}
	if r.realtedProfileIncludeHasHierarchyOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtedProfileIncludeHasHierarchyOnly", r.realtedProfileIncludeHasHierarchyOnly, "")
	}
	if r.relatedProfileNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileNegotiatedRates", r.relatedProfileNegotiatedRates, "")
	}
	if r.relatedProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileType", r.relatedProfileType, "")
	}
	if r.relatedProfileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileName", r.relatedProfileName, "")
	}
	if r.protectedProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectedProfiles", r.protectedProfiles, "")
	}
	if r.identificationNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identificationNo", r.identificationNo, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.predefinedFilterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "predefinedFilterId", r.predefinedFilterId, "")
	}
	if r.predefinedFilterCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "predefinedFilterCode", r.predefinedFilterCode, "")
	}
	if r.prioritieCodes != nil {
		t := *r.prioritieCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prioritieCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prioritieCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStayHistoryRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	includePurgeProfiles *bool
	markAsRecentlyAccessed *bool
	limit *[]int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStayHistoryRequest) Authorization(authorization string) ApiGetStayHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStayHistoryRequest) XAppKey(xAppKey string) ApiGetStayHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStayHistoryRequest) XHotelid(xHotelid string) ApiGetStayHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ApiGetStayHistoryRequest) HotelId(hotelId string) ApiGetStayHistoryRequest {
	r.hotelId = &hotelId
	return r
}

// Providing this flag includes purged profiles in the result.
func (r ApiGetStayHistoryRequest) IncludePurgeProfiles(includePurgeProfiles bool) ApiGetStayHistoryRequest {
	r.includePurgeProfiles = &includePurgeProfiles
	return r
}

// Providing this flag marks the profile as recently accessed.
func (r ApiGetStayHistoryRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ApiGetStayHistoryRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetStayHistoryRequest) Limit(limit []int32) ApiGetStayHistoryRequest {
	r.limit = &limit
	return r
}

// Simple type for instructions that can be used in requests for partial operations to fetch past and future reservation.
func (r ApiGetStayHistoryRequest) FetchInstructions(fetchInstructions []string) ApiGetStayHistoryRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetStayHistoryRequest) XExternalsystem(xExternalsystem string) ApiGetStayHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStayHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetStayHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStayHistoryRequest) Execute() (*ProfileStayHistory, *http.Response, error) {
	return r.ApiService.GetStayHistoryExecute(r)
}

/*
GetStayHistory FetchStayHistory method provides stay history and future reservations of a profile based on the unique internal ID specified.

 <p><strong>OperationId:</strong>getStayHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ApiGetStayHistoryRequest
*/
func (a *ProfileApiService) GetStayHistory(ctx context.Context, profileId string) ApiGetStayHistoryRequest {
	return ApiGetStayHistoryRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileStayHistory
func (a *ProfileApiService) GetStayHistoryExecute(r ApiGetStayHistoryRequest) (*ProfileStayHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileStayHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.GetStayHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/stayHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.includePurgeProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePurgeProfiles", r.includePurgeProfiles, "")
	}
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergeProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	survivorProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileToBeMerged *MergeProfilesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiMergeProfilesRequest) Authorization(authorization string) ApiMergeProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiMergeProfilesRequest) XAppKey(xAppKey string) ApiMergeProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiMergeProfilesRequest) XHotelid(xHotelid string) ApiMergeProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for merging profiles.
func (r ApiMergeProfilesRequest) ProfileToBeMerged(profileToBeMerged MergeProfilesRequest) ApiMergeProfilesRequest {
	r.profileToBeMerged = &profileToBeMerged
	return r
}

// External system code.
func (r ApiMergeProfilesRequest) XExternalsystem(xExternalsystem string) ApiMergeProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiMergeProfilesRequest) AcceptLanguage(acceptLanguage string) ApiMergeProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiMergeProfilesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.MergeProfilesExecute(r)
}

/*
MergeProfiles Merge two profiles by ID

When you need to merge 2 guest profiles into 1 profile, use this API. <p><strong>OperationId:</strong>mergeProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param survivorProfileId Original Profile ID to which profiles will be merged in OPERA.
 @return ApiMergeProfilesRequest
*/
func (a *ProfileApiService) MergeProfiles(ctx context.Context, survivorProfileId string) ApiMergeProfilesRequest {
	return ApiMergeProfilesRequest{
		ApiService: a,
		ctx: ctx,
		survivorProfileId: survivorProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) MergeProfilesExecute(r ApiMergeProfilesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.MergeProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{survivorProfileId}/merges"
	localVarPath = strings.Replace(localVarPath, "{"+"survivorProfileId"+"}", url.PathEscape(parameterValueToString(r.survivorProfileId, "survivorProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.survivorProfileId) < 1 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have at least 1 elements")
	}
	if strlen(r.survivorProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profileToBeMerged == nil {
		return localVarReturnValue, nil, reportError("profileToBeMerged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileToBeMerged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCompanyProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	company *PostCompanyProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCompanyProfileRequest) Authorization(authorization string) ApiPostCompanyProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCompanyProfileRequest) XAppKey(xAppKey string) ApiPostCompanyProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCompanyProfileRequest) XHotelid(xHotelid string) ApiPostCompanyProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of company profile. This object contains profile details with unique identifiers of a profile. The standard optional Opera Context element is also included.
func (r ApiPostCompanyProfileRequest) Company(company PostCompanyProfileRequest) ApiPostCompanyProfileRequest {
	r.company = &company
	return r
}

// External system code.
func (r ApiPostCompanyProfileRequest) XExternalsystem(xExternalsystem string) ApiPostCompanyProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCompanyProfileRequest) AcceptLanguage(acceptLanguage string) ApiPostCompanyProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCompanyProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompanyProfileExecute(r)
}

/*
PostCompanyProfile This API facilitates creation of a company/agent/group/source profile in OPERA.

When a profile doesn't already exist for a guest, use this to create a new profile.  The response will provide the newly created profile's OPERA ID. There are many fields in postProfile defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postProfile. <p><strong>OperationId:</strong>postCompanyProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCompanyProfileRequest
*/
func (a *ProfileApiService) PostCompanyProfile(ctx context.Context) ApiPostCompanyProfileRequest {
	return ApiPostCompanyProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) PostCompanyProfileExecute(r ApiPostCompanyProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.PostCompanyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.company == nil {
		return localVarReturnValue, nil, reportError("company is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.company
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGuestProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guest *PostGuestProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostGuestProfileRequest) Authorization(authorization string) ApiPostGuestProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostGuestProfileRequest) XAppKey(xAppKey string) ApiPostGuestProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostGuestProfileRequest) XHotelid(xHotelid string) ApiPostGuestProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of guest profile. This object contains profile details with unique identifiers of a profile. The standard optional Opera Context element is also included.
func (r ApiPostGuestProfileRequest) Guest(guest PostGuestProfileRequest) ApiPostGuestProfileRequest {
	r.guest = &guest
	return r
}

// External system code.
func (r ApiPostGuestProfileRequest) XExternalsystem(xExternalsystem string) ApiPostGuestProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostGuestProfileRequest) AcceptLanguage(acceptLanguage string) ApiPostGuestProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostGuestProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuestProfileExecute(r)
}

/*
PostGuestProfile Create a guest, contact or employee profile in OPERA

When a profile doesn't already exist for a guest, use this to create a new profile.  The response will provide the newly created profile's OPERA ID. There are many fields in postProfile defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postProfile. <p><strong>OperationId:</strong>postGuestProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGuestProfileRequest
*/
func (a *ProfileApiService) PostGuestProfile(ctx context.Context) ApiPostGuestProfileRequest {
	return ApiPostGuestProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) PostGuestProfileExecute(r ApiPostGuestProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.PostGuestProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.guest == nil {
		return localVarReturnValue, nil, reportError("guest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profile *PostProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostProfileRequest) Authorization(authorization string) ApiPostProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostProfileRequest) XAppKey(xAppKey string) ApiPostProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostProfileRequest) XHotelid(xHotelid string) ApiPostProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of profiles. This object contains profile details with unique identifiers for each profile. The standard optional Opera Context element is also included.
func (r ApiPostProfileRequest) Profile(profile PostProfileRequest) ApiPostProfileRequest {
	r.profile = &profile
	return r
}

// External system code.
func (r ApiPostProfileRequest) XExternalsystem(xExternalsystem string) ApiPostProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostProfileRequest) AcceptLanguage(acceptLanguage string) ApiPostProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileExecute(r)
}

/*
PostProfile Create a profile

When a profile doesn&apos;t already exist in OPERA, use this to create a new profile. The response will provide the newly created profile&apos;s OPERA ID in the Location header. There are many fields in postProfile defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postProfile.<p><strong>OperationId:</strong>postProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostProfileRequest
*/
func (a *ProfileApiService) PostProfile(ctx context.Context) ApiPostProfileRequest {
	return ApiPostProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) PostProfileExecute(r ApiPostProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.PostProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profile == nil {
		return localVarReturnValue, nil, reportError("profile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProfileRelationshipRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	targetProfileId string
	sourceProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileRelationship *PostProfileRelationshipRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostProfileRelationshipRequest) Authorization(authorization string) ApiPostProfileRelationshipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostProfileRelationshipRequest) XAppKey(xAppKey string) ApiPostProfileRelationshipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostProfileRelationshipRequest) XHotelid(xHotelid string) ApiPostProfileRelationshipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating profile relationship.
func (r ApiPostProfileRelationshipRequest) ProfileRelationship(profileRelationship PostProfileRelationshipRequest) ApiPostProfileRelationshipRequest {
	r.profileRelationship = &profileRelationship
	return r
}

// External system code.
func (r ApiPostProfileRelationshipRequest) XExternalsystem(xExternalsystem string) ApiPostProfileRelationshipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostProfileRelationshipRequest) AcceptLanguage(acceptLanguage string) ApiPostProfileRelationshipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostProfileRelationshipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileRelationshipExecute(r)
}

/*
PostProfileRelationship CreateProfileRelationship method provides the ability to create profile relationship based on the request criteria of SourceProfileID,TargetProfileID and SourceRelationType specified.

 <p><strong>OperationId:</strong>postProfileRelationship</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetProfileId
 @param sourceProfileId
 @return ApiPostProfileRelationshipRequest
*/
func (a *ProfileApiService) PostProfileRelationship(ctx context.Context, targetProfileId string, sourceProfileId string) ApiPostProfileRelationshipRequest {
	return ApiPostProfileRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		targetProfileId: targetProfileId,
		sourceProfileId: sourceProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) PostProfileRelationshipExecute(r ApiPostProfileRelationshipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.PostProfileRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{sourceProfileId}/relationships/{targetProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetProfileId"+"}", url.PathEscape(parameterValueToString(r.targetProfileId, "targetProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceProfileId"+"}", url.PathEscape(parameterValueToString(r.sourceProfileId, "sourceProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetProfileId) < 1 {
		return localVarReturnValue, nil, reportError("targetProfileId must have at least 1 elements")
	}
	if strlen(r.targetProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("targetProfileId must have less than 2000 elements")
	}
	if strlen(r.sourceProfileId) < 1 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have at least 1 elements")
	}
	if strlen(r.sourceProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profileRelationship == nil {
		return localVarReturnValue, nil, reportError("profileRelationship is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileRelationship
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutProfileRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profile *PutProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutProfileRequest) Authorization(authorization string) ApiPutProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutProfileRequest) XAppKey(xAppKey string) ApiPutProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutProfileRequest) XHotelid(xHotelid string) ApiPutProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change/modification of profile details. This object contains modified profile details with unique identifiers for each profile. The standard optional Opera Context element is also included.
func (r ApiPutProfileRequest) Profile(profile PutProfileRequest) ApiPutProfileRequest {
	r.profile = &profile
	return r
}

// External system code.
func (r ApiPutProfileRequest) XExternalsystem(xExternalsystem string) ApiPutProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutProfileRequest) AcceptLanguage(acceptLanguage string) ApiPutProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutProfileRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.PutProfileExecute(r)
}

/*
PutProfile Update a profile by ID

Use this to update a guests details on their profile.  You will need to know the OPERA Profile ID to use this API, and you will also need to know the List of Values for profile fields, such as AddressType, PhoneType, Title.  <p><strong>OperationId:</strong>putProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId OPERA internal profile ID which is used to uniquely identify the profile in OPERA. This ID is a primary identification of a profile in OPERA.
 @return ApiPutProfileRequest
*/
func (a *ProfileApiService) PutProfile(ctx context.Context, profileId string) ApiPutProfileRequest {
	return ApiPutProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileApiService) PutProfileExecute(r ApiPutProfileRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.PutProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profile == nil {
		return localVarReturnValue, nil, reportError("profile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutProfileRelationshipRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	targetProfileId string
	sourceProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileRelationshipToBeChanged *PutProfileRelationshipRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutProfileRelationshipRequest) Authorization(authorization string) ApiPutProfileRelationshipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutProfileRelationshipRequest) XAppKey(xAppKey string) ApiPutProfileRelationshipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutProfileRelationshipRequest) XHotelid(xHotelid string) ApiPutProfileRelationshipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing profile relationship.
func (r ApiPutProfileRelationshipRequest) ProfileRelationshipToBeChanged(profileRelationshipToBeChanged PutProfileRelationshipRequest) ApiPutProfileRelationshipRequest {
	r.profileRelationshipToBeChanged = &profileRelationshipToBeChanged
	return r
}

// External system code.
func (r ApiPutProfileRelationshipRequest) XExternalsystem(xExternalsystem string) ApiPutProfileRelationshipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutProfileRelationshipRequest) AcceptLanguage(acceptLanguage string) ApiPutProfileRelationshipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutProfileRelationshipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutProfileRelationshipExecute(r)
}

/*
PutProfileRelationship ChangeProfileRelationship method provides the ability to update(delete and add) profile relationship based on the request criteria of SourceProfileID , TargetProfileID, To Be ChangedProfileID and SourceProfileRelationType specified.

 <p><strong>OperationId:</strong>putProfileRelationship</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetProfileId
 @param sourceProfileId
 @return ApiPutProfileRelationshipRequest
*/
func (a *ProfileApiService) PutProfileRelationship(ctx context.Context, targetProfileId string, sourceProfileId string) ApiPutProfileRelationshipRequest {
	return ApiPutProfileRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		targetProfileId: targetProfileId,
		sourceProfileId: sourceProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) PutProfileRelationshipExecute(r ApiPutProfileRelationshipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.PutProfileRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{sourceProfileId}/relationships/{targetProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetProfileId"+"}", url.PathEscape(parameterValueToString(r.targetProfileId, "targetProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceProfileId"+"}", url.PathEscape(parameterValueToString(r.sourceProfileId, "sourceProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetProfileId) < 1 {
		return localVarReturnValue, nil, reportError("targetProfileId must have at least 1 elements")
	}
	if strlen(r.targetProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("targetProfileId must have less than 2000 elements")
	}
	if strlen(r.sourceProfileId) < 1 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have at least 1 elements")
	}
	if strlen(r.sourceProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profileRelationshipToBeChanged == nil {
		return localVarReturnValue, nil, reportError("profileRelationshipToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileRelationshipToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveProfileRelationshipRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	targetProfileId string
	sourceProfileId string
	sourceRelation *string
	targetRelation *string
	authorization *string
	xAppKey *string
	xHotelid *string
	primary *bool
	sourceRelationDescription *string
	targetRelationDescription *string
	xExternalsystem *string
	acceptLanguage *string
}

// Indicates the type of relationship the current profile(Source Profile) has with the related profile(Target Profile).
func (r ApiRemoveProfileRelationshipRequest) SourceRelation(sourceRelation string) ApiRemoveProfileRelationshipRequest {
	r.sourceRelation = &sourceRelation
	return r
}

// Indicates the type of relationship the related profile(Target Profile) has with the current profile(Source Profile).
func (r ApiRemoveProfileRelationshipRequest) TargetRelation(targetRelation string) ApiRemoveProfileRelationshipRequest {
	r.targetRelation = &targetRelation
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveProfileRelationshipRequest) Authorization(authorization string) ApiRemoveProfileRelationshipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveProfileRelationshipRequest) XAppKey(xAppKey string) ApiRemoveProfileRelationshipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveProfileRelationshipRequest) XHotelid(xHotelid string) ApiRemoveProfileRelationshipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if this relationship is the primary relationship.
func (r ApiRemoveProfileRelationshipRequest) Primary(primary bool) ApiRemoveProfileRelationshipRequest {
	r.primary = &primary
	return r
}

// Displays the description of relationship the current profile(Source Profile) has with the related profile(Target Profile).This needs to be passed if the attribute primary is sent as true.
func (r ApiRemoveProfileRelationshipRequest) SourceRelationDescription(sourceRelationDescription string) ApiRemoveProfileRelationshipRequest {
	r.sourceRelationDescription = &sourceRelationDescription
	return r
}

// Displays the description of relationship the related profile(Target Profile) has with the current profile(Source Profile).
func (r ApiRemoveProfileRelationshipRequest) TargetRelationDescription(targetRelationDescription string) ApiRemoveProfileRelationshipRequest {
	r.targetRelationDescription = &targetRelationDescription
	return r
}

// External system code.
func (r ApiRemoveProfileRelationshipRequest) XExternalsystem(xExternalsystem string) ApiRemoveProfileRelationshipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveProfileRelationshipRequest) AcceptLanguage(acceptLanguage string) ApiRemoveProfileRelationshipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveProfileRelationshipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveProfileRelationshipExecute(r)
}

/*
RemoveProfileRelationship DeleteProfileRelationship method provides the ability to delete profile relationship based on the request criteria of SourceProfileID,TargetProfileID and SourceRelationType specified.

 <p><strong>OperationId:</strong>removeProfileRelationship</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetProfileId
 @param sourceProfileId
 @return ApiRemoveProfileRelationshipRequest
*/
func (a *ProfileApiService) RemoveProfileRelationship(ctx context.Context, targetProfileId string, sourceProfileId string) ApiRemoveProfileRelationshipRequest {
	return ApiRemoveProfileRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		targetProfileId: targetProfileId,
		sourceProfileId: sourceProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) RemoveProfileRelationshipExecute(r ApiRemoveProfileRelationshipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.RemoveProfileRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{sourceProfileId}/relationships/{targetProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetProfileId"+"}", url.PathEscape(parameterValueToString(r.targetProfileId, "targetProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceProfileId"+"}", url.PathEscape(parameterValueToString(r.sourceProfileId, "sourceProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetProfileId) < 1 {
		return localVarReturnValue, nil, reportError("targetProfileId must have at least 1 elements")
	}
	if strlen(r.targetProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("targetProfileId must have less than 2000 elements")
	}
	if strlen(r.sourceProfileId) < 1 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have at least 1 elements")
	}
	if strlen(r.sourceProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have less than 2000 elements")
	}
	if r.sourceRelation == nil {
		return localVarReturnValue, nil, reportError("sourceRelation is required and must be specified")
	}
	if r.targetRelation == nil {
		return localVarReturnValue, nil, reportError("targetRelation is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceRelation", r.sourceRelation, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "targetRelation", r.targetRelation, "")
	if r.primary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primary", r.primary, "")
	}
	if r.sourceRelationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceRelationDescription", r.sourceRelationDescription, "")
	}
	if r.targetRelationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetRelationDescription", r.targetRelationDescription, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStoreEmailRequest struct {
	ctx context.Context
	ApiService *ProfileApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	emailMessageType *StoreEmailRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiStoreEmailRequest) Authorization(authorization string) ApiStoreEmailRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiStoreEmailRequest) XAppKey(xAppKey string) ApiStoreEmailRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiStoreEmailRequest) XHotelid(xHotelid string) ApiStoreEmailRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for storing an email.
func (r ApiStoreEmailRequest) EmailMessageType(emailMessageType StoreEmailRequest) ApiStoreEmailRequest {
	r.emailMessageType = &emailMessageType
	return r
}

// External system code.
func (r ApiStoreEmailRequest) XExternalsystem(xExternalsystem string) ApiStoreEmailRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiStoreEmailRequest) AcceptLanguage(acceptLanguage string) ApiStoreEmailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiStoreEmailRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.StoreEmailExecute(r)
}

/*
StoreEmail Create an Email.

Use this API to create a new Email in OPERA.  You would need to know the Profile Id such as Contact or Account. <p><strong>OperationId:</strong>storeEmail</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Profile ID linked to an Email.
 @return ApiStoreEmailRequest
*/
func (a *ProfileApiService) StoreEmail(ctx context.Context, profileId string) ApiStoreEmailRequest {
	return ApiStoreEmailRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileApiService) StoreEmailExecute(r ApiStoreEmailRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileApiService.StoreEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/emails"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.emailMessageType == nil {
		return localVarReturnValue, nil, reportError("emailMessageType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.emailMessageType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
