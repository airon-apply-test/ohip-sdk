/*
OPERA Cloud Cashiering API

APIs to cater for Cashiering related external (outbound) functionality with OPERA. These APIs facilitate various operations related to getting data from an external system, and inserting it into OPERA.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CashieringApiService CashieringApi service
type CashieringApiService service

type ApiApproveCompPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	postings *ApproveCompPostingsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiApproveCompPostingsRequest) Authorization(authorization string) ApiApproveCompPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r ApiApproveCompPostingsRequest) XAppKey(xAppKey string) ApiApproveCompPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request object to submit comp transactions request to gaming system
func (r ApiApproveCompPostingsRequest) Postings(postings ApproveCompPostingsRequest) ApiApproveCompPostingsRequest {
	r.postings = &postings
	return r
}

// Language code
func (r ApiApproveCompPostingsRequest) AcceptLanguage(acceptLanguage string) ApiApproveCompPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiApproveCompPostingsRequest) Execute() (*SendCompTransactionsStatus, *http.Response, error) {
	return r.ApiService.ApproveCompPostingsExecute(r)
}

/*
ApproveCompPostings Operation to request for comp postings approval.

You can use this API to submit Comp Transactions. <p><strong>OperationId:</strong>approveCompPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiApproveCompPostingsRequest
*/
func (a *CashieringApiService) ApproveCompPostings(ctx context.Context, hotelId string) ApiApproveCompPostingsRequest {
	return ApiApproveCompPostingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SendCompTransactionsStatus
func (a *CashieringApiService) ApproveCompPostingsExecute(r ApiApproveCompPostingsRequest) (*SendCompTransactionsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendCompTransactionsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ApproveCompPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compPostingsApproval"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.postings == nil {
		return localVarReturnValue, nil, reportError("postings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizeCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	authorizeCompRedemptions *AuthorizeCompRedemptionsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiAuthorizeCompRedemptionsRequest) Authorization(authorization string) ApiAuthorizeCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r ApiAuthorizeCompRedemptionsRequest) XAppKey(xAppKey string) ApiAuthorizeCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request type for Complimentary Redemptions authorization.
func (r ApiAuthorizeCompRedemptionsRequest) AuthorizeCompRedemptions(authorizeCompRedemptions AuthorizeCompRedemptionsRequest) ApiAuthorizeCompRedemptionsRequest {
	r.authorizeCompRedemptions = &authorizeCompRedemptions
	return r
}

// Language code
func (r ApiAuthorizeCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) ApiAuthorizeCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiAuthorizeCompRedemptionsRequest) Execute() (*AuthorizeCompRedemptionsRS, *http.Response, error) {
	return r.ApiService.AuthorizeCompRedemptionsExecute(r)
}

/*
AuthorizeCompRedemptions Operation to authorize complimentary redemptions for a guest having PTS Membership Type

You can use this API to authorize complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>authorizeCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return ApiAuthorizeCompRedemptionsRequest
*/
func (a *CashieringApiService) AuthorizeCompRedemptions(ctx context.Context, membershipId string, hotelId string) ApiAuthorizeCompRedemptionsRequest {
	return ApiAuthorizeCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizeCompRedemptionsRS
func (a *CashieringApiService) AuthorizeCompRedemptionsExecute(r ApiAuthorizeCompRedemptionsRequest) (*AuthorizeCompRedemptionsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizeCompRedemptionsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AuthorizeCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptionAuthorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.authorizeCompRedemptions == nil {
		return localVarReturnValue, nil, reportError("authorizeCompRedemptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizeCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompRedemptionsRequest) Authorization(authorization string) ApiGetCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r ApiGetCompRedemptionsRequest) XAppKey(xAppKey string) ApiGetCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Language code
func (r ApiGetCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) ApiGetCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompRedemptionsRequest) Execute() (*FetchCompRedemptionsRS, *http.Response, error) {
	return r.ApiService.GetCompRedemptionsExecute(r)
}

/*
GetCompRedemptions Operation to get complimentary redemptions for a guest having PTS Membership Type

You can use this API to get complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>getCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetCompRedemptionsRequest
*/
func (a *CashieringApiService) GetCompRedemptions(ctx context.Context, membershipId string, hotelId string) ApiGetCompRedemptionsRequest {
	return ApiGetCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchCompRedemptionsRS
func (a *CashieringApiService) GetCompRedemptionsExecute(r ApiGetCompRedemptionsRequest) (*FetchCompRedemptionsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchCompRedemptionsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptions"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	postCompRedemptions *PostCompRedemptionsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCompRedemptionsRequest) Authorization(authorization string) ApiPostCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r ApiPostCompRedemptionsRequest) XAppKey(xAppKey string) ApiPostCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request type of Complimentary Redemptions posting.
func (r ApiPostCompRedemptionsRequest) PostCompRedemptions(postCompRedemptions PostCompRedemptionsRequest) ApiPostCompRedemptionsRequest {
	r.postCompRedemptions = &postCompRedemptions
	return r
}

// Language code
func (r ApiPostCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) ApiPostCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCompRedemptionsRequest) Execute() (*PostCompRedemptionsRS, *http.Response, error) {
	return r.ApiService.PostCompRedemptionsExecute(r)
}

/*
PostCompRedemptions Operation to post complimentary redemptions for a guest having PTS Membership Type

You can use this API to post complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>postCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostCompRedemptionsRequest
*/
func (a *CashieringApiService) PostCompRedemptions(ctx context.Context, membershipId string, hotelId string) ApiPostCompRedemptionsRequest {
	return ApiPostCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostCompRedemptionsRS
func (a *CashieringApiService) PostCompRedemptionsExecute(r ApiPostCompRedemptionsRequest) (*PostCompRedemptionsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCompRedemptionsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptionPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.postCompRedemptions == nil {
		return localVarReturnValue, nil, reportError("postCompRedemptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseCompPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	postings *ApproveCompPostingsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseCompPostingsRequest) Authorization(authorization string) ApiReverseCompPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r ApiReverseCompPostingsRequest) XAppKey(xAppKey string) ApiReverseCompPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request object for comp postings reversal to be sent to the gaming system.
func (r ApiReverseCompPostingsRequest) Postings(postings ApproveCompPostingsRequest) ApiReverseCompPostingsRequest {
	r.postings = &postings
	return r
}

// Language code
func (r ApiReverseCompPostingsRequest) AcceptLanguage(acceptLanguage string) ApiReverseCompPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseCompPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCompPostingsExecute(r)
}

/*
ReverseCompPostings Operation to request for comp postings reversal.

You can use this API to reverse Comp Transactions. <p><strong>OperationId:</strong>reverseCompPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiReverseCompPostingsRequest
*/
func (a *CashieringApiService) ReverseCompPostings(ctx context.Context, hotelId string) ApiReverseCompPostingsRequest {
	return ApiReverseCompPostingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseCompPostingsExecute(r ApiReverseCompPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseCompPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compPostingsReversal"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.postings == nil {
		return localVarReturnValue, nil, reportError("postings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	reverseCompRedemptions *ReverseCompRedemptionsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseCompRedemptionsRequest) Authorization(authorization string) ApiReverseCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r ApiReverseCompRedemptionsRequest) XAppKey(xAppKey string) ApiReverseCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request type of Complimentary Redemptions reversal.
func (r ApiReverseCompRedemptionsRequest) ReverseCompRedemptions(reverseCompRedemptions ReverseCompRedemptionsRequest) ApiReverseCompRedemptionsRequest {
	r.reverseCompRedemptions = &reverseCompRedemptions
	return r
}

// Language code
func (r ApiReverseCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) ApiReverseCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseCompRedemptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCompRedemptionsExecute(r)
}

/*
ReverseCompRedemptions Operation to reverse complimentary redemptions for a guest having PTS Membership Type

You can use this API to reverse complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>reverseCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return ApiReverseCompRedemptionsRequest
*/
func (a *CashieringApiService) ReverseCompRedemptions(ctx context.Context, membershipId string, hotelId string) ApiReverseCompRedemptionsRequest {
	return ApiReverseCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseCompRedemptionsExecute(r ApiReverseCompRedemptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptionReversals"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.reverseCompRedemptions == nil {
		return localVarReturnValue, nil, reportError("reverseCompRedemptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
