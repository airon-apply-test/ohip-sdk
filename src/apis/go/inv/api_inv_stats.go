/*
OPERA Cloud Inventory API

APIs to cater for Inventory functionality in OPERA Cloud. This includes sell limits for date ranges, viewing and updating the property&apos;s inventory, as well as item inventory (such as rollaways, microwaves etc.).<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// INVStatsApiService INVStatsApi service
type INVStatsApiService service

type ApiDeleteinvStatsServiceRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteinvStatsServiceRequest) Authorization(authorization string) ApiDeleteinvStatsServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteinvStatsServiceRequest) XAppKey(xAppKey string) ApiDeleteinvStatsServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r ApiDeleteinvStatsServiceRequest) XHotelid(xHotelid string) ApiDeleteinvStatsServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteinvStatsServiceRequest) XExternalsystem(xExternalsystem string) ApiDeleteinvStatsServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteinvStatsServiceRequest) AcceptLanguage(acceptLanguage string) ApiDeleteinvStatsServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteinvStatsServiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteinvStatsServiceExecute(r)
}

/*
DeleteinvStatsService Clear Cache

Clearing of cache in inventory statistics service <p><strong>OperationId:</strong>deleteinvStatsService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteinvStatsServiceRequest
*/
func (a *INVStatsApiService) DeleteinvStatsService(ctx context.Context) ApiDeleteinvStatsServiceRequest {
	return ApiDeleteinvStatsServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *INVStatsApiService) DeleteinvStatsServiceExecute(r ApiDeleteinvStatsServiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.DeleteinvStatsService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/invStatsService/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockInventoryStatisticsRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeBlocksWithNoRoom *bool
	includeOverbooking *bool
	includeOpportunities *bool
	includeTentativeInventory *bool
	limit *int32
	offset *int32
	endDateRange *string
	startDateRange *string
	blockStatusCodes *[]string
	originCodes *[]string
	roomOwnerCodes *[]string
	blockOwners *[]string
	summarySortByCode *string
	detailSortByCode *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockInventoryStatisticsRequest) Authorization(authorization string) ApiGetBlockInventoryStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockInventoryStatisticsRequest) XAppKey(xAppKey string) ApiGetBlockInventoryStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r ApiGetBlockInventoryStatisticsRequest) XHotelid(xHotelid string) ApiGetBlockInventoryStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// If set to true, includes business blocks without rooms.
func (r ApiGetBlockInventoryStatisticsRequest) IncludeBlocksWithNoRoom(includeBlocksWithNoRoom bool) ApiGetBlockInventoryStatisticsRequest {
	r.includeBlocksWithNoRoom = &includeBlocksWithNoRoom
	return r
}

// If set to true, the house overbooking limit for each day is added to the total number of physical rooms.
func (r ApiGetBlockInventoryStatisticsRequest) IncludeOverbooking(includeOverbooking bool) ApiGetBlockInventoryStatisticsRequest {
	r.includeOverbooking = &includeOverbooking
	return r
}

// If set to true, the results will include opportunities. If this flag is not provided it will be considered false and exclude opportunities.
func (r ApiGetBlockInventoryStatisticsRequest) IncludeOpportunities(includeOpportunities bool) ApiGetBlockInventoryStatisticsRequest {
	r.includeOpportunities = &includeOpportunities
	return r
}

// If set to true, includes non-deduct business blocks and group reservations in the Sales Allowance Available Rooms and House Availability statistics.
func (r ApiGetBlockInventoryStatisticsRequest) IncludeTentativeInventory(includeTentativeInventory bool) ApiGetBlockInventoryStatisticsRequest {
	r.includeTentativeInventory = &includeTentativeInventory
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetBlockInventoryStatisticsRequest) Limit(limit int32) ApiGetBlockInventoryStatisticsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetBlockInventoryStatisticsRequest) Offset(offset int32) ApiGetBlockInventoryStatisticsRequest {
	r.offset = &offset
	return r
}

// The ending value of the date range.
func (r ApiGetBlockInventoryStatisticsRequest) EndDateRange(endDateRange string) ApiGetBlockInventoryStatisticsRequest {
	r.endDateRange = &endDateRange
	return r
}

// The starting value of the date range.
func (r ApiGetBlockInventoryStatisticsRequest) StartDateRange(startDateRange string) ApiGetBlockInventoryStatisticsRequest {
	r.startDateRange = &startDateRange
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) BlockStatusCodes(blockStatusCodes []string) ApiGetBlockInventoryStatisticsRequest {
	r.blockStatusCodes = &blockStatusCodes
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) OriginCodes(originCodes []string) ApiGetBlockInventoryStatisticsRequest {
	r.originCodes = &originCodes
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) RoomOwnerCodes(roomOwnerCodes []string) ApiGetBlockInventoryStatisticsRequest {
	r.roomOwnerCodes = &roomOwnerCodes
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) BlockOwners(blockOwners []string) ApiGetBlockInventoryStatisticsRequest {
	r.blockOwners = &blockOwners
	return r
}

// Supported block inventory statistical sorting.
func (r ApiGetBlockInventoryStatisticsRequest) SummarySortByCode(summarySortByCode string) ApiGetBlockInventoryStatisticsRequest {
	r.summarySortByCode = &summarySortByCode
	return r
}

// Supported block inventory statistical sorting.
func (r ApiGetBlockInventoryStatisticsRequest) DetailSortByCode(detailSortByCode string) ApiGetBlockInventoryStatisticsRequest {
	r.detailSortByCode = &detailSortByCode
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Friday(friday bool) ApiGetBlockInventoryStatisticsRequest {
	r.friday = &friday
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Monday(monday bool) ApiGetBlockInventoryStatisticsRequest {
	r.monday = &monday
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Saturday(saturday bool) ApiGetBlockInventoryStatisticsRequest {
	r.saturday = &saturday
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Sunday(sunday bool) ApiGetBlockInventoryStatisticsRequest {
	r.sunday = &sunday
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Thursday(thursday bool) ApiGetBlockInventoryStatisticsRequest {
	r.thursday = &thursday
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Tuesday(tuesday bool) ApiGetBlockInventoryStatisticsRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Wednesday(wednesday bool) ApiGetBlockInventoryStatisticsRequest {
	r.wednesday = &wednesday
	return r
}

// Type for block inventory statistics instructions that can be used in requests for partial operations.
func (r ApiGetBlockInventoryStatisticsRequest) FetchInstructions(fetchInstructions []string) ApiGetBlockInventoryStatisticsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetBlockInventoryStatisticsRequest) XExternalsystem(xExternalsystem string) ApiGetBlockInventoryStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockInventoryStatisticsRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockInventoryStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockInventoryStatisticsRequest) Execute() (*BlockInventoryStatistic, *http.Response, error) {
	return r.ApiService.GetBlockInventoryStatisticsExecute(r)
}

/*
GetBlockInventoryStatistics Get block inventory statistics

Use this API to get block statistics on a per-day basis across a specified date range. The result includes a summary section of rooms booked by status by date, details on deduct and non-deduct rooms booked per day, and Sales Allowance and House Availability figures per day. The details section of the results include block details such as name, block, code, start and end date, owner, and more. It also shows a breakdown of blocked picked-up and available rooms per day per block. The result set is used to feed the GRC (Group Rooms Control) page in the OPERA UI. <p><strong>OperationId:</strong>getBlockInventoryStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where block inventory statistics are searched.
 @return ApiGetBlockInventoryStatisticsRequest
*/
func (a *INVStatsApiService) GetBlockInventoryStatistics(ctx context.Context, hotelId string) ApiGetBlockInventoryStatisticsRequest {
	return ApiGetBlockInventoryStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockInventoryStatistic
func (a *INVStatsApiService) GetBlockInventoryStatisticsExecute(r ApiGetBlockInventoryStatisticsRequest) (*BlockInventoryStatistic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockInventoryStatistic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.GetBlockInventoryStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blockInventoryStatistics"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeBlocksWithNoRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeBlocksWithNoRoom", r.includeBlocksWithNoRoom, "")
	}
	if r.includeOverbooking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOverbooking", r.includeOverbooking, "")
	}
	if r.includeOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpportunities", r.includeOpportunities, "")
	}
	if r.includeTentativeInventory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTentativeInventory", r.includeTentativeInventory, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.endDateRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateRange", r.endDateRange, "")
	}
	if r.startDateRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateRange", r.startDateRange, "")
	}
	if r.blockStatusCodes != nil {
		t := *r.blockStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", t, "multi")
		}
	}
	if r.originCodes != nil {
		t := *r.originCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "originCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "originCodes", t, "multi")
		}
	}
	if r.roomOwnerCodes != nil {
		t := *r.roomOwnerCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomOwnerCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomOwnerCodes", t, "multi")
		}
	}
	if r.blockOwners != nil {
		t := *r.blockOwners
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwners", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwners", t, "multi")
		}
	}
	if r.summarySortByCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarySortByCode", r.summarySortByCode, "")
	}
	if r.detailSortByCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailSortByCode", r.detailSortByCode, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryStatisticsRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	hotelId string
	dateRangeEnd *string
	reportCode *string
	dateRangeStart *string
	authorization *string
	xAppKey *string
	xHotelid *string
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The ending value of the date range.
func (r ApiGetInventoryStatisticsRequest) DateRangeEnd(dateRangeEnd string) ApiGetInventoryStatisticsRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// Identifies the type of statistics collected. Each ReportCode corresponds to a set of category summaries based upon a predetermined agreement.
func (r ApiGetInventoryStatisticsRequest) ReportCode(reportCode string) ApiGetInventoryStatisticsRequest {
	r.reportCode = &reportCode
	return r
}

// The starting value of the date range.
func (r ApiGetInventoryStatisticsRequest) DateRangeStart(dateRangeStart string) ApiGetInventoryStatisticsRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInventoryStatisticsRequest) Authorization(authorization string) ApiGetInventoryStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInventoryStatisticsRequest) XAppKey(xAppKey string) ApiGetInventoryStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r ApiGetInventoryStatisticsRequest) XHotelid(xHotelid string) ApiGetInventoryStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Name of the parameter.
func (r ApiGetInventoryStatisticsRequest) ParameterName(parameterName []string) ApiGetInventoryStatisticsRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInventoryStatisticsRequest) ParameterValue(parameterValue []string) ApiGetInventoryStatisticsRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInventoryStatisticsRequest) XExternalsystem(xExternalsystem string) ApiGetInventoryStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInventoryStatisticsRequest) AcceptLanguage(acceptLanguage string) ApiGetInventoryStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInventoryStatisticsRequest) Execute() ([]StatisticType, *http.Response, error) {
	return r.ApiService.GetInventoryStatisticsExecute(r)
}

/*
GetInventoryStatistics Get hotel inventory

Use this API to retrieve the inventory data for a specified hotel. Narrow down your results using the query parameters such as a date range, room type, room class, and/or tentative inventory included. Maximum days limit with a single request is 30 days.<p><strong>OperationId:</strong>getInventoryStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where inventory statistics are searched.
 @return ApiGetInventoryStatisticsRequest
*/
func (a *INVStatsApiService) GetInventoryStatistics(ctx context.Context, hotelId string) ApiGetInventoryStatisticsRequest {
	return ApiGetInventoryStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []StatisticType
func (a *INVStatsApiService) GetInventoryStatisticsExecute(r ApiGetInventoryStatisticsRequest) ([]StatisticType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StatisticType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.GetInventoryStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/inventoryStatistics"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.dateRangeEnd == nil {
		return localVarReturnValue, nil, reportError("dateRangeEnd is required and must be specified")
	}
	if r.reportCode == nil {
		return localVarReturnValue, nil, reportError("reportCode is required and must be specified")
	}
	if r.dateRangeStart == nil {
		return localVarReturnValue, nil, reportError("dateRangeStart is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "reportCode", r.reportCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPinginvStatsServiceRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPinginvStatsServiceRequest) Authorization(authorization string) ApiPinginvStatsServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPinginvStatsServiceRequest) XAppKey(xAppKey string) ApiPinginvStatsServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r ApiPinginvStatsServiceRequest) XHotelid(xHotelid string) ApiPinginvStatsServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiPinginvStatsServiceRequest) XExternalsystem(xExternalsystem string) ApiPinginvStatsServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPinginvStatsServiceRequest) AcceptLanguage(acceptLanguage string) ApiPinginvStatsServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPinginvStatsServiceRequest) Execute() (*PingDetail, *http.Response, error) {
	return r.ApiService.PinginvStatsServiceExecute(r)
}

/*
PinginvStatsService Ping

Check inventory statistics service <p><strong>OperationId:</strong>pinginvStatsService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPinginvStatsServiceRequest
*/
func (a *INVStatsApiService) PinginvStatsService(ctx context.Context) ApiPinginvStatsServiceRequest {
	return ApiPinginvStatsServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PingDetail
func (a *INVStatsApiService) PinginvStatsServiceExecute(r ApiPinginvStatsServiceRequest) (*PingDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PingDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.PinginvStatsService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/invStatsService/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
