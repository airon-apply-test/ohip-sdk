/*
OPERA Cloud Housekeeping Service API

APIs to cater for Housekeeping functionality in OPERA Cloud. <br /><br />Housekeeping enables you to schedule daily room cleaning, maintenance, and housekeeping staff activities. It provides information on room status, out of order/out of service rooms, and forecasting.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hsk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HousekeepingApiService HousekeepingApi service
type HousekeepingApiService service

type HousekeepingApiCompleteOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completeRoomRepair *CompleteOutOfOrderRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) CompleteRoomRepair(completeRoomRepair CompleteOutOfOrderRoomsRequest) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.completeRoomRepair = &completeRoomRepair
	return r
}

// External system code.
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) Execute() (*CompleteRoomRepairStatus, *http.Response, error) {
	return r.ApiService.CompleteOutOfOrderRoomsExecute(r)
}

/*
CompleteOutOfOrderRooms Complete rooms Out Of Order

Use this API when one or more rooms are no longer Out Of Order, and can now be available for a guest to stay in.  Specify in the request what status the room(s) should be returned to, such as clean, Inspected, dirty or Pickup. <p><strong>OperationId:</strong>completeOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Order rooms needs to be returned to Clean, Inspected, Dirty or Pickup status.
 @return HousekeepingApiCompleteOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) CompleteOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	return HousekeepingApiCompleteOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompleteRoomRepairStatus
func (a *HousekeepingApiService) CompleteOutOfOrderRoomsExecute(r HousekeepingApiCompleteOutOfOrderRoomsRequest) (*CompleteRoomRepairStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteRoomRepairStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.completeRoomRepair
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiCompleteOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completeRoomRepair *CompleteOutOfServiceRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) CompleteRoomRepair(completeRoomRepair CompleteOutOfServiceRoomsRequest) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.completeRoomRepair = &completeRoomRepair
	return r
}

// External system code.
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) Execute() (*CompleteRoomRepairStatus, *http.Response, error) {
	return r.ApiService.CompleteOutOfServiceRoomsExecute(r)
}

/*
CompleteOutOfServiceRooms Complete Rooms Out of Service

Use this API when one or more rooms are no longer Out Of Service, and can now be available for a guest to stay in.  Specify in the request what status the room(s) should be returned to, such as clean, Inspected, dirty or Pickup. <p><strong>OperationId:</strong>completeOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Service rooms needs to be returned to Clean, Inspected, Dirty or Pickup status.
 @return HousekeepingApiCompleteOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) CompleteOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	return HousekeepingApiCompleteOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompleteRoomRepairStatus
func (a *HousekeepingApiService) CompleteOutOfServiceRoomsExecute(r HousekeepingApiCompleteOutOfServiceRoomsRequest) (*CompleteRoomRepairStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteRoomRepairStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.completeRoomRepair
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingDiscrepanciesRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomDiscrepancyStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	roomClass *[]string
	housekeepingEndDate *string
	housekeepingStartDate *string
	floor *[]string
	dueOut *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for discrepant room status instructions to be used in requests for fetching housekeeping and front office room discrepancy. Valid values are Sleep, Skip, Person Discrepancy, Due Out Only.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) RoomDiscrepancyStatus(roomDiscrepancyStatus []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.roomDiscrepancyStatus = &roomDiscrepancyStatus
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

// Room Class of the Room.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) RoomClass(roomClass []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.roomClass = &roomClass
	return r
}

// The ending value of the date range.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) HousekeepingEndDate(housekeepingEndDate string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.housekeepingEndDate = &housekeepingEndDate
	return r
}

// The starting value of the date range.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) HousekeepingStartDate(housekeepingStartDate string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.housekeepingStartDate = &housekeepingStartDate
	return r
}

// The floor of room to be fetched.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Floor(floor []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.floor = &floor
	return r
}

// List the rooms based on the flag DUE OUT for departure only.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) DueOut(dueOut bool) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.dueOut = &dueOut
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetHousekeepingDiscrepanciesExecute(r)
}

/*
GetHousekeepingDiscrepancies Get hotel housekeeping discrepant rooms

Use this API to return the current housekeeping discrepant rooms for a specific property based on search parameters such as roomDiscrepancyStatus, roomClass, floor, dueOut, etc. These are rooms where the housekeeping status does not match the front office status.<p><strong>OperationId:</strong>getHousekeepingDiscrepancies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetHousekeepingDiscrepanciesRequest
*/
func (a *HousekeepingApiService) GetHousekeepingDiscrepancies(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	return HousekeepingApiGetHousekeepingDiscrepanciesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetHousekeepingDiscrepanciesExecute(r HousekeepingApiGetHousekeepingDiscrepanciesRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingDiscrepancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingDiscrepancies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomDiscrepancyStatus != nil {
		t := *r.roomDiscrepancyStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomDiscrepancyStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomDiscrepancyStatus", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.housekeepingEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingEndDate", r.housekeepingEndDate, "")
	}
	if r.housekeepingStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingStartDate", r.housekeepingStartDate, "")
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.dueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueOut", r.dueOut, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingOverviewRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	housekeepingRoomStatus *[]string
	frontOfficeRoomStatus *[]string
	turndownStatus *[]string
	roomParityStatus *[]string
	serviceRequestStatus *[]string
	roomAssignmentStatus *[]string
	fetchInstructions *[]string
	fromRoomNumber *string
	toRoomNumber *string
	floor *[]string
	roomType *[]string
	roomClass *[]string
	building *[]string
	roomFeatures *[]string
	daySection *[]string
	eveningSection *[]string
	reservationStatus *[]string
	guestServiceRequest *string
	roomIdText *string
	excludeCombo *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingOverviewRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetHousekeepingOverviewRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingOverviewRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Limit(limit int32) HousekeepingApiGetHousekeepingOverviewRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Offset(offset int32) HousekeepingApiGetHousekeepingOverviewRequest {
	r.offset = &offset
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHousekeepingOverviewRequest) HousekeepingRoomStatus(housekeepingRoomStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.housekeepingRoomStatus = &housekeepingRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r HousekeepingApiGetHousekeepingOverviewRequest) FrontOfficeRoomStatus(frontOfficeRoomStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.frontOfficeRoomStatus = &frontOfficeRoomStatus
	return r
}

// Simple type for turndown status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Required, Not Required and Completed.
func (r HousekeepingApiGetHousekeepingOverviewRequest) TurndownStatus(turndownStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.turndownStatus = &turndownStatus
	return r
}

// Simple type for room parity instructions to be used in requests for fetching housekeeping rooms. Valid status values are Odd and Even.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomParityStatus(roomParityStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomParityStatus = &roomParityStatus
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) ServiceRequestStatus(serviceRequestStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.serviceRequestStatus = &serviceRequestStatus
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomAssignmentStatus(roomAssignmentStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomAssignmentStatus = &roomAssignmentStatus
	return r
}

// Simple type for housekeeping instructions that can be used in requests for partial operations.
func (r HousekeepingApiGetHousekeepingOverviewRequest) FetchInstructions(fetchInstructions []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

// The floor of room to be fetched.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Floor(floor []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.floor = &floor
	return r
}

// Room Type of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomType(roomType []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomType = &roomType
	return r
}

// Room Class of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomClass(roomClass []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomClass = &roomClass
	return r
}

// Building of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Building(building []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.building = &building
	return r
}

// Features of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomFeatures(roomFeatures []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// AM Sections of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) DaySection(daySection []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.daySection = &daySection
	return r
}

// PM Sections of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) EveningSection(eveningSection []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.eveningSection = &eveningSection
	return r
}

// The status of the reservation to which this Room is assigned.
func (r HousekeepingApiGetHousekeepingOverviewRequest) ReservationStatus(reservationStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// Possible values for the Guest Service Status.
func (r HousekeepingApiGetHousekeepingOverviewRequest) GuestServiceRequest(guestServiceRequest string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.guestServiceRequest = &guestServiceRequest
	return r
}

// Wild Card entry for Room numbers to be Fetched.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomIdText(roomIdText string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomIdText = &roomIdText
	return r
}

// Indicates we need to exclude the combo rooms while fetching the housekeeping details.
func (r HousekeepingApiGetHousekeepingOverviewRequest) ExcludeCombo(excludeCombo bool) HousekeepingApiGetHousekeepingOverviewRequest {
	r.excludeCombo = &excludeCombo
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingOverviewRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingOverviewRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) Execute() (*HousekeepingBoard, *http.Response, error) {
	return r.ApiService.GetHousekeepingOverviewExecute(r)
}

/*
GetHousekeepingOverview Get housekeeping rooms overview

Use this API to return the status of rooms for a specific property based on search criteria such as hotelId, limit, housekeepingRoomStatus, frontOfficeRoomStatus, roomAssignmentStatus, roomType, roomFeatures. The results will give you a list of rooms, and their current housekeeping details.  You could then go ahead and update any of these rooms by using postOutOfOrderRoom for example. <p><strong>OperationId:</strong>getHousekeepingOverview</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Housekeeping overview needs to be fetched
 @return HousekeepingApiGetHousekeepingOverviewRequest
*/
func (a *HousekeepingApiService) GetHousekeepingOverview(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingOverviewRequest {
	return HousekeepingApiGetHousekeepingOverviewRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingBoard
func (a *HousekeepingApiService) GetHousekeepingOverviewExecute(r HousekeepingApiGetHousekeepingOverviewRequest) (*HousekeepingBoard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingBoard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingOverview"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.housekeepingRoomStatus != nil {
		t := *r.housekeepingRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", t, "multi")
		}
	}
	if r.frontOfficeRoomStatus != nil {
		t := *r.frontOfficeRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", t, "multi")
		}
	}
	if r.turndownStatus != nil {
		t := *r.turndownStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "turndownStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "turndownStatus", t, "multi")
		}
	}
	if r.roomParityStatus != nil {
		t := *r.roomParityStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", t, "multi")
		}
	}
	if r.serviceRequestStatus != nil {
		t := *r.serviceRequestStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRequestStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRequestStatus", t, "multi")
		}
	}
	if r.roomAssignmentStatus != nil {
		t := *r.roomAssignmentStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.building != nil {
		t := *r.building
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "building", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "building", t, "multi")
		}
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.daySection != nil {
		t := *r.daySection
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daySection", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daySection", t, "multi")
		}
	}
	if r.eveningSection != nil {
		t := *r.eveningSection
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eveningSection", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eveningSection", t, "multi")
		}
	}
	if r.reservationStatus != nil {
		t := *r.reservationStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", t, "multi")
		}
	}
	if r.guestServiceRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestServiceRequest", r.guestServiceRequest, "")
	}
	if r.roomIdText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomIdText", r.roomIdText, "")
	}
	if r.excludeCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCombo", r.excludeCombo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomId *string
	endDate *string
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The start date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) StartDate(startDate string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room number to be Fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomId(roomId string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomId = &roomId
	return r
}

// The end date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) EndDate(endDate string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.endDate = &endDate
	return r
}

// The room type of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomTypes = &roomTypes
	return r
}

// The room class of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetOutOfOrderRoomsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetOutOfOrderRoomsExecute(r)
}

/*
GetOutOfOrderRooms Get Out of Order Rooms

Use this API to get a list of rooms for a hotel that are Out of Order.  You can narrow down your results with search criteria such as Room class, Room Type, date range. <p><strong>OperationId:</strong>getOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Order rooms needs to be fetched.
 @return HousekeepingApiGetOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) GetOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiGetOutOfOrderRoomsRequest {
	return HousekeepingApiGetOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetOutOfOrderRoomsExecute(r HousekeepingApiGetOutOfOrderRoomsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomId *string
	endDate *string
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The start date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) StartDate(startDate string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room number to be Fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomId(roomId string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomId = &roomId
	return r
}

// The end date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) EndDate(endDate string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.endDate = &endDate
	return r
}

// The room type of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomTypes = &roomTypes
	return r
}

// The room class of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetOutOfServiceRoomsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetOutOfServiceRoomsExecute(r)
}

/*
GetOutOfServiceRooms Get Out of Service Rooms

Use this API to get a list of rooms for a hotel that are Out of Service.  You can narrow down your results with search criteria such as Room class, Room Type, date range. <p><strong>OperationId:</strong>getOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Service rooms needs to be fetched.
 @return HousekeepingApiGetOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) GetOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiGetOutOfServiceRoomsRequest {
	return HousekeepingApiGetOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetOutOfServiceRoomsExecute(r HousekeepingApiGetOutOfServiceRoomsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRepairOutOfOrder *PostOutOfOrderRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPostOutOfOrderRoomsRequest) RoomRepairOutOfOrder(roomRepairOutOfOrder PostOutOfOrderRoomsRequest) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.roomRepairOutOfOrder = &roomRepairOutOfOrder
	return r
}

// External system code.
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostOutOfOrderRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOutOfOrderRoomsExecute(r)
}

/*
PostOutOfOrderRooms Set multiple rooms to Out Of Order

This API allows you to initially set rooms to 'Out Of Order' housekeeping status and update existing outOfOrderRooms. <p><strong>OperationId:</strong>postOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code of Room(s) which is to be set as Out Of Order.
 @return HousekeepingApiPostOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) PostOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiPostOutOfOrderRoomsRequest {
	return HousekeepingApiPostOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostOutOfOrderRoomsExecute(r HousekeepingApiPostOutOfOrderRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRepairOutOfOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRepairOutOfService *PostOutOfServiceRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPostOutOfServiceRoomsRequest) RoomRepairOutOfService(roomRepairOutOfService PostOutOfServiceRoomsRequest) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.roomRepairOutOfService = &roomRepairOutOfService
	return r
}

// External system code.
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostOutOfServiceRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOutOfServiceRoomsExecute(r)
}

/*
PostOutOfServiceRooms Set multiple rooms to Out Of Service

This API allows you to initially set rooms to 'Out Of Service' housekeeping status and update existing outOfServiceRooms. <p><strong>OperationId:</strong>postOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code of Room(s) which is to be set as Out Of Service.
 @return HousekeepingApiPostOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) PostOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiPostOutOfServiceRoomsRequest {
	return HousekeepingApiPostOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostOutOfServiceRoomsExecute(r HousekeepingApiPostOutOfServiceRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRepairOutOfService
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutRoomRelatedStatusRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingRoomStatusCriteria *PutRoomRelatedStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutRoomRelatedStatusRequest) Authorization(authorization string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiPutRoomRelatedStatusRequest) XAppKey(xAppKey string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutRoomRelatedStatusRequest) XHotelid(xHotelid string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPutRoomRelatedStatusRequest) HousekeepingRoomStatusCriteria(housekeepingRoomStatusCriteria PutRoomRelatedStatusRequest) HousekeepingApiPutRoomRelatedStatusRequest {
	r.housekeepingRoomStatusCriteria = &housekeepingRoomStatusCriteria
	return r
}

// External system code.
func (r HousekeepingApiPutRoomRelatedStatusRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutRoomRelatedStatusRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutRoomRelatedStatusRequest) Execute() (*HousekeepingRoomStatus, *http.Response, error) {
	return r.ApiService.PutRoomRelatedStatusExecute(r)
}

/*
PutRoomRelatedStatus Update Housekeeping Room Status

Use this API to update the housekeeping room status for multiple rooms.  Statuses typically include Inspected, Clean, Pickup or Dirty. <p><strong>OperationId:</strong>putRoomRelatedStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which housekeeping room status, housekeeping status or turndown status have to be modified
 @return HousekeepingApiPutRoomRelatedStatusRequest
*/
func (a *HousekeepingApiService) PutRoomRelatedStatus(ctx context.Context, hotelId string) HousekeepingApiPutRoomRelatedStatusRequest {
	return HousekeepingApiPutRoomRelatedStatusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingRoomStatus
func (a *HousekeepingApiService) PutRoomRelatedStatusExecute(r HousekeepingApiPutRoomRelatedStatusRequest) (*HousekeepingRoomStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingRoomStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutRoomRelatedStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/status"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingRoomStatusCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
