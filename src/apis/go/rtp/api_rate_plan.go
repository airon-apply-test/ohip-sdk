/*
OPERA Cloud Rate API

APIs to cater for Rate Availability functionality in OPERA Cloud. <br /><br /> Rate Management provides all the tools you need to effectively define and manage the rate structures for a property in OPERA Cloud. Some of the things you can do include creating and managing rate codes, rate classes, rate categories, display sets, rate strategies, as well as managing promotion groups and codes.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// RatePlanApiService RatePlanApi service
type RatePlanApiService service

type ApiDeleteBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	code *[]string
	end *string
	start *string
	authorization *string
	xAppKey *string
	xHotelid *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	lOS1 *bool
	lOS2 *bool
	lOS3 *bool
	lOS4 *bool
	lOS5 *bool
	lOS6 *bool
	lOS7 *bool
	lOS8 *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiDeleteBestAvailableRatesRequest) Code(code []string) ApiDeleteBestAvailableRatesRequest {
	r.code = &code
	return r
}

// The ending value of the date range.
func (r ApiDeleteBestAvailableRatesRequest) End(end string) ApiDeleteBestAvailableRatesRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ApiDeleteBestAvailableRatesRequest) Start(start string) ApiDeleteBestAvailableRatesRequest {
	r.start = &start
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteBestAvailableRatesRequest) Authorization(authorization string) ApiDeleteBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiDeleteBestAvailableRatesRequest) XAppKey(xAppKey string) ApiDeleteBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteBestAvailableRatesRequest) XHotelid(xHotelid string) ApiDeleteBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Friday(friday bool) ApiDeleteBestAvailableRatesRequest {
	r.friday = &friday
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Monday(monday bool) ApiDeleteBestAvailableRatesRequest {
	r.monday = &monday
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Saturday(saturday bool) ApiDeleteBestAvailableRatesRequest {
	r.saturday = &saturday
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Sunday(sunday bool) ApiDeleteBestAvailableRatesRequest {
	r.sunday = &sunday
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Thursday(thursday bool) ApiDeleteBestAvailableRatesRequest {
	r.thursday = &thursday
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Tuesday(tuesday bool) ApiDeleteBestAvailableRatesRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Wednesday(wednesday bool) ApiDeleteBestAvailableRatesRequest {
	r.wednesday = &wednesday
	return r
}

// Indicates Length of Stay 1 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS1(lOS1 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS1 = &lOS1
	return r
}

// Indicates Length of Stay 2 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS2(lOS2 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS2 = &lOS2
	return r
}

// Indicates Length of Stay 3 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS3(lOS3 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS3 = &lOS3
	return r
}

// Indicates Length of Stay 4 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS4(lOS4 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS4 = &lOS4
	return r
}

// Indicates Length of Stay 5 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS5(lOS5 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS5 = &lOS5
	return r
}

// Indicates Length of Stay 6 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS6(lOS6 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS6 = &lOS6
	return r
}

// Indicates Length of Stay 7 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS7(lOS7 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS7 = &lOS7
	return r
}

// Indicates Length of Stay 8 configuration.
func (r ApiDeleteBestAvailableRatesRequest) LOS8(lOS8 bool) ApiDeleteBestAvailableRatesRequest {
	r.lOS8 = &lOS8
	return r
}

// External system code.
func (r ApiDeleteBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) ApiDeleteBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteBestAvailableRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBestAvailableRatesExecute(r)
}

/*
DeleteBestAvailableRates Delete Best Available Rates

This API allows to fetch Best Available rates for rate code(s). <p><strong>OperationId:</strong>deleteBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiDeleteBestAvailableRatesRequest
*/
func (a *RatePlanApiService) DeleteBestAvailableRates(ctx context.Context, hotelId string) ApiDeleteBestAvailableRatesRequest {
	return ApiDeleteBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) DeleteBestAvailableRatesExecute(r ApiDeleteBestAvailableRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.DeleteBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.lOS1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS1", r.lOS1, "")
	}
	if r.lOS2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS2", r.lOS2, "")
	}
	if r.lOS3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS3", r.lOS3, "")
	}
	if r.lOS4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS4", r.lOS4, "")
	}
	if r.lOS5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS5", r.lOS5, "")
	}
	if r.lOS6 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS6", r.lOS6, "")
	}
	if r.lOS7 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS7", r.lOS7, "")
	}
	if r.lOS8 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS8", r.lOS8, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	ratePlanScheduleIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteRatePlanSchedulesRequest) RatePlanScheduleIds(ratePlanScheduleIds []string) ApiDeleteRatePlanSchedulesRequest {
	r.ratePlanScheduleIds = &ratePlanScheduleIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteRatePlanSchedulesRequest) Authorization(authorization string) ApiDeleteRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiDeleteRatePlanSchedulesRequest) XAppKey(xAppKey string) ApiDeleteRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteRatePlanSchedulesRequest) XHotelid(xHotelid string) ApiDeleteRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) ApiDeleteRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanSchedulesExecute(r)
}

/*
DeleteRatePlanSchedules Delete rate plan schedule

Use this API to delete Rate Plan schedules.<p><strong>OperationId:</strong>deleteRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiDeleteRatePlanSchedulesRequest
*/
func (a *RatePlanApiService) DeleteRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) ApiDeleteRatePlanSchedulesRequest {
	return ApiDeleteRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) DeleteRatePlanSchedulesExecute(r ApiDeleteRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.DeleteRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.ratePlanScheduleIds == nil {
		return localVarReturnValue, nil, reportError("ratePlanScheduleIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.ratePlanScheduleIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	startDay *string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	rateCode *[]string
	endDay *string
	daysOfWeek *[]string
	lengthOfStay *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The starting value of the date range.
func (r ApiGetBestAvailableRatesRequest) StartDay(startDay string) ApiGetBestAvailableRatesRequest {
	r.startDay = &startDay
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBestAvailableRatesRequest) Authorization(authorization string) ApiGetBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetBestAvailableRatesRequest) XAppKey(xAppKey string) ApiGetBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBestAvailableRatesRequest) XHotelid(xHotelid string) ApiGetBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetBestAvailableRatesRequest) Limit(limit int32) ApiGetBestAvailableRatesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetBestAvailableRatesRequest) Offset(offset int32) ApiGetBestAvailableRatesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetBestAvailableRatesRequest) RateCode(rateCode []string) ApiGetBestAvailableRatesRequest {
	r.rateCode = &rateCode
	return r
}

// The ending value of the date range.
func (r ApiGetBestAvailableRatesRequest) EndDay(endDay string) ApiGetBestAvailableRatesRequest {
	r.endDay = &endDay
	return r
}

// Allowed values for the days of week type.
func (r ApiGetBestAvailableRatesRequest) DaysOfWeek(daysOfWeek []string) ApiGetBestAvailableRatesRequest {
	r.daysOfWeek = &daysOfWeek
	return r
}

// Allowed values for length stay type.
func (r ApiGetBestAvailableRatesRequest) LengthOfStay(lengthOfStay []string) ApiGetBestAvailableRatesRequest {
	r.lengthOfStay = &lengthOfStay
	return r
}

// External system code.
func (r ApiGetBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) ApiGetBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) ApiGetBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBestAvailableRatesRequest) Execute() (*GetBestAvailableRatesDetails, *http.Response, error) {
	return r.ApiService.GetBestAvailableRatesExecute(r)
}

/*
GetBestAvailableRates Fetch Best Available Rates

This API allows to fetch Best Available rates for rate code(s). <p><strong>OperationId:</strong>getBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetBestAvailableRatesRequest
*/
func (a *RatePlanApiService) GetBestAvailableRates(ctx context.Context, hotelId string) ApiGetBestAvailableRatesRequest {
	return ApiGetBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GetBestAvailableRatesDetails
func (a *RatePlanApiService) GetBestAvailableRatesExecute(r ApiGetBestAvailableRatesRequest) (*GetBestAvailableRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBestAvailableRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.startDay == nil {
		return localVarReturnValue, nil, reportError("startDay is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDay", r.startDay, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
	}
	if r.endDay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDay", r.endDay, "")
	}
	if r.daysOfWeek != nil {
		t := *r.daysOfWeek
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daysOfWeek", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daysOfWeek", t, "multi")
		}
	}
	if r.lengthOfStay != nil {
		t := *r.lengthOfStay
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetNegotiatedRatesRequest) Authorization(authorization string) ApiGetNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetNegotiatedRatesRequest) XAppKey(xAppKey string) ApiGetNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetNegotiatedRatesRequest) XHotelid(xHotelid string) ApiGetNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetNegotiatedRatesRequest) Limit(limit int32) ApiGetNegotiatedRatesRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r ApiGetNegotiatedRatesRequest) StartDate(startDate string) ApiGetNegotiatedRatesRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r ApiGetNegotiatedRatesRequest) EndDate(endDate string) ApiGetNegotiatedRatesRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r ApiGetNegotiatedRatesRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) ApiGetNegotiatedRatesRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetNegotiatedRatesRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) ApiGetNegotiatedRatesRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r ApiGetNegotiatedRatesRequest) FetchInstructions(fetchInstructions []string) ApiGetNegotiatedRatesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) ApiGetNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) ApiGetNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetNegotiatedRatesRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesExecute(r)
}

/*
GetNegotiatedRates Get negotiated rates and profiles 

This API allows you to fetch negotiated rates and profile for a given hotel id. <p><strong>OperationId:</strong>getNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetNegotiatedRatesRequest
*/
func (a *RatePlanApiService) GetNegotiatedRates(ctx context.Context, hotelId string) ApiGetNegotiatedRatesRequest {
	return ApiGetNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanApiService) GetNegotiatedRatesExecute(r ApiGetNegotiatedRatesRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
	}
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiatedRatesForGivenHotelAndRateRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) Authorization(authorization string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) XAppKey(xAppKey string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) XHotelid(xHotelid string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) Limit(limit int32) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) StartDate(startDate string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) EndDate(endDate string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) FetchInstructions(fetchInstructions []string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) XExternalsystem(xExternalsystem string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) AcceptLanguage(acceptLanguage string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesForGivenHotelAndRateExecute(r)
}

/*
GetNegotiatedRatesForGivenHotelAndRate Fetch Negotiated Rates

This API allows you to fetch a Rate Plan and Profile for given hotel id and negotiated rate code. <p><strong>OperationId:</strong>getNegotiatedRatesForGivenHotelAndRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetNegotiatedRatesForGivenHotelAndRateRequest
*/
func (a *RatePlanApiService) GetNegotiatedRatesForGivenHotelAndRate(ctx context.Context, rateCode string, hotelId string) ApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	return ApiGetNegotiatedRatesForGivenHotelAndRateRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanApiService) GetNegotiatedRatesForGivenHotelAndRateExecute(r ApiGetNegotiatedRatesForGivenHotelAndRateRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetNegotiatedRatesForGivenHotelAndRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/{rateCode}/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
	}
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiatedRatesForGivenProfileRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetNegotiatedRatesForGivenProfileRequest) Authorization(authorization string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetNegotiatedRatesForGivenProfileRequest) XAppKey(xAppKey string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetNegotiatedRatesForGivenProfileRequest) XHotelid(xHotelid string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) Limit(limit int32) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) StartDate(startDate string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) EndDate(endDate string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) FetchInstructions(fetchInstructions []string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetNegotiatedRatesForGivenProfileRequest) XExternalsystem(xExternalsystem string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetNegotiatedRatesForGivenProfileRequest) AcceptLanguage(acceptLanguage string) ApiGetNegotiatedRatesForGivenProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetNegotiatedRatesForGivenProfileRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesForGivenProfileExecute(r)
}

/*
GetNegotiatedRatesForGivenProfile Get negotiated rate details for given profile

This API allows you to fetch negotiated Rates for a given profile. <p><strong>OperationId:</strong>getNegotiatedRatesForGivenProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID that identifies a single hotel property.
 @return ApiGetNegotiatedRatesForGivenProfileRequest
*/
func (a *RatePlanApiService) GetNegotiatedRatesForGivenProfile(ctx context.Context, profileId string) ApiGetNegotiatedRatesForGivenProfileRequest {
	return ApiGetNegotiatedRatesForGivenProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanApiService) GetNegotiatedRatesForGivenProfileExecute(r ApiGetNegotiatedRatesForGivenProfileRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetNegotiatedRatesForGivenProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
	}
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	hotelId *[]string
	packageCode *[]string
	descriptionWildCard *string
	startDate *string
	endDate *string
	adults *int32
	children *int32
	includeGroup *bool
	sellSeparate *bool
	ticketPostingRhythm *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPackagesRequest) Authorization(authorization string) ApiGetPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetPackagesRequest) XAppKey(xAppKey string) ApiGetPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPackagesRequest) XHotelid(xHotelid string) ApiGetPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetPackagesRequest) Limit(limit int32) ApiGetPackagesRequest {
	r.limit = &limit
	return r
}

// Hotel code.
func (r ApiGetPackagesRequest) HotelId(hotelId []string) ApiGetPackagesRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiGetPackagesRequest) PackageCode(packageCode []string) ApiGetPackagesRequest {
	r.packageCode = &packageCode
	return r
}

// The description or a part of the description based on which results should be filtered.
func (r ApiGetPackagesRequest) DescriptionWildCard(descriptionWildCard string) ApiGetPackagesRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// Start Date for pricing schedule.
func (r ApiGetPackagesRequest) StartDate(startDate string) ApiGetPackagesRequest {
	r.startDate = &startDate
	return r
}

// End Date for pricing schedule.
func (r ApiGetPackagesRequest) EndDate(endDate string) ApiGetPackagesRequest {
	r.endDate = &endDate
	return r
}

// Number of adults for pricing schedule calculation.
func (r ApiGetPackagesRequest) Adults(adults int32) ApiGetPackagesRequest {
	r.adults = &adults
	return r
}

// Number of children for pricing schedule calculation.
func (r ApiGetPackagesRequest) Children(children int32) ApiGetPackagesRequest {
	r.children = &children
	return r
}

// Indicates if Group Packages will be fetched.
func (r ApiGetPackagesRequest) IncludeGroup(includeGroup bool) ApiGetPackagesRequest {
	r.includeGroup = &includeGroup
	return r
}

// Indicates if Only Sell Separate Packages will be fetched, if not specified, it will ignore the criteria.
func (r ApiGetPackagesRequest) SellSeparate(sellSeparate bool) ApiGetPackagesRequest {
	r.sellSeparate = &sellSeparate
	return r
}

// Indicates if Only Ticket Posting Rhythm will be fetched, if not specified, it will ignore the criteria.
func (r ApiGetPackagesRequest) TicketPostingRhythm(ticketPostingRhythm bool) ApiGetPackagesRequest {
	r.ticketPostingRhythm = &ticketPostingRhythm
	return r
}

// Simple type for package instructions that can be used in requests for partial operations.
func (r ApiGetPackagesRequest) FetchInstructions(fetchInstructions []string) ApiGetPackagesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetPackagesRequest) XExternalsystem(xExternalsystem string) ApiGetPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPackagesRequest) AcceptLanguage(acceptLanguage string) ApiGetPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPackagesRequest) Execute() (*PackagesInfo, *http.Response, error) {
	return r.ApiService.GetPackagesExecute(r)
}

/*
GetPackages Get Packages

Use this API you to get configured packages for a hotel.<p><strong>OperationId:</strong>getPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPackagesRequest
*/
func (a *RatePlanApiService) GetPackages(ctx context.Context) ApiGetPackagesRequest {
	return ApiGetPackagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackagesInfo
func (a *RatePlanApiService) GetPackagesExecute(r ApiGetPackagesRequest) (*PackagesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackagesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.packageCode != nil {
		t := *r.packageCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", t, "multi")
		}
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.includeGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGroup", r.includeGroup, "")
	}
	if r.sellSeparate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellSeparate", r.sellSeparate, "")
	}
	if r.ticketPostingRhythm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPostingRhythm", r.ticketPostingRhythm, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCode *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRatePlanRequest) Authorization(authorization string) ApiGetRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetRatePlanRequest) XAppKey(xAppKey string) ApiGetRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRatePlanRequest) XHotelid(xHotelid string) ApiGetRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate plan code.
func (r ApiGetRatePlanRequest) RatePlanCode(ratePlanCode string) ApiGetRatePlanRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Simple type for Rate plan codes instructions that can be used in requests for partial operations.
func (r ApiGetRatePlanRequest) FetchInstructions(fetchInstructions []string) ApiGetRatePlanRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetRatePlanRequest) XExternalsystem(xExternalsystem string) ApiGetRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRatePlanRequest) AcceptLanguage(acceptLanguage string) ApiGetRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRatePlanRequest) Execute() (*RatePlanInfo, *http.Response, error) {
	return r.ApiService.GetRatePlanExecute(r)
}

/*
GetRatePlan Get rate plan

This API allows you to fetch Rate Plans for a given hotel id. <p><strong>OperationId:</strong>getRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetRatePlanRequest
*/
func (a *RatePlanApiService) GetRatePlan(ctx context.Context, hotelId string) ApiGetRatePlanRequest {
	return ApiGetRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanInfo
func (a *RatePlanApiService) GetRatePlanExecute(r ApiGetRatePlanRequest) (*RatePlanInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeRatePlanPackage *bool
	limit *int32
	tierId *int32
	ratePlanScheduleId *string
	ratePlanScheduleIdType *string
	startDate *string
	endDate *string
	duration *string
	roomType *[]string
	roomClass *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRatePlanSchedulesRequest) Authorization(authorization string) ApiGetRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetRatePlanSchedulesRequest) XAppKey(xAppKey string) ApiGetRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRatePlanSchedulesRequest) XHotelid(xHotelid string) ApiGetRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Exclude the List of Pricing Schedule Packages from the response.
func (r ApiGetRatePlanSchedulesRequest) ExcludeRatePlanPackage(excludeRatePlanPackage bool) ApiGetRatePlanSchedulesRequest {
	r.excludeRatePlanPackage = &excludeRatePlanPackage
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetRatePlanSchedulesRequest) Limit(limit int32) ApiGetRatePlanSchedulesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRatePlanSchedulesRequest) TierId(tierId int32) ApiGetRatePlanSchedulesRequest {
	r.tierId = &tierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRatePlanSchedulesRequest) RatePlanScheduleId(ratePlanScheduleId string) ApiGetRatePlanSchedulesRequest {
	r.ratePlanScheduleId = &ratePlanScheduleId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetRatePlanSchedulesRequest) RatePlanScheduleIdType(ratePlanScheduleIdType string) ApiGetRatePlanSchedulesRequest {
	r.ratePlanScheduleIdType = &ratePlanScheduleIdType
	return r
}

func (r ApiGetRatePlanSchedulesRequest) StartDate(startDate string) ApiGetRatePlanSchedulesRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetRatePlanSchedulesRequest) EndDate(endDate string) ApiGetRatePlanSchedulesRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetRatePlanSchedulesRequest) Duration(duration string) ApiGetRatePlanSchedulesRequest {
	r.duration = &duration
	return r
}

// Room Type.
func (r ApiGetRatePlanSchedulesRequest) RoomType(roomType []string) ApiGetRatePlanSchedulesRequest {
	r.roomType = &roomType
	return r
}

// Room Class.
func (r ApiGetRatePlanSchedulesRequest) RoomClass(roomClass []string) ApiGetRatePlanSchedulesRequest {
	r.roomClass = &roomClass
	return r
}

// Include inactive rate schedules in the fetch result.
func (r ApiGetRatePlanSchedulesRequest) IncludeInactive(includeInactive bool) ApiGetRatePlanSchedulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) ApiGetRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) ApiGetRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRatePlanSchedulesRequest) Execute() (*RatePlanSchedulesInfo, *http.Response, error) {
	return r.ApiService.GetRatePlanSchedulesExecute(r)
}

/*
GetRatePlanSchedules Get rate plan schedules

Use this API to get a rate plan&apos;s pricing schedules. The information includes the date range and room types for which the price is valid, rate amounts for multiple persons, and associated packages.<p><strong>OperationId:</strong>getRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetRatePlanSchedulesRequest
*/
func (a *RatePlanApiService) GetRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) ApiGetRatePlanSchedulesRequest {
	return ApiGetRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanSchedulesInfo
func (a *RatePlanApiService) GetRatePlanSchedulesExecute(r ApiGetRatePlanSchedulesRequest) (*RatePlanSchedulesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanSchedulesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.excludeRatePlanPackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRatePlanPackage", r.excludeRatePlanPackage, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.tierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tierId", r.tierId, "")
	}
	if r.ratePlanScheduleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleId", r.ratePlanScheduleId, "")
	}
	if r.ratePlanScheduleIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIdType", r.ratePlanScheduleIdType, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatePlansRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeRateInformation *bool
	limit *int32
	offset *int32
	ratePlanCode *[]string
	rateCategory *[]string
	sellDate *string
	displaySet *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	attributeName *[]string
	orderType *[]string
	includeInactive *bool
	dayUseOnly *bool
	approvalStatus *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code.
func (r ApiGetRatePlansRequest) HotelId(hotelId []string) ApiGetRatePlansRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRatePlansRequest) Authorization(authorization string) ApiGetRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetRatePlansRequest) XAppKey(xAppKey string) ApiGetRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRatePlansRequest) XHotelid(xHotelid string) ApiGetRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether rate plan short and long information should be included in the fetched results.
func (r ApiGetRatePlansRequest) IncludeRateInformation(includeRateInformation bool) ApiGetRatePlansRequest {
	r.includeRateInformation = &includeRateInformation
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetRatePlansRequest) Limit(limit int32) ApiGetRatePlansRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetRatePlansRequest) Offset(offset int32) ApiGetRatePlansRequest {
	r.offset = &offset
	return r
}

// Rate Plan code.
func (r ApiGetRatePlansRequest) RatePlanCode(ratePlanCode []string) ApiGetRatePlansRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Rate category of the rate plan.
func (r ApiGetRatePlansRequest) RateCategory(rateCategory []string) ApiGetRatePlansRequest {
	r.rateCategory = &rateCategory
	return r
}

// Sell date of the rate plan.
func (r ApiGetRatePlansRequest) SellDate(sellDate string) ApiGetRatePlansRequest {
	r.sellDate = &sellDate
	return r
}

// Display set for the rate plan.
func (r ApiGetRatePlansRequest) DisplaySet(displaySet string) ApiGetRatePlansRequest {
	r.displaySet = &displaySet
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRatePlansRequest) Id(id string) ApiGetRatePlansRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiGetRatePlansRequest) IdExtension(idExtension int32) ApiGetRatePlansRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetRatePlansRequest) IdContext(idContext string) ApiGetRatePlansRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetRatePlansRequest) Type_(type_ string) ApiGetRatePlansRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetRatePlansRequest) AttributeName(attributeName []string) ApiGetRatePlansRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiGetRatePlansRequest) OrderType(orderType []string) ApiGetRatePlansRequest {
	r.orderType = &orderType
	return r
}

// Include or not include inactive rate codes.
func (r ApiGetRatePlansRequest) IncludeInactive(includeInactive bool) ApiGetRatePlansRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates to only fetch rate plans flagged as Day Use.
func (r ApiGetRatePlansRequest) DayUseOnly(dayUseOnly bool) ApiGetRatePlansRequest {
	r.dayUseOnly = &dayUseOnly
	return r
}

// Indicates that the Rate Plan is approved for selling.
func (r ApiGetRatePlansRequest) ApprovalStatus(approvalStatus string) ApiGetRatePlansRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// External system code.
func (r ApiGetRatePlansRequest) XExternalsystem(xExternalsystem string) ApiGetRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRatePlansRequest) AcceptLanguage(acceptLanguage string) ApiGetRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRatePlansRequest) Execute() (*RatePlansSummary, *http.Response, error) {
	return r.ApiService.GetRatePlansExecute(r)
}

/*
GetRatePlans Get rate plans

Use this API to get configured Rate Plans for a property and filter this by search criteria.<p><strong>OperationId:</strong>getRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRatePlansRequest
*/
func (a *RatePlanApiService) GetRatePlans(ctx context.Context) ApiGetRatePlansRequest {
	return ApiGetRatePlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RatePlansSummary
func (a *RatePlanApiService) GetRatePlansExecute(r ApiGetRatePlansRequest) (*RatePlansSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlansSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ratePlans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelId == nil {
		return localVarReturnValue, nil, reportError("hotelId is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.includeRateInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRateInformation", r.includeRateInformation, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.rateCategory != nil {
		t := *r.rateCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", t, "multi")
		}
	}
	if r.sellDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellDate", r.sellDate, "")
	}
	if r.displaySet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "displaySet", r.displaySet, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.dayUseOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUseOnly", r.dayUseOnly, "")
	}
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createBestAvailableRates *PostBestAvailableRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBestAvailableRatesRequest) Authorization(authorization string) ApiPostBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostBestAvailableRatesRequest) XAppKey(xAppKey string) ApiPostBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBestAvailableRatesRequest) XHotelid(xHotelid string) ApiPostBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create best available rates for rate code(s)
func (r ApiPostBestAvailableRatesRequest) CreateBestAvailableRates(createBestAvailableRates PostBestAvailableRatesRequest) ApiPostBestAvailableRatesRequest {
	r.createBestAvailableRates = &createBestAvailableRates
	return r
}

// External system code.
func (r ApiPostBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) ApiPostBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) ApiPostBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBestAvailableRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBestAvailableRatesExecute(r)
}

/*
PostBestAvailableRates Create a Best Available Rates

This API allows to create Best Available rates for rate code(s). <p><strong>OperationId:</strong>postBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPostBestAvailableRatesRequest
*/
func (a *RatePlanApiService) PostBestAvailableRates(ctx context.Context, hotelId string) ApiPostBestAvailableRatesRequest {
	return ApiPostBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PostBestAvailableRatesExecute(r ApiPostBestAvailableRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PostBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.createBestAvailableRates == nil {
		return localVarReturnValue, nil, reportError("createBestAvailableRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createBestAvailableRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	negotiatedRates *PostNegotiatedRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostNegotiatedRatesRequest) Authorization(authorization string) ApiPostNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostNegotiatedRatesRequest) XAppKey(xAppKey string) ApiPostNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostNegotiatedRatesRequest) XHotelid(xHotelid string) ApiPostNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating negotiated rates. Also this object creates new profile discounts for given negotiated rates.
func (r ApiPostNegotiatedRatesRequest) NegotiatedRates(negotiatedRates PostNegotiatedRatesRequest) ApiPostNegotiatedRatesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// External system code.
func (r ApiPostNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) ApiPostNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) ApiPostNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostNegotiatedRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostNegotiatedRatesExecute(r)
}

/*
PostNegotiatedRates Create negotiated rates 

This API allows you to create negotiated rate for a given profile. <p><strong>OperationId:</strong>postNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPostNegotiatedRatesRequest
*/
func (a *RatePlanApiService) PostNegotiatedRates(ctx context.Context, hotelId string) ApiPostNegotiatedRatesRequest {
	return ApiPostNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PostNegotiatedRatesExecute(r ApiPostNegotiatedRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PostNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.negotiatedRates == nil {
		return localVarReturnValue, nil, reportError("negotiatedRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.negotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	negotiatedRates *PostNegotiatedRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutNegotiatedRatesRequest) Authorization(authorization string) ApiPutNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPutNegotiatedRatesRequest) XAppKey(xAppKey string) ApiPutNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutNegotiatedRatesRequest) XHotelid(xHotelid string) ApiPutNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing negotiated rates. This object can be used to manage the negotiated rates and profile discounts. Profile discounts can be created/updated/deleted.
func (r ApiPutNegotiatedRatesRequest) NegotiatedRates(negotiatedRates PostNegotiatedRatesRequest) ApiPutNegotiatedRatesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// External system code.
func (r ApiPutNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) ApiPutNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) ApiPutNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutNegotiatedRatesRequest) Execute() (*NegotiatedRatesDetails, *http.Response, error) {
	return r.ApiService.PutNegotiatedRatesExecute(r)
}

/*
PutNegotiatedRates Change negotiated rates 

This API allows you to update negotiated rate for a given profile. <p><strong>OperationId:</strong>putNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPutNegotiatedRatesRequest
*/
func (a *RatePlanApiService) PutNegotiatedRates(ctx context.Context, rateCode string, hotelId string) ApiPutNegotiatedRatesRequest {
	return ApiPutNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRatesDetails
func (a *RatePlanApiService) PutNegotiatedRatesExecute(r ApiPutNegotiatedRatesRequest) (*NegotiatedRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PutNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/{rateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.negotiatedRates == nil {
		return localVarReturnValue, nil, reportError("negotiatedRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.negotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
