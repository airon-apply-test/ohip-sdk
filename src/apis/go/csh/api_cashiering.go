/*
OPERA Cloud Cashiering API

APIs to cater for Cashiering related functionality in OPERA Cloud.<br /><br /> Cashiering provides access to a guest folio, posting journals, receipt histories, currency calculations, credit card settlements, and check a guest out.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// CashieringApiService CashieringApi service
type CashieringApiService service

type ApiActivatePrepaidCardRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activatePrepaidCard *ActivatePrepaidCardRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiActivatePrepaidCardRequest) Authorization(authorization string) ApiActivatePrepaidCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiActivatePrepaidCardRequest) XAppKey(xAppKey string) ApiActivatePrepaidCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiActivatePrepaidCardRequest) XHotelid(xHotelid string) ApiActivatePrepaidCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for activate prepaid card.
func (r ApiActivatePrepaidCardRequest) ActivatePrepaidCard(activatePrepaidCard ActivatePrepaidCardRequest) ApiActivatePrepaidCardRequest {
	r.activatePrepaidCard = &activatePrepaidCard
	return r
}

// External system code.
func (r ApiActivatePrepaidCardRequest) XExternalsystem(xExternalsystem string) ApiActivatePrepaidCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiActivatePrepaidCardRequest) AcceptLanguage(acceptLanguage string) ApiActivatePrepaidCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiActivatePrepaidCardRequest) Execute() (*ActivatePrepaidCardStatus, *http.Response, error) {
	return r.ApiService.ActivatePrepaidCardExecute(r)
}

/*
ActivatePrepaidCard Operation to activate prepaid card.

You can use this API to activate Prepaid Card. <p><strong>OperationId:</strong>activatePrepaidCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiActivatePrepaidCardRequest
*/
func (a *CashieringApiService) ActivatePrepaidCard(ctx context.Context, hotelId string) ApiActivatePrepaidCardRequest {
	return ApiActivatePrepaidCardRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivatePrepaidCardStatus
func (a *CashieringApiService) ActivatePrepaidCardExecute(r ApiActivatePrepaidCardRequest) (*ActivatePrepaidCardStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivatePrepaidCardStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ActivatePrepaidCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.activatePrepaidCard == nil {
		return localVarReturnValue, nil, reportError("activatePrepaidCard is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activatePrepaidCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdjustTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionsAdjustment *AdjustTransactionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiAdjustTransactionsRequest) Authorization(authorization string) ApiAdjustTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiAdjustTransactionsRequest) XAppKey(xAppKey string) ApiAdjustTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiAdjustTransactionsRequest) XHotelid(xHotelid string) ApiAdjustTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to adjust a transaction. In order to adjust a transaction, a valid amount or percentage is required. A valid reason code and reason text is also required. Only negative adjustments are done. The adjust process will post a new negative transaction for the same transaction code for the current day.
func (r ApiAdjustTransactionsRequest) TransactionsAdjustment(transactionsAdjustment AdjustTransactionsRequest) ApiAdjustTransactionsRequest {
	r.transactionsAdjustment = &transactionsAdjustment
	return r
}

// External system code.
func (r ApiAdjustTransactionsRequest) XExternalsystem(xExternalsystem string) ApiAdjustTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiAdjustTransactionsRequest) AcceptLanguage(acceptLanguage string) ApiAdjustTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiAdjustTransactionsRequest) Execute() (*AdjustedTransactions, *http.Response, error) {
	return r.ApiService.AdjustTransactionsExecute(r)
}

/*
AdjustTransactions Adjust Transactions

You can use this API to Adjust Transactions. <p><strong>OperationId:</strong>adjustTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiAdjustTransactionsRequest
*/
func (a *CashieringApiService) AdjustTransactions(ctx context.Context, hotelId string) ApiAdjustTransactionsRequest {
	return ApiAdjustTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdjustedTransactions
func (a *CashieringApiService) AdjustTransactionsExecute(r ApiAdjustTransactionsRequest) (*AdjustedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AdjustTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/adjust"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transactionsAdjustment == nil {
		return localVarReturnValue, nil, reportError("transactionsAdjustment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionsAdjustment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyFinalPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	finalPostings *ApplyFinalPostingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiApplyFinalPostingsRequest) Authorization(authorization string) ApiApplyFinalPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiApplyFinalPostingsRequest) XAppKey(xAppKey string) ApiApplyFinalPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiApplyFinalPostingsRequest) XHotelid(xHotelid string) ApiApplyFinalPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to apply any final charges or payments to a reservation prior to checkout. This operation should be called prior to the guest settlement which would then reflect the balance the guest has to pay.
func (r ApiApplyFinalPostingsRequest) FinalPostings(finalPostings ApplyFinalPostingsRequest) ApiApplyFinalPostingsRequest {
	r.finalPostings = &finalPostings
	return r
}

// External system code.
func (r ApiApplyFinalPostingsRequest) XExternalsystem(xExternalsystem string) ApiApplyFinalPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiApplyFinalPostingsRequest) AcceptLanguage(acceptLanguage string) ApiApplyFinalPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiApplyFinalPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ApplyFinalPostingsExecute(r)
}

/*
ApplyFinalPostings Apply final Postings

You can use this API to apply final postings on a reservation. <p><strong>OperationId:</strong>applyFinalPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiApplyFinalPostingsRequest
*/
func (a *CashieringApiService) ApplyFinalPostings(ctx context.Context, reservationId string, hotelId string) ApiApplyFinalPostingsRequest {
	return ApiApplyFinalPostingsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ApplyFinalPostingsExecute(r ApiApplyFinalPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ApplyFinalPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/finalCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.finalPostings == nil {
		return localVarReturnValue, nil, reportError("finalPostings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.finalPostings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyFlexibleBenefitPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	flexibleBenefitPostingsCriteria *ApplyFlexibleBenefitPostingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiApplyFlexibleBenefitPostingsRequest) Authorization(authorization string) ApiApplyFlexibleBenefitPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiApplyFlexibleBenefitPostingsRequest) XAppKey(xAppKey string) ApiApplyFlexibleBenefitPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiApplyFlexibleBenefitPostingsRequest) XHotelid(xHotelid string) ApiApplyFlexibleBenefitPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Apply Flexible Benefit Postings.
func (r ApiApplyFlexibleBenefitPostingsRequest) FlexibleBenefitPostingsCriteria(flexibleBenefitPostingsCriteria ApplyFlexibleBenefitPostingsRequest) ApiApplyFlexibleBenefitPostingsRequest {
	r.flexibleBenefitPostingsCriteria = &flexibleBenefitPostingsCriteria
	return r
}

// External system code.
func (r ApiApplyFlexibleBenefitPostingsRequest) XExternalsystem(xExternalsystem string) ApiApplyFlexibleBenefitPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiApplyFlexibleBenefitPostingsRequest) AcceptLanguage(acceptLanguage string) ApiApplyFlexibleBenefitPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiApplyFlexibleBenefitPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ApplyFlexibleBenefitPostingsExecute(r)
}

/*
ApplyFlexibleBenefitPostings Apply flexible benefit postings

You can use this API to apply flexible benefit postings. <p><strong>OperationId:</strong>applyFlexibleBenefitPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiApplyFlexibleBenefitPostingsRequest
*/
func (a *CashieringApiService) ApplyFlexibleBenefitPostings(ctx context.Context, reservationId string, hotelId string) ApiApplyFlexibleBenefitPostingsRequest {
	return ApiApplyFlexibleBenefitPostingsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ApplyFlexibleBenefitPostingsExecute(r ApiApplyFlexibleBenefitPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ApplyFlexibleBenefitPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/flexibleBenefitPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.flexibleBenefitPostingsCriteria == nil {
		return localVarReturnValue, nil, reportError("flexibleBenefitPostingsCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.flexibleBenefitPostingsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachDepositPolicyToPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	policyId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attachPolicyApplyCriteria *AttachDepositPolicyToPaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiAttachDepositPolicyToPaymentRequest) Authorization(authorization string) ApiAttachDepositPolicyToPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiAttachDepositPolicyToPaymentRequest) XAppKey(xAppKey string) ApiAttachDepositPolicyToPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiAttachDepositPolicyToPaymentRequest) XHotelid(xHotelid string) ApiAttachDepositPolicyToPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to attach an existing Deposit Policy on a reservation towards an existing deposit payment on the same reservation.
func (r ApiAttachDepositPolicyToPaymentRequest) AttachPolicyApplyCriteria(attachPolicyApplyCriteria AttachDepositPolicyToPaymentRequest) ApiAttachDepositPolicyToPaymentRequest {
	r.attachPolicyApplyCriteria = &attachPolicyApplyCriteria
	return r
}

// External system code.
func (r ApiAttachDepositPolicyToPaymentRequest) XExternalsystem(xExternalsystem string) ApiAttachDepositPolicyToPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiAttachDepositPolicyToPaymentRequest) AcceptLanguage(acceptLanguage string) ApiAttachDepositPolicyToPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiAttachDepositPolicyToPaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.AttachDepositPolicyToPaymentExecute(r)
}

/*
AttachDepositPolicyToPayment Attach Deposit Policy to Payment

You can use this API to attach Deposit Policy to Payment. <p><strong>OperationId:</strong>attachDepositPolicyToPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param policyId Unique ID of the policy
 @param hotelId Unique ID of the hotel
 @return ApiAttachDepositPolicyToPaymentRequest
*/
func (a *CashieringApiService) AttachDepositPolicyToPayment(ctx context.Context, transactionId string, policyId string, hotelId string) ApiAttachDepositPolicyToPaymentRequest {
	return ApiAttachDepositPolicyToPaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		policyId: policyId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) AttachDepositPolicyToPaymentExecute(r ApiAttachDepositPolicyToPaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AttachDepositPolicyToPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/policies/{policyId}/transactions/{transactionId}/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", url.PathEscape(parameterValueToString(r.policyId, "policyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.policyId) < 1 {
		return localVarReturnValue, nil, reportError("policyId must have at least 1 elements")
	}
	if strlen(r.policyId) > 2000 {
		return localVarReturnValue, nil, reportError("policyId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.attachPolicyApplyCriteria == nil {
		return localVarReturnValue, nil, reportError("attachPolicyApplyCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attachPolicyApplyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizeCreditCardAmountRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccAuthorizationCriteria *AuthorizeCreditCardAmountByProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiAuthorizeCreditCardAmountRequest) Authorization(authorization string) ApiAuthorizeCreditCardAmountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiAuthorizeCreditCardAmountRequest) XAppKey(xAppKey string) ApiAuthorizeCreditCardAmountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiAuthorizeCreditCardAmountRequest) XHotelid(xHotelid string) ApiAuthorizeCreditCardAmountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for a credit card authorization. An authorization request will be sent to the Credit Card Vendor as part of this request.
func (r ApiAuthorizeCreditCardAmountRequest) CcAuthorizationCriteria(ccAuthorizationCriteria AuthorizeCreditCardAmountByProfileRequest) ApiAuthorizeCreditCardAmountRequest {
	r.ccAuthorizationCriteria = &ccAuthorizationCriteria
	return r
}

// External system code.
func (r ApiAuthorizeCreditCardAmountRequest) XExternalsystem(xExternalsystem string) ApiAuthorizeCreditCardAmountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiAuthorizeCreditCardAmountRequest) AcceptLanguage(acceptLanguage string) ApiAuthorizeCreditCardAmountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiAuthorizeCreditCardAmountRequest) Execute() (*AuthorizationInfo, *http.Response, error) {
	return r.ApiService.AuthorizeCreditCardAmountExecute(r)
}

/*
AuthorizeCreditCardAmount Authorize Credit Card Amount

You can use this API to authorize Credit Card Amount by Reservation. <p><strong>OperationId:</strong>authorizeCreditCardAmount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiAuthorizeCreditCardAmountRequest
*/
func (a *CashieringApiService) AuthorizeCreditCardAmount(ctx context.Context, reservationId string, hotelId string) ApiAuthorizeCreditCardAmountRequest {
	return ApiAuthorizeCreditCardAmountRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizationInfo
func (a *CashieringApiService) AuthorizeCreditCardAmountExecute(r ApiAuthorizeCreditCardAmountRequest) (*AuthorizationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AuthorizeCreditCardAmount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods/creditCard/authorize"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.ccAuthorizationCriteria == nil {
		return localVarReturnValue, nil, reportError("ccAuthorizationCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccAuthorizationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizeCreditCardAmountByProfileRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccAuthorizationCriteria *AuthorizeCreditCardAmountByProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiAuthorizeCreditCardAmountByProfileRequest) Authorization(authorization string) ApiAuthorizeCreditCardAmountByProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiAuthorizeCreditCardAmountByProfileRequest) XAppKey(xAppKey string) ApiAuthorizeCreditCardAmountByProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiAuthorizeCreditCardAmountByProfileRequest) XHotelid(xHotelid string) ApiAuthorizeCreditCardAmountByProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for a credit card authorization. An authorization request will be sent to the Credit Card Vendor as part of this request.
func (r ApiAuthorizeCreditCardAmountByProfileRequest) CcAuthorizationCriteria(ccAuthorizationCriteria AuthorizeCreditCardAmountByProfileRequest) ApiAuthorizeCreditCardAmountByProfileRequest {
	r.ccAuthorizationCriteria = &ccAuthorizationCriteria
	return r
}

// External system code.
func (r ApiAuthorizeCreditCardAmountByProfileRequest) XExternalsystem(xExternalsystem string) ApiAuthorizeCreditCardAmountByProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiAuthorizeCreditCardAmountByProfileRequest) AcceptLanguage(acceptLanguage string) ApiAuthorizeCreditCardAmountByProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiAuthorizeCreditCardAmountByProfileRequest) Execute() (*AuthorizationInfo, *http.Response, error) {
	return r.ApiService.AuthorizeCreditCardAmountByProfileExecute(r)
}

/*
AuthorizeCreditCardAmountByProfile Authorize Credit Card Amount by Profile

You can use this API to authorize Credit Card Amount by Profile. <p><strong>OperationId:</strong>authorizeCreditCardAmountByProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return ApiAuthorizeCreditCardAmountByProfileRequest
*/
func (a *CashieringApiService) AuthorizeCreditCardAmountByProfile(ctx context.Context, profileId string, hotelId string) ApiAuthorizeCreditCardAmountByProfileRequest {
	return ApiAuthorizeCreditCardAmountByProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizationInfo
func (a *CashieringApiService) AuthorizeCreditCardAmountByProfileExecute(r ApiAuthorizeCreditCardAmountByProfileRequest) (*AuthorizationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AuthorizeCreditCardAmountByProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/paymentMethods/creditCard/authorize"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.ccAuthorizationCriteria == nil {
		return localVarReturnValue, nil, reportError("ccAuthorizationCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccAuthorizationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAutoSettleCompFoliosRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoSettleCompFolios *AutoSettleCompFoliosRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiAutoSettleCompFoliosRequest) Authorization(authorization string) ApiAutoSettleCompFoliosRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiAutoSettleCompFoliosRequest) XAppKey(xAppKey string) ApiAutoSettleCompFoliosRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiAutoSettleCompFoliosRequest) XHotelid(xHotelid string) ApiAutoSettleCompFoliosRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to auto settle comp folios. OPERA will reference the &#39;Default Comp Payment Method&#39; setting to settle the folio if no authorizer AR account is associated with the folio.
func (r ApiAutoSettleCompFoliosRequest) AutoSettleCompFolios(autoSettleCompFolios AutoSettleCompFoliosRequest) ApiAutoSettleCompFoliosRequest {
	r.autoSettleCompFolios = &autoSettleCompFolios
	return r
}

// External system code.
func (r ApiAutoSettleCompFoliosRequest) XExternalsystem(xExternalsystem string) ApiAutoSettleCompFoliosRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiAutoSettleCompFoliosRequest) AcceptLanguage(acceptLanguage string) ApiAutoSettleCompFoliosRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiAutoSettleCompFoliosRequest) Execute() (*AutoSettleCompFoliosStatus, *http.Response, error) {
	return r.ApiService.AutoSettleCompFoliosExecute(r)
}

/*
AutoSettleCompFolios Operation to auto settle comp folios.

You can use this API to auto Settle CompFolios <p><strong>OperationId:</strong>autoSettleCompFolios</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiAutoSettleCompFoliosRequest
*/
func (a *CashieringApiService) AutoSettleCompFolios(ctx context.Context, reservationId string, hotelId string) ApiAutoSettleCompFoliosRequest {
	return ApiAutoSettleCompFoliosRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoSettleCompFoliosStatus
func (a *CashieringApiService) AutoSettleCompFoliosExecute(r ApiAutoSettleCompFoliosRequest) (*AutoSettleCompFoliosStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoSettleCompFoliosStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AutoSettleCompFolios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/comp/folios/autoSettlements"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.autoSettleCompFolios == nil {
		return localVarReturnValue, nil, reportError("autoSettleCompFolios is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoSettleCompFolios
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBreakCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiBreakCashierLockRequest) Authorization(authorization string) ApiBreakCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiBreakCashierLockRequest) XAppKey(xAppKey string) ApiBreakCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiBreakCashierLockRequest) XHotelid(xHotelid string) ApiBreakCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiBreakCashierLockRequest) XExternalsystem(xExternalsystem string) ApiBreakCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiBreakCashierLockRequest) AcceptLanguage(acceptLanguage string) ApiBreakCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiBreakCashierLockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.BreakCashierLockExecute(r)
}

/*
BreakCashierLock Break Cashier Lock

You can use this API to Break Cashier Lock. <p><strong>OperationId:</strong>breakCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return ApiBreakCashierLockRequest
*/
func (a *CashieringApiService) BreakCashierLock(ctx context.Context, cashierId string) ApiBreakCashierLockRequest {
	return ApiBreakCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) BreakCashierLockExecute(r ApiBreakCashierLockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.BreakCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/locks"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCalculateForeignCurrencyRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	foreignCurrencyCriteria *CalculateForeignCurrencyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCalculateForeignCurrencyRequest) Authorization(authorization string) ApiCalculateForeignCurrencyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCalculateForeignCurrencyRequest) XAppKey(xAppKey string) ApiCalculateForeignCurrencyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCalculateForeignCurrencyRequest) XHotelid(xHotelid string) ApiCalculateForeignCurrencyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to calculate foreign currency exchange.
func (r ApiCalculateForeignCurrencyRequest) ForeignCurrencyCriteria(foreignCurrencyCriteria CalculateForeignCurrencyRequest) ApiCalculateForeignCurrencyRequest {
	r.foreignCurrencyCriteria = &foreignCurrencyCriteria
	return r
}

// External system code.
func (r ApiCalculateForeignCurrencyRequest) XExternalsystem(xExternalsystem string) ApiCalculateForeignCurrencyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCalculateForeignCurrencyRequest) AcceptLanguage(acceptLanguage string) ApiCalculateForeignCurrencyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCalculateForeignCurrencyRequest) Execute() (*CalculatedForeignCurrency, *http.Response, error) {
	return r.ApiService.CalculateForeignCurrencyExecute(r)
}

/*
CalculateForeignCurrency Calculate Foreign Currency

This API will allow you to Calculate Foreign Currency exchange. <p><strong>OperationId:</strong>calculateForeignCurrency</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCalculateForeignCurrencyRequest
*/
func (a *CashieringApiService) CalculateForeignCurrency(ctx context.Context) ApiCalculateForeignCurrencyRequest {
	return ApiCalculateForeignCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CalculatedForeignCurrency
func (a *CashieringApiService) CalculateForeignCurrencyExecute(r ApiCalculateForeignCurrencyRequest) (*CalculatedForeignCurrency, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalculatedForeignCurrency
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.CalculateForeignCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.foreignCurrencyCriteria == nil {
		return localVarReturnValue, nil, reportError("foreignCurrencyCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.foreignCurrencyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelPrepaidCardTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelPrepaidCardTransaction *CancelPrepaidCardTransactionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCancelPrepaidCardTransactionRequest) Authorization(authorization string) ApiCancelPrepaidCardTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCancelPrepaidCardTransactionRequest) XAppKey(xAppKey string) ApiCancelPrepaidCardTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCancelPrepaidCardTransactionRequest) XHotelid(xHotelid string) ApiCancelPrepaidCardTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for reload prepaid card.
func (r ApiCancelPrepaidCardTransactionRequest) CancelPrepaidCardTransaction(cancelPrepaidCardTransaction CancelPrepaidCardTransactionRequest) ApiCancelPrepaidCardTransactionRequest {
	r.cancelPrepaidCardTransaction = &cancelPrepaidCardTransaction
	return r
}

// External system code.
func (r ApiCancelPrepaidCardTransactionRequest) XExternalsystem(xExternalsystem string) ApiCancelPrepaidCardTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCancelPrepaidCardTransactionRequest) AcceptLanguage(acceptLanguage string) ApiCancelPrepaidCardTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCancelPrepaidCardTransactionRequest) Execute() (*CancelPrepaidCardTransactionStatus, *http.Response, error) {
	return r.ApiService.CancelPrepaidCardTransactionExecute(r)
}

/*
CancelPrepaidCardTransaction Operation to cancel prepaid card transaction.

You can use this API to cancel PrepaidCard Transaction. <p><strong>OperationId:</strong>cancelPrepaidCardTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiCancelPrepaidCardTransactionRequest
*/
func (a *CashieringApiService) CancelPrepaidCardTransaction(ctx context.Context, hotelId string) ApiCancelPrepaidCardTransactionRequest {
	return ApiCancelPrepaidCardTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancelPrepaidCardTransactionStatus
func (a *CashieringApiService) CancelPrepaidCardTransactionExecute(r ApiCancelPrepaidCardTransactionRequest) (*CancelPrepaidCardTransactionStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelPrepaidCardTransactionStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.CancelPrepaidCardTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cancelPrepaidCardTransaction == nil {
		return localVarReturnValue, nil, reportError("cancelPrepaidCardTransaction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelPrepaidCardTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCashOutPrepaidCardRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashOutPrepaidCard *CashOutPrepaidCardRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCashOutPrepaidCardRequest) Authorization(authorization string) ApiCashOutPrepaidCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCashOutPrepaidCardRequest) XAppKey(xAppKey string) ApiCashOutPrepaidCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCashOutPrepaidCardRequest) XHotelid(xHotelid string) ApiCashOutPrepaidCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for cashout prepaid card.
func (r ApiCashOutPrepaidCardRequest) CashOutPrepaidCard(cashOutPrepaidCard CashOutPrepaidCardRequest) ApiCashOutPrepaidCardRequest {
	r.cashOutPrepaidCard = &cashOutPrepaidCard
	return r
}

// External system code.
func (r ApiCashOutPrepaidCardRequest) XExternalsystem(xExternalsystem string) ApiCashOutPrepaidCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCashOutPrepaidCardRequest) AcceptLanguage(acceptLanguage string) ApiCashOutPrepaidCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCashOutPrepaidCardRequest) Execute() (*CashOutPrepaidCardStatus, *http.Response, error) {
	return r.ApiService.CashOutPrepaidCardExecute(r)
}

/*
CashOutPrepaidCard Operation to cash out prepaid card.

You can use this API to cashOut Prepaid Card. <p><strong>OperationId:</strong>cashOutPrepaidCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiCashOutPrepaidCardRequest
*/
func (a *CashieringApiService) CashOutPrepaidCard(ctx context.Context, hotelId string) ApiCashOutPrepaidCardRequest {
	return ApiCashOutPrepaidCardRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashOutPrepaidCardStatus
func (a *CashieringApiService) CashOutPrepaidCardExecute(r ApiCashOutPrepaidCardRequest) (*CashOutPrepaidCardStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashOutPrepaidCardStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.CashOutPrepaidCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/cashOut"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cashOutPrepaidCard == nil {
		return localVarReturnValue, nil, reportError("cashOutPrepaidCard is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashOutPrepaidCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeBillingPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingPaymentToChange *ChangeBillingPaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiChangeBillingPaymentRequest) Authorization(authorization string) ApiChangeBillingPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiChangeBillingPaymentRequest) XAppKey(xAppKey string) ApiChangeBillingPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiChangeBillingPaymentRequest) XHotelid(xHotelid string) ApiChangeBillingPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change a payment posting.
func (r ApiChangeBillingPaymentRequest) BillingPaymentToChange(billingPaymentToChange ChangeBillingPaymentRequest) ApiChangeBillingPaymentRequest {
	r.billingPaymentToChange = &billingPaymentToChange
	return r
}

// External system code.
func (r ApiChangeBillingPaymentRequest) XExternalsystem(xExternalsystem string) ApiChangeBillingPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiChangeBillingPaymentRequest) AcceptLanguage(acceptLanguage string) ApiChangeBillingPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiChangeBillingPaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeBillingPaymentExecute(r)
}

/*
ChangeBillingPayment Change Billing Payment

You can use this API to change Billing Payment. <p><strong>OperationId:</strong>changeBillingPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiChangeBillingPaymentRequest
*/
func (a *CashieringApiService) ChangeBillingPayment(ctx context.Context, transactionId string, hotelId string) ApiChangeBillingPaymentRequest {
	return ApiChangeBillingPaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ChangeBillingPaymentExecute(r ApiChangeBillingPaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ChangeBillingPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.billingPaymentToChange == nil {
		return localVarReturnValue, nil, reportError("billingPaymentToChange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingPaymentToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructionsToChange *ChangeRoutingInstructionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiChangeRoutingInstructionsRequest) Authorization(authorization string) ApiChangeRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiChangeRoutingInstructionsRequest) XAppKey(xAppKey string) ApiChangeRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiChangeRoutingInstructionsRequest) XHotelid(xHotelid string) ApiChangeRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request when changing a routing instruction.
func (r ApiChangeRoutingInstructionsRequest) RoutingInstructionsToChange(routingInstructionsToChange ChangeRoutingInstructionsRequest) ApiChangeRoutingInstructionsRequest {
	r.routingInstructionsToChange = &routingInstructionsToChange
	return r
}

// External system code.
func (r ApiChangeRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiChangeRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiChangeRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiChangeRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiChangeRoutingInstructionsRequest) Execute() (*ChangedRoutingInstructions, *http.Response, error) {
	return r.ApiService.ChangeRoutingInstructionsExecute(r)
}

/*
ChangeRoutingInstructions Change routing instructions

You can use this API to update routing instructions for a specified reservation. <p><strong>OperationId:</strong>changeRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiChangeRoutingInstructionsRequest
*/
func (a *CashieringApiService) ChangeRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiChangeRoutingInstructionsRequest {
	return ApiChangeRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedRoutingInstructions
func (a *CashieringApiService) ChangeRoutingInstructionsExecute(r ApiChangeRoutingInstructionsRequest) (*ChangedRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ChangeRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/change"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.routingInstructionsToChange == nil {
		return localVarReturnValue, nil, reportError("routingInstructionsToChange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructionsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckPostRateCodeRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	rateCode string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postRateCodeCriteria *PostRateCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCheckPostRateCodeRequest) Authorization(authorization string) ApiCheckPostRateCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCheckPostRateCodeRequest) XAppKey(xAppKey string) ApiCheckPostRateCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCheckPostRateCodeRequest) XHotelid(xHotelid string) ApiCheckPostRateCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to check if a Rate Code can be posted to the room manually. This will check if the Rate Code is valid, if the Products(Packages) which are defined as part of the Rate Code can be posted or reversed.
func (r ApiCheckPostRateCodeRequest) PostRateCodeCriteria(postRateCodeCriteria PostRateCodeRequest) ApiCheckPostRateCodeRequest {
	r.postRateCodeCriteria = &postRateCodeCriteria
	return r
}

// External system code.
func (r ApiCheckPostRateCodeRequest) XExternalsystem(xExternalsystem string) ApiCheckPostRateCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCheckPostRateCodeRequest) AcceptLanguage(acceptLanguage string) ApiCheckPostRateCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCheckPostRateCodeRequest) Execute() (*CheckedRateCode, *http.Response, error) {
	return r.ApiService.CheckPostRateCodeExecute(r)
}

/*
CheckPostRateCode Change posted rate codes

You can use this API to change posted rate codes. <p><strong>OperationId:</strong>checkPostRateCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode The Rate Code which is to be posted on the Guest Folio.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiCheckPostRateCodeRequest
*/
func (a *CashieringApiService) CheckPostRateCode(ctx context.Context, rateCode string, reservationId string, hotelId string) ApiCheckPostRateCodeRequest {
	return ApiCheckPostRateCodeRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckedRateCode
func (a *CashieringApiService) CheckPostRateCodeExecute(r ApiCheckPostRateCodeRequest) (*CheckedRateCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedRateCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.CheckPostRateCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservation/{reservationId}/rateCode/{rateCode}/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.postRateCodeCriteria == nil {
		return localVarReturnValue, nil, reportError("postRateCodeCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postRateCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClearCashieringServiceCacheRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiClearCashieringServiceCacheRequest) Authorization(authorization string) ApiClearCashieringServiceCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiClearCashieringServiceCacheRequest) XAppKey(xAppKey string) ApiClearCashieringServiceCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiClearCashieringServiceCacheRequest) XHotelid(xHotelid string) ApiClearCashieringServiceCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiClearCashieringServiceCacheRequest) XExternalsystem(xExternalsystem string) ApiClearCashieringServiceCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiClearCashieringServiceCacheRequest) AcceptLanguage(acceptLanguage string) ApiClearCashieringServiceCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiClearCashieringServiceCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ClearCashieringServiceCacheExecute(r)
}

/*
ClearCashieringServiceCache clearing of cache in cashiering services

You can use this API to clear cache in cashiering services. <p><strong>OperationId:</strong>clearCashieringServiceCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClearCashieringServiceCacheRequest
*/
func (a *CashieringApiService) ClearCashieringServiceCache(ctx context.Context) ApiClearCashieringServiceCacheRequest {
	return ApiClearCashieringServiceCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ClearCashieringServiceCacheExecute(r ApiClearCashieringServiceCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ClearCashieringServiceCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/cashiering/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloseReservationFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closeFolioCriteria *CloseReservationFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCloseReservationFolioRequest) Authorization(authorization string) ApiCloseReservationFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCloseReservationFolioRequest) XAppKey(xAppKey string) ApiCloseReservationFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCloseReservationFolioRequest) XHotelid(xHotelid string) ApiCloseReservationFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to close an Open Folio Reservation. The Property should be using the Open Folio Functionality to use this operation.
func (r ApiCloseReservationFolioRequest) CloseFolioCriteria(closeFolioCriteria CloseReservationFolioRequest) ApiCloseReservationFolioRequest {
	r.closeFolioCriteria = &closeFolioCriteria
	return r
}

// External system code.
func (r ApiCloseReservationFolioRequest) XExternalsystem(xExternalsystem string) ApiCloseReservationFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCloseReservationFolioRequest) AcceptLanguage(acceptLanguage string) ApiCloseReservationFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCloseReservationFolioRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CloseReservationFolioExecute(r)
}

/*
CloseReservationFolio Close Reservation Folio

You can use this API to close the Reservation Folio on a reservation. <p><strong>OperationId:</strong>closeReservationFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiCloseReservationFolioRequest
*/
func (a *CashieringApiService) CloseReservationFolio(ctx context.Context, reservationId string, hotelId string) ApiCloseReservationFolioRequest {
	return ApiCloseReservationFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) CloseReservationFolioExecute(r ApiCloseReservationFolioRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.CloseReservationFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.closeFolioCriteria == nil {
		return localVarReturnValue, nil, reportError("closeFolioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.closeFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConvertFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	convertFolioCriteria *ConvertFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiConvertFolioRequest) Authorization(authorization string) ApiConvertFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiConvertFolioRequest) XAppKey(xAppKey string) ApiConvertFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiConvertFolioRequest) XHotelid(xHotelid string) ApiConvertFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to convert folio from a Non Fiscal Folio type to a Fiscal Folio Type. Functionality is used in Italy and is only available when the country mode is set to Italy.
func (r ApiConvertFolioRequest) ConvertFolioCriteria(convertFolioCriteria ConvertFolioRequest) ApiConvertFolioRequest {
	r.convertFolioCriteria = &convertFolioCriteria
	return r
}

// External system code.
func (r ApiConvertFolioRequest) XExternalsystem(xExternalsystem string) ApiConvertFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiConvertFolioRequest) AcceptLanguage(acceptLanguage string) ApiConvertFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiConvertFolioRequest) Execute() (*ConvertFolioDetails, *http.Response, error) {
	return r.ApiService.ConvertFolioExecute(r)
}

/*
ConvertFolio Convert Folio

You can use this API to Convert folio. <p><strong>OperationId:</strong>convertFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio
 @param hotelId Unique ID of the hotel
 @return ApiConvertFolioRequest
*/
func (a *CashieringApiService) ConvertFolio(ctx context.Context, folioId string, hotelId string) ApiConvertFolioRequest {
	return ApiConvertFolioRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ConvertFolioDetails
func (a *CashieringApiService) ConvertFolioExecute(r ApiConvertFolioRequest) (*ConvertFolioDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConvertFolioDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ConvertFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folio/{folioId}/convert"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.convertFolioCriteria == nil {
		return localVarReturnValue, nil, reportError("convertFolioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.convertFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCompRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	folioWindowNo *int32
	payeeId *string
	membershipIdNo *int32
	authorizerId *string
	userId *int32
	userName *string
	comments *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	creditLimit *[]float32
	percentageLimit *[]float32
	covers *[]float32
	transactionCode *[]string
	billingCode *[]string
	routingInstructionsId *[]float32
	routingLinkId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteCompRoutingInstructionsRequest) Authorization(authorization string) ApiDeleteCompRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteCompRoutingInstructionsRequest) XAppKey(xAppKey string) ApiDeleteCompRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteCompRoutingInstructionsRequest) XHotelid(xHotelid string) ApiDeleteCompRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r ApiDeleteCompRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) ApiDeleteCompRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r ApiDeleteCompRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) ApiDeleteCompRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) FolioWindowNo(folioWindowNo int32) ApiDeleteCompRoutingInstructionsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteCompRoutingInstructionsRequest) PayeeId(payeeId string) ApiDeleteCompRoutingInstructionsRequest {
	r.payeeId = &payeeId
	return r
}

// Unique Id of membership
func (r ApiDeleteCompRoutingInstructionsRequest) MembershipIdNo(membershipIdNo int32) ApiDeleteCompRoutingInstructionsRequest {
	r.membershipIdNo = &membershipIdNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteCompRoutingInstructionsRequest) AuthorizerId(authorizerId string) ApiDeleteCompRoutingInstructionsRequest {
	r.authorizerId = &authorizerId
	return r
}

// User Id of the Opera User
func (r ApiDeleteCompRoutingInstructionsRequest) UserId(userId int32) ApiDeleteCompRoutingInstructionsRequest {
	r.userId = &userId
	return r
}

// Name of the Opera User
func (r ApiDeleteCompRoutingInstructionsRequest) UserName(userName string) ApiDeleteCompRoutingInstructionsRequest {
	r.userName = &userName
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Comments(comments string) ApiDeleteCompRoutingInstructionsRequest {
	r.comments = &comments
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r ApiDeleteCompRoutingInstructionsRequest) Daily(daily bool) ApiDeleteCompRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Sunday(sunday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Monday(monday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Tuesday(tuesday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Wednesday(wednesday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Thursday(thursday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Friday(friday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Saturday(saturday bool) ApiDeleteCompRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) StartDate(startDate string) ApiDeleteCompRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) EndDate(endDate string) ApiDeleteCompRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r ApiDeleteCompRoutingInstructionsRequest) CreditLimit(creditLimit []float32) ApiDeleteCompRoutingInstructionsRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r ApiDeleteCompRoutingInstructionsRequest) PercentageLimit(percentageLimit []float32) ApiDeleteCompRoutingInstructionsRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r ApiDeleteCompRoutingInstructionsRequest) Covers(covers []float32) ApiDeleteCompRoutingInstructionsRequest {
	r.covers = &covers
	return r
}

// Unique identifier for the Transaction code.
func (r ApiDeleteCompRoutingInstructionsRequest) TransactionCode(transactionCode []string) ApiDeleteCompRoutingInstructionsRequest {
	r.transactionCode = &transactionCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r ApiDeleteCompRoutingInstructionsRequest) BillingCode(billingCode []string) ApiDeleteCompRoutingInstructionsRequest {
	r.billingCode = &billingCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiDeleteCompRoutingInstructionsRequest) RoutingInstructionsId(routingInstructionsId []float32) ApiDeleteCompRoutingInstructionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteCompRoutingInstructionsRequest) RoutingLinkId(routingLinkId string) ApiDeleteCompRoutingInstructionsRequest {
	r.routingLinkId = &routingLinkId
	return r
}

// External system code.
func (r ApiDeleteCompRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteCompRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteCompRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCompRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteCompRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteCompRoutingInstructionsExecute(r)
}

/*
DeleteCompRoutingInstructions Delete comp routing instructions

You can use this API to delete comp routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteCompRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiDeleteCompRoutingInstructionsRequest
*/
func (a *CashieringApiService) DeleteCompRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiDeleteCompRoutingInstructionsRequest {
	return ApiDeleteCompRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringApiService) DeleteCompRoutingInstructionsExecute(r ApiDeleteCompRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.DeleteCompRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/comp"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
	}
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.payeeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payeeId", r.payeeId, "")
	}
	if r.membershipIdNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipIdNo", r.membershipIdNo, "")
	}
	if r.authorizerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerId", r.authorizerId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "")
	}
	if r.comments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comments", r.comments, "")
	}
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.creditLimit != nil {
		t := *r.creditLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", t, "multi")
		}
	}
	if r.percentageLimit != nil {
		t := *r.percentageLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", t, "multi")
		}
	}
	if r.covers != nil {
		t := *r.covers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "covers", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "covers", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
	}
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
	}
	if r.routingLinkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkId", r.routingLinkId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFolioRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	folioWindowNo *int32
	payeeId *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	creditLimit *[]float32
	percentageLimit *[]float32
	covers *[]float32
	transactionCode *[]string
	billingCode *[]string
	routingInstructionsId *[]float32
	routingLinkId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteFolioRoutingInstructionsRequest) Authorization(authorization string) ApiDeleteFolioRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteFolioRoutingInstructionsRequest) XAppKey(xAppKey string) ApiDeleteFolioRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteFolioRoutingInstructionsRequest) XHotelid(xHotelid string) ApiDeleteFolioRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r ApiDeleteFolioRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r ApiDeleteFolioRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) FolioWindowNo(folioWindowNo int32) ApiDeleteFolioRoutingInstructionsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteFolioRoutingInstructionsRequest) PayeeId(payeeId string) ApiDeleteFolioRoutingInstructionsRequest {
	r.payeeId = &payeeId
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r ApiDeleteFolioRoutingInstructionsRequest) Daily(daily bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Sunday(sunday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Monday(monday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Tuesday(tuesday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Wednesday(wednesday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Thursday(thursday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Friday(friday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Saturday(saturday bool) ApiDeleteFolioRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) StartDate(startDate string) ApiDeleteFolioRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) EndDate(endDate string) ApiDeleteFolioRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r ApiDeleteFolioRoutingInstructionsRequest) CreditLimit(creditLimit []float32) ApiDeleteFolioRoutingInstructionsRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r ApiDeleteFolioRoutingInstructionsRequest) PercentageLimit(percentageLimit []float32) ApiDeleteFolioRoutingInstructionsRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r ApiDeleteFolioRoutingInstructionsRequest) Covers(covers []float32) ApiDeleteFolioRoutingInstructionsRequest {
	r.covers = &covers
	return r
}

// Unique identifier for the Transaction code.
func (r ApiDeleteFolioRoutingInstructionsRequest) TransactionCode(transactionCode []string) ApiDeleteFolioRoutingInstructionsRequest {
	r.transactionCode = &transactionCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r ApiDeleteFolioRoutingInstructionsRequest) BillingCode(billingCode []string) ApiDeleteFolioRoutingInstructionsRequest {
	r.billingCode = &billingCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiDeleteFolioRoutingInstructionsRequest) RoutingInstructionsId(routingInstructionsId []float32) ApiDeleteFolioRoutingInstructionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteFolioRoutingInstructionsRequest) RoutingLinkId(routingLinkId string) ApiDeleteFolioRoutingInstructionsRequest {
	r.routingLinkId = &routingLinkId
	return r
}

// External system code.
func (r ApiDeleteFolioRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteFolioRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteFolioRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteFolioRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteFolioRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteFolioRoutingInstructionsExecute(r)
}

/*
DeleteFolioRoutingInstructions Delete Folio routing instructions

You can use this API to delete folio routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteFolioRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiDeleteFolioRoutingInstructionsRequest
*/
func (a *CashieringApiService) DeleteFolioRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiDeleteFolioRoutingInstructionsRequest {
	return ApiDeleteFolioRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringApiService) DeleteFolioRoutingInstructionsExecute(r ApiDeleteFolioRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.DeleteFolioRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/folio"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
	}
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.payeeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payeeId", r.payeeId, "")
	}
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.creditLimit != nil {
		t := *r.creditLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", t, "multi")
		}
	}
	if r.percentageLimit != nil {
		t := *r.percentageLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", t, "multi")
		}
	}
	if r.covers != nil {
		t := *r.covers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "covers", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "covers", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
	}
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
	}
	if r.routingLinkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkId", r.routingLinkId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRequestRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	userName *string
	comments *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteRequestRoutingInstructionsRequest) Authorization(authorization string) ApiDeleteRequestRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteRequestRoutingInstructionsRequest) XAppKey(xAppKey string) ApiDeleteRequestRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteRequestRoutingInstructionsRequest) XHotelid(xHotelid string) ApiDeleteRequestRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r ApiDeleteRequestRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r ApiDeleteRequestRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

// Name of the Opera User
func (r ApiDeleteRequestRoutingInstructionsRequest) UserName(userName string) ApiDeleteRequestRoutingInstructionsRequest {
	r.userName = &userName
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Comments(comments string) ApiDeleteRequestRoutingInstructionsRequest {
	r.comments = &comments
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r ApiDeleteRequestRoutingInstructionsRequest) Daily(daily bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Sunday(sunday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Monday(monday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Tuesday(tuesday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Wednesday(wednesday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Thursday(thursday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Friday(friday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Saturday(saturday bool) ApiDeleteRequestRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) StartDate(startDate string) ApiDeleteRequestRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) EndDate(endDate string) ApiDeleteRequestRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// External system code.
func (r ApiDeleteRequestRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteRequestRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteRequestRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteRequestRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteRequestRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteRequestRoutingInstructionsExecute(r)
}

/*
DeleteRequestRoutingInstructions Delete request routing instructions

You can use this API to delete request routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteRequestRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiDeleteRequestRoutingInstructionsRequest
*/
func (a *CashieringApiService) DeleteRequestRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiDeleteRequestRoutingInstructionsRequest {
	return ApiDeleteRequestRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringApiService) DeleteRequestRoutingInstructionsExecute(r ApiDeleteRequestRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.DeleteRequestRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/request"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
	}
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
	}
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "")
	}
	if r.comments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comments", r.comments, "")
	}
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoomRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	reservationNameId *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	creditLimit *[]float32
	percentageLimit *[]float32
	covers *[]float32
	transactionCode *[]string
	billingCode *[]string
	routingInstructionsId *[]float32
	routingLinkId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteRoomRoutingInstructionsRequest) Authorization(authorization string) ApiDeleteRoomRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteRoomRoutingInstructionsRequest) XAppKey(xAppKey string) ApiDeleteRoomRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteRoomRoutingInstructionsRequest) XHotelid(xHotelid string) ApiDeleteRoomRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r ApiDeleteRoomRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r ApiDeleteRoomRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteRoomRoutingInstructionsRequest) ReservationNameId(reservationNameId string) ApiDeleteRoomRoutingInstructionsRequest {
	r.reservationNameId = &reservationNameId
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r ApiDeleteRoomRoutingInstructionsRequest) Daily(daily bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Sunday(sunday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Monday(monday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Tuesday(tuesday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Wednesday(wednesday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Thursday(thursday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Friday(friday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Saturday(saturday bool) ApiDeleteRoomRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) StartDate(startDate string) ApiDeleteRoomRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) EndDate(endDate string) ApiDeleteRoomRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r ApiDeleteRoomRoutingInstructionsRequest) CreditLimit(creditLimit []float32) ApiDeleteRoomRoutingInstructionsRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r ApiDeleteRoomRoutingInstructionsRequest) PercentageLimit(percentageLimit []float32) ApiDeleteRoomRoutingInstructionsRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r ApiDeleteRoomRoutingInstructionsRequest) Covers(covers []float32) ApiDeleteRoomRoutingInstructionsRequest {
	r.covers = &covers
	return r
}

// Unique identifier for the Transaction code.
func (r ApiDeleteRoomRoutingInstructionsRequest) TransactionCode(transactionCode []string) ApiDeleteRoomRoutingInstructionsRequest {
	r.transactionCode = &transactionCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r ApiDeleteRoomRoutingInstructionsRequest) BillingCode(billingCode []string) ApiDeleteRoomRoutingInstructionsRequest {
	r.billingCode = &billingCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiDeleteRoomRoutingInstructionsRequest) RoutingInstructionsId(routingInstructionsId []float32) ApiDeleteRoomRoutingInstructionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteRoomRoutingInstructionsRequest) RoutingLinkId(routingLinkId string) ApiDeleteRoomRoutingInstructionsRequest {
	r.routingLinkId = &routingLinkId
	return r
}

// External system code.
func (r ApiDeleteRoomRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteRoomRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteRoomRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteRoomRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteRoomRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteRoomRoutingInstructionsExecute(r)
}

/*
DeleteRoomRoutingInstructions Delete Room routing instructions

You can use this API to delete room routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteRoomRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiDeleteRoomRoutingInstructionsRequest
*/
func (a *CashieringApiService) DeleteRoomRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiDeleteRoomRoutingInstructionsRequest {
	return ApiDeleteRoomRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringApiService) DeleteRoomRoutingInstructionsExecute(r ApiDeleteRoomRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.DeleteRoomRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/room"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
	}
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
	}
	if r.reservationNameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationNameId", r.reservationNameId, "")
	}
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.creditLimit != nil {
		t := *r.creditLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", t, "multi")
		}
	}
	if r.percentageLimit != nil {
		t := *r.percentageLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", t, "multi")
		}
	}
	if r.covers != nil {
		t := *r.covers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "covers", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "covers", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
	}
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
	}
	if r.routingLinkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkId", r.routingLinkId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteRoutingInstructionsRequest) Authorization(authorization string) ApiDeleteRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteRoutingInstructionsRequest) XAppKey(xAppKey string) ApiDeleteRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteRoutingInstructionsRequest) XHotelid(xHotelid string) ApiDeleteRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoutingInstructionsExecute(r)
}

/*
DeleteRoutingInstructions Delete routing instructions

You can use this API to delete routing instructions for a specified reservation.<br><p><strong><mark>This API is deprecated. Please use deleteFolioRoutingInstructions or  deleteRoomRoutingInstructions or deleteCompRoutingInstructions or deleteRequestRoutingInstructions instead</mark></strong></p> <p><strong>OperationId:</strong>deleteRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiDeleteRoutingInstructionsRequest

Deprecated
*/
func (a *CashieringApiService) DeleteRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiDeleteRoutingInstructionsRequest {
	return ApiDeleteRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringApiService) DeleteRoutingInstructionsExecute(r ApiDeleteRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.DeleteRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetachDepositPolicyFromPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	detachPolicyApplyCriteria *DetachDepositPolicyFromPaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDetachDepositPolicyFromPaymentRequest) Authorization(authorization string) ApiDetachDepositPolicyFromPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDetachDepositPolicyFromPaymentRequest) XAppKey(xAppKey string) ApiDetachDepositPolicyFromPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDetachDepositPolicyFromPaymentRequest) XHotelid(xHotelid string) ApiDetachDepositPolicyFromPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to detach a deposit payment from a Deposit Policy on a reservation.
func (r ApiDetachDepositPolicyFromPaymentRequest) DetachPolicyApplyCriteria(detachPolicyApplyCriteria DetachDepositPolicyFromPaymentRequest) ApiDetachDepositPolicyFromPaymentRequest {
	r.detachPolicyApplyCriteria = &detachPolicyApplyCriteria
	return r
}

// External system code.
func (r ApiDetachDepositPolicyFromPaymentRequest) XExternalsystem(xExternalsystem string) ApiDetachDepositPolicyFromPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDetachDepositPolicyFromPaymentRequest) AcceptLanguage(acceptLanguage string) ApiDetachDepositPolicyFromPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDetachDepositPolicyFromPaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DetachDepositPolicyFromPaymentExecute(r)
}

/*
DetachDepositPolicyFromPayment Detach Deposit Policy from Payment

You can use this API to detach Deposit Policy from Payment. <p><strong>OperationId:</strong>detachDepositPolicyFromPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiDetachDepositPolicyFromPaymentRequest
*/
func (a *CashieringApiService) DetachDepositPolicyFromPayment(ctx context.Context, transactionId string, hotelId string) ApiDetachDepositPolicyFromPaymentRequest {
	return ApiDetachDepositPolicyFromPaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) DetachDepositPolicyFromPaymentExecute(r ApiDetachDepositPolicyFromPaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.DetachDepositPolicyFromPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/policies/detach/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.detachPolicyApplyCriteria == nil {
		return localVarReturnValue, nil, reportError("detachPolicyApplyCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.detachPolicyApplyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateFiscalFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalInfoFolioCriteria *GenerateFiscalFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGenerateFiscalFolioRequest) Authorization(authorization string) ApiGenerateFiscalFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGenerateFiscalFolioRequest) XAppKey(xAppKey string) ApiGenerateFiscalFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGenerateFiscalFolioRequest) XHotelid(xHotelid string) ApiGenerateFiscalFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate fiscal Information folio.
func (r ApiGenerateFiscalFolioRequest) FiscalInfoFolioCriteria(fiscalInfoFolioCriteria GenerateFiscalFolioRequest) ApiGenerateFiscalFolioRequest {
	r.fiscalInfoFolioCriteria = &fiscalInfoFolioCriteria
	return r
}

// External system code.
func (r ApiGenerateFiscalFolioRequest) XExternalsystem(xExternalsystem string) ApiGenerateFiscalFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGenerateFiscalFolioRequest) AcceptLanguage(acceptLanguage string) ApiGenerateFiscalFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGenerateFiscalFolioRequest) Execute() (*FiscalInformationFolio, *http.Response, error) {
	return r.ApiService.GenerateFiscalFolioExecute(r)
}

/*
GenerateFiscalFolio Create Fiscal Information Folio

You can use this API to create Fiscal Information Folio. <p><strong>OperationId:</strong>generateFiscalFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGenerateFiscalFolioRequest
*/
func (a *CashieringApiService) GenerateFiscalFolio(ctx context.Context, hotelId string) ApiGenerateFiscalFolioRequest {
	return ApiGenerateFiscalFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalInformationFolio
func (a *CashieringApiService) GenerateFiscalFolioExecute(r ApiGenerateFiscalFolioRequest) (*FiscalInformationFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalInformationFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GenerateFiscalFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalFolios"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fiscalInfoFolioCriteria == nil {
		return localVarReturnValue, nil, reportError("fiscalInfoFolioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalInfoFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioCriteria *GenerateFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGenerateFolioRequest) Authorization(authorization string) ApiGenerateFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGenerateFolioRequest) XAppKey(xAppKey string) ApiGenerateFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGenerateFolioRequest) XHotelid(xHotelid string) ApiGenerateFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Generate Folio request can be used to create a folio for checked in reservation or reservation with open folios
func (r ApiGenerateFolioRequest) FolioCriteria(folioCriteria GenerateFolioRequest) ApiGenerateFolioRequest {
	r.folioCriteria = &folioCriteria
	return r
}

// External system code.
func (r ApiGenerateFolioRequest) XExternalsystem(xExternalsystem string) ApiGenerateFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGenerateFolioRequest) AcceptLanguage(acceptLanguage string) ApiGenerateFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGenerateFolioRequest) Execute() (*GeneratedFolio, *http.Response, error) {
	return r.ApiService.GenerateFolioExecute(r)
}

/*
GenerateFolio Generate Folios

You can use this API to generate folios for a reservation. <p><strong>OperationId:</strong>generateFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGenerateFolioRequest
*/
func (a *CashieringApiService) GenerateFolio(ctx context.Context, reservationId string, hotelId string) ApiGenerateFolioRequest {
	return ApiGenerateFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GeneratedFolio
func (a *CashieringApiService) GenerateFolioExecute(r ApiGenerateFolioRequest) (*GeneratedFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GeneratedFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GenerateFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.folioCriteria == nil {
		return localVarReturnValue, nil, reportError("folioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdditionalTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	folioView *int32
	currencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAdditionalTaxesRequest) Authorization(authorization string) ApiGetAdditionalTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAdditionalTaxesRequest) XAppKey(xAppKey string) ApiGetAdditionalTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAdditionalTaxesRequest) XHotelid(xHotelid string) ApiGetAdditionalTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetAdditionalTaxesRequest) IdContext(idContext string) ApiGetAdditionalTaxesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetAdditionalTaxesRequest) Type_(type_ string) ApiGetAdditionalTaxesRequest {
	r.type_ = &type_
	return r
}

// Folio Window.
func (r ApiGetAdditionalTaxesRequest) FolioView(folioView int32) ApiGetAdditionalTaxesRequest {
	r.folioView = &folioView
	return r
}

// Currency code on which tax is to be calculated
func (r ApiGetAdditionalTaxesRequest) CurrencyCode(currencyCode string) ApiGetAdditionalTaxesRequest {
	r.currencyCode = &currencyCode
	return r
}

// External system code.
func (r ApiGetAdditionalTaxesRequest) XExternalsystem(xExternalsystem string) ApiGetAdditionalTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAdditionalTaxesRequest) AcceptLanguage(acceptLanguage string) ApiGetAdditionalTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAdditionalTaxesRequest) Execute() (*AdditionalTaxesDetails, *http.Response, error) {
	return r.ApiService.GetAdditionalTaxesExecute(r)
}

/*
GetAdditionalTaxes Get additional Taxes

You can use this API to get Additional Taxes. <p><strong>OperationId:</strong>getAdditionalTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiGetAdditionalTaxesRequest
*/
func (a *CashieringApiService) GetAdditionalTaxes(ctx context.Context, reservationId string, hotelId string) ApiGetAdditionalTaxesRequest {
	return ApiGetAdditionalTaxesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdditionalTaxesDetails
func (a *CashieringApiService) GetAdditionalTaxesExecute(r ApiGetAdditionalTaxesRequest) (*AdditionalTaxesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdditionalTaxesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetAdditionalTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/additionalTaxes"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdvancePaymentBalanceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	fromDate *string
	numberOfNights *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAdvancePaymentBalanceRequest) Authorization(authorization string) ApiGetAdvancePaymentBalanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAdvancePaymentBalanceRequest) XAppKey(xAppKey string) ApiGetAdvancePaymentBalanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAdvancePaymentBalanceRequest) XHotelid(xHotelid string) ApiGetAdvancePaymentBalanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetAdvancePaymentBalanceRequest) IdContext(idContext string) ApiGetAdvancePaymentBalanceRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetAdvancePaymentBalanceRequest) Type_(type_ string) ApiGetAdvancePaymentBalanceRequest {
	r.type_ = &type_
	return r
}

// From date of reservation.
func (r ApiGetAdvancePaymentBalanceRequest) FromDate(fromDate string) ApiGetAdvancePaymentBalanceRequest {
	r.fromDate = &fromDate
	return r
}

// Number of nights to calculate advance payment.
func (r ApiGetAdvancePaymentBalanceRequest) NumberOfNights(numberOfNights int32) ApiGetAdvancePaymentBalanceRequest {
	r.numberOfNights = &numberOfNights
	return r
}

// External system code.
func (r ApiGetAdvancePaymentBalanceRequest) XExternalsystem(xExternalsystem string) ApiGetAdvancePaymentBalanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAdvancePaymentBalanceRequest) AcceptLanguage(acceptLanguage string) ApiGetAdvancePaymentBalanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAdvancePaymentBalanceRequest) Execute() (*AdvancePaymentBalance, *http.Response, error) {
	return r.ApiService.GetAdvancePaymentBalanceExecute(r)
}

/*
GetAdvancePaymentBalance Get advance payment balance

You can use this API to get advance payment balance. <p><strong>OperationId:</strong>getAdvancePaymentBalance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetAdvancePaymentBalanceRequest
*/
func (a *CashieringApiService) GetAdvancePaymentBalance(ctx context.Context, reservationId string, hotelId string) ApiGetAdvancePaymentBalanceRequest {
	return ApiGetAdvancePaymentBalanceRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdvancePaymentBalance
func (a *CashieringApiService) GetAdvancePaymentBalanceExecute(r ApiGetAdvancePaymentBalanceRequest) (*AdvancePaymentBalance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdvancePaymentBalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetAdvancePaymentBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advancePaymentBalance"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.numberOfNights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfNights", r.numberOfNights, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	alertArea *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAlertsRequest) Authorization(authorization string) ApiGetAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAlertsRequest) XAppKey(xAppKey string) ApiGetAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAlertsRequest) XHotelid(xHotelid string) ApiGetAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetAlertsRequest) AlertArea(alertArea string) ApiGetAlertsRequest {
	r.alertArea = &alertArea
	return r
}

// External system code.
func (r ApiGetAlertsRequest) XExternalsystem(xExternalsystem string) ApiGetAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAlertsRequest) AcceptLanguage(acceptLanguage string) ApiGetAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAlertsRequest) Execute() (*AlertNotices, *http.Response, error) {
	return r.ApiService.GetAlertsExecute(r)
}

/*
GetAlerts Get Alert Notices

You can use this API to get Alert Notices.<br><p><strong><mark>This API is deprecated.</mark></strong></p> <p><strong>OperationId:</strong>getAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel
 @return ApiGetAlertsRequest

Deprecated
*/
func (a *CashieringApiService) GetAlerts(ctx context.Context, reservationId string, hotelId string) ApiGetAlertsRequest {
	return ApiGetAlertsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AlertNotices
// Deprecated
func (a *CashieringApiService) GetAlertsExecute(r ApiGetAlertsRequest) (*AlertNotices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertNotices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.alertArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertArea", r.alertArea, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizationHistoryRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	includeAuthorizations *bool
	includePayments *bool
	includeRefunds *bool
	includeFailures *bool
	folioView *int32
	transactionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAuthorizationHistoryRequest) Authorization(authorization string) ApiGetAuthorizationHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAuthorizationHistoryRequest) XAppKey(xAppKey string) ApiGetAuthorizationHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAuthorizationHistoryRequest) XHotelid(xHotelid string) ApiGetAuthorizationHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetAuthorizationHistoryRequest) IdContext(idContext string) ApiGetAuthorizationHistoryRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetAuthorizationHistoryRequest) Type_(type_ string) ApiGetAuthorizationHistoryRequest {
	r.type_ = &type_
	return r
}

// A flag which indicates whether authorizations should be included in the returned list.
func (r ApiGetAuthorizationHistoryRequest) IncludeAuthorizations(includeAuthorizations bool) ApiGetAuthorizationHistoryRequest {
	r.includeAuthorizations = &includeAuthorizations
	return r
}

// A flag which indicates whether payments should be included in the returned list.
func (r ApiGetAuthorizationHistoryRequest) IncludePayments(includePayments bool) ApiGetAuthorizationHistoryRequest {
	r.includePayments = &includePayments
	return r
}

// A flag which indicates whether refunds should be included in the returned list.
func (r ApiGetAuthorizationHistoryRequest) IncludeRefunds(includeRefunds bool) ApiGetAuthorizationHistoryRequest {
	r.includeRefunds = &includeRefunds
	return r
}

// A flag which indicates whether failures should be included in the returned list.
func (r ApiGetAuthorizationHistoryRequest) IncludeFailures(includeFailures bool) ApiGetAuthorizationHistoryRequest {
	r.includeFailures = &includeFailures
	return r
}

func (r ApiGetAuthorizationHistoryRequest) FolioView(folioView int32) ApiGetAuthorizationHistoryRequest {
	r.folioView = &folioView
	return r
}

// Currently supported transaction type categories used for credit card authorization.
func (r ApiGetAuthorizationHistoryRequest) TransactionType(transactionType string) ApiGetAuthorizationHistoryRequest {
	r.transactionType = &transactionType
	return r
}

// External system code.
func (r ApiGetAuthorizationHistoryRequest) XExternalsystem(xExternalsystem string) ApiGetAuthorizationHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAuthorizationHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetAuthorizationHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAuthorizationHistoryRequest) Execute() (*AuthorizationHistory, *http.Response, error) {
	return r.ApiService.GetAuthorizationHistoryExecute(r)
}

/*
GetAuthorizationHistory Get authorization history

You can use this API to get authorization history. <p><strong>OperationId:</strong>getAuthorizationHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetAuthorizationHistoryRequest
*/
func (a *CashieringApiService) GetAuthorizationHistory(ctx context.Context, reservationId string, hotelId string) ApiGetAuthorizationHistoryRequest {
	return ApiGetAuthorizationHistoryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizationHistory
func (a *CashieringApiService) GetAuthorizationHistoryExecute(r ApiGetAuthorizationHistoryRequest) (*AuthorizationHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetAuthorizationHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/authorizationHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.includeAuthorizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAuthorizations", r.includeAuthorizations, "")
	}
	if r.includePayments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePayments", r.includePayments, "")
	}
	if r.includeRefunds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRefunds", r.includeRefunds, "")
	}
	if r.includeFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFailures", r.includeFailures, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.transactionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", r.transactionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizersCreditInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	startDate *string
	endDate *string
	duration *string
	code *[]string
	includeCreditDetails *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAuthorizersCreditInfoRequest) Authorization(authorization string) ApiGetAuthorizersCreditInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAuthorizersCreditInfoRequest) XAppKey(xAppKey string) ApiGetAuthorizersCreditInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAuthorizersCreditInfoRequest) XHotelid(xHotelid string) ApiGetAuthorizersCreditInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetAuthorizersCreditInfoRequest) StartDate(startDate string) ApiGetAuthorizersCreditInfoRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetAuthorizersCreditInfoRequest) EndDate(endDate string) ApiGetAuthorizersCreditInfoRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetAuthorizersCreditInfoRequest) Duration(duration string) ApiGetAuthorizersCreditInfoRequest {
	r.duration = &duration
	return r
}

func (r ApiGetAuthorizersCreditInfoRequest) Code(code []string) ApiGetAuthorizersCreditInfoRequest {
	r.code = &code
	return r
}

// This flag will notify the service if the Credit details will also be returned or not.
func (r ApiGetAuthorizersCreditInfoRequest) IncludeCreditDetails(includeCreditDetails bool) ApiGetAuthorizersCreditInfoRequest {
	r.includeCreditDetails = &includeCreditDetails
	return r
}

// External system code.
func (r ApiGetAuthorizersCreditInfoRequest) XExternalsystem(xExternalsystem string) ApiGetAuthorizersCreditInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAuthorizersCreditInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetAuthorizersCreditInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAuthorizersCreditInfoRequest) Execute() (*AuthorizersCreditInfo, *http.Response, error) {
	return r.ApiService.GetAuthorizersCreditInfoExecute(r)
}

/*
GetAuthorizersCreditInfo Get Authorizers Credit Info

You can use this API to get Authorizers Credit Info. <p><strong>OperationId:</strong>getAuthorizersCreditInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetAuthorizersCreditInfoRequest
*/
func (a *CashieringApiService) GetAuthorizersCreditInfo(ctx context.Context, hotelId string) ApiGetAuthorizersCreditInfoRequest {
	return ApiGetAuthorizersCreditInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizersCreditInfo
func (a *CashieringApiService) GetAuthorizersCreditInfoExecute(r ApiGetAuthorizersCreditInfoRequest) (*AuthorizersCreditInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizersCreditInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetAuthorizersCreditInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/authorizers/credits"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.includeCreditDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCreditDetails", r.includeCreditDetails, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBalanceInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	id *string
	idContext *string
	type_ *string
	folioWindowNo *[]int32
	cashierId *[]float32
	transactionCode *[]string
	articleCode *[]string
	amount *[]float32
	currencyCode *[]string
	postingQuantity *[]int32
	postingReference *[]string
	postingRemark *[]string
	checkNumber *[]string
	arrangementCode *[]string
	applyRoutingInstructions *[]bool
	usePackageAllowance *[]bool
	autoPosting *[]bool
	uniqueIdId *[]string
	uniqueIdIdContext *[]string
	uniqueIdType *[]string
	postItNumberId *string
	postItNumberIdContext *string
	postItNumberType *string
	profileIdId *string
	profileIdIdContext *string
	profileIdType *string
	reservationIdId *string
	reservationIdIdContext *string
	reservationIdType *string
	policyIdId *string
	policyIdIdContext *string
	policyIdType *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBalanceInfoRequest) Authorization(authorization string) ApiGetBalanceInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBalanceInfoRequest) XAppKey(xAppKey string) ApiGetBalanceInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBalanceInfoRequest) XHotelid(xHotelid string) ApiGetBalanceInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r ApiGetBalanceInfoRequest) Event(event string) ApiGetBalanceInfoRequest {
	r.event = &event
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBalanceInfoRequest) Id(id string) ApiGetBalanceInfoRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBalanceInfoRequest) IdContext(idContext string) ApiGetBalanceInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBalanceInfoRequest) Type_(type_ string) ApiGetBalanceInfoRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetBalanceInfoRequest) FolioWindowNo(folioWindowNo []int32) ApiGetBalanceInfoRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetBalanceInfoRequest) CashierId(cashierId []float32) ApiGetBalanceInfoRequest {
	r.cashierId = &cashierId
	return r
}

// Transaction Code to post.
func (r ApiGetBalanceInfoRequest) TransactionCode(transactionCode []string) ApiGetBalanceInfoRequest {
	r.transactionCode = &transactionCode
	return r
}

// Article ID.
func (r ApiGetBalanceInfoRequest) ArticleCode(articleCode []string) ApiGetBalanceInfoRequest {
	r.articleCode = &articleCode
	return r
}

// A monetary amount.
func (r ApiGetBalanceInfoRequest) Amount(amount []float32) ApiGetBalanceInfoRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetBalanceInfoRequest) CurrencyCode(currencyCode []string) ApiGetBalanceInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// Quantity to post to the folio.
func (r ApiGetBalanceInfoRequest) PostingQuantity(postingQuantity []int32) ApiGetBalanceInfoRequest {
	r.postingQuantity = &postingQuantity
	return r
}

// User-defined posting reference.
func (r ApiGetBalanceInfoRequest) PostingReference(postingReference []string) ApiGetBalanceInfoRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r ApiGetBalanceInfoRequest) PostingRemark(postingRemark []string) ApiGetBalanceInfoRequest {
	r.postingRemark = &postingRemark
	return r
}

// Indicates the Cheque number.
func (r ApiGetBalanceInfoRequest) CheckNumber(checkNumber []string) ApiGetBalanceInfoRequest {
	r.checkNumber = &checkNumber
	return r
}

// Corrected arrangement code from the package associated to this transaction.
func (r ApiGetBalanceInfoRequest) ArrangementCode(arrangementCode []string) ApiGetBalanceInfoRequest {
	r.arrangementCode = &arrangementCode
	return r
}

// Apply room routing when making this posting.
func (r ApiGetBalanceInfoRequest) ApplyRoutingInstructions(applyRoutingInstructions []bool) ApiGetBalanceInfoRequest {
	r.applyRoutingInstructions = &applyRoutingInstructions
	return r
}

// Use the applicable package allowance when making this posting.
func (r ApiGetBalanceInfoRequest) UsePackageAllowance(usePackageAllowance []bool) ApiGetBalanceInfoRequest {
	r.usePackageAllowance = &usePackageAllowance
	return r
}

// True indicates the Transaction Code is allowed to be posted automatically.
func (r ApiGetBalanceInfoRequest) AutoPosting(autoPosting []bool) ApiGetBalanceInfoRequest {
	r.autoPosting = &autoPosting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBalanceInfoRequest) UniqueIdId(uniqueIdId []string) ApiGetBalanceInfoRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBalanceInfoRequest) UniqueIdIdContext(uniqueIdIdContext []string) ApiGetBalanceInfoRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBalanceInfoRequest) UniqueIdType(uniqueIdType []string) ApiGetBalanceInfoRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBalanceInfoRequest) PostItNumberId(postItNumberId string) ApiGetBalanceInfoRequest {
	r.postItNumberId = &postItNumberId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBalanceInfoRequest) PostItNumberIdContext(postItNumberIdContext string) ApiGetBalanceInfoRequest {
	r.postItNumberIdContext = &postItNumberIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBalanceInfoRequest) PostItNumberType(postItNumberType string) ApiGetBalanceInfoRequest {
	r.postItNumberType = &postItNumberType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBalanceInfoRequest) ProfileIdId(profileIdId string) ApiGetBalanceInfoRequest {
	r.profileIdId = &profileIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBalanceInfoRequest) ProfileIdIdContext(profileIdIdContext string) ApiGetBalanceInfoRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBalanceInfoRequest) ProfileIdType(profileIdType string) ApiGetBalanceInfoRequest {
	r.profileIdType = &profileIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBalanceInfoRequest) ReservationIdId(reservationIdId string) ApiGetBalanceInfoRequest {
	r.reservationIdId = &reservationIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBalanceInfoRequest) ReservationIdIdContext(reservationIdIdContext string) ApiGetBalanceInfoRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBalanceInfoRequest) ReservationIdType(reservationIdType string) ApiGetBalanceInfoRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBalanceInfoRequest) PolicyIdId(policyIdId string) ApiGetBalanceInfoRequest {
	r.policyIdId = &policyIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBalanceInfoRequest) PolicyIdIdContext(policyIdIdContext string) ApiGetBalanceInfoRequest {
	r.policyIdIdContext = &policyIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBalanceInfoRequest) PolicyIdType(policyIdType string) ApiGetBalanceInfoRequest {
	r.policyIdType = &policyIdType
	return r
}

// The Fiscal Bill number of this posting
func (r ApiGetBalanceInfoRequest) FiscalBillNo(fiscalBillNo string) ApiGetBalanceInfoRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiGetBalanceInfoRequest) FolioDate(folioDate string) ApiGetBalanceInfoRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r ApiGetBalanceInfoRequest) FolioNo(folioNo float32) ApiGetBalanceInfoRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiGetBalanceInfoRequest) FolioStatus(folioStatus string) ApiGetBalanceInfoRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiGetBalanceInfoRequest) FolioTypeName(folioTypeName string) ApiGetBalanceInfoRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetBalanceInfoRequest) InternalFolioWindowID(internalFolioWindowID string) ApiGetBalanceInfoRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetBalanceInfoRequest) InvoiceNo(invoiceNo float32) ApiGetBalanceInfoRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiGetBalanceInfoRequest) XExternalsystem(xExternalsystem string) ApiGetBalanceInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBalanceInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetBalanceInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBalanceInfoRequest) Execute() (*BalanceInfoCriteria, *http.Response, error) {
	return r.ApiService.GetBalanceInfoExecute(r)
}

/*
GetBalanceInfo Get Balance Information

You can use this API to get Balance Information. <p><strong>OperationId:</strong>getBalanceInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetBalanceInfoRequest
*/
func (a *CashieringApiService) GetBalanceInfo(ctx context.Context, hotelId string) ApiGetBalanceInfoRequest {
	return ApiGetBalanceInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BalanceInfoCriteria
func (a *CashieringApiService) GetBalanceInfoExecute(r ApiGetBalanceInfoRequest) (*BalanceInfoCriteria, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceInfoCriteria
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetBalanceInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionsTotal"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
	}
	if r.cashierId != nil {
		t := *r.cashierId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.amount != nil {
		t := *r.amount
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amount", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amount", t, "multi")
		}
	}
	if r.currencyCode != nil {
		t := *r.currencyCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", t, "multi")
		}
	}
	if r.postingQuantity != nil {
		t := *r.postingQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", t, "multi")
		}
	}
	if r.postingReference != nil {
		t := *r.postingReference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", t, "multi")
		}
	}
	if r.postingRemark != nil {
		t := *r.postingRemark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", t, "multi")
		}
	}
	if r.checkNumber != nil {
		t := *r.checkNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", t, "multi")
		}
	}
	if r.arrangementCode != nil {
		t := *r.arrangementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", t, "multi")
		}
	}
	if r.applyRoutingInstructions != nil {
		t := *r.applyRoutingInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", t, "multi")
		}
	}
	if r.usePackageAllowance != nil {
		t := *r.usePackageAllowance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", t, "multi")
		}
	}
	if r.autoPosting != nil {
		t := *r.autoPosting
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", t, "multi")
		}
	}
	if r.uniqueIdId != nil {
		t := *r.uniqueIdId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", t, "multi")
		}
	}
	if r.uniqueIdIdContext != nil {
		t := *r.uniqueIdIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", t, "multi")
		}
	}
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
	}
	if r.postItNumberId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postItNumberId", r.postItNumberId, "")
	}
	if r.postItNumberIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postItNumberIdContext", r.postItNumberIdContext, "")
	}
	if r.postItNumberType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postItNumberType", r.postItNumberType, "")
	}
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
	}
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
	}
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
	}
	if r.reservationIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdId", r.reservationIdId, "")
	}
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.policyIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdId", r.policyIdId, "")
	}
	if r.policyIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdIdContext", r.policyIdIdContext, "")
	}
	if r.policyIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdType", r.policyIdType, "")
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
	}
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
	}
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
	}
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchCCSettlementsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	offlineSettlement *bool
	transactionDate *string
	guestName *string
	roomId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBatchCCSettlementsRequest) Authorization(authorization string) ApiGetBatchCCSettlementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBatchCCSettlementsRequest) XAppKey(xAppKey string) ApiGetBatchCCSettlementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBatchCCSettlementsRequest) XHotelid(xHotelid string) ApiGetBatchCCSettlementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// fetch only offline settlements.
func (r ApiGetBatchCCSettlementsRequest) OfflineSettlement(offlineSettlement bool) ApiGetBatchCCSettlementsRequest {
	r.offlineSettlement = &offlineSettlement
	return r
}

// Transaction Date associated with the transaction.
func (r ApiGetBatchCCSettlementsRequest) TransactionDate(transactionDate string) ApiGetBatchCCSettlementsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Guest name associated with the transaction.
func (r ApiGetBatchCCSettlementsRequest) GuestName(guestName string) ApiGetBatchCCSettlementsRequest {
	r.guestName = &guestName
	return r
}

// Room number associated with the transaction.
func (r ApiGetBatchCCSettlementsRequest) RoomId(roomId string) ApiGetBatchCCSettlementsRequest {
	r.roomId = &roomId
	return r
}

// External system code.
func (r ApiGetBatchCCSettlementsRequest) XExternalsystem(xExternalsystem string) ApiGetBatchCCSettlementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBatchCCSettlementsRequest) AcceptLanguage(acceptLanguage string) ApiGetBatchCCSettlementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBatchCCSettlementsRequest) Execute() (*CcBatchSettlements, *http.Response, error) {
	return r.ApiService.GetBatchCCSettlementsExecute(r)
}

/*
GetBatchCCSettlements Get batch CC Settlements

You can use this API to get batch CC Settlements. <p><strong>OperationId:</strong>getBatchCCSettlements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetBatchCCSettlementsRequest
*/
func (a *CashieringApiService) GetBatchCCSettlements(ctx context.Context, hotelId string) ApiGetBatchCCSettlementsRequest {
	return ApiGetBatchCCSettlementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcBatchSettlements
func (a *CashieringApiService) GetBatchCCSettlementsExecute(r ApiGetBatchCCSettlementsRequest) (*CcBatchSettlements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcBatchSettlements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetBatchCCSettlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/cCSettlements"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.offlineSettlement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offlineSettlement", r.offlineSettlement, "")
	}
	if r.transactionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", r.transactionDate, "")
	}
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchCCSettlementsStatusRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	batchId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBatchCCSettlementsStatusRequest) Authorization(authorization string) ApiGetBatchCCSettlementsStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBatchCCSettlementsStatusRequest) XAppKey(xAppKey string) ApiGetBatchCCSettlementsStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBatchCCSettlementsStatusRequest) XHotelid(xHotelid string) ApiGetBatchCCSettlementsStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBatchCCSettlementsStatusRequest) Id(id []string) ApiGetBatchCCSettlementsStatusRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBatchCCSettlementsStatusRequest) IdContext(idContext []string) ApiGetBatchCCSettlementsStatusRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBatchCCSettlementsStatusRequest) Type_(type_ []string) ApiGetBatchCCSettlementsStatusRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiGetBatchCCSettlementsStatusRequest) XExternalsystem(xExternalsystem string) ApiGetBatchCCSettlementsStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBatchCCSettlementsStatusRequest) AcceptLanguage(acceptLanguage string) ApiGetBatchCCSettlementsStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBatchCCSettlementsStatusRequest) Execute() (*CcBatchSettlementsStatus, *http.Response, error) {
	return r.ApiService.GetBatchCCSettlementsStatusExecute(r)
}

/*
GetBatchCCSettlementsStatus Get Batch CC Settlements Status

You can use this API to get Batch CC Settlements Status. <p><strong>OperationId:</strong>getBatchCCSettlementsStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchId Unique ID of the batch
 @param hotelId Unique ID of the hotel
 @return ApiGetBatchCCSettlementsStatusRequest
*/
func (a *CashieringApiService) GetBatchCCSettlementsStatus(ctx context.Context, batchId string, hotelId string) ApiGetBatchCCSettlementsStatusRequest {
	return ApiGetBatchCCSettlementsStatusRequest{
		ApiService: a,
		ctx: ctx,
		batchId: batchId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcBatchSettlementsStatus
func (a *CashieringApiService) GetBatchCCSettlementsStatusExecute(r ApiGetBatchCCSettlementsStatusRequest) (*CcBatchSettlementsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcBatchSettlementsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetBatchCCSettlementsStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bulkCCSettlements/{batchId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"batchId"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.batchId) < 1 {
		return localVarReturnValue, nil, reportError("batchId must have at least 1 elements")
	}
	if strlen(r.batchId) > 2000 {
		return localVarReturnValue, nil, reportError("batchId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arrival *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBedTaxInfoRequest) Authorization(authorization string) ApiGetBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBedTaxInfoRequest) XAppKey(xAppKey string) ApiGetBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBedTaxInfoRequest) XHotelid(xHotelid string) ApiGetBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Arrival Date of the reservation
func (r ApiGetBedTaxInfoRequest) Arrival(arrival string) ApiGetBedTaxInfoRequest {
	r.arrival = &arrival
	return r
}

// External system code.
func (r ApiGetBedTaxInfoRequest) XExternalsystem(xExternalsystem string) ApiGetBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBedTaxInfoRequest) Execute() (*BedTaxInfo, *http.Response, error) {
	return r.ApiService.GetBedTaxInfoExecute(r)
}

/*
GetBedTaxInfo Get bed tax information

You can use this API to Retrieve bed tax information for a property. <p><strong>OperationId:</strong>getBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetBedTaxInfoRequest
*/
func (a *CashieringApiService) GetBedTaxInfo(ctx context.Context, hotelId string) ApiGetBedTaxInfoRequest {
	return ApiGetBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BedTaxInfo
func (a *CashieringApiService) GetBedTaxInfoExecute(r ApiGetBedTaxInfoRequest) (*BedTaxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BedTaxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.arrival != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrival", r.arrival, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillingInstructionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	includeBillingInstructions *bool
	includeCompInstructions *bool
	codeWildCard *string
	descriptionWildCard *string
	id *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBillingInstructionCodesRequest) Authorization(authorization string) ApiGetBillingInstructionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBillingInstructionCodesRequest) XAppKey(xAppKey string) ApiGetBillingInstructionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBillingInstructionCodesRequest) XHotelid(xHotelid string) ApiGetBillingInstructionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to include the search in the Transaction Codes.
func (r ApiGetBillingInstructionCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) ApiGetBillingInstructionCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Flag to include the search in the Billing Instructions.
func (r ApiGetBillingInstructionCodesRequest) IncludeBillingInstructions(includeBillingInstructions bool) ApiGetBillingInstructionCodesRequest {
	r.includeBillingInstructions = &includeBillingInstructions
	return r
}

// Flag to include the comp instructions in the available list.
func (r ApiGetBillingInstructionCodesRequest) IncludeCompInstructions(includeCompInstructions bool) ApiGetBillingInstructionCodesRequest {
	r.includeCompInstructions = &includeCompInstructions
	return r
}

// Lookup string which will try to match an existing Billing and/or Transaction Codes.
func (r ApiGetBillingInstructionCodesRequest) CodeWildCard(codeWildCard string) ApiGetBillingInstructionCodesRequest {
	r.codeWildCard = &codeWildCard
	return r
}

// Lookup string which will try to match an existing Billing and/or Transaction Code Description.
func (r ApiGetBillingInstructionCodesRequest) DescriptionWildCard(descriptionWildCard string) ApiGetBillingInstructionCodesRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetBillingInstructionCodesRequest) Id(id string) ApiGetBillingInstructionCodesRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetBillingInstructionCodesRequest) IdContext(idContext string) ApiGetBillingInstructionCodesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetBillingInstructionCodesRequest) Type_(type_ string) ApiGetBillingInstructionCodesRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiGetBillingInstructionCodesRequest) XExternalsystem(xExternalsystem string) ApiGetBillingInstructionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBillingInstructionCodesRequest) AcceptLanguage(acceptLanguage string) ApiGetBillingInstructionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBillingInstructionCodesRequest) Execute() (*BillingInstructionCodes, *http.Response, error) {
	return r.ApiService.GetBillingInstructionCodesExecute(r)
}

/*
GetBillingInstructionCodes Get Billing (routing) Instruction Codes

You can use this API to get Billing Instruction Codes. <p><strong>OperationId:</strong>getBillingInstructionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetBillingInstructionCodesRequest
*/
func (a *CashieringApiService) GetBillingInstructionCodes(ctx context.Context, hotelId string) ApiGetBillingInstructionCodesRequest {
	return ApiGetBillingInstructionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingInstructionCodes
func (a *CashieringApiService) GetBillingInstructionCodesExecute(r ApiGetBillingInstructionCodesRequest) (*BillingInstructionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingInstructionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetBillingInstructionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/routingInstructionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.includeBillingInstructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeBillingInstructions", r.includeBillingInstructions, "")
	}
	if r.includeCompInstructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompInstructions", r.includeCompInstructions, "")
	}
	if r.codeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "codeWildCard", r.codeWildCard, "")
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCCAuthorizationInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	evaluateApprovalAmount *bool
	sourceOfAuthorization *string
	updateReservation *bool
	idContext *string
	type_ *string
	profileIdIdContext *string
	profileIdType *string
	amount *float32
	currencyCode *string
	folioView *int32
	description *string
	paymentFolioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	cardPresent *bool
	citId *string
	userDefinedCardType *string
	cardIdId *string
	cardIdIdContext *string
	cardIdType *string
	currentAuthorizedAmountAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *time.Time
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *time.Time
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	terminalId *string
	incidentalAmountAmount *float32
	incidentalAmountCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCCAuthorizationInstructionsRequest) Authorization(authorization string) ApiGetCCAuthorizationInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCCAuthorizationInstructionsRequest) XAppKey(xAppKey string) ApiGetCCAuthorizationInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCCAuthorizationInstructionsRequest) XHotelid(xHotelid string) ApiGetCCAuthorizationInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the approval amount should be calculated before authorization. If this is true and if the amount is 0 the approval amount will be calculated based on the rules.
func (r ApiGetCCAuthorizationInstructionsRequest) EvaluateApprovalAmount(evaluateApprovalAmount bool) ApiGetCCAuthorizationInstructionsRequest {
	r.evaluateApprovalAmount = &evaluateApprovalAmount
	return r
}

// Currently supported transaction type categories used for credit card authorization.
func (r ApiGetCCAuthorizationInstructionsRequest) SourceOfAuthorization(sourceOfAuthorization string) ApiGetCCAuthorizationInstructionsRequest {
	r.sourceOfAuthorization = &sourceOfAuthorization
	return r
}

// Update the card details on the reservations for Chip and Pin Authorizations.
func (r ApiGetCCAuthorizationInstructionsRequest) UpdateReservation(updateReservation bool) ApiGetCCAuthorizationInstructionsRequest {
	r.updateReservation = &updateReservation
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsRequest) IdContext(idContext string) ApiGetCCAuthorizationInstructionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsRequest) Type_(type_ string) ApiGetCCAuthorizationInstructionsRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsRequest) ProfileIdIdContext(profileIdIdContext string) ApiGetCCAuthorizationInstructionsRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsRequest) ProfileIdType(profileIdType string) ApiGetCCAuthorizationInstructionsRequest {
	r.profileIdType = &profileIdType
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) Amount(amount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) CurrencyCode(currencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.currencyCode = &currencyCode
	return r
}

// The folio window where this authorization is applied.
func (r ApiGetCCAuthorizationInstructionsRequest) FolioView(folioView int32) ApiGetCCAuthorizationInstructionsRequest {
	r.folioView = &folioView
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) Description(description string) ApiGetCCAuthorizationInstructionsRequest {
	r.description = &description
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) PaymentFolioView(paymentFolioView int32) ApiGetCCAuthorizationInstructionsRequest {
	r.paymentFolioView = &paymentFolioView
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) PaymentMethod(paymentMethod string) ApiGetCCAuthorizationInstructionsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r ApiGetCCAuthorizationInstructionsRequest) Track2Data(track2Data string) ApiGetCCAuthorizationInstructionsRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r ApiGetCCAuthorizationInstructionsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetCCAuthorizationInstructionsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) CardHolderName(cardHolderName string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) CardNumber(cardNumber string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) CardNumberMasked(cardNumberMasked string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetCCAuthorizationInstructionsRequest) CardOrToken(cardOrToken string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetCCAuthorizationInstructionsRequest) CardType(cardType string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetCCAuthorizationInstructionsRequest) ExpirationDate(expirationDate string) ApiGetCCAuthorizationInstructionsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetCCAuthorizationInstructionsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetCCAuthorizationInstructionsRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetCCAuthorizationInstructionsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) Processing(processing string) ApiGetCCAuthorizationInstructionsRequest {
	r.processing = &processing
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) Swiped(swiped bool) ApiGetCCAuthorizationInstructionsRequest {
	r.swiped = &swiped
	return r
}

// Flag to determine if the credit card was swiped/manually entered , This element is only used when PAYMENT SERVICE DIRECTIVE(PSD) Opera Control is active.
func (r ApiGetCCAuthorizationInstructionsRequest) CardPresent(cardPresent bool) ApiGetCCAuthorizationInstructionsRequest {
	r.cardPresent = &cardPresent
	return r
}

// Customer Initiated Transaction(CIT) Id for Credit Cards. This is only used when PAYMENT SERVICES DIRECTIVE (PSD2) Opera Control is active.
func (r ApiGetCCAuthorizationInstructionsRequest) CitId(citId string) ApiGetCCAuthorizationInstructionsRequest {
	r.citId = &citId
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetCCAuthorizationInstructionsRequest) UserDefinedCardType(userDefinedCardType string) ApiGetCCAuthorizationInstructionsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCCAuthorizationInstructionsRequest) CardIdId(cardIdId string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardIdId = &cardIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsRequest) CardIdIdContext(cardIdIdContext string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardIdIdContext = &cardIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsRequest) CardIdType(cardIdType string) ApiGetCCAuthorizationInstructionsRequest {
	r.cardIdType = &cardIdType
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) CurrentAuthorizedAmountAmount(currentAuthorizedAmountAmount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.currentAuthorizedAmountAmount = &currentAuthorizedAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) BalanceAmount(balanceAmount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ApiGetCCAuthorizationInstructionsRequest) Code(code int32) ApiGetCCAuthorizationInstructionsRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) AmountAmount(amountAmount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) AmountCurrencyCode(amountCurrencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ApiGetCCAuthorizationInstructionsRequest) Percent(percent float32) ApiGetCCAuthorizationInstructionsRequest {
	r.percent = &percent
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) EmailFolio(emailFolio bool) ApiGetCCAuthorizationInstructionsRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCCAuthorizationInstructionsRequest) UniqueIdId(uniqueIdId string) ApiGetCCAuthorizationInstructionsRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsRequest) UniqueIdIdContext(uniqueIdIdContext string) ApiGetCCAuthorizationInstructionsRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsRequest) UniqueIdType(uniqueIdType string) ApiGetCCAuthorizationInstructionsRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r ApiGetCCAuthorizationInstructionsRequest) CreateDateTime(createDateTime time.Time) ApiGetCCAuthorizationInstructionsRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ApiGetCCAuthorizationInstructionsRequest) CreatorId(creatorId string) ApiGetCCAuthorizationInstructionsRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r ApiGetCCAuthorizationInstructionsRequest) EmailAddress(emailAddress string) ApiGetCCAuthorizationInstructionsRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r ApiGetCCAuthorizationInstructionsRequest) EmailFormat(emailFormat string) ApiGetCCAuthorizationInstructionsRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ApiGetCCAuthorizationInstructionsRequest) LastModifierId(lastModifierId string) ApiGetCCAuthorizationInstructionsRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r ApiGetCCAuthorizationInstructionsRequest) LastModifyDateTime(lastModifyDateTime time.Time) ApiGetCCAuthorizationInstructionsRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r ApiGetCCAuthorizationInstructionsRequest) OrderSequence(orderSequence float32) ApiGetCCAuthorizationInstructionsRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r ApiGetCCAuthorizationInstructionsRequest) PrimaryInd(primaryInd bool) ApiGetCCAuthorizationInstructionsRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ApiGetCCAuthorizationInstructionsRequest) PurgeDate(purgeDate string) ApiGetCCAuthorizationInstructionsRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ApiGetCCAuthorizationInstructionsRequest) EmailType(emailType string) ApiGetCCAuthorizationInstructionsRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r ApiGetCCAuthorizationInstructionsRequest) TypeDescription(typeDescription string) ApiGetCCAuthorizationInstructionsRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r ApiGetCCAuthorizationInstructionsRequest) ApprovalCode(approvalCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r ApiGetCCAuthorizationInstructionsRequest) OriginalAuthSequence(originalAuthSequence int32) ApiGetCCAuthorizationInstructionsRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r ApiGetCCAuthorizationInstructionsRequest) VendorTranId(vendorTranId string) ApiGetCCAuthorizationInstructionsRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) ApprovalAmountAmount(approvalAmountAmount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Applicable for chip and pin. The ID of the terminal where the chip and pin device is connected.
func (r ApiGetCCAuthorizationInstructionsRequest) TerminalId(terminalId string) ApiGetCCAuthorizationInstructionsRequest {
	r.terminalId = &terminalId
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsRequest) IncidentalAmountAmount(incidentalAmountAmount float32) ApiGetCCAuthorizationInstructionsRequest {
	r.incidentalAmountAmount = &incidentalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsRequest) IncidentalAmountCurrencyCode(incidentalAmountCurrencyCode string) ApiGetCCAuthorizationInstructionsRequest {
	r.incidentalAmountCurrencyCode = &incidentalAmountCurrencyCode
	return r
}

// External system code.
func (r ApiGetCCAuthorizationInstructionsRequest) XExternalsystem(xExternalsystem string) ApiGetCCAuthorizationInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCCAuthorizationInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiGetCCAuthorizationInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCCAuthorizationInstructionsRequest) Execute() (*CcAuthorizationInstructions, *http.Response, error) {
	return r.ApiService.GetCCAuthorizationInstructionsExecute(r)
}

/*
GetCCAuthorizationInstructions Get CC Authorization Instructions

You can use this API to get Credit Card Authorization Instructions by Reservation. <p><strong>OperationId:</strong>getCCAuthorizationInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetCCAuthorizationInstructionsRequest
*/
func (a *CashieringApiService) GetCCAuthorizationInstructions(ctx context.Context, reservationId string, hotelId string) ApiGetCCAuthorizationInstructionsRequest {
	return ApiGetCCAuthorizationInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcAuthorizationInstructions
func (a *CashieringApiService) GetCCAuthorizationInstructionsExecute(r ApiGetCCAuthorizationInstructionsRequest) (*CcAuthorizationInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcAuthorizationInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCCAuthorizationInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods/creditCard/authorizeInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.evaluateApprovalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evaluateApprovalAmount", r.evaluateApprovalAmount, "")
	}
	if r.sourceOfAuthorization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceOfAuthorization", r.sourceOfAuthorization, "")
	}
	if r.updateReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateReservation", r.updateReservation, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
	}
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.paymentFolioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentFolioView", r.paymentFolioView, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.cardPresent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardPresent", r.cardPresent, "")
	}
	if r.citId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citId", r.citId, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.cardIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdId", r.cardIdId, "")
	}
	if r.cardIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIdContext", r.cardIdIdContext, "")
	}
	if r.cardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdType", r.cardIdType, "")
	}
	if r.currentAuthorizedAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountAmount", r.currentAuthorizedAmountAmount, "")
	}
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
	}
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
	}
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
	}
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
	}
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
	}
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
	}
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
	}
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
	}
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
	}
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
	}
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
	}
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
	}
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
	}
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
	}
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
	}
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
	}
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
	}
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
	}
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
	}
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.terminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminalId", r.terminalId, "")
	}
	if r.incidentalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountAmount", r.incidentalAmountAmount, "")
	}
	if r.incidentalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountCurrencyCode", r.incidentalAmountCurrencyCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCCAuthorizationInstructionsByProfileRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	evaluateApprovalAmount *bool
	sourceOfAuthorization *string
	updateReservation *bool
	idContext *string
	type_ *string
	profileIdIdContext *string
	profileIdType *string
	amount *float32
	currencyCode *string
	folioView *int32
	description *string
	paymentFolioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	cardPresent *bool
	citId *string
	userDefinedCardType *string
	cardIdId *string
	cardIdIdContext *string
	cardIdType *string
	currentAuthorizedAmountAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *time.Time
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *time.Time
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	terminalId *string
	incidentalAmountAmount *float32
	incidentalAmountCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Authorization(authorization string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) XAppKey(xAppKey string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) XHotelid(xHotelid string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the approval amount should be calculated before authorization. If this is true and if the amount is 0 the approval amount will be calculated based on the rules.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) EvaluateApprovalAmount(evaluateApprovalAmount bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.evaluateApprovalAmount = &evaluateApprovalAmount
	return r
}

// Currently supported transaction type categories used for credit card authorization.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) SourceOfAuthorization(sourceOfAuthorization string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.sourceOfAuthorization = &sourceOfAuthorization
	return r
}

// Update the card details on the reservations for Chip and Pin Authorizations.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) UpdateReservation(updateReservation bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.updateReservation = &updateReservation
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) IdContext(idContext string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Type_(type_ string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ProfileIdIdContext(profileIdIdContext string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ProfileIdType(profileIdType string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.profileIdType = &profileIdType
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Amount(amount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CurrencyCode(currencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.currencyCode = &currencyCode
	return r
}

// The folio window where this authorization is applied.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) FolioView(folioView int32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.folioView = &folioView
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Description(description string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.description = &description
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) PaymentFolioView(paymentFolioView int32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.paymentFolioView = &paymentFolioView
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) PaymentMethod(paymentMethod string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Track2Data(track2Data string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardHolderName(cardHolderName string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardNumber(cardNumber string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardNumberMasked(cardNumberMasked string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardOrToken(cardOrToken string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardType(cardType string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ExpirationDate(expirationDate string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Processing(processing string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.processing = &processing
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Swiped(swiped bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.swiped = &swiped
	return r
}

// Flag to determine if the credit card was swiped/manually entered , This element is only used when PAYMENT SERVICE DIRECTIVE(PSD) Opera Control is active.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardPresent(cardPresent bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardPresent = &cardPresent
	return r
}

// Customer Initiated Transaction(CIT) Id for Credit Cards. This is only used when PAYMENT SERVICES DIRECTIVE (PSD2) Opera Control is active.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CitId(citId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.citId = &citId
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) UserDefinedCardType(userDefinedCardType string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardIdId(cardIdId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardIdId = &cardIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardIdIdContext(cardIdIdContext string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardIdIdContext = &cardIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CardIdType(cardIdType string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.cardIdType = &cardIdType
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CurrentAuthorizedAmountAmount(currentAuthorizedAmountAmount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.currentAuthorizedAmountAmount = &currentAuthorizedAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) BalanceAmount(balanceAmount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Code(code int32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) AmountAmount(amountAmount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) AmountCurrencyCode(amountCurrencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Percent(percent float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.percent = &percent
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) EmailFolio(emailFolio bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) UniqueIdId(uniqueIdId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) UniqueIdIdContext(uniqueIdIdContext string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) UniqueIdType(uniqueIdType string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CreateDateTime(createDateTime time.Time) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) CreatorId(creatorId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) EmailAddress(emailAddress string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) EmailFormat(emailFormat string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) LastModifierId(lastModifierId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) LastModifyDateTime(lastModifyDateTime time.Time) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) OrderSequence(orderSequence float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) PrimaryInd(primaryInd bool) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) PurgeDate(purgeDate string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) EmailType(emailType string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) TypeDescription(typeDescription string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ApprovalCode(approvalCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) OriginalAuthSequence(originalAuthSequence int32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) VendorTranId(vendorTranId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountAmount(approvalAmountAmount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Applicable for chip and pin. The ID of the terminal where the chip and pin device is connected.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) TerminalId(terminalId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.terminalId = &terminalId
	return r
}

// A monetary amount.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) IncidentalAmountAmount(incidentalAmountAmount float32) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.incidentalAmountAmount = &incidentalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) IncidentalAmountCurrencyCode(incidentalAmountCurrencyCode string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.incidentalAmountCurrencyCode = &incidentalAmountCurrencyCode
	return r
}

// External system code.
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) XExternalsystem(xExternalsystem string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCCAuthorizationInstructionsByProfileRequest) AcceptLanguage(acceptLanguage string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCCAuthorizationInstructionsByProfileRequest) Execute() (*CcAuthorizationInstructions, *http.Response, error) {
	return r.ApiService.GetCCAuthorizationInstructionsByProfileExecute(r)
}

/*
GetCCAuthorizationInstructionsByProfile Get CC Authorization Instructions by Profile

You can use this API to get Credit Card Authorization Instructions by Profile. <p><strong>OperationId:</strong>getCCAuthorizationInstructionsByProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return ApiGetCCAuthorizationInstructionsByProfileRequest
*/
func (a *CashieringApiService) GetCCAuthorizationInstructionsByProfile(ctx context.Context, profileId string, hotelId string) ApiGetCCAuthorizationInstructionsByProfileRequest {
	return ApiGetCCAuthorizationInstructionsByProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcAuthorizationInstructions
func (a *CashieringApiService) GetCCAuthorizationInstructionsByProfileExecute(r ApiGetCCAuthorizationInstructionsByProfileRequest) (*CcAuthorizationInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcAuthorizationInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCCAuthorizationInstructionsByProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/paymentMethods/creditCard/authorizeInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.evaluateApprovalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evaluateApprovalAmount", r.evaluateApprovalAmount, "")
	}
	if r.sourceOfAuthorization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceOfAuthorization", r.sourceOfAuthorization, "")
	}
	if r.updateReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateReservation", r.updateReservation, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
	}
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.paymentFolioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentFolioView", r.paymentFolioView, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.cardPresent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardPresent", r.cardPresent, "")
	}
	if r.citId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citId", r.citId, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.cardIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdId", r.cardIdId, "")
	}
	if r.cardIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIdContext", r.cardIdIdContext, "")
	}
	if r.cardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdType", r.cardIdType, "")
	}
	if r.currentAuthorizedAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountAmount", r.currentAuthorizedAmountAmount, "")
	}
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
	}
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
	}
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
	}
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
	}
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
	}
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
	}
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
	}
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
	}
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
	}
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
	}
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
	}
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
	}
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
	}
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
	}
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
	}
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
	}
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
	}
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
	}
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
	}
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.terminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminalId", r.terminalId, "")
	}
	if r.incidentalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountAmount", r.incidentalAmountAmount, "")
	}
	if r.incidentalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountCurrencyCode", r.incidentalAmountCurrencyCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCCSurchargeInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	description *string
	folioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	id *string
	idContext *string
	type_ *string
	amount *float32
	currencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *time.Time
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *time.Time
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	postingAmountAmount *float32
	postingAmountCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCCSurchargeInfoRequest) Authorization(authorization string) ApiGetCCSurchargeInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCCSurchargeInfoRequest) XAppKey(xAppKey string) ApiGetCCSurchargeInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCCSurchargeInfoRequest) XHotelid(xHotelid string) ApiGetCCSurchargeInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetCCSurchargeInfoRequest) CashierId(cashierId float32) ApiGetCCSurchargeInfoRequest {
	r.cashierId = &cashierId
	return r
}

func (r ApiGetCCSurchargeInfoRequest) Description(description string) ApiGetCCSurchargeInfoRequest {
	r.description = &description
	return r
}

func (r ApiGetCCSurchargeInfoRequest) FolioView(folioView int32) ApiGetCCSurchargeInfoRequest {
	r.folioView = &folioView
	return r
}

func (r ApiGetCCSurchargeInfoRequest) PaymentMethod(paymentMethod string) ApiGetCCSurchargeInfoRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r ApiGetCCSurchargeInfoRequest) Track2Data(track2Data string) ApiGetCCSurchargeInfoRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r ApiGetCCSurchargeInfoRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetCCSurchargeInfoRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetCCSurchargeInfoRequest) CardHolderName(cardHolderName string) ApiGetCCSurchargeInfoRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetCCSurchargeInfoRequest) CardNumber(cardNumber string) ApiGetCCSurchargeInfoRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetCCSurchargeInfoRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetCCSurchargeInfoRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetCCSurchargeInfoRequest) CardNumberMasked(cardNumberMasked string) ApiGetCCSurchargeInfoRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetCCSurchargeInfoRequest) CardOrToken(cardOrToken string) ApiGetCCSurchargeInfoRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetCCSurchargeInfoRequest) CardType(cardType string) ApiGetCCSurchargeInfoRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetCCSurchargeInfoRequest) ExpirationDate(expirationDate string) ApiGetCCSurchargeInfoRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetCCSurchargeInfoRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetCCSurchargeInfoRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetCCSurchargeInfoRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetCCSurchargeInfoRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetCCSurchargeInfoRequest) Processing(processing string) ApiGetCCSurchargeInfoRequest {
	r.processing = &processing
	return r
}

func (r ApiGetCCSurchargeInfoRequest) Swiped(swiped bool) ApiGetCCSurchargeInfoRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetCCSurchargeInfoRequest) UserDefinedCardType(userDefinedCardType string) ApiGetCCSurchargeInfoRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCCSurchargeInfoRequest) Id(id string) ApiGetCCSurchargeInfoRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCSurchargeInfoRequest) IdContext(idContext string) ApiGetCCSurchargeInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCSurchargeInfoRequest) Type_(type_ string) ApiGetCCSurchargeInfoRequest {
	r.type_ = &type_
	return r
}

// A monetary amount.
func (r ApiGetCCSurchargeInfoRequest) Amount(amount float32) ApiGetCCSurchargeInfoRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCSurchargeInfoRequest) CurrencyCode(currencyCode string) ApiGetCCSurchargeInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCSurchargeInfoRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) ApiGetCCSurchargeInfoRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCSurchargeInfoRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) ApiGetCCSurchargeInfoRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCSurchargeInfoRequest) BalanceAmount(balanceAmount float32) ApiGetCCSurchargeInfoRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCSurchargeInfoRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetCCSurchargeInfoRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ApiGetCCSurchargeInfoRequest) Code(code int32) ApiGetCCSurchargeInfoRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r ApiGetCCSurchargeInfoRequest) AmountAmount(amountAmount float32) ApiGetCCSurchargeInfoRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCSurchargeInfoRequest) AmountCurrencyCode(amountCurrencyCode string) ApiGetCCSurchargeInfoRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ApiGetCCSurchargeInfoRequest) Percent(percent float32) ApiGetCCSurchargeInfoRequest {
	r.percent = &percent
	return r
}

func (r ApiGetCCSurchargeInfoRequest) EmailFolio(emailFolio bool) ApiGetCCSurchargeInfoRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCCSurchargeInfoRequest) UniqueIdId(uniqueIdId string) ApiGetCCSurchargeInfoRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCCSurchargeInfoRequest) UniqueIdIdContext(uniqueIdIdContext string) ApiGetCCSurchargeInfoRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCCSurchargeInfoRequest) UniqueIdType(uniqueIdType string) ApiGetCCSurchargeInfoRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r ApiGetCCSurchargeInfoRequest) CreateDateTime(createDateTime time.Time) ApiGetCCSurchargeInfoRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ApiGetCCSurchargeInfoRequest) CreatorId(creatorId string) ApiGetCCSurchargeInfoRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r ApiGetCCSurchargeInfoRequest) EmailAddress(emailAddress string) ApiGetCCSurchargeInfoRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r ApiGetCCSurchargeInfoRequest) EmailFormat(emailFormat string) ApiGetCCSurchargeInfoRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ApiGetCCSurchargeInfoRequest) LastModifierId(lastModifierId string) ApiGetCCSurchargeInfoRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r ApiGetCCSurchargeInfoRequest) LastModifyDateTime(lastModifyDateTime time.Time) ApiGetCCSurchargeInfoRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r ApiGetCCSurchargeInfoRequest) OrderSequence(orderSequence float32) ApiGetCCSurchargeInfoRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r ApiGetCCSurchargeInfoRequest) PrimaryInd(primaryInd bool) ApiGetCCSurchargeInfoRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ApiGetCCSurchargeInfoRequest) PurgeDate(purgeDate string) ApiGetCCSurchargeInfoRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ApiGetCCSurchargeInfoRequest) EmailType(emailType string) ApiGetCCSurchargeInfoRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r ApiGetCCSurchargeInfoRequest) TypeDescription(typeDescription string) ApiGetCCSurchargeInfoRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r ApiGetCCSurchargeInfoRequest) ApprovalCode(approvalCode string) ApiGetCCSurchargeInfoRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r ApiGetCCSurchargeInfoRequest) OriginalAuthSequence(originalAuthSequence int32) ApiGetCCSurchargeInfoRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r ApiGetCCSurchargeInfoRequest) VendorTranId(vendorTranId string) ApiGetCCSurchargeInfoRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r ApiGetCCSurchargeInfoRequest) ApprovalAmountAmount(approvalAmountAmount float32) ApiGetCCSurchargeInfoRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCSurchargeInfoRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetCCSurchargeInfoRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetCCSurchargeInfoRequest) PostingAmountAmount(postingAmountAmount float32) ApiGetCCSurchargeInfoRequest {
	r.postingAmountAmount = &postingAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetCCSurchargeInfoRequest) PostingAmountCurrencyCode(postingAmountCurrencyCode string) ApiGetCCSurchargeInfoRequest {
	r.postingAmountCurrencyCode = &postingAmountCurrencyCode
	return r
}

// External system code.
func (r ApiGetCCSurchargeInfoRequest) XExternalsystem(xExternalsystem string) ApiGetCCSurchargeInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCCSurchargeInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetCCSurchargeInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCCSurchargeInfoRequest) Execute() (*CcSurchargeDetails, *http.Response, error) {
	return r.ApiService.GetCCSurchargeInfoExecute(r)
}

/*
GetCCSurchargeInfo Get CC Surcharge Information

You can use this API to get CC Surcharge Information. <p><strong>OperationId:</strong>getCCSurchargeInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetCCSurchargeInfoRequest
*/
func (a *CashieringApiService) GetCCSurchargeInfo(ctx context.Context, hotelId string) ApiGetCCSurchargeInfoRequest {
	return ApiGetCCSurchargeInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcSurchargeDetails
func (a *CashieringApiService) GetCCSurchargeInfoExecute(r ApiGetCCSurchargeInfoRequest) (*CcSurchargeDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcSurchargeDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCCSurchargeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardsurcharge"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
	}
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
	}
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
	}
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
	}
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
	}
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
	}
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
	}
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
	}
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
	}
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
	}
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
	}
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
	}
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
	}
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
	}
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
	}
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
	}
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
	}
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
	}
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.postingAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountAmount", r.postingAmountAmount, "")
	}
	if r.postingAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountCurrencyCode", r.postingAmountCurrencyCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierClosureRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierLockHandle *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierClosureRequest) Authorization(authorization string) ApiGetCashierClosureRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierClosureRequest) XAppKey(xAppKey string) ApiGetCashierClosureRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierClosureRequest) XHotelid(xHotelid string) ApiGetCashierClosureRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Lock Handle to pass along with operation which required cashier to be locked.
func (r ApiGetCashierClosureRequest) CashierLockHandle(cashierLockHandle float32) ApiGetCashierClosureRequest {
	r.cashierLockHandle = &cashierLockHandle
	return r
}

// External system code.
func (r ApiGetCashierClosureRequest) XExternalsystem(xExternalsystem string) ApiGetCashierClosureRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierClosureRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierClosureRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierClosureRequest) Execute() (*CashierClosureDetails, *http.Response, error) {
	return r.ApiService.GetCashierClosureExecute(r)
}

/*
GetCashierClosure Get Cashier Closure

You can use this API to get Cashier Closure. <p><strong>OperationId:</strong>getCashierClosure</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @param hotelId Unique ID of the hotel
 @return ApiGetCashierClosureRequest
*/
func (a *CashieringApiService) GetCashierClosure(ctx context.Context, cashierId string, hotelId string) ApiGetCashierClosureRequest {
	return ApiGetCashierClosureRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierClosureDetails
func (a *CashieringApiService) GetCashierClosureExecute(r ApiGetCashierClosureRequest) (*CashierClosureDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierClosureDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCashierClosure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashiers/{cashierId}/closure"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.cashierLockHandle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierLockHandle", r.cashierLockHandle, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierClosureInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closureNo *float32
	cashierId *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	closureBusinessDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierClosureInfoRequest) Authorization(authorization string) ApiGetCashierClosureInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierClosureInfoRequest) XAppKey(xAppKey string) ApiGetCashierClosureInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierClosureInfoRequest) XHotelid(xHotelid string) ApiGetCashierClosureInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Shift Number.
func (r ApiGetCashierClosureInfoRequest) ClosureNo(closureNo float32) ApiGetCashierClosureInfoRequest {
	r.closureNo = &closureNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetCashierClosureInfoRequest) CashierId(cashierId float32) ApiGetCashierClosureInfoRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier closure shift drop location code.
func (r ApiGetCashierClosureInfoRequest) ShiftDropLocationCode(shiftDropLocationCode string) ApiGetCashierClosureInfoRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r ApiGetCashierClosureInfoRequest) BagNumberForOthers(bagNumberForOthers string) ApiGetCashierClosureInfoRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r ApiGetCashierClosureInfoRequest) BagNumberForCash(bagNumberForCash string) ApiGetCashierClosureInfoRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// Business Date of cashier closure.
func (r ApiGetCashierClosureInfoRequest) ClosureBusinessDate(closureBusinessDate string) ApiGetCashierClosureInfoRequest {
	r.closureBusinessDate = &closureBusinessDate
	return r
}

// External system code.
func (r ApiGetCashierClosureInfoRequest) XExternalsystem(xExternalsystem string) ApiGetCashierClosureInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierClosureInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierClosureInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierClosureInfoRequest) Execute() (*CashierClosureInformation, *http.Response, error) {
	return r.ApiService.GetCashierClosureInfoExecute(r)
}

/*
GetCashierClosureInfo Get Cashier Closure Information

You can use this API to get Cashier Closure Information. <p><strong>OperationId:</strong>getCashierClosureInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetCashierClosureInfoRequest
*/
func (a *CashieringApiService) GetCashierClosureInfo(ctx context.Context, hotelId string) ApiGetCashierClosureInfoRequest {
	return ApiGetCashierClosureInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierClosureInformation
func (a *CashieringApiService) GetCashierClosureInfoExecute(r ApiGetCashierClosureInfoRequest) (*CashierClosureInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierClosureInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCashierClosureInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/closureList"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
	}
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
	}
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
	}
	if r.closureBusinessDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureBusinessDate", r.closureBusinessDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierClosureReportsListRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closureNo *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierClosureReportsListRequest) Authorization(authorization string) ApiGetCashierClosureReportsListRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierClosureReportsListRequest) XAppKey(xAppKey string) ApiGetCashierClosureReportsListRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierClosureReportsListRequest) XHotelid(xHotelid string) ApiGetCashierClosureReportsListRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Shift Number.
func (r ApiGetCashierClosureReportsListRequest) ClosureNo(closureNo float32) ApiGetCashierClosureReportsListRequest {
	r.closureNo = &closureNo
	return r
}

// Cashier closure shift drop location code.
func (r ApiGetCashierClosureReportsListRequest) ShiftDropLocationCode(shiftDropLocationCode string) ApiGetCashierClosureReportsListRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r ApiGetCashierClosureReportsListRequest) BagNumberForOthers(bagNumberForOthers string) ApiGetCashierClosureReportsListRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r ApiGetCashierClosureReportsListRequest) BagNumberForCash(bagNumberForCash string) ApiGetCashierClosureReportsListRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// External system code.
func (r ApiGetCashierClosureReportsListRequest) XExternalsystem(xExternalsystem string) ApiGetCashierClosureReportsListRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierClosureReportsListRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierClosureReportsListRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierClosureReportsListRequest) Execute() (*CashierClosureReportsList, *http.Response, error) {
	return r.ApiService.GetCashierClosureReportsListExecute(r)
}

/*
GetCashierClosureReportsList Get Cashier Closure Reports List

You can use this API to get Cashier Closure Reports List. <p><strong>OperationId:</strong>getCashierClosureReportsList</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @param hotelId Unique ID of the hotel
 @return ApiGetCashierClosureReportsListRequest
*/
func (a *CashieringApiService) GetCashierClosureReportsList(ctx context.Context, cashierId string, hotelId string) ApiGetCashierClosureReportsListRequest {
	return ApiGetCashierClosureReportsListRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierClosureReportsList
func (a *CashieringApiService) GetCashierClosureReportsListExecute(r ApiGetCashierClosureReportsListRequest) (*CashierClosureReportsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierClosureReportsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCashierClosureReportsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashiers/{cashierId}/closureReports"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
	}
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
	}
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
	}
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierLockRequest) Authorization(authorization string) ApiGetCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierLockRequest) XAppKey(xAppKey string) ApiGetCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierLockRequest) XHotelid(xHotelid string) ApiGetCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetCashierLockRequest) XExternalsystem(xExternalsystem string) ApiGetCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierLockRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierLockRequest) Execute() (*AcquiredCashierLock, *http.Response, error) {
	return r.ApiService.GetCashierLockExecute(r)
}

/*
GetCashierLock Acquire Cashier Locks

You can use this API to Acquire Cashier Locks. <p><strong>OperationId:</strong>getCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return ApiGetCashierLockRequest
*/
func (a *CashieringApiService) GetCashierLock(ctx context.Context, cashierId string) ApiGetCashierLockRequest {
	return ApiGetCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return AcquiredCashierLock
func (a *CashieringApiService) GetCashierLockExecute(r ApiGetCashierLockRequest) (*AcquiredCashierLock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AcquiredCashierLock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/locks"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierReportPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	startDate *string
	endDate *string
	duration *string
	requestType *string
	closureNo *float32
	cashierId *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierReportPostingsRequest) Authorization(authorization string) ApiGetCashierReportPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierReportPostingsRequest) XAppKey(xAppKey string) ApiGetCashierReportPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierReportPostingsRequest) XHotelid(xHotelid string) ApiGetCashierReportPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetCashierReportPostingsRequest) HotelId(hotelId []string) ApiGetCashierReportPostingsRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiGetCashierReportPostingsRequest) StartDate(startDate string) ApiGetCashierReportPostingsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetCashierReportPostingsRequest) EndDate(endDate string) ApiGetCashierReportPostingsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetCashierReportPostingsRequest) Duration(duration string) ApiGetCashierReportPostingsRequest {
	r.duration = &duration
	return r
}

// Shift drop report created when cashier closure is completed. It is an integral part of closure report and is not to be printed or accessed by itself.
func (r ApiGetCashierReportPostingsRequest) RequestType(requestType string) ApiGetCashierReportPostingsRequest {
	r.requestType = &requestType
	return r
}

// The Cashier Shift Number.
func (r ApiGetCashierReportPostingsRequest) ClosureNo(closureNo float32) ApiGetCashierReportPostingsRequest {
	r.closureNo = &closureNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetCashierReportPostingsRequest) CashierId(cashierId float32) ApiGetCashierReportPostingsRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier closure shift drop location code.
func (r ApiGetCashierReportPostingsRequest) ShiftDropLocationCode(shiftDropLocationCode string) ApiGetCashierReportPostingsRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r ApiGetCashierReportPostingsRequest) BagNumberForOthers(bagNumberForOthers string) ApiGetCashierReportPostingsRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r ApiGetCashierReportPostingsRequest) BagNumberForCash(bagNumberForCash string) ApiGetCashierReportPostingsRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// External system code.
func (r ApiGetCashierReportPostingsRequest) XExternalsystem(xExternalsystem string) ApiGetCashierReportPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierReportPostingsRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierReportPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierReportPostingsRequest) Execute() (*CashierReportPostingsInfo, *http.Response, error) {
	return r.ApiService.GetCashierReportPostingsExecute(r)
}

/*
GetCashierReportPostings Get Cashier Report Postings

You can use this API to get Cashier Report postings. <p><strong>OperationId:</strong>getCashierReportPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCashierReportPostingsRequest
*/
func (a *CashieringApiService) GetCashierReportPostings(ctx context.Context) ApiGetCashierReportPostingsRequest {
	return ApiGetCashierReportPostingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashierReportPostingsInfo
func (a *CashieringApiService) GetCashierReportPostingsExecute(r ApiGetCashierReportPostingsRequest) (*CashierReportPostingsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierReportPostingsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCashierReportPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierReportPostings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.requestType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestType", r.requestType, "")
	}
	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
	}
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
	}
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closureNo *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierTransactionsRequest) Authorization(authorization string) ApiGetCashierTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierTransactionsRequest) XAppKey(xAppKey string) ApiGetCashierTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierTransactionsRequest) XHotelid(xHotelid string) ApiGetCashierTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Shift Number.
func (r ApiGetCashierTransactionsRequest) ClosureNo(closureNo float32) ApiGetCashierTransactionsRequest {
	r.closureNo = &closureNo
	return r
}

// Cashier closure shift drop location code.
func (r ApiGetCashierTransactionsRequest) ShiftDropLocationCode(shiftDropLocationCode string) ApiGetCashierTransactionsRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r ApiGetCashierTransactionsRequest) BagNumberForOthers(bagNumberForOthers string) ApiGetCashierTransactionsRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r ApiGetCashierTransactionsRequest) BagNumberForCash(bagNumberForCash string) ApiGetCashierTransactionsRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// External system code.
func (r ApiGetCashierTransactionsRequest) XExternalsystem(xExternalsystem string) ApiGetCashierTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierTransactionsRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierTransactionsRequest) Execute() (*CashierTransactionsDetails, *http.Response, error) {
	return r.ApiService.GetCashierTransactionsExecute(r)
}

/*
GetCashierTransactions Get Cashier Transactions

You can use this API to get Cashier Transactions. <p><strong>OperationId:</strong>getCashierTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return ApiGetCashierTransactionsRequest
*/
func (a *CashieringApiService) GetCashierTransactions(ctx context.Context, cashierId string) ApiGetCashierTransactionsRequest {
	return ApiGetCashierTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return CashierTransactionsDetails
func (a *CashieringApiService) GetCashierTransactionsExecute(r ApiGetCashierTransactionsRequest) (*CashierTransactionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierTransactionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCashierTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
	}
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
	}
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
	}
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCheckDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	checkNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCheckDetailsRequest) Authorization(authorization string) ApiGetCheckDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCheckDetailsRequest) XAppKey(xAppKey string) ApiGetCheckDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCheckDetailsRequest) XHotelid(xHotelid string) ApiGetCheckDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetCheckDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetCheckDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCheckDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetCheckDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCheckDetailsRequest) Execute() (*CheckDetails, *http.Response, error) {
	return r.ApiService.GetCheckDetailsExecute(r)
}

/*
GetCheckDetails Get check details

You can use this API to get check details. <p><strong>OperationId:</strong>getCheckDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check
 @param hotelId Unique ID of the hotel
 @return ApiGetCheckDetailsRequest
*/
func (a *CashieringApiService) GetCheckDetails(ctx context.Context, checkNumber string, hotelId string) ApiGetCheckDetailsRequest {
	return ApiGetCheckDetailsRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckDetails
func (a *CashieringApiService) GetCheckDetailsExecute(r ApiGetCheckDetailsRequest) (*CheckDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCheckDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/check/{checkNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompAccountingJournalRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	startDate *string
	endDate *string
	duration *string
	filterTransactionCode *[]string
	hotelId *[]string
	filterRoomNumber *[]string
	id *[]string
	idContext *[]string
	type_ *[]string
	approvalCode *string
	code *[]string
	authorizerNameCode *[]string
	referenceNumberWildCard *string
	supplementWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompAccountingJournalRequest) Authorization(authorization string) ApiGetCompAccountingJournalRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompAccountingJournalRequest) XAppKey(xAppKey string) ApiGetCompAccountingJournalRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompAccountingJournalRequest) XHotelid(xHotelid string) ApiGetCompAccountingJournalRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetCompAccountingJournalRequest) Limit(limit int32) ApiGetCompAccountingJournalRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetCompAccountingJournalRequest) Offset(offset int32) ApiGetCompAccountingJournalRequest {
	r.offset = &offset
	return r
}

func (r ApiGetCompAccountingJournalRequest) StartDate(startDate string) ApiGetCompAccountingJournalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetCompAccountingJournalRequest) EndDate(endDate string) ApiGetCompAccountingJournalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetCompAccountingJournalRequest) Duration(duration string) ApiGetCompAccountingJournalRequest {
	r.duration = &duration
	return r
}

func (r ApiGetCompAccountingJournalRequest) FilterTransactionCode(filterTransactionCode []string) ApiGetCompAccountingJournalRequest {
	r.filterTransactionCode = &filterTransactionCode
	return r
}

func (r ApiGetCompAccountingJournalRequest) HotelId(hotelId []string) ApiGetCompAccountingJournalRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiGetCompAccountingJournalRequest) FilterRoomNumber(filterRoomNumber []string) ApiGetCompAccountingJournalRequest {
	r.filterRoomNumber = &filterRoomNumber
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCompAccountingJournalRequest) Id(id []string) ApiGetCompAccountingJournalRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCompAccountingJournalRequest) IdContext(idContext []string) ApiGetCompAccountingJournalRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCompAccountingJournalRequest) Type_(type_ []string) ApiGetCompAccountingJournalRequest {
	r.type_ = &type_
	return r
}

// Filters the results for approval code.
func (r ApiGetCompAccountingJournalRequest) ApprovalCode(approvalCode string) ApiGetCompAccountingJournalRequest {
	r.approvalCode = &approvalCode
	return r
}

func (r ApiGetCompAccountingJournalRequest) Code(code []string) ApiGetCompAccountingJournalRequest {
	r.code = &code
	return r
}

func (r ApiGetCompAccountingJournalRequest) AuthorizerNameCode(authorizerNameCode []string) ApiGetCompAccountingJournalRequest {
	r.authorizerNameCode = &authorizerNameCode
	return r
}

// Filters the results for reference number.
func (r ApiGetCompAccountingJournalRequest) ReferenceNumberWildCard(referenceNumberWildCard string) ApiGetCompAccountingJournalRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for supplement.
func (r ApiGetCompAccountingJournalRequest) SupplementWildCard(supplementWildCard string) ApiGetCompAccountingJournalRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// External system code.
func (r ApiGetCompAccountingJournalRequest) XExternalsystem(xExternalsystem string) ApiGetCompAccountingJournalRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompAccountingJournalRequest) AcceptLanguage(acceptLanguage string) ApiGetCompAccountingJournalRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompAccountingJournalRequest) Execute() (*CompAccountingJournal, *http.Response, error) {
	return r.ApiService.GetCompAccountingJournalExecute(r)
}

/*
GetCompAccountingJournal Get Comp Accounting Journal

You can use this API to get Comp Accounting Journal. <p><strong>OperationId:</strong>getCompAccountingJournal</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCompAccountingJournalRequest
*/
func (a *CashieringApiService) GetCompAccountingJournal(ctx context.Context) ApiGetCompAccountingJournalRequest {
	return ApiGetCompAccountingJournalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompAccountingJournal
func (a *CashieringApiService) GetCompAccountingJournalExecute(r ApiGetCompAccountingJournalRequest) (*CompAccountingJournal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompAccountingJournal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCompAccountingJournal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compAccountingJournal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.filterTransactionCode != nil {
		t := *r.filterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.filterRoomNumber != nil {
		t := *r.filterRoomNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.authorizerNameCode != nil {
		t := *r.authorizerNameCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerNameCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerNameCode", t, "multi")
		}
	}
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
	}
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	end *string
	start *string
	nameWildcard *string
	firstNameWildCard *string
	roomNumberCodes *[]string
	id *[]string
	idContext *[]string
	type_ *[]string
	membershipId *string
	code *[]string
	resStatusCode *[]string
	compRoutingStatuses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompRoutingInstructionsRequest) Authorization(authorization string) ApiGetCompRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompRoutingInstructionsRequest) XAppKey(xAppKey string) ApiGetCompRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompRoutingInstructionsRequest) XHotelid(xHotelid string) ApiGetCompRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r ApiGetCompRoutingInstructionsRequest) End(end string) ApiGetCompRoutingInstructionsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ApiGetCompRoutingInstructionsRequest) Start(start string) ApiGetCompRoutingInstructionsRequest {
	r.start = &start
	return r
}

// Family name or last name of the guest
func (r ApiGetCompRoutingInstructionsRequest) NameWildcard(nameWildcard string) ApiGetCompRoutingInstructionsRequest {
	r.nameWildcard = &nameWildcard
	return r
}

// Given name or first name of the guest.
func (r ApiGetCompRoutingInstructionsRequest) FirstNameWildCard(firstNameWildCard string) ApiGetCompRoutingInstructionsRequest {
	r.firstNameWildCard = &firstNameWildCard
	return r
}

func (r ApiGetCompRoutingInstructionsRequest) RoomNumberCodes(roomNumberCodes []string) ApiGetCompRoutingInstructionsRequest {
	r.roomNumberCodes = &roomNumberCodes
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCompRoutingInstructionsRequest) Id(id []string) ApiGetCompRoutingInstructionsRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCompRoutingInstructionsRequest) IdContext(idContext []string) ApiGetCompRoutingInstructionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCompRoutingInstructionsRequest) Type_(type_ []string) ApiGetCompRoutingInstructionsRequest {
	r.type_ = &type_
	return r
}

// Membership Card number.
func (r ApiGetCompRoutingInstructionsRequest) MembershipId(membershipId string) ApiGetCompRoutingInstructionsRequest {
	r.membershipId = &membershipId
	return r
}

func (r ApiGetCompRoutingInstructionsRequest) Code(code []string) ApiGetCompRoutingInstructionsRequest {
	r.code = &code
	return r
}

// This reservation is in checked in status and the business date is past departure date. This could occur when ORS and PMS are in same environment.
func (r ApiGetCompRoutingInstructionsRequest) ResStatusCode(resStatusCode []string) ApiGetCompRoutingInstructionsRequest {
	r.resStatusCode = &resStatusCode
	return r
}

// Status which indicates that the Request of Comp Routing was declined
func (r ApiGetCompRoutingInstructionsRequest) CompRoutingStatuses(compRoutingStatuses []string) ApiGetCompRoutingInstructionsRequest {
	r.compRoutingStatuses = &compRoutingStatuses
	return r
}

// External system code.
func (r ApiGetCompRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiGetCompRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiGetCompRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompRoutingInstructionsRequest) Execute() (*CompRoutingInstructions, *http.Response, error) {
	return r.ApiService.GetCompRoutingInstructionsExecute(r)
}

/*
GetCompRoutingInstructions Get Comp Routing Instructions

You can use this API to get Comp Routing Instructions. <p><strong>OperationId:</strong>getCompRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetCompRoutingInstructionsRequest
*/
func (a *CashieringApiService) GetCompRoutingInstructions(ctx context.Context, hotelId string) ApiGetCompRoutingInstructionsRequest {
	return ApiGetCompRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompRoutingInstructions
func (a *CashieringApiService) GetCompRoutingInstructionsExecute(r ApiGetCompRoutingInstructionsRequest) (*CompRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCompRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compRoutingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.nameWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameWildcard", r.nameWildcard, "")
	}
	if r.firstNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstNameWildCard", r.firstNameWildCard, "")
	}
	if r.roomNumberCodes != nil {
		t := *r.roomNumberCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberCodes", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.resStatusCode != nil {
		t := *r.resStatusCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resStatusCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resStatusCode", t, "multi")
		}
	}
	if r.compRoutingStatuses != nil {
		t := *r.compRoutingStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compRoutingStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compRoutingStatuses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompTrxAuthorizersRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	id *[]string
	idContext *[]string
	type_ *[]string
	targetFolioWindowNo *int32
	uniqueIdId *[]string
	uniqueIdIdContext *[]string
	uniqueIdType *[]string
	transaction *[]float32
	authorizerIdId *string
	authorizerIdIdContext *string
	authorizerIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompTrxAuthorizersRequest) Authorization(authorization string) ApiGetCompTrxAuthorizersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompTrxAuthorizersRequest) XAppKey(xAppKey string) ApiGetCompTrxAuthorizersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompTrxAuthorizersRequest) XHotelid(xHotelid string) ApiGetCompTrxAuthorizersRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetCompTrxAuthorizersRequest) CashierId(cashierId float32) ApiGetCompTrxAuthorizersRequest {
	r.cashierId = &cashierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCompTrxAuthorizersRequest) Id(id []string) ApiGetCompTrxAuthorizersRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCompTrxAuthorizersRequest) IdContext(idContext []string) ApiGetCompTrxAuthorizersRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCompTrxAuthorizersRequest) Type_(type_ []string) ApiGetCompTrxAuthorizersRequest {
	r.type_ = &type_
	return r
}

// Folio Window Number to where transactions will be transfered.
func (r ApiGetCompTrxAuthorizersRequest) TargetFolioWindowNo(targetFolioWindowNo int32) ApiGetCompTrxAuthorizersRequest {
	r.targetFolioWindowNo = &targetFolioWindowNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCompTrxAuthorizersRequest) UniqueIdId(uniqueIdId []string) ApiGetCompTrxAuthorizersRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCompTrxAuthorizersRequest) UniqueIdIdContext(uniqueIdIdContext []string) ApiGetCompTrxAuthorizersRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCompTrxAuthorizersRequest) UniqueIdType(uniqueIdType []string) ApiGetCompTrxAuthorizersRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// List of transactions to be transfered.
func (r ApiGetCompTrxAuthorizersRequest) Transaction(transaction []float32) ApiGetCompTrxAuthorizersRequest {
	r.transaction = &transaction
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCompTrxAuthorizersRequest) AuthorizerIdId(authorizerIdId string) ApiGetCompTrxAuthorizersRequest {
	r.authorizerIdId = &authorizerIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCompTrxAuthorizersRequest) AuthorizerIdIdContext(authorizerIdIdContext string) ApiGetCompTrxAuthorizersRequest {
	r.authorizerIdIdContext = &authorizerIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetCompTrxAuthorizersRequest) AuthorizerIdType(authorizerIdType string) ApiGetCompTrxAuthorizersRequest {
	r.authorizerIdType = &authorizerIdType
	return r
}

// External system code.
func (r ApiGetCompTrxAuthorizersRequest) XExternalsystem(xExternalsystem string) ApiGetCompTrxAuthorizersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompTrxAuthorizersRequest) AcceptLanguage(acceptLanguage string) ApiGetCompTrxAuthorizersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompTrxAuthorizersRequest) Execute() (*CompTrxAuthorizers, *http.Response, error) {
	return r.ApiService.GetCompTrxAuthorizersExecute(r)
}

/*
GetCompTrxAuthorizers Get Comp Trx Authorizers

You can use this API to get Comp Trx Authorizers. <p><strong>OperationId:</strong>getCompTrxAuthorizers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetCompTrxAuthorizersRequest
*/
func (a *CashieringApiService) GetCompTrxAuthorizers(ctx context.Context, hotelId string) ApiGetCompTrxAuthorizersRequest {
	return ApiGetCompTrxAuthorizersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompTrxAuthorizers
func (a *CashieringApiService) GetCompTrxAuthorizersExecute(r ApiGetCompTrxAuthorizersRequest) (*CompTrxAuthorizers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTrxAuthorizers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCompTrxAuthorizers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compTrxAuthorizers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.targetFolioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetFolioWindowNo", r.targetFolioWindowNo, "")
	}
	if r.uniqueIdId != nil {
		t := *r.uniqueIdId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", t, "multi")
		}
	}
	if r.uniqueIdIdContext != nil {
		t := *r.uniqueIdIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", t, "multi")
		}
	}
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
	}
	if r.transaction != nil {
		t := *r.transaction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transaction", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transaction", t, "multi")
		}
	}
	if r.authorizerIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerIdId", r.authorizerIdId, "")
	}
	if r.authorizerIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerIdIdContext", r.authorizerIdIdContext, "")
	}
	if r.authorizerIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerIdType", r.authorizerIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditLimitOveragePaymentsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestNameWildCard *string
	roomNumberWildCard *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCreditLimitOveragePaymentsRequest) Authorization(authorization string) ApiGetCreditLimitOveragePaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCreditLimitOveragePaymentsRequest) XAppKey(xAppKey string) ApiGetCreditLimitOveragePaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCreditLimitOveragePaymentsRequest) XHotelid(xHotelid string) ApiGetCreditLimitOveragePaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Guest name associated with the transaction.
func (r ApiGetCreditLimitOveragePaymentsRequest) GuestNameWildCard(guestNameWildCard string) ApiGetCreditLimitOveragePaymentsRequest {
	r.guestNameWildCard = &guestNameWildCard
	return r
}

// Room number associated with the transaction.
func (r ApiGetCreditLimitOveragePaymentsRequest) RoomNumberWildCard(roomNumberWildCard string) ApiGetCreditLimitOveragePaymentsRequest {
	r.roomNumberWildCard = &roomNumberWildCard
	return r
}

func (r ApiGetCreditLimitOveragePaymentsRequest) Code(code []string) ApiGetCreditLimitOveragePaymentsRequest {
	r.code = &code
	return r
}

// External system code.
func (r ApiGetCreditLimitOveragePaymentsRequest) XExternalsystem(xExternalsystem string) ApiGetCreditLimitOveragePaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCreditLimitOveragePaymentsRequest) AcceptLanguage(acceptLanguage string) ApiGetCreditLimitOveragePaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCreditLimitOveragePaymentsRequest) Execute() (*CreditLimitOveragePaymentsInfo, *http.Response, error) {
	return r.ApiService.GetCreditLimitOveragePaymentsExecute(r)
}

/*
GetCreditLimitOveragePayments Get Credit Limits Overage Payments

You can use this API to get Credit Limits Overage Payments. <p><strong>OperationId:</strong>getCreditLimitOveragePayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetCreditLimitOveragePaymentsRequest
*/
func (a *CashieringApiService) GetCreditLimitOveragePayments(ctx context.Context, hotelId string) ApiGetCreditLimitOveragePaymentsRequest {
	return ApiGetCreditLimitOveragePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreditLimitOveragePaymentsInfo
func (a *CashieringApiService) GetCreditLimitOveragePaymentsExecute(r ApiGetCreditLimitOveragePaymentsRequest) (*CreditLimitOveragePaymentsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditLimitOveragePaymentsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCreditLimitOveragePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditLimitsOveragePayments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.guestNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestNameWildCard", r.guestNameWildCard, "")
	}
	if r.roomNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildCard", r.roomNumberWildCard, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepositFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	id *string
	policyIdId *string
	blockIdId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDepositFolioRequest) Authorization(authorization string) ApiGetDepositFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDepositFolioRequest) XAppKey(xAppKey string) ApiGetDepositFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDepositFolioRequest) XHotelid(xHotelid string) ApiGetDepositFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for deposit folio instructions that can be used in requests for partial operations.
func (r ApiGetDepositFolioRequest) FetchInstructions(fetchInstructions []string) ApiGetDepositFolioRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetDepositFolioRequest) Id(id string) ApiGetDepositFolioRequest {
	r.id = &id
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetDepositFolioRequest) PolicyIdId(policyIdId string) ApiGetDepositFolioRequest {
	r.policyIdId = &policyIdId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetDepositFolioRequest) BlockIdId(blockIdId string) ApiGetDepositFolioRequest {
	r.blockIdId = &blockIdId
	return r
}

// External system code.
func (r ApiGetDepositFolioRequest) XExternalsystem(xExternalsystem string) ApiGetDepositFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDepositFolioRequest) AcceptLanguage(acceptLanguage string) ApiGetDepositFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDepositFolioRequest) Execute() (*ReservationDepositFolios, *http.Response, error) {
	return r.ApiService.GetDepositFolioExecute(r)
}

/*
GetDepositFolio Get Deposit Folio

You can use this API to get Deposit Folio. <p><strong>OperationId:</strong>getDepositFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetDepositFolioRequest
*/
func (a *CashieringApiService) GetDepositFolio(ctx context.Context, hotelId string) ApiGetDepositFolioRequest {
	return ApiGetDepositFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationDepositFolios
func (a *CashieringApiService) GetDepositFolioExecute(r ApiGetDepositFolioRequest) (*ReservationDepositFolios, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationDepositFolios
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetDepositFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositFolio"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.policyIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdId", r.policyIdId, "")
	}
	if r.blockIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdId", r.blockIdId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepositFolioTransactionDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	transactionNo *[]float32
	includeExchangeInformation *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDepositFolioTransactionDetailsRequest) Authorization(authorization string) ApiGetDepositFolioTransactionDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDepositFolioTransactionDetailsRequest) XAppKey(xAppKey string) ApiGetDepositFolioTransactionDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDepositFolioTransactionDetailsRequest) XHotelid(xHotelid string) ApiGetDepositFolioTransactionDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the automatically generated transactions, related to the main transaction number above, are also to be retrieved as part of this request.
func (r ApiGetDepositFolioTransactionDetailsRequest) IncludeGenerates(includeGenerates bool) ApiGetDepositFolioTransactionDetailsRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// Unique Transaction Number of the transaction(posting) for which details are required.
func (r ApiGetDepositFolioTransactionDetailsRequest) TransactionNo(transactionNo []float32) ApiGetDepositFolioTransactionDetailsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Flag to indicate what currency exchange information text needs to be included in response.
func (r ApiGetDepositFolioTransactionDetailsRequest) IncludeExchangeInformation(includeExchangeInformation bool) ApiGetDepositFolioTransactionDetailsRequest {
	r.includeExchangeInformation = &includeExchangeInformation
	return r
}

// External system code.
func (r ApiGetDepositFolioTransactionDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetDepositFolioTransactionDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDepositFolioTransactionDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetDepositFolioTransactionDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDepositFolioTransactionDetailsRequest) Execute() (*DepositFolioTransactionDetails, *http.Response, error) {
	return r.ApiService.GetDepositFolioTransactionDetailsExecute(r)
}

/*
GetDepositFolioTransactionDetails Get Deposit Folio Transaction Details

You can use this API to get Deposit Folio Transaction Details. <p><strong>OperationId:</strong>getDepositFolioTransactionDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetDepositFolioTransactionDetailsRequest
*/
func (a *CashieringApiService) GetDepositFolioTransactionDetails(ctx context.Context, hotelId string) ApiGetDepositFolioTransactionDetailsRequest {
	return ApiGetDepositFolioTransactionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositFolioTransactionDetails
func (a *CashieringApiService) GetDepositFolioTransactionDetailsExecute(r ApiGetDepositFolioTransactionDetailsRequest) (*DepositFolioTransactionDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositFolioTransactionDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetDepositFolioTransactionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
	}
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
	}
	if r.includeExchangeInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExchangeInformation", r.includeExchangeInformation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepositMaturityInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDepositMaturityInfoRequest) Authorization(authorization string) ApiGetDepositMaturityInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDepositMaturityInfoRequest) XAppKey(xAppKey string) ApiGetDepositMaturityInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDepositMaturityInfoRequest) XHotelid(xHotelid string) ApiGetDepositMaturityInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetDepositMaturityInfoRequest) CashierId(cashierId float32) ApiGetDepositMaturityInfoRequest {
	r.cashierId = &cashierId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetDepositMaturityInfoRequest) IdContext(idContext string) ApiGetDepositMaturityInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetDepositMaturityInfoRequest) Type_(type_ string) ApiGetDepositMaturityInfoRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiGetDepositMaturityInfoRequest) XExternalsystem(xExternalsystem string) ApiGetDepositMaturityInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDepositMaturityInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetDepositMaturityInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDepositMaturityInfoRequest) Execute() (*DepositMaturityDetails, *http.Response, error) {
	return r.ApiService.GetDepositMaturityInfoExecute(r)
}

/*
GetDepositMaturityInfo Get Deposit Maturity Information

You can use this API to get Deposit Maturity Information. <p><strong>OperationId:</strong>getDepositMaturityInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiGetDepositMaturityInfoRequest
*/
func (a *CashieringApiService) GetDepositMaturityInfo(ctx context.Context, reservationId string, hotelId string) ApiGetDepositMaturityInfoRequest {
	return ApiGetDepositMaturityInfoRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositMaturityDetails
func (a *CashieringApiService) GetDepositMaturityInfoExecute(r ApiGetDepositMaturityInfoRequest) (*DepositMaturityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositMaturityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetDepositMaturityInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositMaturity"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFinancialPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	startDate *string
	endDate *string
	duration *string
	cashierId *float32
	filterTransactionCode *[]string
	code *[]string
	filterRoomNumber *[]string
	referenceNumberWildCard *string
	checkNumberWildCard *string
	supplementWildCard *string
	approvalCode *string
	approvalStatusCode *[]string
	folioWindowNo *[]int32
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	id *string
	idContext *string
	type_ *string
	amount *float32
	currencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	closureNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFinancialPostingsRequest) Authorization(authorization string) ApiGetFinancialPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFinancialPostingsRequest) XAppKey(xAppKey string) ApiGetFinancialPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFinancialPostingsRequest) XHotelid(xHotelid string) ApiGetFinancialPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetFinancialPostingsRequest) Limit(limit int32) ApiGetFinancialPostingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetFinancialPostingsRequest) Offset(offset int32) ApiGetFinancialPostingsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetFinancialPostingsRequest) StartDate(startDate string) ApiGetFinancialPostingsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetFinancialPostingsRequest) EndDate(endDate string) ApiGetFinancialPostingsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetFinancialPostingsRequest) Duration(duration string) ApiGetFinancialPostingsRequest {
	r.duration = &duration
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetFinancialPostingsRequest) CashierId(cashierId float32) ApiGetFinancialPostingsRequest {
	r.cashierId = &cashierId
	return r
}

func (r ApiGetFinancialPostingsRequest) FilterTransactionCode(filterTransactionCode []string) ApiGetFinancialPostingsRequest {
	r.filterTransactionCode = &filterTransactionCode
	return r
}

func (r ApiGetFinancialPostingsRequest) Code(code []string) ApiGetFinancialPostingsRequest {
	r.code = &code
	return r
}

func (r ApiGetFinancialPostingsRequest) FilterRoomNumber(filterRoomNumber []string) ApiGetFinancialPostingsRequest {
	r.filterRoomNumber = &filterRoomNumber
	return r
}

// Filters the results for reference number.
func (r ApiGetFinancialPostingsRequest) ReferenceNumberWildCard(referenceNumberWildCard string) ApiGetFinancialPostingsRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for Cheque number&#39;s code.
func (r ApiGetFinancialPostingsRequest) CheckNumberWildCard(checkNumberWildCard string) ApiGetFinancialPostingsRequest {
	r.checkNumberWildCard = &checkNumberWildCard
	return r
}

// Filter the results for supplement.
func (r ApiGetFinancialPostingsRequest) SupplementWildCard(supplementWildCard string) ApiGetFinancialPostingsRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// Filters the results for approval code.
func (r ApiGetFinancialPostingsRequest) ApprovalCode(approvalCode string) ApiGetFinancialPostingsRequest {
	r.approvalCode = &approvalCode
	return r
}

func (r ApiGetFinancialPostingsRequest) ApprovalStatusCode(approvalStatusCode []string) ApiGetFinancialPostingsRequest {
	r.approvalStatusCode = &approvalStatusCode
	return r
}

// Filters the result to only include transactions in this window number.
func (r ApiGetFinancialPostingsRequest) FolioWindowNo(folioWindowNo []int32) ApiGetFinancialPostingsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Attach the credit card to profile.
func (r ApiGetFinancialPostingsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetFinancialPostingsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetFinancialPostingsRequest) CardHolderName(cardHolderName string) ApiGetFinancialPostingsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetFinancialPostingsRequest) CardNumber(cardNumber string) ApiGetFinancialPostingsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetFinancialPostingsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetFinancialPostingsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetFinancialPostingsRequest) CardNumberMasked(cardNumberMasked string) ApiGetFinancialPostingsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetFinancialPostingsRequest) CardOrToken(cardOrToken string) ApiGetFinancialPostingsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetFinancialPostingsRequest) CardType(cardType string) ApiGetFinancialPostingsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetFinancialPostingsRequest) ExpirationDate(expirationDate string) ApiGetFinancialPostingsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetFinancialPostingsRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetFinancialPostingsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetFinancialPostingsRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetFinancialPostingsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetFinancialPostingsRequest) Processing(processing string) ApiGetFinancialPostingsRequest {
	r.processing = &processing
	return r
}

func (r ApiGetFinancialPostingsRequest) Swiped(swiped bool) ApiGetFinancialPostingsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetFinancialPostingsRequest) UserDefinedCardType(userDefinedCardType string) ApiGetFinancialPostingsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFinancialPostingsRequest) Id(id string) ApiGetFinancialPostingsRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFinancialPostingsRequest) IdContext(idContext string) ApiGetFinancialPostingsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFinancialPostingsRequest) Type_(type_ string) ApiGetFinancialPostingsRequest {
	r.type_ = &type_
	return r
}

// A monetary amount.
func (r ApiGetFinancialPostingsRequest) Amount(amount float32) ApiGetFinancialPostingsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFinancialPostingsRequest) CurrencyCode(currencyCode string) ApiGetFinancialPostingsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r ApiGetFinancialPostingsRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) ApiGetFinancialPostingsRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFinancialPostingsRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) ApiGetFinancialPostingsRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// Filters the result to only display the postings that were made during the cashier closure range
func (r ApiGetFinancialPostingsRequest) ClosureNo(closureNo int32) ApiGetFinancialPostingsRequest {
	r.closureNo = &closureNo
	return r
}

// External system code.
func (r ApiGetFinancialPostingsRequest) XExternalsystem(xExternalsystem string) ApiGetFinancialPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFinancialPostingsRequest) AcceptLanguage(acceptLanguage string) ApiGetFinancialPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFinancialPostingsRequest) Execute() (*FinancialPostings, *http.Response, error) {
	return r.ApiService.GetFinancialPostingsExecute(r)
}

/*
GetFinancialPostings Get Financial Postings

You can use this API to get Financial postings. <p><strong>OperationId:</strong>getFinancialPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFinancialPostingsRequest
*/
func (a *CashieringApiService) GetFinancialPostings(ctx context.Context, hotelId string) ApiGetFinancialPostingsRequest {
	return ApiGetFinancialPostingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FinancialPostings
func (a *CashieringApiService) GetFinancialPostingsExecute(r ApiGetFinancialPostingsRequest) (*FinancialPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FinancialPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFinancialPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/financialPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.filterTransactionCode != nil {
		t := *r.filterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.filterRoomNumber != nil {
		t := *r.filterRoomNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", t, "multi")
		}
	}
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
	}
	if r.checkNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumberWildCard", r.checkNumberWildCard, "")
	}
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
	}
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
	}
	if r.approvalStatusCode != nil {
		t := *r.approvalStatusCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatusCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatusCode", t, "multi")
		}
	}
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
	}
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
	}
	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiscalFolioActivityRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioSeqNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFiscalFolioActivityRequest) Authorization(authorization string) ApiGetFiscalFolioActivityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFiscalFolioActivityRequest) XAppKey(xAppKey string) ApiGetFiscalFolioActivityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFiscalFolioActivityRequest) XHotelid(xHotelid string) ApiGetFiscalFolioActivityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio Sequence number for a folio
func (r ApiGetFiscalFolioActivityRequest) FolioSeqNo(folioSeqNo int32) ApiGetFiscalFolioActivityRequest {
	r.folioSeqNo = &folioSeqNo
	return r
}

// External system code.
func (r ApiGetFiscalFolioActivityRequest) XExternalsystem(xExternalsystem string) ApiGetFiscalFolioActivityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFiscalFolioActivityRequest) AcceptLanguage(acceptLanguage string) ApiGetFiscalFolioActivityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFiscalFolioActivityRequest) Execute() (*FolioActivityDetailsType, *http.Response, error) {
	return r.ApiService.GetFiscalFolioActivityExecute(r)
}

/*
GetFiscalFolioActivity Get the Fiscal Folio Activity for a folio

You can use this API to get the fiscal folio activity details for a folio. <p><strong>OperationId:</strong>getFiscalFolioActivity</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFiscalFolioActivityRequest
*/
func (a *CashieringApiService) GetFiscalFolioActivity(ctx context.Context, hotelId string) ApiGetFiscalFolioActivityRequest {
	return ApiGetFiscalFolioActivityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioActivityDetailsType
func (a *CashieringApiService) GetFiscalFolioActivityExecute(r ApiGetFiscalFolioActivityRequest) (*FolioActivityDetailsType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioActivityDetailsType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFiscalFolioActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalFolioResponse"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.folioSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioSeqNo", r.folioSeqNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiscalFolioActivityDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioSeqNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	responseAttemptNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFiscalFolioActivityDetailsRequest) Authorization(authorization string) ApiGetFiscalFolioActivityDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFiscalFolioActivityDetailsRequest) XAppKey(xAppKey string) ApiGetFiscalFolioActivityDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFiscalFolioActivityDetailsRequest) XHotelid(xHotelid string) ApiGetFiscalFolioActivityDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Number of fiscal response attempt made for the folio
func (r ApiGetFiscalFolioActivityDetailsRequest) ResponseAttemptNo(responseAttemptNo int32) ApiGetFiscalFolioActivityDetailsRequest {
	r.responseAttemptNo = &responseAttemptNo
	return r
}

// External system code.
func (r ApiGetFiscalFolioActivityDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetFiscalFolioActivityDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFiscalFolioActivityDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetFiscalFolioActivityDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFiscalFolioActivityDetailsRequest) Execute() (*FolioActivityResponseDetailType, *http.Response, error) {
	return r.ApiService.GetFiscalFolioActivityDetailsExecute(r)
}

/*
GetFiscalFolioActivityDetails Get the Fiscal Folio Activity Response details for a folio

You can use this API to get the fiscal folio activity response details for a folio. <p><strong>OperationId:</strong>getFiscalFolioActivityDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioSeqNo Unique ID of the folio
 @param hotelId Unique ID of the hotel
 @return ApiGetFiscalFolioActivityDetailsRequest
*/
func (a *CashieringApiService) GetFiscalFolioActivityDetails(ctx context.Context, folioSeqNo string, hotelId string) ApiGetFiscalFolioActivityDetailsRequest {
	return ApiGetFiscalFolioActivityDetailsRequest{
		ApiService: a,
		ctx: ctx,
		folioSeqNo: folioSeqNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioActivityResponseDetailType
func (a *CashieringApiService) GetFiscalFolioActivityDetailsExecute(r ApiGetFiscalFolioActivityDetailsRequest) (*FolioActivityResponseDetailType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioActivityResponseDetailType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFiscalFolioActivityDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalFolioResponse/{folioSeqNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioSeqNo"+"}", url.PathEscape(parameterValueToString(r.folioSeqNo, "folioSeqNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioSeqNo) < 1 {
		return localVarReturnValue, nil, reportError("folioSeqNo must have at least 1 elements")
	}
	if strlen(r.folioSeqNo) > 2000 {
		return localVarReturnValue, nil, reportError("folioSeqNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.responseAttemptNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseAttemptNo", r.responseAttemptNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiscalPrintingDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioView *int32
	folioType *string
	id *string
	code *[]string
	fetchInstruction *[]string
	profileIdId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFiscalPrintingDetailsRequest) Authorization(authorization string) ApiGetFiscalPrintingDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFiscalPrintingDetailsRequest) XAppKey(xAppKey string) ApiGetFiscalPrintingDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFiscalPrintingDetailsRequest) XHotelid(xHotelid string) ApiGetFiscalPrintingDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The folio window where this settlement is applied.
func (r ApiGetFiscalPrintingDetailsRequest) FolioView(folioView int32) ApiGetFiscalPrintingDetailsRequest {
	r.folioView = &folioView
	return r
}

// Folio Type
func (r ApiGetFiscalPrintingDetailsRequest) FolioType(folioType string) ApiGetFiscalPrintingDetailsRequest {
	r.folioType = &folioType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFiscalPrintingDetailsRequest) Id(id string) ApiGetFiscalPrintingDetailsRequest {
	r.id = &id
	return r
}

func (r ApiGetFiscalPrintingDetailsRequest) Code(code []string) ApiGetFiscalPrintingDetailsRequest {
	r.code = &code
	return r
}

// Reservation Related information.
func (r ApiGetFiscalPrintingDetailsRequest) FetchInstruction(fetchInstruction []string) ApiGetFiscalPrintingDetailsRequest {
	r.fetchInstruction = &fetchInstruction
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFiscalPrintingDetailsRequest) ProfileIdId(profileIdId string) ApiGetFiscalPrintingDetailsRequest {
	r.profileIdId = &profileIdId
	return r
}

// External system code.
func (r ApiGetFiscalPrintingDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetFiscalPrintingDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFiscalPrintingDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetFiscalPrintingDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFiscalPrintingDetailsRequest) Execute() (*FiscalCallStatus, *http.Response, error) {
	return r.ApiService.GetFiscalPrintingDetailsExecute(r)
}

/*
GetFiscalPrintingDetails Get Fiscal Printing Details

You can use this API to get Fiscal Printing Details.<br><p><strong><mark>This API is deprecated. Please use getValidateFiscalPrintingDetails instead</mark></strong></p> <p><strong>OperationId:</strong>getFiscalPrintingDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetFiscalPrintingDetailsRequest

Deprecated
*/
func (a *CashieringApiService) GetFiscalPrintingDetails(ctx context.Context, reservationId string, hotelId string) ApiGetFiscalPrintingDetailsRequest {
	return ApiGetFiscalPrintingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCallStatus
// Deprecated
func (a *CashieringApiService) GetFiscalPrintingDetailsExecute(r ApiGetFiscalPrintingDetailsRequest) (*FiscalCallStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCallStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFiscalPrintingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fiscalPrinting"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.fetchInstruction != nil {
		t := *r.fetchInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", t, "multi")
		}
	}
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFixedChargesRequest) Authorization(authorization string) ApiGetFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFixedChargesRequest) XAppKey(xAppKey string) ApiGetFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFixedChargesRequest) XHotelid(xHotelid string) ApiGetFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFixedChargesRequest) IdContext(idContext string) ApiGetFixedChargesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFixedChargesRequest) Type_(type_ string) ApiGetFixedChargesRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiGetFixedChargesRequest) XExternalsystem(xExternalsystem string) ApiGetFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFixedChargesRequest) AcceptLanguage(acceptLanguage string) ApiGetFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFixedChargesRequest) Execute() (*FixedChargesDetails, *http.Response, error) {
	return r.ApiService.GetFixedChargesExecute(r)
}

/*
GetFixedCharges Get Fixed Charges

You can use this API to get fixed Charges for a reservation. <p><strong>OperationId:</strong>getFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetFixedChargesRequest
*/
func (a *CashieringApiService) GetFixedCharges(ctx context.Context, reservationId string, hotelId string) ApiGetFixedChargesRequest {
	return ApiGetFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FixedChargesDetails
func (a *CashieringApiService) GetFixedChargesExecute(r ApiGetFixedChargesRequest) (*FixedChargesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FixedChargesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestPayOnly *bool
	includeFolioHistory *bool
	reservationBalanceOnly *bool
	fetchInstructions *[]string
	end *[]string
	folioWindowNo *[]int32
	limit *[]int32
	offset *[]int32
	start *[]string
	summaryOnly *bool
	groupType *string
	exchangeCurrency *string
	calculateCollectingAgentTaxes *bool
	vATOffset *bool
	includeDepositTaxes *bool
	simpleFolio *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioRequest) Authorization(authorization string) ApiGetFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioRequest) XAppKey(xAppKey string) ApiGetFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioRequest) XHotelid(xHotelid string) ApiGetFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to return the Folio Windows information where the Reservation Guest is the Payee, i.e the Folio Window is not Routed to another Reservation or another Profile.
func (r ApiGetFolioRequest) GuestPayOnly(guestPayOnly bool) ApiGetFolioRequest {
	r.guestPayOnly = &guestPayOnly
	return r
}

// This flag will notify the service if the folio history will also be returned or not.
func (r ApiGetFolioRequest) IncludeFolioHistory(includeFolioHistory bool) ApiGetFolioRequest {
	r.includeFolioHistory = &includeFolioHistory
	return r
}

// This flag will notify the service if the reservation summary information will be returned. If TRUE then we will only return the reservation&#39;s outstanding balance.
func (r ApiGetFolioRequest) ReservationBalanceOnly(reservationBalanceOnly bool) ApiGetFolioRequest {
	r.reservationBalanceOnly = &reservationBalanceOnly
	return r
}

// Posting details of each window.
func (r ApiGetFolioRequest) FetchInstructions(fetchInstructions []string) ApiGetFolioRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// The ending value of the date range.
func (r ApiGetFolioRequest) End(end []string) ApiGetFolioRequest {
	r.end = &end
	return r
}

func (r ApiGetFolioRequest) FolioWindowNo(folioWindowNo []int32) ApiGetFolioRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetFolioRequest) Limit(limit []int32) ApiGetFolioRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetFolioRequest) Offset(offset []int32) ApiGetFolioRequest {
	r.offset = &offset
	return r
}

// The starting value of the date range.
func (r ApiGetFolioRequest) Start(start []string) ApiGetFolioRequest {
	r.start = &start
	return r
}

// This flag will notify the service that transactional postings will not be returned.
func (r ApiGetFolioRequest) SummaryOnly(summaryOnly bool) ApiGetFolioRequest {
	r.summaryOnly = &summaryOnly
	return r
}

// Grouping by Transactin Type.
func (r ApiGetFolioRequest) GroupType(groupType string) ApiGetFolioRequest {
	r.groupType = &groupType
	return r
}

// Currency to which the Credit and Debit Amounts will be converted for each Folio. The response will have the ExchangeAmounts element with the converted amounts. The Posting Exchange Rate of the current business date will be used for the conversion
func (r ApiGetFolioRequest) ExchangeCurrency(exchangeCurrency string) ApiGetFolioRequest {
	r.exchangeCurrency = &exchangeCurrency
	return r
}

func (r ApiGetFolioRequest) CalculateCollectingAgentTaxes(calculateCollectingAgentTaxes bool) ApiGetFolioRequest {
	r.calculateCollectingAgentTaxes = &calculateCollectingAgentTaxes
	return r
}

func (r ApiGetFolioRequest) VATOffset(vATOffset bool) ApiGetFolioRequest {
	r.vATOffset = &vATOffset
	return r
}

func (r ApiGetFolioRequest) IncludeDepositTaxes(includeDepositTaxes bool) ApiGetFolioRequest {
	r.includeDepositTaxes = &includeDepositTaxes
	return r
}

// This flag signifies that generated Folio is Normal or Simple Folio. Certain countries of the World mandate a simple folio when the invoice amount is less than defined threshold.
func (r ApiGetFolioRequest) SimpleFolio(simpleFolio bool) ApiGetFolioRequest {
	r.simpleFolio = &simpleFolio
	return r
}

// External system code.
func (r ApiGetFolioRequest) XExternalsystem(xExternalsystem string) ApiGetFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioRequest) Execute() (*Folio, *http.Response, error) {
	return r.ApiService.GetFolioExecute(r)
}

/*
GetFolio Get folios

This API is used to fetch the folios for a given reservation. A guest reservation could have 1 or more folios per reservation. Folios will only exist for a reservation once the guest has checked into the hotel. <p><strong>OperationId:</strong>getFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioRequest
*/
func (a *CashieringApiService) GetFolio(ctx context.Context, reservationId string, hotelId string) ApiGetFolioRequest {
	return ApiGetFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Folio
func (a *CashieringApiService) GetFolioExecute(r ApiGetFolioRequest) (*Folio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Folio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.guestPayOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestPayOnly", r.guestPayOnly, "")
	}
	if r.includeFolioHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFolioHistory", r.includeFolioHistory, "")
	}
	if r.reservationBalanceOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBalanceOnly", r.reservationBalanceOnly, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.end != nil {
		t := *r.end
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end", t, "multi")
		}
	}
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
	}
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
	}
	if r.offset != nil {
		t := *r.offset
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "offset", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "offset", t, "multi")
		}
	}
	if r.start != nil {
		t := *r.start
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start", t, "multi")
		}
	}
	if r.summaryOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryOnly", r.summaryOnly, "")
	}
	if r.groupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupType", r.groupType, "")
	}
	if r.exchangeCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeCurrency", r.exchangeCurrency, "")
	}
	if r.calculateCollectingAgentTaxes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "calculateCollectingAgentTaxes", r.calculateCollectingAgentTaxes, "")
	}
	if r.vATOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vATOffset", r.vATOffset, "")
	}
	if r.includeDepositTaxes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDepositTaxes", r.includeDepositTaxes, "")
	}
	if r.simpleFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "simpleFolio", r.simpleFolio, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioHistoryRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idContext *string
	type_ *string
	aR *bool
	checkOut *bool
	creditBill *bool
	includeAssociatedFolios *bool
	noShow *bool
	offlineFolio *bool
	passerBy *bool
	postIt *bool
	videoCheckOut *bool
	folioDate *string
	reservationIdId *string
	reservationIdIdContext *string
	reservationIdType *string
	room *string
	name *string
	firstName *string
	creditCardNo *string
	folioNo *string
	invoiceNo *float32
	addresseeName *string
	fiscalFolioNo *string
	code *[]string
	partnerFiscalFolioStatusCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioHistoryRequest) Authorization(authorization string) ApiGetFolioHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioHistoryRequest) XAppKey(xAppKey string) ApiGetFolioHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioHistoryRequest) XHotelid(xHotelid string) ApiGetFolioHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioHistoryRequest) Id(id string) ApiGetFolioHistoryRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioHistoryRequest) IdContext(idContext string) ApiGetFolioHistoryRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFolioHistoryRequest) Type_(type_ string) ApiGetFolioHistoryRequest {
	r.type_ = &type_
	return r
}

// Indicates if search includes AR Folios.
func (r ApiGetFolioHistoryRequest) AR(aR bool) ApiGetFolioHistoryRequest {
	r.aR = &aR
	return r
}

// Indicates if search includes Check Out Folios.
func (r ApiGetFolioHistoryRequest) CheckOut(checkOut bool) ApiGetFolioHistoryRequest {
	r.checkOut = &checkOut
	return r
}

// Indicates if search includes Credit Bill Folios.
func (r ApiGetFolioHistoryRequest) CreditBill(creditBill bool) ApiGetFolioHistoryRequest {
	r.creditBill = &creditBill
	return r
}

// Indicates if search result includes Associated Bills and is only applied when Folio History for a particular reservation (i.e. ReservationID has a value) is requested.
func (r ApiGetFolioHistoryRequest) IncludeAssociatedFolios(includeAssociatedFolios bool) ApiGetFolioHistoryRequest {
	r.includeAssociatedFolios = &includeAssociatedFolios
	return r
}

// Indicates if search includes No Show Folios.
func (r ApiGetFolioHistoryRequest) NoShow(noShow bool) ApiGetFolioHistoryRequest {
	r.noShow = &noShow
	return r
}

// Indicates if search includes Offline Folios.
func (r ApiGetFolioHistoryRequest) OfflineFolio(offlineFolio bool) ApiGetFolioHistoryRequest {
	r.offlineFolio = &offlineFolio
	return r
}

// Indicates if search includes Passer By Folios.
func (r ApiGetFolioHistoryRequest) PasserBy(passerBy bool) ApiGetFolioHistoryRequest {
	r.passerBy = &passerBy
	return r
}

// Indicates if search includes Post-It Folios.
func (r ApiGetFolioHistoryRequest) PostIt(postIt bool) ApiGetFolioHistoryRequest {
	r.postIt = &postIt
	return r
}

// Indicates if search includes Video Check Out Folios.
func (r ApiGetFolioHistoryRequest) VideoCheckOut(videoCheckOut bool) ApiGetFolioHistoryRequest {
	r.videoCheckOut = &videoCheckOut
	return r
}

// Folio History Date.
func (r ApiGetFolioHistoryRequest) FolioDate(folioDate string) ApiGetFolioHistoryRequest {
	r.folioDate = &folioDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioHistoryRequest) ReservationIdId(reservationIdId string) ApiGetFolioHistoryRequest {
	r.reservationIdId = &reservationIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioHistoryRequest) ReservationIdIdContext(reservationIdIdContext string) ApiGetFolioHistoryRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFolioHistoryRequest) ReservationIdType(reservationIdType string) ApiGetFolioHistoryRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Room Number to which this record applies.
func (r ApiGetFolioHistoryRequest) Room(room string) ApiGetFolioHistoryRequest {
	r.room = &room
	return r
}

// Family name, last name or Company Name.
func (r ApiGetFolioHistoryRequest) Name(name string) ApiGetFolioHistoryRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r ApiGetFolioHistoryRequest) FirstName(firstName string) ApiGetFolioHistoryRequest {
	r.firstName = &firstName
	return r
}

// Credit card number used.
func (r ApiGetFolioHistoryRequest) CreditCardNo(creditCardNo string) ApiGetFolioHistoryRequest {
	r.creditCardNo = &creditCardNo
	return r
}

// Folio Number.
func (r ApiGetFolioHistoryRequest) FolioNo(folioNo string) ApiGetFolioHistoryRequest {
	r.folioNo = &folioNo
	return r
}

// Invoice Number.
func (r ApiGetFolioHistoryRequest) InvoiceNo(invoiceNo float32) ApiGetFolioHistoryRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r ApiGetFolioHistoryRequest) AddresseeName(addresseeName string) ApiGetFolioHistoryRequest {
	r.addresseeName = &addresseeName
	return r
}

// Fiscal Folio Number filter. Works with the Fiscal Folio Number Functionality.
func (r ApiGetFolioHistoryRequest) FiscalFolioNo(fiscalFolioNo string) ApiGetFolioHistoryRequest {
	r.fiscalFolioNo = &fiscalFolioNo
	return r
}

func (r ApiGetFolioHistoryRequest) Code(code []string) ApiGetFolioHistoryRequest {
	r.code = &code
	return r
}

func (r ApiGetFolioHistoryRequest) PartnerFiscalFolioStatusCode(partnerFiscalFolioStatusCode []string) ApiGetFolioHistoryRequest {
	r.partnerFiscalFolioStatusCode = &partnerFiscalFolioStatusCode
	return r
}

// External system code.
func (r ApiGetFolioHistoryRequest) XExternalsystem(xExternalsystem string) ApiGetFolioHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioHistoryRequest) Execute() (*FolioHistoryResponse, *http.Response, error) {
	return r.ApiService.GetFolioHistoryExecute(r)
}

/*
GetFolioHistory Get folio history

You can use this API to get folio history for a reservation. <p><strong>OperationId:</strong>getFolioHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioHistoryRequest
*/
func (a *CashieringApiService) GetFolioHistory(ctx context.Context, hotelId string) ApiGetFolioHistoryRequest {
	return ApiGetFolioHistoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioHistoryResponse
func (a *CashieringApiService) GetFolioHistoryExecute(r ApiGetFolioHistoryRequest) (*FolioHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolioHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.aR != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aR", r.aR, "")
	}
	if r.checkOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkOut", r.checkOut, "")
	}
	if r.creditBill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditBill", r.creditBill, "")
	}
	if r.includeAssociatedFolios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAssociatedFolios", r.includeAssociatedFolios, "")
	}
	if r.noShow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noShow", r.noShow, "")
	}
	if r.offlineFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offlineFolio", r.offlineFolio, "")
	}
	if r.passerBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "passerBy", r.passerBy, "")
	}
	if r.postIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postIt", r.postIt, "")
	}
	if r.videoCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCheckOut", r.videoCheckOut, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.reservationIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdId", r.reservationIdId, "")
	}
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.creditCardNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardNo", r.creditCardNo, "")
	}
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	if r.addresseeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeName", r.addresseeName, "")
	}
	if r.fiscalFolioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalFolioNo", r.fiscalFolioNo, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.partnerFiscalFolioStatusCode != nil {
		t := *r.partnerFiscalFolioStatusCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partnerFiscalFolioStatusCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partnerFiscalFolioStatusCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioPrintersRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allFolioWindow *bool
	correction *bool
	debitFolio *bool
	folioWindowNo *int32
	manualFolioNo *int32
	cashierId *float32
	fiscalTerminalId *string
	eventType *string
	id *string
	profileIdId *string
	currencyCode *string
	exchangeRate *float32
	associatedBillNumber *float32
	associatedBillFolioType *string
	associatedBillQueueName *string
	associatedBillFiscalBillNumber *string
	associatedBillGenerationDate *string
	folioType *string
	generateFiscalFolio *bool
	queueName *string
	folioSeqId *int32
	fiscalFolioInstruction *string
	transactionServiceType *string
	amount *float32
	balanceCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioPrintersRequest) Authorization(authorization string) ApiGetFolioPrintersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioPrintersRequest) XAppKey(xAppKey string) ApiGetFolioPrintersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioPrintersRequest) XHotelid(xHotelid string) ApiGetFolioPrintersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to decide if folios is to be generated for all windows in addition to the one requested with applicable postings and zero balance. If any of the windows have non-zero balance then folios are not generated for other windows.
func (r ApiGetFolioPrintersRequest) AllFolioWindow(allFolioWindow bool) ApiGetFolioPrintersRequest {
	r.allFolioWindow = &allFolioWindow
	return r
}

// Correction flag
func (r ApiGetFolioPrintersRequest) Correction(correction bool) ApiGetFolioPrintersRequest {
	r.correction = &correction
	return r
}

// Indicates the type of folio to be generated
func (r ApiGetFolioPrintersRequest) DebitFolio(debitFolio bool) ApiGetFolioPrintersRequest {
	r.debitFolio = &debitFolio
	return r
}

func (r ApiGetFolioPrintersRequest) FolioWindowNo(folioWindowNo int32) ApiGetFolioPrintersRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Manual Folio Number used for settlement during checkout
func (r ApiGetFolioPrintersRequest) ManualFolioNo(manualFolioNo int32) ApiGetFolioPrintersRequest {
	r.manualFolioNo = &manualFolioNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetFolioPrintersRequest) CashierId(cashierId float32) ApiGetFolioPrintersRequest {
	r.cashierId = &cashierId
	return r
}

// Applicable for Fiscal Terminal. The ID of the terminal where the fiscal device is connected.
func (r ApiGetFolioPrintersRequest) FiscalTerminalId(fiscalTerminalId string) ApiGetFolioPrintersRequest {
	r.fiscalTerminalId = &fiscalTerminalId
	return r
}

// Event being generated by a Supplemental Folio.
func (r ApiGetFolioPrintersRequest) EventType(eventType string) ApiGetFolioPrintersRequest {
	r.eventType = &eventType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioPrintersRequest) Id(id string) ApiGetFolioPrintersRequest {
	r.id = &id
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioPrintersRequest) ProfileIdId(profileIdId string) ApiGetFolioPrintersRequest {
	r.profileIdId = &profileIdId
	return r
}

// Description of currency Code.
func (r ApiGetFolioPrintersRequest) CurrencyCode(currencyCode string) ApiGetFolioPrintersRequest {
	r.currencyCode = &currencyCode
	return r
}

// Description of exchange rate.
func (r ApiGetFolioPrintersRequest) ExchangeRate(exchangeRate float32) ApiGetFolioPrintersRequest {
	r.exchangeRate = &exchangeRate
	return r
}

// The bill number of the original bill for which the Credit Bill is being generated.
func (r ApiGetFolioPrintersRequest) AssociatedBillNumber(associatedBillNumber float32) ApiGetFolioPrintersRequest {
	r.associatedBillNumber = &associatedBillNumber
	return r
}

// The folio type of the original bill for which the Credit Bill is being generated.
func (r ApiGetFolioPrintersRequest) AssociatedBillFolioType(associatedBillFolioType string) ApiGetFolioPrintersRequest {
	r.associatedBillFolioType = &associatedBillFolioType
	return r
}

// The folio number queue(used in certain countries) of the original bill for which the Credit Bill is being generated.
func (r ApiGetFolioPrintersRequest) AssociatedBillQueueName(associatedBillQueueName string) ApiGetFolioPrintersRequest {
	r.associatedBillQueueName = &associatedBillQueueName
	return r
}

// The Fiscal Folio Bill Number(from a Fiscal System) of the original bill for which the Credit Bill is being generated.
func (r ApiGetFolioPrintersRequest) AssociatedBillFiscalBillNumber(associatedBillFiscalBillNumber string) ApiGetFolioPrintersRequest {
	r.associatedBillFiscalBillNumber = &associatedBillFiscalBillNumber
	return r
}

// The bill generation date of the original bill for which the Credit Bill is being generated.
func (r ApiGetFolioPrintersRequest) AssociatedBillGenerationDate(associatedBillGenerationDate string) ApiGetFolioPrintersRequest {
	r.associatedBillGenerationDate = &associatedBillGenerationDate
	return r
}

// Folio Type to be assigned to generated folio. This is a country requirement.
func (r ApiGetFolioPrintersRequest) FolioType(folioType string) ApiGetFolioPrintersRequest {
	r.folioType = &folioType
	return r
}

// Fiscal folio flag to call fiscal folio web service after folio generation.
func (r ApiGetFolioPrintersRequest) GenerateFiscalFolio(generateFiscalFolio bool) ApiGetFolioPrintersRequest {
	r.generateFiscalFolio = &generateFiscalFolio
	return r
}

// Folio Queue name.
func (r ApiGetFolioPrintersRequest) QueueName(queueName string) ApiGetFolioPrintersRequest {
	r.queueName = &queueName
	return r
}

// Fiscal Folio sequence ID stored in queue table.
func (r ApiGetFolioPrintersRequest) FolioSeqId(folioSeqId int32) ApiGetFolioPrintersRequest {
	r.folioSeqId = &folioSeqId
	return r
}

// Action to generate Offline folio when no reponse is received from fiscal service.
func (r ApiGetFolioPrintersRequest) FiscalFolioInstruction(fiscalFolioInstruction string) ApiGetFolioPrintersRequest {
	r.fiscalFolioInstruction = &fiscalFolioInstruction
	return r
}

// Contains transaction service type.
func (r ApiGetFolioPrintersRequest) TransactionServiceType(transactionServiceType string) ApiGetFolioPrintersRequest {
	r.transactionServiceType = &transactionServiceType
	return r
}

// A monetary amount.
func (r ApiGetFolioPrintersRequest) Amount(amount float32) ApiGetFolioPrintersRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioPrintersRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetFolioPrintersRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// External system code.
func (r ApiGetFolioPrintersRequest) XExternalsystem(xExternalsystem string) ApiGetFolioPrintersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioPrintersRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioPrintersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioPrintersRequest) Execute() (*FolioPrinters, *http.Response, error) {
	return r.ApiService.GetFolioPrintersExecute(r)
}

/*
GetFolioPrinters Get folio printers

You can use this API to get folio printers. <p><strong>OperationId:</strong>getFolioPrinters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioPrintersRequest
*/
func (a *CashieringApiService) GetFolioPrinters(ctx context.Context, hotelId string) ApiGetFolioPrintersRequest {
	return ApiGetFolioPrintersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioPrinters
func (a *CashieringApiService) GetFolioPrintersExecute(r ApiGetFolioPrintersRequest) (*FolioPrinters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioPrinters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolioPrinters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioPrinters"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.allFolioWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allFolioWindow", r.allFolioWindow, "")
	}
	if r.correction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "correction", r.correction, "")
	}
	if r.debitFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "debitFolio", r.debitFolio, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.manualFolioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualFolioNo", r.manualFolioNo, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.fiscalTerminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalTerminalId", r.fiscalTerminalId, "")
	}
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.exchangeRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeRate", r.exchangeRate, "")
	}
	if r.associatedBillNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillNumber", r.associatedBillNumber, "")
	}
	if r.associatedBillFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillFolioType", r.associatedBillFolioType, "")
	}
	if r.associatedBillQueueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillQueueName", r.associatedBillQueueName, "")
	}
	if r.associatedBillFiscalBillNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillFiscalBillNumber", r.associatedBillFiscalBillNumber, "")
	}
	if r.associatedBillGenerationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillGenerationDate", r.associatedBillGenerationDate, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	if r.generateFiscalFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateFiscalFolio", r.generateFiscalFolio, "")
	}
	if r.queueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", r.queueName, "")
	}
	if r.folioSeqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioSeqId", r.folioSeqId, "")
	}
	if r.fiscalFolioInstruction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalFolioInstruction", r.fiscalFolioInstruction, "")
	}
	if r.transactionServiceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionServiceType", r.transactionServiceType, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioTaxPaymentsInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioWindowNo *int32
	cashierId *float32
	description *string
	folioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	id *string
	idContext *string
	type_ *string
	amount *float32
	currencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *time.Time
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *time.Time
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	postingAmountAmount *float32
	postingAmountCurrencyCode *string
	postingReference *string
	postingRemark *string
	comments *string
	applyCCSurcharge *bool
	manualPaymentTaxInfoFolioWindowNo *int32
	transactionCode *string
	transactionDate *string
	transactionDescription *string
	transactionNo *float32
	taxInvoiceNo *string
	paymentType *string
	manualPaymentTaxAmount *float32
	manualPaymentTaxCurrencyCode *string
	taxableAmountAmount *float32
	taxableAmountCurrencyCode *string
	nonTaxableAmountAmount *float32
	nonTaxableAmountCurrencyCode *string
	availableCreditAmount *float32
	availableCreditCurrencyCode *string
	paymentDate *string
	taxFolioWindowNo *[]int32
	taxTransactionCode *[]string
	taxTransactionDate *[]string
	taxTransactionDescription *[]string
	taxTransactionNo *[]float32
	taxTaxInvoiceNo *[]string
	taxPaymentType *[]string
	creditablePaymentTaxesAmount *float32
	creditablePaymentTaxesCurrencyCode *string
	creditablePaymentTaxableAmount *float32
	creditablePaymentTaxableCurrencyCode *string
	creditablePaymentNonTaxableAmount *float32
	creditablePaymentNonTaxableCurrencyCode *string
	availableTaxCreditAmount *float32
	availableTaxCreditCurrencyCode *string
	taxPaymentDate *[]string
	terminalId *string
	overrideInsufficientCC *bool
	changeDueAmount *float32
	changeDueAmountCurrencyCode *string
	overrideARCreditLimit *bool
	applyCurrencyTaxes *bool
	vATOffset *bool
	action *string
	reservationIdIdContext *string
	reservationIdType *string
	profileIdId *string
	profileIdIdContext *string
	profileIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioTaxPaymentsInfoRequest) Authorization(authorization string) ApiGetFolioTaxPaymentsInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioTaxPaymentsInfoRequest) XAppKey(xAppKey string) ApiGetFolioTaxPaymentsInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioTaxPaymentsInfoRequest) XHotelid(xHotelid string) ApiGetFolioTaxPaymentsInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) FolioWindowNo(folioWindowNo int32) ApiGetFolioTaxPaymentsInfoRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetFolioTaxPaymentsInfoRequest) CashierId(cashierId float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.cashierId = &cashierId
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) Description(description string) ApiGetFolioTaxPaymentsInfoRequest {
	r.description = &description
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) FolioView(folioView int32) ApiGetFolioTaxPaymentsInfoRequest {
	r.folioView = &folioView
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) PaymentMethod(paymentMethod string) ApiGetFolioTaxPaymentsInfoRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r ApiGetFolioTaxPaymentsInfoRequest) Track2Data(track2Data string) ApiGetFolioTaxPaymentsInfoRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r ApiGetFolioTaxPaymentsInfoRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) CardHolderName(cardHolderName string) ApiGetFolioTaxPaymentsInfoRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) CardNumber(cardNumber string) ApiGetFolioTaxPaymentsInfoRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetFolioTaxPaymentsInfoRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) CardNumberMasked(cardNumberMasked string) ApiGetFolioTaxPaymentsInfoRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetFolioTaxPaymentsInfoRequest) CardOrToken(cardOrToken string) ApiGetFolioTaxPaymentsInfoRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetFolioTaxPaymentsInfoRequest) CardType(cardType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetFolioTaxPaymentsInfoRequest) ExpirationDate(expirationDate string) ApiGetFolioTaxPaymentsInfoRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetFolioTaxPaymentsInfoRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetFolioTaxPaymentsInfoRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) Processing(processing string) ApiGetFolioTaxPaymentsInfoRequest {
	r.processing = &processing
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) Swiped(swiped bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetFolioTaxPaymentsInfoRequest) UserDefinedCardType(userDefinedCardType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioTaxPaymentsInfoRequest) Id(id string) ApiGetFolioTaxPaymentsInfoRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioTaxPaymentsInfoRequest) IdContext(idContext string) ApiGetFolioTaxPaymentsInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFolioTaxPaymentsInfoRequest) Type_(type_ string) ApiGetFolioTaxPaymentsInfoRequest {
	r.type_ = &type_
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) Amount(amount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) CurrencyCode(currencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) BalanceAmount(balanceAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ApiGetFolioTaxPaymentsInfoRequest) Code(code int32) ApiGetFolioTaxPaymentsInfoRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) AmountAmount(amountAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) AmountCurrencyCode(amountCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ApiGetFolioTaxPaymentsInfoRequest) Percent(percent float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.percent = &percent
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) EmailFolio(emailFolio bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioTaxPaymentsInfoRequest) UniqueIdId(uniqueIdId string) ApiGetFolioTaxPaymentsInfoRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioTaxPaymentsInfoRequest) UniqueIdIdContext(uniqueIdIdContext string) ApiGetFolioTaxPaymentsInfoRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFolioTaxPaymentsInfoRequest) UniqueIdType(uniqueIdType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreateDateTime(createDateTime time.Time) ApiGetFolioTaxPaymentsInfoRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreatorId(creatorId string) ApiGetFolioTaxPaymentsInfoRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r ApiGetFolioTaxPaymentsInfoRequest) EmailAddress(emailAddress string) ApiGetFolioTaxPaymentsInfoRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r ApiGetFolioTaxPaymentsInfoRequest) EmailFormat(emailFormat string) ApiGetFolioTaxPaymentsInfoRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ApiGetFolioTaxPaymentsInfoRequest) LastModifierId(lastModifierId string) ApiGetFolioTaxPaymentsInfoRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r ApiGetFolioTaxPaymentsInfoRequest) LastModifyDateTime(lastModifyDateTime time.Time) ApiGetFolioTaxPaymentsInfoRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r ApiGetFolioTaxPaymentsInfoRequest) OrderSequence(orderSequence float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r ApiGetFolioTaxPaymentsInfoRequest) PrimaryInd(primaryInd bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ApiGetFolioTaxPaymentsInfoRequest) PurgeDate(purgeDate string) ApiGetFolioTaxPaymentsInfoRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ApiGetFolioTaxPaymentsInfoRequest) EmailType(emailType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r ApiGetFolioTaxPaymentsInfoRequest) TypeDescription(typeDescription string) ApiGetFolioTaxPaymentsInfoRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApprovalCode(approvalCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r ApiGetFolioTaxPaymentsInfoRequest) OriginalAuthSequence(originalAuthSequence int32) ApiGetFolioTaxPaymentsInfoRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r ApiGetFolioTaxPaymentsInfoRequest) VendorTranId(vendorTranId string) ApiGetFolioTaxPaymentsInfoRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApprovalAmountAmount(approvalAmountAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) PostingAmountAmount(postingAmountAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.postingAmountAmount = &postingAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) PostingAmountCurrencyCode(postingAmountCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.postingAmountCurrencyCode = &postingAmountCurrencyCode
	return r
}

// User-defined posting reference.
func (r ApiGetFolioTaxPaymentsInfoRequest) PostingReference(postingReference string) ApiGetFolioTaxPaymentsInfoRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r ApiGetFolioTaxPaymentsInfoRequest) PostingRemark(postingRemark string) ApiGetFolioTaxPaymentsInfoRequest {
	r.postingRemark = &postingRemark
	return r
}

// User Defined Comments. Used for Deposit Payment postings.
func (r ApiGetFolioTaxPaymentsInfoRequest) Comments(comments string) ApiGetFolioTaxPaymentsInfoRequest {
	r.comments = &comments
	return r
}

// Flag to indicate if Credit Card Surcharge has to be applied to this payment, when the functionality for Credit Card Surcharge is available.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApplyCCSurcharge(applyCCSurcharge bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.applyCCSurcharge = &applyCCSurcharge
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) ManualPaymentTaxInfoFolioWindowNo(manualPaymentTaxInfoFolioWindowNo int32) ApiGetFolioTaxPaymentsInfoRequest {
	r.manualPaymentTaxInfoFolioWindowNo = &manualPaymentTaxInfoFolioWindowNo
	return r
}

// Billing Transaction Code of the Payment.
func (r ApiGetFolioTaxPaymentsInfoRequest) TransactionCode(transactionCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.transactionCode = &transactionCode
	return r
}

// Transaction Date of the Payment.
func (r ApiGetFolioTaxPaymentsInfoRequest) TransactionDate(transactionDate string) ApiGetFolioTaxPaymentsInfoRequest {
	r.transactionDate = &transactionDate
	return r
}

// Billing Transaction Description.
func (r ApiGetFolioTaxPaymentsInfoRequest) TransactionDescription(transactionDescription string) ApiGetFolioTaxPaymentsInfoRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Unique Transaction Identifier.
func (r ApiGetFolioTaxPaymentsInfoRequest) TransactionNo(transactionNo float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.transactionNo = &transactionNo
	return r
}

// The Tax Invoice for this payment.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxInvoiceNo(taxInvoiceNo string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxInvoiceNo = &taxInvoiceNo
	return r
}

// The types of Payment Tax transactions.
func (r ApiGetFolioTaxPaymentsInfoRequest) PaymentType(paymentType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.paymentType = &paymentType
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) ManualPaymentTaxAmount(manualPaymentTaxAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.manualPaymentTaxAmount = &manualPaymentTaxAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) ManualPaymentTaxCurrencyCode(manualPaymentTaxCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.manualPaymentTaxCurrencyCode = &manualPaymentTaxCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxableAmountAmount(taxableAmountAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxableAmountAmount = &taxableAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxableAmountCurrencyCode(taxableAmountCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxableAmountCurrencyCode = &taxableAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) NonTaxableAmountAmount(nonTaxableAmountAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.nonTaxableAmountAmount = &nonTaxableAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) NonTaxableAmountCurrencyCode(nonTaxableAmountCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.nonTaxableAmountCurrencyCode = &nonTaxableAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) AvailableCreditAmount(availableCreditAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.availableCreditAmount = &availableCreditAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) AvailableCreditCurrencyCode(availableCreditCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.availableCreditCurrencyCode = &availableCreditCurrencyCode
	return r
}

// The Payment Invoice date
func (r ApiGetFolioTaxPaymentsInfoRequest) PaymentDate(paymentDate string) ApiGetFolioTaxPaymentsInfoRequest {
	r.paymentDate = &paymentDate
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) TaxFolioWindowNo(taxFolioWindowNo []int32) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxFolioWindowNo = &taxFolioWindowNo
	return r
}

// Billing Transaction Code of the Payment.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxTransactionCode(taxTransactionCode []string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionCode = &taxTransactionCode
	return r
}

// Transaction Date of the Payment.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxTransactionDate(taxTransactionDate []string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionDate = &taxTransactionDate
	return r
}

// Billing Transaction Description.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxTransactionDescription(taxTransactionDescription []string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionDescription = &taxTransactionDescription
	return r
}

// Unique Transaction Identifier.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxTransactionNo(taxTransactionNo []float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionNo = &taxTransactionNo
	return r
}

// The Tax Invoice for this payment.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxTaxInvoiceNo(taxTaxInvoiceNo []string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxTaxInvoiceNo = &taxTaxInvoiceNo
	return r
}

// The types of Payment Tax transactions.
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxPaymentType(taxPaymentType []string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxPaymentType = &taxPaymentType
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxesAmount(creditablePaymentTaxesAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxesAmount = &creditablePaymentTaxesAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxesCurrencyCode(creditablePaymentTaxesCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxesCurrencyCode = &creditablePaymentTaxesCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxableAmount(creditablePaymentTaxableAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxableAmount = &creditablePaymentTaxableAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxableCurrencyCode(creditablePaymentTaxableCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxableCurrencyCode = &creditablePaymentTaxableCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreditablePaymentNonTaxableAmount(creditablePaymentNonTaxableAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentNonTaxableAmount = &creditablePaymentNonTaxableAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) CreditablePaymentNonTaxableCurrencyCode(creditablePaymentNonTaxableCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentNonTaxableCurrencyCode = &creditablePaymentNonTaxableCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) AvailableTaxCreditAmount(availableTaxCreditAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.availableTaxCreditAmount = &availableTaxCreditAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) AvailableTaxCreditCurrencyCode(availableTaxCreditCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.availableTaxCreditCurrencyCode = &availableTaxCreditCurrencyCode
	return r
}

// The Payment Invoice date
func (r ApiGetFolioTaxPaymentsInfoRequest) TaxPaymentDate(taxPaymentDate []string) ApiGetFolioTaxPaymentsInfoRequest {
	r.taxPaymentDate = &taxPaymentDate
	return r
}

// Applicable for chip and pin. The ID of the terminal where the chip and pin device is connected and where the payment is made.
func (r ApiGetFolioTaxPaymentsInfoRequest) TerminalId(terminalId string) ApiGetFolioTaxPaymentsInfoRequest {
	r.terminalId = &terminalId
	return r
}

// Flag to allow a rebate by Credit Card
func (r ApiGetFolioTaxPaymentsInfoRequest) OverrideInsufficientCC(overrideInsufficientCC bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.overrideInsufficientCC = &overrideInsufficientCC
	return r
}

// A monetary amount.
func (r ApiGetFolioTaxPaymentsInfoRequest) ChangeDueAmount(changeDueAmount float32) ApiGetFolioTaxPaymentsInfoRequest {
	r.changeDueAmount = &changeDueAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetFolioTaxPaymentsInfoRequest) ChangeDueAmountCurrencyCode(changeDueAmountCurrencyCode string) ApiGetFolioTaxPaymentsInfoRequest {
	r.changeDueAmountCurrencyCode = &changeDueAmountCurrencyCode
	return r
}

// Flag to override account receivable credit limit
func (r ApiGetFolioTaxPaymentsInfoRequest) OverrideARCreditLimit(overrideARCreditLimit bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.overrideARCreditLimit = &overrideARCreditLimit
	return r
}

// Flag to indidcate if currency taxes need to be applied or not. For ex, in case of Chile, it depends upon nationality of the guest.
func (r ApiGetFolioTaxPaymentsInfoRequest) ApplyCurrencyTaxes(applyCurrencyTaxes bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.applyCurrencyTaxes = &applyCurrencyTaxes
	return r
}

// Flag to indidcate if currency taxes need to be applied or not. For ex, in case of Chile, it depends upon nationality of the guest.
func (r ApiGetFolioTaxPaymentsInfoRequest) VATOffset(vATOffset bool) ApiGetFolioTaxPaymentsInfoRequest {
	r.vATOffset = &vATOffset
	return r
}

// Payment action to know from where the payment has been made.
func (r ApiGetFolioTaxPaymentsInfoRequest) Action(action string) ApiGetFolioTaxPaymentsInfoRequest {
	r.action = &action
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioTaxPaymentsInfoRequest) ReservationIdIdContext(reservationIdIdContext string) ApiGetFolioTaxPaymentsInfoRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFolioTaxPaymentsInfoRequest) ReservationIdType(reservationIdType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFolioTaxPaymentsInfoRequest) ProfileIdId(profileIdId string) ApiGetFolioTaxPaymentsInfoRequest {
	r.profileIdId = &profileIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioTaxPaymentsInfoRequest) ProfileIdIdContext(profileIdIdContext string) ApiGetFolioTaxPaymentsInfoRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetFolioTaxPaymentsInfoRequest) ProfileIdType(profileIdType string) ApiGetFolioTaxPaymentsInfoRequest {
	r.profileIdType = &profileIdType
	return r
}

// External system code.
func (r ApiGetFolioTaxPaymentsInfoRequest) XExternalsystem(xExternalsystem string) ApiGetFolioTaxPaymentsInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioTaxPaymentsInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioTaxPaymentsInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioTaxPaymentsInfoRequest) Execute() (*FolioTaxPaymentsInfo, *http.Response, error) {
	return r.ApiService.GetFolioTaxPaymentsInfoExecute(r)
}

/*
GetFolioTaxPaymentsInfo Get folio tax payments information

You can use this API to get folio tax payments information. <p><strong>OperationId:</strong>getFolioTaxPaymentsInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioTaxPaymentsInfoRequest
*/
func (a *CashieringApiService) GetFolioTaxPaymentsInfo(ctx context.Context, reservationId string, hotelId string) ApiGetFolioTaxPaymentsInfoRequest {
	return ApiGetFolioTaxPaymentsInfoRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTaxPaymentsInfo
func (a *CashieringApiService) GetFolioTaxPaymentsInfoExecute(r ApiGetFolioTaxPaymentsInfoRequest) (*FolioTaxPaymentsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTaxPaymentsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolioTaxPaymentsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folioTaxPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
	}
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
	}
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
	}
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
	}
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
	}
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
	}
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
	}
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
	}
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
	}
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
	}
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
	}
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
	}
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
	}
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
	}
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
	}
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
	}
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
	}
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
	}
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.postingAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountAmount", r.postingAmountAmount, "")
	}
	if r.postingAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountCurrencyCode", r.postingAmountCurrencyCode, "")
	}
	if r.postingReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", r.postingReference, "")
	}
	if r.postingRemark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", r.postingRemark, "")
	}
	if r.comments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comments", r.comments, "")
	}
	if r.applyCCSurcharge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applyCCSurcharge", r.applyCCSurcharge, "")
	}
	if r.manualPaymentTaxInfoFolioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPaymentTaxInfoFolioWindowNo", r.manualPaymentTaxInfoFolioWindowNo, "")
	}
	if r.transactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", r.transactionCode, "")
	}
	if r.transactionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", r.transactionDate, "")
	}
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
	}
	if r.transactionNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", r.transactionNo, "")
	}
	if r.taxInvoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxInvoiceNo", r.taxInvoiceNo, "")
	}
	if r.paymentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentType", r.paymentType, "")
	}
	if r.manualPaymentTaxAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPaymentTaxAmount", r.manualPaymentTaxAmount, "")
	}
	if r.manualPaymentTaxCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPaymentTaxCurrencyCode", r.manualPaymentTaxCurrencyCode, "")
	}
	if r.taxableAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxableAmountAmount", r.taxableAmountAmount, "")
	}
	if r.taxableAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxableAmountCurrencyCode", r.taxableAmountCurrencyCode, "")
	}
	if r.nonTaxableAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nonTaxableAmountAmount", r.nonTaxableAmountAmount, "")
	}
	if r.nonTaxableAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nonTaxableAmountCurrencyCode", r.nonTaxableAmountCurrencyCode, "")
	}
	if r.availableCreditAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableCreditAmount", r.availableCreditAmount, "")
	}
	if r.availableCreditCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableCreditCurrencyCode", r.availableCreditCurrencyCode, "")
	}
	if r.paymentDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentDate", r.paymentDate, "")
	}
	if r.taxFolioWindowNo != nil {
		t := *r.taxFolioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxFolioWindowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxFolioWindowNo", t, "multi")
		}
	}
	if r.taxTransactionCode != nil {
		t := *r.taxTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionCode", t, "multi")
		}
	}
	if r.taxTransactionDate != nil {
		t := *r.taxTransactionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDate", t, "multi")
		}
	}
	if r.taxTransactionDescription != nil {
		t := *r.taxTransactionDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDescription", t, "multi")
		}
	}
	if r.taxTransactionNo != nil {
		t := *r.taxTransactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionNo", t, "multi")
		}
	}
	if r.taxTaxInvoiceNo != nil {
		t := *r.taxTaxInvoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTaxInvoiceNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTaxInvoiceNo", t, "multi")
		}
	}
	if r.taxPaymentType != nil {
		t := *r.taxPaymentType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentType", t, "multi")
		}
	}
	if r.creditablePaymentTaxesAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxesAmount", r.creditablePaymentTaxesAmount, "")
	}
	if r.creditablePaymentTaxesCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxesCurrencyCode", r.creditablePaymentTaxesCurrencyCode, "")
	}
	if r.creditablePaymentTaxableAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxableAmount", r.creditablePaymentTaxableAmount, "")
	}
	if r.creditablePaymentTaxableCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxableCurrencyCode", r.creditablePaymentTaxableCurrencyCode, "")
	}
	if r.creditablePaymentNonTaxableAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentNonTaxableAmount", r.creditablePaymentNonTaxableAmount, "")
	}
	if r.creditablePaymentNonTaxableCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentNonTaxableCurrencyCode", r.creditablePaymentNonTaxableCurrencyCode, "")
	}
	if r.availableTaxCreditAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableTaxCreditAmount", r.availableTaxCreditAmount, "")
	}
	if r.availableTaxCreditCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableTaxCreditCurrencyCode", r.availableTaxCreditCurrencyCode, "")
	}
	if r.taxPaymentDate != nil {
		t := *r.taxPaymentDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentDate", t, "multi")
		}
	}
	if r.terminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminalId", r.terminalId, "")
	}
	if r.overrideInsufficientCC != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideInsufficientCC", r.overrideInsufficientCC, "")
	}
	if r.changeDueAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeDueAmount", r.changeDueAmount, "")
	}
	if r.changeDueAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeDueAmountCurrencyCode", r.changeDueAmountCurrencyCode, "")
	}
	if r.overrideARCreditLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideARCreditLimit", r.overrideARCreditLimit, "")
	}
	if r.applyCurrencyTaxes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applyCurrencyTaxes", r.applyCurrencyTaxes, "")
	}
	if r.vATOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vATOffset", r.vATOffset, "")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "")
	}
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
	}
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
	}
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioTransactionDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	transactionNo *[]float32
	includeExchangeInformation *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioTransactionDetailsRequest) Authorization(authorization string) ApiGetFolioTransactionDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioTransactionDetailsRequest) XAppKey(xAppKey string) ApiGetFolioTransactionDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioTransactionDetailsRequest) XHotelid(xHotelid string) ApiGetFolioTransactionDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the automatically generated transactions, related to the main transaction number above, are also to be retrieved as part of this request.
func (r ApiGetFolioTransactionDetailsRequest) IncludeGenerates(includeGenerates bool) ApiGetFolioTransactionDetailsRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// Unique Transaction Number of the transaction(posting) for which details are required.
func (r ApiGetFolioTransactionDetailsRequest) TransactionNo(transactionNo []float32) ApiGetFolioTransactionDetailsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Flag to indicate what currency exchange information text needs to be included in response.
func (r ApiGetFolioTransactionDetailsRequest) IncludeExchangeInformation(includeExchangeInformation bool) ApiGetFolioTransactionDetailsRequest {
	r.includeExchangeInformation = &includeExchangeInformation
	return r
}

// External system code.
func (r ApiGetFolioTransactionDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetFolioTransactionDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioTransactionDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioTransactionDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioTransactionDetailsRequest) Execute() (*FolioTransactionDetails, *http.Response, error) {
	return r.ApiService.GetFolioTransactionDetailsExecute(r)
}

/*
GetFolioTransactionDetails Get Folio Transaction Details

You can use this API to get Folio Transaction Details. <p><strong>OperationId:</strong>getFolioTransactionDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioTransactionDetailsRequest
*/
func (a *CashieringApiService) GetFolioTransactionDetails(ctx context.Context, hotelId string) ApiGetFolioTransactionDetailsRequest {
	return ApiGetFolioTransactionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTransactionDetails
func (a *CashieringApiService) GetFolioTransactionDetailsExecute(r ApiGetFolioTransactionDetailsRequest) (*FolioTransactionDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTransactionDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolioTransactionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
	}
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
	}
	if r.includeExchangeInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExchangeInformation", r.includeExchangeInformation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioTypeNameRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	internalFolioWindowId *string
	languageCode *string
	folioTypeName *string
	folioReportGroup *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioTypeNameRequest) Authorization(authorization string) ApiGetFolioTypeNameRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioTypeNameRequest) XAppKey(xAppKey string) ApiGetFolioTypeNameRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioTypeNameRequest) XHotelid(xHotelid string) ApiGetFolioTypeNameRequest {
	r.xHotelid = &xHotelid
	return r
}

// The internal folio window Id for the reservation to determine the guest language details.
func (r ApiGetFolioTypeNameRequest) InternalFolioWindowId(internalFolioWindowId string) ApiGetFolioTypeNameRequest {
	r.internalFolioWindowId = &internalFolioWindowId
	return r
}

// The Filter language code which will be used to retrieve the report name set for this language.
func (r ApiGetFolioTypeNameRequest) LanguageCode(languageCode string) ApiGetFolioTypeNameRequest {
	r.languageCode = &languageCode
	return r
}

// The Folio Type for which the details are requested.
func (r ApiGetFolioTypeNameRequest) FolioTypeName(folioTypeName string) ApiGetFolioTypeNameRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// The Folio Report Group name. The folio report will be defined under each group and based on where the folio has to be printed, Opera will pick up the correct folio report name to print.
func (r ApiGetFolioTypeNameRequest) FolioReportGroup(folioReportGroup string) ApiGetFolioTypeNameRequest {
	r.folioReportGroup = &folioReportGroup
	return r
}

// External system code.
func (r ApiGetFolioTypeNameRequest) XExternalsystem(xExternalsystem string) ApiGetFolioTypeNameRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioTypeNameRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioTypeNameRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioTypeNameRequest) Execute() (*FolioTypeNameInfo, *http.Response, error) {
	return r.ApiService.GetFolioTypeNameExecute(r)
}

/*
GetFolioTypeName Get Folio Type Name

You can use this API to get Folio Type Name. <p><strong>OperationId:</strong>getFolioTypeName</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioTypeNameRequest
*/
func (a *CashieringApiService) GetFolioTypeName(ctx context.Context, hotelId string) ApiGetFolioTypeNameRequest {
	return ApiGetFolioTypeNameRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTypeNameInfo
func (a *CashieringApiService) GetFolioTypeNameExecute(r ApiGetFolioTypeNameRequest) (*FolioTypeNameInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeNameInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolioTypeName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioTypeNames"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.internalFolioWindowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowId", r.internalFolioWindowId, "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
	}
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
	}
	if r.folioReportGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioReportGroup", r.folioReportGroup, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioTypesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeCompress *bool
	includeCredit *bool
	folioType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioTypesRequest) Authorization(authorization string) ApiGetFolioTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioTypesRequest) XAppKey(xAppKey string) ApiGetFolioTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioTypesRequest) XHotelid(xHotelid string) ApiGetFolioTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio to be use for compress bills.
func (r ApiGetFolioTypesRequest) IncludeCompress(includeCompress bool) ApiGetFolioTypesRequest {
	r.includeCompress = &includeCompress
	return r
}

// Folio to be use for credit bills.
func (r ApiGetFolioTypesRequest) IncludeCredit(includeCredit bool) ApiGetFolioTypesRequest {
	r.includeCredit = &includeCredit
	return r
}

// Folio Type.
func (r ApiGetFolioTypesRequest) FolioType(folioType string) ApiGetFolioTypesRequest {
	r.folioType = &folioType
	return r
}

// External system code.
func (r ApiGetFolioTypesRequest) XExternalsystem(xExternalsystem string) ApiGetFolioTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioTypesRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioTypesRequest) Execute() (*FolioTypesInfo, *http.Response, error) {
	return r.ApiService.GetFolioTypesExecute(r)
}

/*
GetFolioTypes Get Folio Types

You can use this API to get Folio Types. <p><strong>OperationId:</strong>getFolioTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetFolioTypesRequest
*/
func (a *CashieringApiService) GetFolioTypes(ctx context.Context, hotelId string) ApiGetFolioTypesRequest {
	return ApiGetFolioTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTypesInfo
func (a *CashieringApiService) GetFolioTypesExecute(r ApiGetFolioTypesRequest) (*FolioTypesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetFolioTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeCompress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompress", r.includeCompress, "")
	}
	if r.includeCredit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCredit", r.includeCredit, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGamingRequestStatusInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGamingRequestStatusInfoRequest) Authorization(authorization string) ApiGetGamingRequestStatusInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGamingRequestStatusInfoRequest) XAppKey(xAppKey string) ApiGetGamingRequestStatusInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGamingRequestStatusInfoRequest) XHotelid(xHotelid string) ApiGetGamingRequestStatusInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetGamingRequestStatusInfoRequest) XExternalsystem(xExternalsystem string) ApiGetGamingRequestStatusInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGamingRequestStatusInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetGamingRequestStatusInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGamingRequestStatusInfoRequest) Execute() (*GamingRequestStatusInfo, *http.Response, error) {
	return r.ApiService.GetGamingRequestStatusInfoExecute(r)
}

/*
GetGamingRequestStatusInfo Get Gaming Request Status 

You can use this API to get Gaming Request Status Information. <p><strong>OperationId:</strong>getGamingRequestStatusInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction.
 @param hotelId Unique ID of the hotel
 @return ApiGetGamingRequestStatusInfoRequest
*/
func (a *CashieringApiService) GetGamingRequestStatusInfo(ctx context.Context, transactionId string, hotelId string) ApiGetGamingRequestStatusInfoRequest {
	return ApiGetGamingRequestStatusInfoRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GamingRequestStatusInfo
func (a *CashieringApiService) GetGamingRequestStatusInfoExecute(r ApiGetGamingRequestStatusInfoRequest) (*GamingRequestStatusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GamingRequestStatusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetGamingRequestStatusInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/compRequestStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGuestsTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	reservationList *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	includeTransactionsWithARInvoiceNo *bool
	includeTransactionsWithFolioNo *bool
	includeTransactionsWithManualPostingOnly *bool
	idContext *[]string
	type_ *[]string
	transactionNo *[]float32
	transactionGroup *[]string
	transactionSubGroup *[]string
	billingCode *[]string
	billingHotelId *[]string
	desc *[]string
	routingInstructionsId *[]float32
	trxCodeWildCard *string
	trxDescriptionWildCard *string
	checkNumberWildCard *string
	referenceNumberWildCard *string
	supplementWildCard *string
	windowNo *[]int32
	cashieringTransactionType *[]string
	startDate *string
	endDate *string
	cashierId *float32
	code *[]string
	commissionable *bool
	serviceRecoveryAllowed *bool
	postedTransactionType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetGuestsTransactionsRequest) ReservationList(reservationList []string) ApiGetGuestsTransactionsRequest {
	r.reservationList = &reservationList
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGuestsTransactionsRequest) Authorization(authorization string) ApiGetGuestsTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGuestsTransactionsRequest) XAppKey(xAppKey string) ApiGetGuestsTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGuestsTransactionsRequest) XHotelid(xHotelid string) ApiGetGuestsTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuring this flag to be TRUE will return transactions that are auto generated like taxes.
func (r ApiGetGuestsTransactionsRequest) IncludeGenerates(includeGenerates bool) ApiGetGuestsTransactionsRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// Configuring this flag to be TRUE will return transactions that are included in an Accounts Receivable invoice.
func (r ApiGetGuestsTransactionsRequest) IncludeTransactionsWithARInvoiceNo(includeTransactionsWithARInvoiceNo bool) ApiGetGuestsTransactionsRequest {
	r.includeTransactionsWithARInvoiceNo = &includeTransactionsWithARInvoiceNo
	return r
}

// Configuring this flag to be TRUE will return transactions that already belongs to a folio.
func (r ApiGetGuestsTransactionsRequest) IncludeTransactionsWithFolioNo(includeTransactionsWithFolioNo bool) ApiGetGuestsTransactionsRequest {
	r.includeTransactionsWithFolioNo = &includeTransactionsWithFolioNo
	return r
}

// Configuring this flag to be TRUE will return transactions whose transaction codes have manual posting enabled, or when an adjustment code is attached to the transaction code, the adjustment code&#39;s manual posting is enabled.
func (r ApiGetGuestsTransactionsRequest) IncludeTransactionsWithManualPostingOnly(includeTransactionsWithManualPostingOnly bool) ApiGetGuestsTransactionsRequest {
	r.includeTransactionsWithManualPostingOnly = &includeTransactionsWithManualPostingOnly
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetGuestsTransactionsRequest) IdContext(idContext []string) ApiGetGuestsTransactionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetGuestsTransactionsRequest) Type_(type_ []string) ApiGetGuestsTransactionsRequest {
	r.type_ = &type_
	return r
}

// Transaction number of the payment being corrected.
func (r ApiGetGuestsTransactionsRequest) TransactionNo(transactionNo []float32) ApiGetGuestsTransactionsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Category of the transaction code to filter the result.
func (r ApiGetGuestsTransactionsRequest) TransactionGroup(transactionGroup []string) ApiGetGuestsTransactionsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code to filter the result.
func (r ApiGetGuestsTransactionsRequest) TransactionSubGroup(transactionSubGroup []string) ApiGetGuestsTransactionsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique identifier for the Billing Instruction.
func (r ApiGetGuestsTransactionsRequest) BillingCode(billingCode []string) ApiGetGuestsTransactionsRequest {
	r.billingCode = &billingCode
	return r
}

// Hotel context of the Billing Instruction.
func (r ApiGetGuestsTransactionsRequest) BillingHotelId(billingHotelId []string) ApiGetGuestsTransactionsRequest {
	r.billingHotelId = &billingHotelId
	return r
}

// Billing Instruction code description.
func (r ApiGetGuestsTransactionsRequest) Desc(desc []string) ApiGetGuestsTransactionsRequest {
	r.desc = &desc
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiGetGuestsTransactionsRequest) RoutingInstructionsId(routingInstructionsId []float32) ApiGetGuestsTransactionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Lookup string which will try to match an existing Transaction Code/s.
func (r ApiGetGuestsTransactionsRequest) TrxCodeWildCard(trxCodeWildCard string) ApiGetGuestsTransactionsRequest {
	r.trxCodeWildCard = &trxCodeWildCard
	return r
}

// Lookup string which will try to match an existing Transaction Code&#39;s Description.
func (r ApiGetGuestsTransactionsRequest) TrxDescriptionWildCard(trxDescriptionWildCard string) ApiGetGuestsTransactionsRequest {
	r.trxDescriptionWildCard = &trxDescriptionWildCard
	return r
}

// Lookup string which will try to match an existing Cheque number&#39;s code.
func (r ApiGetGuestsTransactionsRequest) CheckNumberWildCard(checkNumberWildCard string) ApiGetGuestsTransactionsRequest {
	r.checkNumberWildCard = &checkNumberWildCard
	return r
}

// Filters the results for reference number.
func (r ApiGetGuestsTransactionsRequest) ReferenceNumberWildCard(referenceNumberWildCard string) ApiGetGuestsTransactionsRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for supplement.
func (r ApiGetGuestsTransactionsRequest) SupplementWildCard(supplementWildCard string) ApiGetGuestsTransactionsRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// Filters the result to only include transactions in this window number.
func (r ApiGetGuestsTransactionsRequest) WindowNo(windowNo []int32) ApiGetGuestsTransactionsRequest {
	r.windowNo = &windowNo
	return r
}

// Wrapper Transaction Type.
func (r ApiGetGuestsTransactionsRequest) CashieringTransactionType(cashieringTransactionType []string) ApiGetGuestsTransactionsRequest {
	r.cashieringTransactionType = &cashieringTransactionType
	return r
}

func (r ApiGetGuestsTransactionsRequest) StartDate(startDate string) ApiGetGuestsTransactionsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetGuestsTransactionsRequest) EndDate(endDate string) ApiGetGuestsTransactionsRequest {
	r.endDate = &endDate
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetGuestsTransactionsRequest) CashierId(cashierId float32) ApiGetGuestsTransactionsRequest {
	r.cashierId = &cashierId
	return r
}

func (r ApiGetGuestsTransactionsRequest) Code(code []string) ApiGetGuestsTransactionsRequest {
	r.code = &code
	return r
}

// Filters the result based on its commission property. Do not set this criteria if all transactions should be included whether or not they are commissionable.
func (r ApiGetGuestsTransactionsRequest) Commissionable(commissionable bool) ApiGetGuestsTransactionsRequest {
	r.commissionable = &commissionable
	return r
}

// Filters the result which are allow for service recovery.
func (r ApiGetGuestsTransactionsRequest) ServiceRecoveryAllowed(serviceRecoveryAllowed bool) ApiGetGuestsTransactionsRequest {
	r.serviceRecoveryAllowed = &serviceRecoveryAllowed
	return r
}

// Returns only postings without bill number.
func (r ApiGetGuestsTransactionsRequest) PostedTransactionType(postedTransactionType []string) ApiGetGuestsTransactionsRequest {
	r.postedTransactionType = &postedTransactionType
	return r
}

// External system code.
func (r ApiGetGuestsTransactionsRequest) XExternalsystem(xExternalsystem string) ApiGetGuestsTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGuestsTransactionsRequest) AcceptLanguage(acceptLanguage string) ApiGetGuestsTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGuestsTransactionsRequest) Execute() (*GuestsTransactions, *http.Response, error) {
	return r.ApiService.GetGuestsTransactionsExecute(r)
}

/*
GetGuestsTransactions Get Guests Transactions

You can use this API to get  Guests Transactions. <p><strong>OperationId:</strong>getGuestsTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetGuestsTransactionsRequest
*/
func (a *CashieringApiService) GetGuestsTransactions(ctx context.Context, hotelId string) ApiGetGuestsTransactionsRequest {
	return ApiGetGuestsTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestsTransactions
func (a *CashieringApiService) GetGuestsTransactionsExecute(r ApiGetGuestsTransactionsRequest) (*GuestsTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestsTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetGuestsTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.reservationList == nil {
		return localVarReturnValue, nil, reportError("reservationList is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.reservationList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationList", t, "multi")
		}
	}
	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
	}
	if r.includeTransactionsWithARInvoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionsWithARInvoiceNo", r.includeTransactionsWithARInvoiceNo, "")
	}
	if r.includeTransactionsWithFolioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionsWithFolioNo", r.includeTransactionsWithFolioNo, "")
	}
	if r.includeTransactionsWithManualPostingOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionsWithManualPostingOnly", r.includeTransactionsWithManualPostingOnly, "")
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
	}
	if r.transactionGroup != nil {
		t := *r.transactionGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", t, "multi")
		}
	}
	if r.transactionSubGroup != nil {
		t := *r.transactionSubGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", t, "multi")
		}
	}
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
	}
	if r.billingHotelId != nil {
		t := *r.billingHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", t, "multi")
		}
	}
	if r.desc != nil {
		t := *r.desc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "desc", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "desc", t, "multi")
		}
	}
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
	}
	if r.trxCodeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeWildCard", r.trxCodeWildCard, "")
	}
	if r.trxDescriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxDescriptionWildCard", r.trxDescriptionWildCard, "")
	}
	if r.checkNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumberWildCard", r.checkNumberWildCard, "")
	}
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
	}
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
	}
	if r.windowNo != nil {
		t := *r.windowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "windowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "windowNo", t, "multi")
		}
	}
	if r.cashieringTransactionType != nil {
		t := *r.cashieringTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashieringTransactionType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashieringTransactionType", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.commissionable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "commissionable", r.commissionable, "")
	}
	if r.serviceRecoveryAllowed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRecoveryAllowed", r.serviceRecoveryAllowed, "")
	}
	if r.postedTransactionType != nil {
		t := *r.postedTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postedTransactionType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postedTransactionType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelRevenueRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	businessDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelRevenueRequest) Authorization(authorization string) ApiGetHotelRevenueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelRevenueRequest) XAppKey(xAppKey string) ApiGetHotelRevenueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelRevenueRequest) XHotelid(xHotelid string) ApiGetHotelRevenueRequest {
	r.xHotelid = &xHotelid
	return r
}

// Business date.
func (r ApiGetHotelRevenueRequest) BusinessDate(businessDate string) ApiGetHotelRevenueRequest {
	r.businessDate = &businessDate
	return r
}

// External system code.
func (r ApiGetHotelRevenueRequest) XExternalsystem(xExternalsystem string) ApiGetHotelRevenueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelRevenueRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelRevenueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelRevenueRequest) Execute() (*HotelRevenueDetails, *http.Response, error) {
	return r.ApiService.GetHotelRevenueExecute(r)
}

/*
GetHotelRevenue Get Hotel Revenue

You can use this API to get Hotel Revenue. <p><strong>OperationId:</strong>getHotelRevenue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetHotelRevenueRequest
*/
func (a *CashieringApiService) GetHotelRevenue(ctx context.Context, hotelId string) ApiGetHotelRevenueRequest {
	return ApiGetHotelRevenueRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelRevenueDetails
func (a *CashieringApiService) GetHotelRevenueExecute(r ApiGetHotelRevenueRequest) (*HotelRevenueDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelRevenueDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetHotelRevenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/revenue"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.businessDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessDate", r.businessDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMaturedDepositsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMaturedDepositsRequest) Authorization(authorization string) ApiGetMaturedDepositsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMaturedDepositsRequest) XAppKey(xAppKey string) ApiGetMaturedDepositsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMaturedDepositsRequest) XHotelid(xHotelid string) ApiGetMaturedDepositsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetMaturedDepositsRequest) XExternalsystem(xExternalsystem string) ApiGetMaturedDepositsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMaturedDepositsRequest) AcceptLanguage(acceptLanguage string) ApiGetMaturedDepositsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMaturedDepositsRequest) Execute() (*MaturedDepositsDetails, *http.Response, error) {
	return r.ApiService.GetMaturedDepositsExecute(r)
}

/*
GetMaturedDeposits Get matured deposits

You can use this API to fetch matured deposits. <p><strong>OperationId:</strong>getMaturedDeposits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetMaturedDepositsRequest
*/
func (a *CashieringApiService) GetMaturedDeposits(ctx context.Context, reservationId string, hotelId string) ApiGetMaturedDepositsRequest {
	return ApiGetMaturedDepositsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MaturedDepositsDetails
func (a *CashieringApiService) GetMaturedDepositsExecute(r ApiGetMaturedDepositsRequest) (*MaturedDepositsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MaturedDepositsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetMaturedDeposits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostBillingChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	folioWindowNo *[]int32
	chargeCashierId *[]float32
	transactionCode *[]string
	articleCode *[]string
	amount *float32
	currencyCode *string
	postingQuantity *[]int32
	postingReference *[]string
	postingRemark *[]string
	checkNumber *[]string
	arrangementCode *[]string
	applyRoutingInstructions *[]bool
	usePackageAllowance *[]bool
	autoPosting *[]bool
	id *[]string
	idContext *[]string
	type_ *[]string
	reservationIdIdContext *string
	reservationIdType *string
	option *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostBillingChargesRequest) Authorization(authorization string) ApiGetPostBillingChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostBillingChargesRequest) XAppKey(xAppKey string) ApiGetPostBillingChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostBillingChargesRequest) XHotelid(xHotelid string) ApiGetPostBillingChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetPostBillingChargesRequest) CashierId(cashierId float32) ApiGetPostBillingChargesRequest {
	r.cashierId = &cashierId
	return r
}

func (r ApiGetPostBillingChargesRequest) FolioWindowNo(folioWindowNo []int32) ApiGetPostBillingChargesRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetPostBillingChargesRequest) ChargeCashierId(chargeCashierId []float32) ApiGetPostBillingChargesRequest {
	r.chargeCashierId = &chargeCashierId
	return r
}

// Transaction Code to post.
func (r ApiGetPostBillingChargesRequest) TransactionCode(transactionCode []string) ApiGetPostBillingChargesRequest {
	r.transactionCode = &transactionCode
	return r
}

// Article ID.
func (r ApiGetPostBillingChargesRequest) ArticleCode(articleCode []string) ApiGetPostBillingChargesRequest {
	r.articleCode = &articleCode
	return r
}

// A monetary amount.
func (r ApiGetPostBillingChargesRequest) Amount(amount float32) ApiGetPostBillingChargesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetPostBillingChargesRequest) CurrencyCode(currencyCode string) ApiGetPostBillingChargesRequest {
	r.currencyCode = &currencyCode
	return r
}

// Quantity to post to the folio.
func (r ApiGetPostBillingChargesRequest) PostingQuantity(postingQuantity []int32) ApiGetPostBillingChargesRequest {
	r.postingQuantity = &postingQuantity
	return r
}

// User-defined posting reference.
func (r ApiGetPostBillingChargesRequest) PostingReference(postingReference []string) ApiGetPostBillingChargesRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r ApiGetPostBillingChargesRequest) PostingRemark(postingRemark []string) ApiGetPostBillingChargesRequest {
	r.postingRemark = &postingRemark
	return r
}

// Indicates the Cheque number.
func (r ApiGetPostBillingChargesRequest) CheckNumber(checkNumber []string) ApiGetPostBillingChargesRequest {
	r.checkNumber = &checkNumber
	return r
}

// Corrected arrangement code from the package associated to this transaction.
func (r ApiGetPostBillingChargesRequest) ArrangementCode(arrangementCode []string) ApiGetPostBillingChargesRequest {
	r.arrangementCode = &arrangementCode
	return r
}

// Apply room routing when making this posting.
func (r ApiGetPostBillingChargesRequest) ApplyRoutingInstructions(applyRoutingInstructions []bool) ApiGetPostBillingChargesRequest {
	r.applyRoutingInstructions = &applyRoutingInstructions
	return r
}

// Use the applicable package allowance when making this posting.
func (r ApiGetPostBillingChargesRequest) UsePackageAllowance(usePackageAllowance []bool) ApiGetPostBillingChargesRequest {
	r.usePackageAllowance = &usePackageAllowance
	return r
}

// True indicates the Transaction Code is allowed to be posted automatically.
func (r ApiGetPostBillingChargesRequest) AutoPosting(autoPosting []bool) ApiGetPostBillingChargesRequest {
	r.autoPosting = &autoPosting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetPostBillingChargesRequest) Id(id []string) ApiGetPostBillingChargesRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPostBillingChargesRequest) IdContext(idContext []string) ApiGetPostBillingChargesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetPostBillingChargesRequest) Type_(type_ []string) ApiGetPostBillingChargesRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPostBillingChargesRequest) ReservationIdIdContext(reservationIdIdContext string) ApiGetPostBillingChargesRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetPostBillingChargesRequest) ReservationIdType(reservationIdType string) ApiGetPostBillingChargesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// This is the Default option. Operation checks if charges can be posted to the reservation based on the status of the reservation.
func (r ApiGetPostBillingChargesRequest) Option(option []string) ApiGetPostBillingChargesRequest {
	r.option = &option
	return r
}

// External system code.
func (r ApiGetPostBillingChargesRequest) XExternalsystem(xExternalsystem string) ApiGetPostBillingChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostBillingChargesRequest) AcceptLanguage(acceptLanguage string) ApiGetPostBillingChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostBillingChargesRequest) Execute() (*BillingChargesStatus, *http.Response, error) {
	return r.ApiService.GetPostBillingChargesExecute(r)
}

/*
GetPostBillingCharges Get Billing Charges

You can use this API to get post Billing Charges. <p><strong>OperationId:</strong>getPostBillingCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetPostBillingChargesRequest
*/
func (a *CashieringApiService) GetPostBillingCharges(ctx context.Context, reservationId string, hotelId string) ApiGetPostBillingChargesRequest {
	return ApiGetPostBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingChargesStatus
func (a *CashieringApiService) GetPostBillingChargesExecute(r ApiGetPostBillingChargesRequest) (*BillingChargesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetPostBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
	}
	if r.chargeCashierId != nil {
		t := *r.chargeCashierId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.postingQuantity != nil {
		t := *r.postingQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", t, "multi")
		}
	}
	if r.postingReference != nil {
		t := *r.postingReference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", t, "multi")
		}
	}
	if r.postingRemark != nil {
		t := *r.postingRemark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", t, "multi")
		}
	}
	if r.checkNumber != nil {
		t := *r.checkNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", t, "multi")
		}
	}
	if r.arrangementCode != nil {
		t := *r.arrangementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", t, "multi")
		}
	}
	if r.applyRoutingInstructions != nil {
		t := *r.applyRoutingInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", t, "multi")
		}
	}
	if r.usePackageAllowance != nil {
		t := *r.usePackageAllowance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", t, "multi")
		}
	}
	if r.autoPosting != nil {
		t := *r.autoPosting
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.option != nil {
		t := *r.option
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "option", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "option", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostingActivityDetailRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	module *string
	logDate *time.Time
	refActionId *float32
	logUserId *int32
	logUserName *string
	machineStation *string
	croCode *string
	actionType *string
	actionDescription *string
	iPAddress *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostingActivityDetailRequest) Authorization(authorization string) ApiGetPostingActivityDetailRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostingActivityDetailRequest) XAppKey(xAppKey string) ApiGetPostingActivityDetailRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostingActivityDetailRequest) XHotelid(xHotelid string) ApiGetPostingActivityDetailRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPostingActivityDetailRequest) IdContext(idContext string) ApiGetPostingActivityDetailRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetPostingActivityDetailRequest) Type_(type_ string) ApiGetPostingActivityDetailRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetPostingActivityDetailRequest) Module(module string) ApiGetPostingActivityDetailRequest {
	r.module = &module
	return r
}

func (r ApiGetPostingActivityDetailRequest) LogDate(logDate time.Time) ApiGetPostingActivityDetailRequest {
	r.logDate = &logDate
	return r
}

func (r ApiGetPostingActivityDetailRequest) RefActionId(refActionId float32) ApiGetPostingActivityDetailRequest {
	r.refActionId = &refActionId
	return r
}

func (r ApiGetPostingActivityDetailRequest) LogUserId(logUserId int32) ApiGetPostingActivityDetailRequest {
	r.logUserId = &logUserId
	return r
}

func (r ApiGetPostingActivityDetailRequest) LogUserName(logUserName string) ApiGetPostingActivityDetailRequest {
	r.logUserName = &logUserName
	return r
}

func (r ApiGetPostingActivityDetailRequest) MachineStation(machineStation string) ApiGetPostingActivityDetailRequest {
	r.machineStation = &machineStation
	return r
}

func (r ApiGetPostingActivityDetailRequest) CroCode(croCode string) ApiGetPostingActivityDetailRequest {
	r.croCode = &croCode
	return r
}

func (r ApiGetPostingActivityDetailRequest) ActionType(actionType string) ApiGetPostingActivityDetailRequest {
	r.actionType = &actionType
	return r
}

func (r ApiGetPostingActivityDetailRequest) ActionDescription(actionDescription string) ApiGetPostingActivityDetailRequest {
	r.actionDescription = &actionDescription
	return r
}

// The IP Address of the machine that performed the activity
func (r ApiGetPostingActivityDetailRequest) IPAddress(iPAddress string) ApiGetPostingActivityDetailRequest {
	r.iPAddress = &iPAddress
	return r
}

// External system code.
func (r ApiGetPostingActivityDetailRequest) XExternalsystem(xExternalsystem string) ApiGetPostingActivityDetailRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostingActivityDetailRequest) AcceptLanguage(acceptLanguage string) ApiGetPostingActivityDetailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostingActivityDetailRequest) Execute() (*PostingActivityDetail, *http.Response, error) {
	return r.ApiService.GetPostingActivityDetailExecute(r)
}

/*
GetPostingActivityDetail Get posting activity details

You can use this API to get posting activity details. <p><strong>OperationId:</strong>getPostingActivityDetail</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiGetPostingActivityDetailRequest
*/
func (a *CashieringApiService) GetPostingActivityDetail(ctx context.Context, reservationId string, hotelId string) ApiGetPostingActivityDetailRequest {
	return ApiGetPostingActivityDetailRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostingActivityDetail
func (a *CashieringApiService) GetPostingActivityDetailExecute(r ApiGetPostingActivityDetailRequest) (*PostingActivityDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostingActivityDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetPostingActivityDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/postingActivities"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	}
	if r.logDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logDate", r.logDate, "")
	}
	if r.refActionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refActionId", r.refActionId, "")
	}
	if r.logUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logUserId", r.logUserId, "")
	}
	if r.logUserName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logUserName", r.logUserName, "")
	}
	if r.machineStation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "machineStation", r.machineStation, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.actionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "")
	}
	if r.actionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionDescription", r.actionDescription, "")
	}
	if r.iPAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iPAddress", r.iPAddress, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostingSummaryRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	postingDate *string
	checkPostings *bool
	postingsByExternalSystem *bool
	cashierId *float32
	currency *string
	postingSummaryType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostingSummaryRequest) Authorization(authorization string) ApiGetPostingSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostingSummaryRequest) XAppKey(xAppKey string) ApiGetPostingSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostingSummaryRequest) XHotelid(xHotelid string) ApiGetPostingSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuring this flag to be TRUE will return transactions that are auto generated like taxes.
func (r ApiGetPostingSummaryRequest) IncludeGenerates(includeGenerates bool) ApiGetPostingSummaryRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// The date on which the charge is posted.
func (r ApiGetPostingSummaryRequest) PostingDate(postingDate string) ApiGetPostingSummaryRequest {
	r.postingDate = &postingDate
	return r
}

// When set to true,the summary of only the postings using checks will be fetched.
func (r ApiGetPostingSummaryRequest) CheckPostings(checkPostings bool) ApiGetPostingSummaryRequest {
	r.checkPostings = &checkPostings
	return r
}

// When set to true,the summary of only the postings done by external systems will be fetched.
func (r ApiGetPostingSummaryRequest) PostingsByExternalSystem(postingsByExternalSystem bool) ApiGetPostingSummaryRequest {
	r.postingsByExternalSystem = &postingsByExternalSystem
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetPostingSummaryRequest) CashierId(cashierId float32) ApiGetPostingSummaryRequest {
	r.cashierId = &cashierId
	return r
}

// Currency in which the postings are done. If null,amounts posted in local currency will be fetched.
func (r ApiGetPostingSummaryRequest) Currency(currency string) ApiGetPostingSummaryRequest {
	r.currency = &currency
	return r
}

// Enumeration Type of Posting Summary Information.
func (r ApiGetPostingSummaryRequest) PostingSummaryType(postingSummaryType string) ApiGetPostingSummaryRequest {
	r.postingSummaryType = &postingSummaryType
	return r
}

// External system code.
func (r ApiGetPostingSummaryRequest) XExternalsystem(xExternalsystem string) ApiGetPostingSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostingSummaryRequest) AcceptLanguage(acceptLanguage string) ApiGetPostingSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostingSummaryRequest) Execute() (*PostingSummaryList, *http.Response, error) {
	return r.ApiService.GetPostingSummaryExecute(r)
}

/*
GetPostingSummary Get Posting Summary

You can use this API to get posting Summary. <p><strong>OperationId:</strong>getPostingSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetPostingSummaryRequest
*/
func (a *CashieringApiService) GetPostingSummary(ctx context.Context, hotelId string) ApiGetPostingSummaryRequest {
	return ApiGetPostingSummaryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostingSummaryList
func (a *CashieringApiService) GetPostingSummaryExecute(r ApiGetPostingSummaryRequest) (*PostingSummaryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostingSummaryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetPostingSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/postingDates/date/postingSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
	}
	if r.postingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", r.postingDate, "")
	}
	if r.checkPostings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkPostings", r.checkPostings, "")
	}
	if r.postingsByExternalSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingsByExternalSystem", r.postingsByExternalSystem, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.postingSummaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingSummaryType", r.postingSummaryType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostingsForRefreshRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	targetReservationId string
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	targetResvNameIdContext *string
	targetResvNameIdType *string
	daily *bool
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	startDate *string
	endDate *string
	transactionHotelId *[]string
	printTrxReceipt *[]bool
	transactionCode *[]string
	description *[]string
	transactionGroup *[]string
	transactionSubGroup *[]string
	universalProductCode *[]string
	routingInstructionsId *[]float32
	articleCode *[]string
	articleHotelId *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	articleTransactionCode *[]string
	amount *float32
	currencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	billingCode *[]string
	billingHotelId *[]string
	desc *[]string
	billingInstructionRoutingInstructionsId *[]float32
	creditLimit *float32
	percentageLimit *float32
	covers *float32
	limitUsed *float32
	id *string
	routingLinkIdIdContext *string
	routingLinkIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostingsForRefreshRequest) Authorization(authorization string) ApiGetPostingsForRefreshRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostingsForRefreshRequest) XAppKey(xAppKey string) ApiGetPostingsForRefreshRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostingsForRefreshRequest) XHotelid(xHotelid string) ApiGetPostingsForRefreshRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPostingsForRefreshRequest) IdContext(idContext string) ApiGetPostingsForRefreshRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetPostingsForRefreshRequest) Type_(type_ string) ApiGetPostingsForRefreshRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPostingsForRefreshRequest) TargetResvNameIdContext(targetResvNameIdContext string) ApiGetPostingsForRefreshRequest {
	r.targetResvNameIdContext = &targetResvNameIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetPostingsForRefreshRequest) TargetResvNameIdType(targetResvNameIdType string) ApiGetPostingsForRefreshRequest {
	r.targetResvNameIdType = &targetResvNameIdType
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r ApiGetPostingsForRefreshRequest) Daily(daily bool) ApiGetPostingsForRefreshRequest {
	r.daily = &daily
	return r
}

func (r ApiGetPostingsForRefreshRequest) Friday(friday bool) ApiGetPostingsForRefreshRequest {
	r.friday = &friday
	return r
}

func (r ApiGetPostingsForRefreshRequest) Monday(monday bool) ApiGetPostingsForRefreshRequest {
	r.monday = &monday
	return r
}

func (r ApiGetPostingsForRefreshRequest) Saturday(saturday bool) ApiGetPostingsForRefreshRequest {
	r.saturday = &saturday
	return r
}

func (r ApiGetPostingsForRefreshRequest) Sunday(sunday bool) ApiGetPostingsForRefreshRequest {
	r.sunday = &sunday
	return r
}

func (r ApiGetPostingsForRefreshRequest) Thursday(thursday bool) ApiGetPostingsForRefreshRequest {
	r.thursday = &thursday
	return r
}

func (r ApiGetPostingsForRefreshRequest) Tuesday(tuesday bool) ApiGetPostingsForRefreshRequest {
	r.tuesday = &tuesday
	return r
}

func (r ApiGetPostingsForRefreshRequest) Wednesday(wednesday bool) ApiGetPostingsForRefreshRequest {
	r.wednesday = &wednesday
	return r
}

func (r ApiGetPostingsForRefreshRequest) StartDate(startDate string) ApiGetPostingsForRefreshRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetPostingsForRefreshRequest) EndDate(endDate string) ApiGetPostingsForRefreshRequest {
	r.endDate = &endDate
	return r
}

// Hotel context of the Transaction code.
func (r ApiGetPostingsForRefreshRequest) TransactionHotelId(transactionHotelId []string) ApiGetPostingsForRefreshRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r ApiGetPostingsForRefreshRequest) PrintTrxReceipt(printTrxReceipt []bool) ApiGetPostingsForRefreshRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r ApiGetPostingsForRefreshRequest) TransactionCode(transactionCode []string) ApiGetPostingsForRefreshRequest {
	r.transactionCode = &transactionCode
	return r
}

// Transaction codes info.
func (r ApiGetPostingsForRefreshRequest) Description(description []string) ApiGetPostingsForRefreshRequest {
	r.description = &description
	return r
}

// Category of the transaction code.
func (r ApiGetPostingsForRefreshRequest) TransactionGroup(transactionGroup []string) ApiGetPostingsForRefreshRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r ApiGetPostingsForRefreshRequest) TransactionSubGroup(transactionSubGroup []string) ApiGetPostingsForRefreshRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r ApiGetPostingsForRefreshRequest) UniversalProductCode(universalProductCode []string) ApiGetPostingsForRefreshRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiGetPostingsForRefreshRequest) RoutingInstructionsId(routingInstructionsId []float32) ApiGetPostingsForRefreshRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r ApiGetPostingsForRefreshRequest) ArticleCode(articleCode []string) ApiGetPostingsForRefreshRequest {
	r.articleCode = &articleCode
	return r
}

// Hotel code to which the article belongs.
func (r ApiGetPostingsForRefreshRequest) ArticleHotelId(articleHotelId []string) ApiGetPostingsForRefreshRequest {
	r.articleHotelId = &articleHotelId
	return r
}

// Indicates whether the article is inactive or not.
func (r ApiGetPostingsForRefreshRequest) Inactive(inactive []bool) ApiGetPostingsForRefreshRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r ApiGetPostingsForRefreshRequest) OrderSequence(orderSequence []float32) ApiGetPostingsForRefreshRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r ApiGetPostingsForRefreshRequest) ArticleDescription(articleDescription []string) ApiGetPostingsForRefreshRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r ApiGetPostingsForRefreshRequest) ArticleTransactionCode(articleTransactionCode []string) ApiGetPostingsForRefreshRequest {
	r.articleTransactionCode = &articleTransactionCode
	return r
}

// A monetary amount.
func (r ApiGetPostingsForRefreshRequest) Amount(amount float32) ApiGetPostingsForRefreshRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetPostingsForRefreshRequest) CurrencyCode(currencyCode string) ApiGetPostingsForRefreshRequest {
	r.currencyCode = &currencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r ApiGetPostingsForRefreshRequest) AvailableForPostIt(availableForPostIt bool) ApiGetPostingsForRefreshRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r ApiGetPostingsForRefreshRequest) Color(color string) ApiGetPostingsForRefreshRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r ApiGetPostingsForRefreshRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) ApiGetPostingsForRefreshRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r ApiGetPostingsForRefreshRequest) BillingCode(billingCode []string) ApiGetPostingsForRefreshRequest {
	r.billingCode = &billingCode
	return r
}

// Hotel context of the Billing Instruction.
func (r ApiGetPostingsForRefreshRequest) BillingHotelId(billingHotelId []string) ApiGetPostingsForRefreshRequest {
	r.billingHotelId = &billingHotelId
	return r
}

// Billing Instruction code description.
func (r ApiGetPostingsForRefreshRequest) Desc(desc []string) ApiGetPostingsForRefreshRequest {
	r.desc = &desc
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiGetPostingsForRefreshRequest) BillingInstructionRoutingInstructionsId(billingInstructionRoutingInstructionsId []float32) ApiGetPostingsForRefreshRequest {
	r.billingInstructionRoutingInstructionsId = &billingInstructionRoutingInstructionsId
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r ApiGetPostingsForRefreshRequest) CreditLimit(creditLimit float32) ApiGetPostingsForRefreshRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r ApiGetPostingsForRefreshRequest) PercentageLimit(percentageLimit float32) ApiGetPostingsForRefreshRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r ApiGetPostingsForRefreshRequest) Covers(covers float32) ApiGetPostingsForRefreshRequest {
	r.covers = &covers
	return r
}

// Amount of Credit used for this routing instruction.
func (r ApiGetPostingsForRefreshRequest) LimitUsed(limitUsed float32) ApiGetPostingsForRefreshRequest {
	r.limitUsed = &limitUsed
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetPostingsForRefreshRequest) Id(id string) ApiGetPostingsForRefreshRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPostingsForRefreshRequest) RoutingLinkIdIdContext(routingLinkIdIdContext string) ApiGetPostingsForRefreshRequest {
	r.routingLinkIdIdContext = &routingLinkIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetPostingsForRefreshRequest) RoutingLinkIdType(routingLinkIdType string) ApiGetPostingsForRefreshRequest {
	r.routingLinkIdType = &routingLinkIdType
	return r
}

// External system code.
func (r ApiGetPostingsForRefreshRequest) XExternalsystem(xExternalsystem string) ApiGetPostingsForRefreshRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostingsForRefreshRequest) AcceptLanguage(acceptLanguage string) ApiGetPostingsForRefreshRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostingsForRefreshRequest) Execute() (*PostingsForRefresh, *http.Response, error) {
	return r.ApiService.GetPostingsForRefreshExecute(r)
}

/*
GetPostingsForRefresh Get Postings For Refresh

You can use this API to get postings For Refresh. <p><strong>OperationId:</strong>getPostingsForRefresh</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetReservationId Unique ID of the target reservation
 @param sourceReservationId Unique ID of the source reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetPostingsForRefreshRequest
*/
func (a *CashieringApiService) GetPostingsForRefresh(ctx context.Context, targetReservationId string, sourceReservationId string, hotelId string) ApiGetPostingsForRefreshRequest {
	return ApiGetPostingsForRefreshRequest{
		ApiService: a,
		ctx: ctx,
		targetReservationId: targetReservationId,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostingsForRefresh
func (a *CashieringApiService) GetPostingsForRefreshExecute(r ApiGetPostingsForRefreshRequest) (*PostingsForRefresh, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostingsForRefresh
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetPostingsForRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/targetReservations/{targetReservationId}/roomRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"targetReservationId"+"}", url.PathEscape(parameterValueToString(r.targetReservationId, "targetReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetReservationId) < 1 {
		return localVarReturnValue, nil, reportError("targetReservationId must have at least 1 elements")
	}
	if strlen(r.targetReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("targetReservationId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.targetResvNameIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetResvNameIdContext", r.targetResvNameIdContext, "")
	}
	if r.targetResvNameIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetResvNameIdType", r.targetResvNameIdType, "")
	}
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.transactionHotelId != nil {
		t := *r.transactionHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", t, "multi")
		}
	}
	if r.printTrxReceipt != nil {
		t := *r.printTrxReceipt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.transactionGroup != nil {
		t := *r.transactionGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", t, "multi")
		}
	}
	if r.transactionSubGroup != nil {
		t := *r.transactionSubGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", t, "multi")
		}
	}
	if r.universalProductCode != nil {
		t := *r.universalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", t, "multi")
		}
	}
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.articleHotelId != nil {
		t := *r.articleHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
	}
	if r.articleTransactionCode != nil {
		t := *r.articleTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleTransactionCode", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
	}
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
	}
	if r.billingHotelId != nil {
		t := *r.billingHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", t, "multi")
		}
	}
	if r.desc != nil {
		t := *r.desc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "desc", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "desc", t, "multi")
		}
	}
	if r.billingInstructionRoutingInstructionsId != nil {
		t := *r.billingInstructionRoutingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingInstructionRoutingInstructionsId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingInstructionRoutingInstructionsId", t, "multi")
		}
	}
	if r.creditLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", r.creditLimit, "")
	}
	if r.percentageLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", r.percentageLimit, "")
	}
	if r.covers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "covers", r.covers, "")
	}
	if r.limitUsed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limitUsed", r.limitUsed, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.routingLinkIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkIdIdContext", r.routingLinkIdIdContext, "")
	}
	if r.routingLinkIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkIdType", r.routingLinkIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptHistoryRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fromDate *string
	toDate *string
	name *string
	firstName *string
	receiptTypeName *string
	taxInvoice *string
	receiptNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReceiptHistoryRequest) Authorization(authorization string) ApiGetReceiptHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReceiptHistoryRequest) XAppKey(xAppKey string) ApiGetReceiptHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReceiptHistoryRequest) XHotelid(xHotelid string) ApiGetReceiptHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Receipt History Date Range(from).
func (r ApiGetReceiptHistoryRequest) FromDate(fromDate string) ApiGetReceiptHistoryRequest {
	r.fromDate = &fromDate
	return r
}

// Receipt History Date Range(to).
func (r ApiGetReceiptHistoryRequest) ToDate(toDate string) ApiGetReceiptHistoryRequest {
	r.toDate = &toDate
	return r
}

// Family name, last name or Company Name.
func (r ApiGetReceiptHistoryRequest) Name(name string) ApiGetReceiptHistoryRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r ApiGetReceiptHistoryRequest) FirstName(firstName string) ApiGetReceiptHistoryRequest {
	r.firstName = &firstName
	return r
}

// Receipt Type.
func (r ApiGetReceiptHistoryRequest) ReceiptTypeName(receiptTypeName string) ApiGetReceiptHistoryRequest {
	r.receiptTypeName = &receiptTypeName
	return r
}

// Tax Invoice Number.
func (r ApiGetReceiptHistoryRequest) TaxInvoice(taxInvoice string) ApiGetReceiptHistoryRequest {
	r.taxInvoice = &taxInvoice
	return r
}

// Receipt Number.
func (r ApiGetReceiptHistoryRequest) ReceiptNo(receiptNo float32) ApiGetReceiptHistoryRequest {
	r.receiptNo = &receiptNo
	return r
}

// External system code.
func (r ApiGetReceiptHistoryRequest) XExternalsystem(xExternalsystem string) ApiGetReceiptHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReceiptHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetReceiptHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReceiptHistoryRequest) Execute() (*ReceiptHistoryResponse, *http.Response, error) {
	return r.ApiService.GetReceiptHistoryExecute(r)
}

/*
GetReceiptHistory Get Receipt History

You can use this API to get Receipt History. <p><strong>OperationId:</strong>getReceiptHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetReceiptHistoryRequest
*/
func (a *CashieringApiService) GetReceiptHistory(ctx context.Context, hotelId string) ApiGetReceiptHistoryRequest {
	return ApiGetReceiptHistoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReceiptHistoryResponse
func (a *CashieringApiService) GetReceiptHistoryExecute(r ApiGetReceiptHistoryRequest) (*ReceiptHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiptHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetReceiptHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/receiptHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.receiptTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptTypeName", r.receiptTypeName, "")
	}
	if r.taxInvoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxInvoice", r.taxInvoice, "")
	}
	if r.receiptNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptNo", r.receiptNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationPackageOptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationPackageOptionsRequest) Authorization(authorization string) ApiGetReservationPackageOptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationPackageOptionsRequest) XAppKey(xAppKey string) ApiGetReservationPackageOptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationPackageOptionsRequest) XHotelid(xHotelid string) ApiGetReservationPackageOptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetReservationPackageOptionsRequest) XExternalsystem(xExternalsystem string) ApiGetReservationPackageOptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationPackageOptionsRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationPackageOptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationPackageOptionsRequest) Execute() (*ReservationPackageOptions, *http.Response, error) {
	return r.ApiService.GetReservationPackageOptionsExecute(r)
}

/*
GetReservationPackageOptions Get Reservation Package Options

You can use this API to get Reservation Package Options. <p><strong>OperationId:</strong>getReservationPackageOptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiGetReservationPackageOptionsRequest
*/
func (a *CashieringApiService) GetReservationPackageOptions(ctx context.Context, reservationId string, hotelId string) ApiGetReservationPackageOptionsRequest {
	return ApiGetReservationPackageOptionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPackageOptions
func (a *CashieringApiService) GetReservationPackageOptionsExecute(r ApiGetReservationPackageOptionsRequest) (*ReservationPackageOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPackageOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetReservationPackageOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packageOptions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationRevenueBucketTotalsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	revenueBucketType *string
	compRevenue *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationRevenueBucketTotalsRequest) Authorization(authorization string) ApiGetReservationRevenueBucketTotalsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationRevenueBucketTotalsRequest) XAppKey(xAppKey string) ApiGetReservationRevenueBucketTotalsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationRevenueBucketTotalsRequest) XHotelid(xHotelid string) ApiGetReservationRevenueBucketTotalsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetReservationRevenueBucketTotalsRequest) IdContext(idContext string) ApiGetReservationRevenueBucketTotalsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetReservationRevenueBucketTotalsRequest) Type_(type_ string) ApiGetReservationRevenueBucketTotalsRequest {
	r.type_ = &type_
	return r
}

// Type if the revenue bucket.
func (r ApiGetReservationRevenueBucketTotalsRequest) RevenueBucketType(revenueBucketType string) ApiGetReservationRevenueBucketTotalsRequest {
	r.revenueBucketType = &revenueBucketType
	return r
}

// This flag will notify the service if the revenue is of complimentary type.
func (r ApiGetReservationRevenueBucketTotalsRequest) CompRevenue(compRevenue bool) ApiGetReservationRevenueBucketTotalsRequest {
	r.compRevenue = &compRevenue
	return r
}

// External system code.
func (r ApiGetReservationRevenueBucketTotalsRequest) XExternalsystem(xExternalsystem string) ApiGetReservationRevenueBucketTotalsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationRevenueBucketTotalsRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationRevenueBucketTotalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationRevenueBucketTotalsRequest) Execute() (*RevenueBucketTotals, *http.Response, error) {
	return r.ApiService.GetReservationRevenueBucketTotalsExecute(r)
}

/*
GetReservationRevenueBucketTotals Get Reservations Revenue Bucket Totals

You can use this API to get a reservations Revenue Bucket Totals. <p><strong>OperationId:</strong>getReservationRevenueBucketTotals</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiGetReservationRevenueBucketTotalsRequest
*/
func (a *CashieringApiService) GetReservationRevenueBucketTotals(ctx context.Context, reservationId string, hotelId string) ApiGetReservationRevenueBucketTotalsRequest {
	return ApiGetReservationRevenueBucketTotalsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RevenueBucketTotals
func (a *CashieringApiService) GetReservationRevenueBucketTotalsExecute(r ApiGetReservationRevenueBucketTotalsRequest) (*RevenueBucketTotals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueBucketTotals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetReservationRevenueBucketTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/revenueBuckets"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.revenueBucketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketType", r.revenueBucketType, "")
	}
	if r.compRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compRevenue", r.compRevenue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoundingDifferenceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	folioWindowNo *int32
	internalFolioWindowID *string
	cashierId *float32
	hotelId *string
	id *string
	amount *float32
	currencyCode *string
	description *string
	folioView *int32
	paymentMethod *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	cardIdId *string
	currentAuthorizedAmountAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	createDateTime *time.Time
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *time.Time
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoundingDifferenceRequest) Authorization(authorization string) ApiGetRoundingDifferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoundingDifferenceRequest) XAppKey(xAppKey string) ApiGetRoundingDifferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoundingDifferenceRequest) XHotelid(xHotelid string) ApiGetRoundingDifferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r ApiGetRoundingDifferenceRequest) Event(event string) ApiGetRoundingDifferenceRequest {
	r.event = &event
	return r
}

func (r ApiGetRoundingDifferenceRequest) FolioWindowNo(folioWindowNo int32) ApiGetRoundingDifferenceRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetRoundingDifferenceRequest) InternalFolioWindowID(internalFolioWindowID string) ApiGetRoundingDifferenceRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetRoundingDifferenceRequest) CashierId(cashierId float32) ApiGetRoundingDifferenceRequest {
	r.cashierId = &cashierId
	return r
}

// Hotel context of the reservation.
func (r ApiGetRoundingDifferenceRequest) HotelId(hotelId string) ApiGetRoundingDifferenceRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRoundingDifferenceRequest) Id(id string) ApiGetRoundingDifferenceRequest {
	r.id = &id
	return r
}

// A monetary amount.
func (r ApiGetRoundingDifferenceRequest) Amount(amount float32) ApiGetRoundingDifferenceRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetRoundingDifferenceRequest) CurrencyCode(currencyCode string) ApiGetRoundingDifferenceRequest {
	r.currencyCode = &currencyCode
	return r
}

func (r ApiGetRoundingDifferenceRequest) Description(description string) ApiGetRoundingDifferenceRequest {
	r.description = &description
	return r
}

func (r ApiGetRoundingDifferenceRequest) FolioView(folioView int32) ApiGetRoundingDifferenceRequest {
	r.folioView = &folioView
	return r
}

func (r ApiGetRoundingDifferenceRequest) PaymentMethod(paymentMethod string) ApiGetRoundingDifferenceRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Attach the credit card to profile.
func (r ApiGetRoundingDifferenceRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetRoundingDifferenceRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetRoundingDifferenceRequest) CardHolderName(cardHolderName string) ApiGetRoundingDifferenceRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetRoundingDifferenceRequest) CardNumber(cardNumber string) ApiGetRoundingDifferenceRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetRoundingDifferenceRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetRoundingDifferenceRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetRoundingDifferenceRequest) CardNumberMasked(cardNumberMasked string) ApiGetRoundingDifferenceRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetRoundingDifferenceRequest) CardOrToken(cardOrToken string) ApiGetRoundingDifferenceRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetRoundingDifferenceRequest) CardType(cardType string) ApiGetRoundingDifferenceRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetRoundingDifferenceRequest) ExpirationDate(expirationDate string) ApiGetRoundingDifferenceRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetRoundingDifferenceRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetRoundingDifferenceRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetRoundingDifferenceRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetRoundingDifferenceRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetRoundingDifferenceRequest) Processing(processing string) ApiGetRoundingDifferenceRequest {
	r.processing = &processing
	return r
}

func (r ApiGetRoundingDifferenceRequest) Swiped(swiped bool) ApiGetRoundingDifferenceRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetRoundingDifferenceRequest) UserDefinedCardType(userDefinedCardType string) ApiGetRoundingDifferenceRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRoundingDifferenceRequest) CardIdId(cardIdId string) ApiGetRoundingDifferenceRequest {
	r.cardIdId = &cardIdId
	return r
}

// A monetary amount.
func (r ApiGetRoundingDifferenceRequest) CurrentAuthorizedAmountAmount(currentAuthorizedAmountAmount float32) ApiGetRoundingDifferenceRequest {
	r.currentAuthorizedAmountAmount = &currentAuthorizedAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetRoundingDifferenceRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) ApiGetRoundingDifferenceRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetRoundingDifferenceRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) ApiGetRoundingDifferenceRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetRoundingDifferenceRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) ApiGetRoundingDifferenceRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetRoundingDifferenceRequest) BalanceAmount(balanceAmount float32) ApiGetRoundingDifferenceRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetRoundingDifferenceRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetRoundingDifferenceRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ApiGetRoundingDifferenceRequest) Code(code int32) ApiGetRoundingDifferenceRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r ApiGetRoundingDifferenceRequest) AmountAmount(amountAmount float32) ApiGetRoundingDifferenceRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetRoundingDifferenceRequest) AmountCurrencyCode(amountCurrencyCode string) ApiGetRoundingDifferenceRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ApiGetRoundingDifferenceRequest) Percent(percent float32) ApiGetRoundingDifferenceRequest {
	r.percent = &percent
	return r
}

func (r ApiGetRoundingDifferenceRequest) EmailFolio(emailFolio bool) ApiGetRoundingDifferenceRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRoundingDifferenceRequest) UniqueIdId(uniqueIdId string) ApiGetRoundingDifferenceRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Time stamp of the creation.
func (r ApiGetRoundingDifferenceRequest) CreateDateTime(createDateTime time.Time) ApiGetRoundingDifferenceRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ApiGetRoundingDifferenceRequest) CreatorId(creatorId string) ApiGetRoundingDifferenceRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r ApiGetRoundingDifferenceRequest) EmailAddress(emailAddress string) ApiGetRoundingDifferenceRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r ApiGetRoundingDifferenceRequest) EmailFormat(emailFormat string) ApiGetRoundingDifferenceRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ApiGetRoundingDifferenceRequest) LastModifierId(lastModifierId string) ApiGetRoundingDifferenceRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r ApiGetRoundingDifferenceRequest) LastModifyDateTime(lastModifyDateTime time.Time) ApiGetRoundingDifferenceRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r ApiGetRoundingDifferenceRequest) OrderSequence(orderSequence float32) ApiGetRoundingDifferenceRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r ApiGetRoundingDifferenceRequest) PrimaryInd(primaryInd bool) ApiGetRoundingDifferenceRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ApiGetRoundingDifferenceRequest) PurgeDate(purgeDate string) ApiGetRoundingDifferenceRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ApiGetRoundingDifferenceRequest) EmailType(emailType string) ApiGetRoundingDifferenceRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r ApiGetRoundingDifferenceRequest) TypeDescription(typeDescription string) ApiGetRoundingDifferenceRequest {
	r.typeDescription = &typeDescription
	return r
}

// External system code.
func (r ApiGetRoundingDifferenceRequest) XExternalsystem(xExternalsystem string) ApiGetRoundingDifferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoundingDifferenceRequest) AcceptLanguage(acceptLanguage string) ApiGetRoundingDifferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoundingDifferenceRequest) Execute() (*RoundingDifferenceAmount, *http.Response, error) {
	return r.ApiService.GetRoundingDifferenceExecute(r)
}

/*
GetRoundingDifference Get Rounding Difference

You can use this API to get Rounding Difference. <p><strong>OperationId:</strong>getRoundingDifference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRoundingDifferenceRequest
*/
func (a *CashieringApiService) GetRoundingDifference(ctx context.Context) ApiGetRoundingDifferenceRequest {
	return ApiGetRoundingDifferenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoundingDifferenceAmount
func (a *CashieringApiService) GetRoundingDifferenceExecute(r ApiGetRoundingDifferenceRequest) (*RoundingDifferenceAmount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoundingDifferenceAmount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetRoundingDifference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roundingDifference"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.cardIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdId", r.cardIdId, "")
	}
	if r.currentAuthorizedAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountAmount", r.currentAuthorizedAmountAmount, "")
	}
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
	}
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
	}
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
	}
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
	}
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
	}
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
	}
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
	}
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
	}
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
	}
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
	}
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
	}
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
	}
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
	}
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	includeWindowRouting *bool
	includeRoomRouting *bool
	includeCompRouting *bool
	includeCompRoutingRequests *bool
	effectiveOn *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoutingInstructionsRequest) Authorization(authorization string) ApiGetRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoutingInstructionsRequest) XAppKey(xAppKey string) ApiGetRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoutingInstructionsRequest) XHotelid(xHotelid string) ApiGetRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetRoutingInstructionsRequest) IdContext(idContext string) ApiGetRoutingInstructionsRequest {
	r.idContext = &idContext
	return r
}

// Include the window routing instructions to the response.
func (r ApiGetRoutingInstructionsRequest) IncludeWindowRouting(includeWindowRouting bool) ApiGetRoutingInstructionsRequest {
	r.includeWindowRouting = &includeWindowRouting
	return r
}

// Include the room routing instructions in the response.
func (r ApiGetRoutingInstructionsRequest) IncludeRoomRouting(includeRoomRouting bool) ApiGetRoutingInstructionsRequest {
	r.includeRoomRouting = &includeRoomRouting
	return r
}

// Include the comp routing instructions in the response.
func (r ApiGetRoutingInstructionsRequest) IncludeCompRouting(includeCompRouting bool) ApiGetRoutingInstructionsRequest {
	r.includeCompRouting = &includeCompRouting
	return r
}

// Include the comp routing requests in the response.
func (r ApiGetRoutingInstructionsRequest) IncludeCompRoutingRequests(includeCompRoutingRequests bool) ApiGetRoutingInstructionsRequest {
	r.includeCompRoutingRequests = &includeCompRoutingRequests
	return r
}

// If date is included then the search result should only be valid for dates which includes this date.
func (r ApiGetRoutingInstructionsRequest) EffectiveOn(effectiveOn string) ApiGetRoutingInstructionsRequest {
	r.effectiveOn = &effectiveOn
	return r
}

// External system code.
func (r ApiGetRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiGetRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiGetRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoutingInstructionsRequest) Execute() (*RoutingInstructionsDetails, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsExecute(r)
}

/*
GetRoutingInstructions Get routing instructions

You can use this API to retrieve routing instructions for a specified reservation. <p><strong>OperationId:</strong>getRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetRoutingInstructionsRequest
*/
func (a *CashieringApiService) GetRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiGetRoutingInstructionsRequest {
	return ApiGetRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoutingInstructionsDetails
func (a *CashieringApiService) GetRoutingInstructionsExecute(r ApiGetRoutingInstructionsRequest) (*RoutingInstructionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutingInstructionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.includeWindowRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeWindowRouting", r.includeWindowRouting, "")
	}
	if r.includeRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRoomRouting", r.includeRoomRouting, "")
	}
	if r.includeCompRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompRouting", r.includeCompRouting, "")
	}
	if r.includeCompRoutingRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompRoutingRequests", r.includeCompRoutingRequests, "")
	}
	if r.effectiveOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveOn", r.effectiveOn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStoredFolioDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalBillNo *string
	folioDate *string
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStoredFolioDetailsRequest) Authorization(authorization string) ApiGetStoredFolioDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStoredFolioDetailsRequest) XAppKey(xAppKey string) ApiGetStoredFolioDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStoredFolioDetailsRequest) XHotelid(xHotelid string) ApiGetStoredFolioDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Fiscal Bill number of this posting
func (r ApiGetStoredFolioDetailsRequest) FiscalBillNo(fiscalBillNo string) ApiGetStoredFolioDetailsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiGetStoredFolioDetailsRequest) FolioDate(folioDate string) ApiGetStoredFolioDetailsRequest {
	r.folioDate = &folioDate
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiGetStoredFolioDetailsRequest) FolioStatus(folioStatus string) ApiGetStoredFolioDetailsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiGetStoredFolioDetailsRequest) FolioTypeName(folioTypeName string) ApiGetStoredFolioDetailsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetStoredFolioDetailsRequest) InternalFolioWindowID(internalFolioWindowID string) ApiGetStoredFolioDetailsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetStoredFolioDetailsRequest) InvoiceNo(invoiceNo float32) ApiGetStoredFolioDetailsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiGetStoredFolioDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetStoredFolioDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStoredFolioDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetStoredFolioDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStoredFolioDetailsRequest) Execute() (*StoredFolioDetailsInfo, *http.Response, error) {
	return r.ApiService.GetStoredFolioDetailsExecute(r)
}

/*
GetStoredFolioDetails Get Stored Folio Details

You can use this API to get Stored Folio Details. <p><strong>OperationId:</strong>getStoredFolioDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return ApiGetStoredFolioDetailsRequest
*/
func (a *CashieringApiService) GetStoredFolioDetails(ctx context.Context, folioId string, hotelId string) ApiGetStoredFolioDetailsRequest {
	return ApiGetStoredFolioDetailsRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StoredFolioDetailsInfo
func (a *CashieringApiService) GetStoredFolioDetailsExecute(r ApiGetStoredFolioDetailsRequest) (*StoredFolioDetailsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StoredFolioDetailsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetStoredFolioDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/storedFolios/{folioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
	}
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
	}
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	includeArticles *bool
	userRoleTransactions *bool
	manualPostAllowed *bool
	code *string
	description *string
	wildCard *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	trxServiceType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionCodesRequest) Authorization(authorization string) ApiGetTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionCodesRequest) XAppKey(xAppKey string) ApiGetTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionCodesRequest) XHotelid(xHotelid string) ApiGetTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r ApiGetTransactionCodesRequest) Event(event string) ApiGetTransactionCodesRequest {
	r.event = &event
	return r
}

// Flag to indicate if Article Codes are required, along with the parent Transaction Codes.
func (r ApiGetTransactionCodesRequest) IncludeArticles(includeArticles bool) ApiGetTransactionCodesRequest {
	r.includeArticles = &includeArticles
	return r
}

// Flag to indicate if it is allowed to manually post transaction codes.
func (r ApiGetTransactionCodesRequest) UserRoleTransactions(userRoleTransactions bool) ApiGetTransactionCodesRequest {
	r.userRoleTransactions = &userRoleTransactions
	return r
}

// Flag to include the search for Manual Post Allowed.
func (r ApiGetTransactionCodesRequest) ManualPostAllowed(manualPostAllowed bool) ApiGetTransactionCodesRequest {
	r.manualPostAllowed = &manualPostAllowed
	return r
}

// Lookup string which will try to match an existing Transaction Codes.
func (r ApiGetTransactionCodesRequest) Code(code string) ApiGetTransactionCodesRequest {
	r.code = &code
	return r
}

// Lookup string which will try to match an existing Transaction Code Description.
func (r ApiGetTransactionCodesRequest) Description(description string) ApiGetTransactionCodesRequest {
	r.description = &description
	return r
}

func (r ApiGetTransactionCodesRequest) WildCard(wildCard string) ApiGetTransactionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// The Fiscal Bill number of this posting
func (r ApiGetTransactionCodesRequest) FiscalBillNo(fiscalBillNo string) ApiGetTransactionCodesRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiGetTransactionCodesRequest) FolioDate(folioDate string) ApiGetTransactionCodesRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r ApiGetTransactionCodesRequest) FolioNo(folioNo float32) ApiGetTransactionCodesRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiGetTransactionCodesRequest) FolioStatus(folioStatus string) ApiGetTransactionCodesRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiGetTransactionCodesRequest) FolioTypeName(folioTypeName string) ApiGetTransactionCodesRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetTransactionCodesRequest) InternalFolioWindowID(internalFolioWindowID string) ApiGetTransactionCodesRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetTransactionCodesRequest) InvoiceNo(invoiceNo float32) ApiGetTransactionCodesRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Goods Type Transactions.
func (r ApiGetTransactionCodesRequest) TrxServiceType(trxServiceType string) ApiGetTransactionCodesRequest {
	r.trxServiceType = &trxServiceType
	return r
}

// External system code.
func (r ApiGetTransactionCodesRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionCodesRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionCodesRequest) Execute() (*TransactionCodes, *http.Response, error) {
	return r.ApiService.GetTransactionCodesExecute(r)
}

/*
GetTransactionCodes Get Transaction Codes

You can use this API to retrieve a list of Transaction Codes configured for a property. <p><strong>OperationId:</strong>getTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetTransactionCodesRequest
*/
func (a *CashieringApiService) GetTransactionCodes(ctx context.Context, hotelId string) ApiGetTransactionCodesRequest {
	return ApiGetTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransactionCodes
func (a *CashieringApiService) GetTransactionCodesExecute(r ApiGetTransactionCodesRequest) (*TransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
	}
	if r.includeArticles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArticles", r.includeArticles, "")
	}
	if r.userRoleTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userRoleTransactions", r.userRoleTransactions, "")
	}
	if r.manualPostAllowed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPostAllowed", r.manualPostAllowed, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
	}
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
	}
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
	}
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	if r.trxServiceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxServiceType", r.trxServiceType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetValidateFiscalPrintingDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioView *int32
	folioType *string
	id *string
	code *[]string
	fetchInstruction *[]string
	profileIdId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetValidateFiscalPrintingDetailsRequest) Authorization(authorization string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetValidateFiscalPrintingDetailsRequest) XAppKey(xAppKey string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetValidateFiscalPrintingDetailsRequest) XHotelid(xHotelid string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The folio window where this settlement is applied.
func (r ApiGetValidateFiscalPrintingDetailsRequest) FolioView(folioView int32) ApiGetValidateFiscalPrintingDetailsRequest {
	r.folioView = &folioView
	return r
}

// Folio Type
func (r ApiGetValidateFiscalPrintingDetailsRequest) FolioType(folioType string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.folioType = &folioType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetValidateFiscalPrintingDetailsRequest) Id(id string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.id = &id
	return r
}

func (r ApiGetValidateFiscalPrintingDetailsRequest) Code(code []string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.code = &code
	return r
}

// Reservation Related information.
func (r ApiGetValidateFiscalPrintingDetailsRequest) FetchInstruction(fetchInstruction []string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.fetchInstruction = &fetchInstruction
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetValidateFiscalPrintingDetailsRequest) ProfileIdId(profileIdId string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.profileIdId = &profileIdId
	return r
}

// External system code.
func (r ApiGetValidateFiscalPrintingDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetValidateFiscalPrintingDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetValidateFiscalPrintingDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetValidateFiscalPrintingDetailsRequest) Execute() (*FiscalCallStatus, *http.Response, error) {
	return r.ApiService.GetValidateFiscalPrintingDetailsExecute(r)
}

/*
GetValidateFiscalPrintingDetails Get Fiscal Printing Details

You can use this API to get Fiscal Printing Details. <p><strong>OperationId:</strong>getValidateFiscalPrintingDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetValidateFiscalPrintingDetailsRequest
*/
func (a *CashieringApiService) GetValidateFiscalPrintingDetails(ctx context.Context, hotelId string) ApiGetValidateFiscalPrintingDetailsRequest {
	return ApiGetValidateFiscalPrintingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCallStatus
func (a *CashieringApiService) GetValidateFiscalPrintingDetailsExecute(r ApiGetValidateFiscalPrintingDetailsRequest) (*FiscalCallStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCallStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetValidateFiscalPrintingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalPrinting"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.fetchInstruction != nil {
		t := *r.fetchInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", t, "multi")
		}
	}
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetfetchStagedTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId2 *string
	folioWindowNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetfetchStagedTransactionsRequest) Authorization(authorization string) ApiGetfetchStagedTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetfetchStagedTransactionsRequest) XAppKey(xAppKey string) ApiGetfetchStagedTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetfetchStagedTransactionsRequest) XHotelid(xHotelid string) ApiGetfetchStagedTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiGetfetchStagedTransactionsRequest) HotelId2(hotelId2 string) ApiGetfetchStagedTransactionsRequest {
	r.hotelId2 = &hotelId2
	return r
}

// Folio Window Number of the staged transactions.
func (r ApiGetfetchStagedTransactionsRequest) FolioWindowNo(folioWindowNo int32) ApiGetfetchStagedTransactionsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// External system code.
func (r ApiGetfetchStagedTransactionsRequest) XExternalsystem(xExternalsystem string) ApiGetfetchStagedTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetfetchStagedTransactionsRequest) AcceptLanguage(acceptLanguage string) ApiGetfetchStagedTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetfetchStagedTransactionsRequest) Execute() (*StagedTransactions, *http.Response, error) {
	return r.ApiService.GetfetchStagedTransactionsExecute(r)
}

/*
GetfetchStagedTransactions Get fetchStagedTransactions

This API is used to fetch the staged transactions for a given reservation. <p><strong>OperationId:</strong>getfetchStagedTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiGetfetchStagedTransactionsRequest
*/
func (a *CashieringApiService) GetfetchStagedTransactions(ctx context.Context, reservationId string, hotelId string) ApiGetfetchStagedTransactionsRequest {
	return ApiGetfetchStagedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StagedTransactions
func (a *CashieringApiService) GetfetchStagedTransactionsExecute(r ApiGetfetchStagedTransactionsRequest) (*StagedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StagedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetfetchStagedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fetchStagedTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId2, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIsDepositRefundEligibleRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiIsDepositRefundEligibleRequest) Authorization(authorization string) ApiIsDepositRefundEligibleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiIsDepositRefundEligibleRequest) XAppKey(xAppKey string) ApiIsDepositRefundEligibleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiIsDepositRefundEligibleRequest) XHotelid(xHotelid string) ApiIsDepositRefundEligibleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiIsDepositRefundEligibleRequest) IdContext(idContext string) ApiIsDepositRefundEligibleRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiIsDepositRefundEligibleRequest) Type_(type_ string) ApiIsDepositRefundEligibleRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiIsDepositRefundEligibleRequest) XExternalsystem(xExternalsystem string) ApiIsDepositRefundEligibleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiIsDepositRefundEligibleRequest) AcceptLanguage(acceptLanguage string) ApiIsDepositRefundEligibleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiIsDepositRefundEligibleRequest) Execute() (*DepositRefundEligibleCheck, *http.Response, error) {
	return r.ApiService.IsDepositRefundEligibleExecute(r)
}

/*
IsDepositRefundEligible Get eligibility of Deposit Refund

You can use this API to get eligibility of Deposit Refund. <p><strong>OperationId:</strong>isDepositRefundEligible</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiIsDepositRefundEligibleRequest
*/
func (a *CashieringApiService) IsDepositRefundEligible(ctx context.Context, transactionId string, reservationId string, hotelId string) ApiIsDepositRefundEligibleRequest {
	return ApiIsDepositRefundEligibleRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositRefundEligibleCheck
func (a *CashieringApiService) IsDepositRefundEligibleExecute(r ApiIsDepositRefundEligibleRequest) (*DepositRefundEligibleCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositRefundEligibleCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.IsDepositRefundEligible")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkReservationPackageAllowanceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	destinationReservationId string
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationPackageAllowance *LinkReservationPackageAllowanceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiLinkReservationPackageAllowanceRequest) Authorization(authorization string) ApiLinkReservationPackageAllowanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiLinkReservationPackageAllowanceRequest) XAppKey(xAppKey string) ApiLinkReservationPackageAllowanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiLinkReservationPackageAllowanceRequest) XHotelid(xHotelid string) ApiLinkReservationPackageAllowanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to create package allowance link from a source reservation to the target reservation.
func (r ApiLinkReservationPackageAllowanceRequest) LinkReservationPackageAllowance(linkReservationPackageAllowance LinkReservationPackageAllowanceRequest) ApiLinkReservationPackageAllowanceRequest {
	r.linkReservationPackageAllowance = &linkReservationPackageAllowance
	return r
}

// External system code.
func (r ApiLinkReservationPackageAllowanceRequest) XExternalsystem(xExternalsystem string) ApiLinkReservationPackageAllowanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiLinkReservationPackageAllowanceRequest) AcceptLanguage(acceptLanguage string) ApiLinkReservationPackageAllowanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiLinkReservationPackageAllowanceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.LinkReservationPackageAllowanceExecute(r)
}

/*
LinkReservationPackageAllowance Link Reservation package allowance

You can use this API to link reservation package allowance. <p><strong>OperationId:</strong>linkReservationPackageAllowance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param destinationReservationId Unique ID of the destination reservation.
 @param sourceReservationId Unique ID of the source reservation.
 @param hotelId Unique ID of the hotel
 @return ApiLinkReservationPackageAllowanceRequest
*/
func (a *CashieringApiService) LinkReservationPackageAllowance(ctx context.Context, destinationReservationId string, sourceReservationId string, hotelId string) ApiLinkReservationPackageAllowanceRequest {
	return ApiLinkReservationPackageAllowanceRequest{
		ApiService: a,
		ctx: ctx,
		destinationReservationId: destinationReservationId,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) LinkReservationPackageAllowanceExecute(r ApiLinkReservationPackageAllowanceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.LinkReservationPackageAllowance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/destinationReservations/{destinationReservationId}/packageAllowance/links"
	localVarPath = strings.Replace(localVarPath, "{"+"destinationReservationId"+"}", url.PathEscape(parameterValueToString(r.destinationReservationId, "destinationReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.destinationReservationId) < 1 {
		return localVarReturnValue, nil, reportError("destinationReservationId must have at least 1 elements")
	}
	if strlen(r.destinationReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("destinationReservationId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.linkReservationPackageAllowance == nil {
		return localVarReturnValue, nil, reportError("linkReservationPackageAllowance is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationPackageAllowance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingCashieringServiceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPingCashieringServiceRequest) Authorization(authorization string) ApiPingCashieringServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPingCashieringServiceRequest) XAppKey(xAppKey string) ApiPingCashieringServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPingCashieringServiceRequest) XHotelid(xHotelid string) ApiPingCashieringServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiPingCashieringServiceRequest) XExternalsystem(xExternalsystem string) ApiPingCashieringServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPingCashieringServiceRequest) AcceptLanguage(acceptLanguage string) ApiPingCashieringServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPingCashieringServiceRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingCashieringServiceExecute(r)
}

/*
PingCashieringService Status check of cashiering services

You can use this API to Status check of cashiering services. <p><strong>OperationId:</strong>pingCashieringService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingCashieringServiceRequest
*/
func (a *CashieringApiService) PingCashieringService(ctx context.Context) ApiPingCashieringServiceRequest {
	return ApiPingCashieringServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *CashieringApiService) PingCashieringServiceExecute(r ApiPingCashieringServiceRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PingCashieringService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/cashiering/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAdvanceFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchAdvanceFolio *PostAdvanceFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAdvanceFolioRequest) Authorization(authorization string) ApiPostAdvanceFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAdvanceFolioRequest) XAppKey(xAppKey string) ApiPostAdvanceFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAdvanceFolioRequest) XHotelid(xHotelid string) ApiPostAdvanceFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for submitting batch advance folio.
func (r ApiPostAdvanceFolioRequest) BatchAdvanceFolio(batchAdvanceFolio PostAdvanceFolioRequest) ApiPostAdvanceFolioRequest {
	r.batchAdvanceFolio = &batchAdvanceFolio
	return r
}

// External system code.
func (r ApiPostAdvanceFolioRequest) XExternalsystem(xExternalsystem string) ApiPostAdvanceFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAdvanceFolioRequest) AcceptLanguage(acceptLanguage string) ApiPostAdvanceFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAdvanceFolioRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdvanceFolioExecute(r)
}

/*
PostAdvanceFolio Create Batch Advance Folio

You can use this API to create Batch Advance Folio. <p><strong>OperationId:</strong>postAdvanceFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostAdvanceFolioRequest
*/
func (a *CashieringApiService) PostAdvanceFolio(ctx context.Context, hotelId string) ApiPostAdvanceFolioRequest {
	return ApiPostAdvanceFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostAdvanceFolioExecute(r ApiPostAdvanceFolioRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostAdvanceFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/advanceFolio/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.batchAdvanceFolio == nil {
		return localVarReturnValue, nil, reportError("batchAdvanceFolio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchAdvanceFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAdvanceRoomChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	advanceRoomCharges *PostAdvanceRoomChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAdvanceRoomChargesRequest) Authorization(authorization string) ApiPostAdvanceRoomChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAdvanceRoomChargesRequest) XAppKey(xAppKey string) ApiPostAdvanceRoomChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAdvanceRoomChargesRequest) XHotelid(xHotelid string) ApiPostAdvanceRoomChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post the Room Charges for a reservation in advance. This request posts the Room Charges for a reservation for tonight or for many nights starting from the last posted night. This can also be used to verify if the reservation has already been charged for the full stay. Setting the Verify flag will return details regarding the last Room Charge posted date and if there are any available dates for which the room charges can be posted in advance. Room Charges cannot be posted for dates prior to the business date of the resort. To make the actual posting, the verification flag should be false.
func (r ApiPostAdvanceRoomChargesRequest) AdvanceRoomCharges(advanceRoomCharges PostAdvanceRoomChargesRequest) ApiPostAdvanceRoomChargesRequest {
	r.advanceRoomCharges = &advanceRoomCharges
	return r
}

// External system code.
func (r ApiPostAdvanceRoomChargesRequest) XExternalsystem(xExternalsystem string) ApiPostAdvanceRoomChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAdvanceRoomChargesRequest) AcceptLanguage(acceptLanguage string) ApiPostAdvanceRoomChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAdvanceRoomChargesRequest) Execute() (*AdvanceRoomChargesReservationInfo, *http.Response, error) {
	return r.ApiService.PostAdvanceRoomChargesExecute(r)
}

/*
PostAdvanceRoomCharges Create advance Room Charges

You can use this API to create advance Room Charges. <p><strong>OperationId:</strong>postAdvanceRoomCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostAdvanceRoomChargesRequest
*/
func (a *CashieringApiService) PostAdvanceRoomCharges(ctx context.Context, reservationId string, hotelId string) ApiPostAdvanceRoomChargesRequest {
	return ApiPostAdvanceRoomChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdvanceRoomChargesReservationInfo
func (a *CashieringApiService) PostAdvanceRoomChargesExecute(r ApiPostAdvanceRoomChargesRequest) (*AdvanceRoomChargesReservationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdvanceRoomChargesReservationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostAdvanceRoomCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advanceRoomCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.advanceRoomCharges == nil {
		return localVarReturnValue, nil, reportError("advanceRoomCharges is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.advanceRoomCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostArticlesSaleRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	articlesSaleCriteria *PostArticlesSaleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostArticlesSaleRequest) Authorization(authorization string) ApiPostArticlesSaleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostArticlesSaleRequest) XAppKey(xAppKey string) ApiPostArticlesSaleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostArticlesSaleRequest) XHotelid(xHotelid string) ApiPostArticlesSaleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a set of charges, payments and generate a bill for a PasserBy or for the Post-It functionality . A PasserBy is someone who is not staying at the Property. A PasserBy transaction requires a Profile in Opera for whom the the folio is being created.
func (r ApiPostArticlesSaleRequest) ArticlesSaleCriteria(articlesSaleCriteria PostArticlesSaleRequest) ApiPostArticlesSaleRequest {
	r.articlesSaleCriteria = &articlesSaleCriteria
	return r
}

// External system code.
func (r ApiPostArticlesSaleRequest) XExternalsystem(xExternalsystem string) ApiPostArticlesSaleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostArticlesSaleRequest) AcceptLanguage(acceptLanguage string) ApiPostArticlesSaleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostArticlesSaleRequest) Execute() (*ArticlesSale, *http.Response, error) {
	return r.ApiService.PostArticlesSaleExecute(r)
}

/*
PostArticlesSale Create Articles Sale

You can use this API to create Articles Sale. <p><strong>OperationId:</strong>postArticlesSale</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostArticlesSaleRequest
*/
func (a *CashieringApiService) PostArticlesSale(ctx context.Context, hotelId string) ApiPostArticlesSaleRequest {
	return ApiPostArticlesSaleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArticlesSale
func (a *CashieringApiService) PostArticlesSaleExecute(r ApiPostArticlesSaleRequest) (*ArticlesSale, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArticlesSale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostArticlesSale")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/articlesSale"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.articlesSaleCriteria == nil {
		return localVarReturnValue, nil, reportError("articlesSaleCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articlesSaleCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAutoCheckoutReservationsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchAutoCheckoutReservation *PostAutoCheckoutReservationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAutoCheckoutReservationsRequest) Authorization(authorization string) ApiPostAutoCheckoutReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAutoCheckoutReservationsRequest) XAppKey(xAppKey string) ApiPostAutoCheckoutReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAutoCheckoutReservationsRequest) XHotelid(xHotelid string) ApiPostAutoCheckoutReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for batch auto checkout.
func (r ApiPostAutoCheckoutReservationsRequest) BatchAutoCheckoutReservation(batchAutoCheckoutReservation PostAutoCheckoutReservationsRequest) ApiPostAutoCheckoutReservationsRequest {
	r.batchAutoCheckoutReservation = &batchAutoCheckoutReservation
	return r
}

// External system code.
func (r ApiPostAutoCheckoutReservationsRequest) XExternalsystem(xExternalsystem string) ApiPostAutoCheckoutReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAutoCheckoutReservationsRequest) AcceptLanguage(acceptLanguage string) ApiPostAutoCheckoutReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAutoCheckoutReservationsRequest) Execute() (*BatchAutoCheckoutDetails, *http.Response, error) {
	return r.ApiService.PostAutoCheckoutReservationsExecute(r)
}

/*
PostAutoCheckoutReservations Create Auto Checkout Reservation Batch 

You can use this API to create Auto Checkout Reservation Batch. <p><strong>OperationId:</strong>postAutoCheckoutReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostAutoCheckoutReservationsRequest
*/
func (a *CashieringApiService) PostAutoCheckoutReservations(ctx context.Context, hotelId string) ApiPostAutoCheckoutReservationsRequest {
	return ApiPostAutoCheckoutReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BatchAutoCheckoutDetails
func (a *CashieringApiService) PostAutoCheckoutReservationsExecute(r ApiPostAutoCheckoutReservationsRequest) (*BatchAutoCheckoutDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchAutoCheckoutDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostAutoCheckoutReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoCheckoutReservations/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.batchAutoCheckoutReservation == nil {
		return localVarReturnValue, nil, reportError("batchAutoCheckoutReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchAutoCheckoutReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBatchAutoSettlementRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchAutoSettlementCriteria *PostBatchAutoSettlementRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBatchAutoSettlementRequest) Authorization(authorization string) ApiPostBatchAutoSettlementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBatchAutoSettlementRequest) XAppKey(xAppKey string) ApiPostBatchAutoSettlementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBatchAutoSettlementRequest) XHotelid(xHotelid string) ApiPostBatchAutoSettlementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for batch auto settlement.
func (r ApiPostBatchAutoSettlementRequest) BatchAutoSettlementCriteria(batchAutoSettlementCriteria PostBatchAutoSettlementRequest) ApiPostBatchAutoSettlementRequest {
	r.batchAutoSettlementCriteria = &batchAutoSettlementCriteria
	return r
}

// External system code.
func (r ApiPostBatchAutoSettlementRequest) XExternalsystem(xExternalsystem string) ApiPostBatchAutoSettlementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBatchAutoSettlementRequest) AcceptLanguage(acceptLanguage string) ApiPostBatchAutoSettlementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBatchAutoSettlementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchAutoSettlementExecute(r)
}

/*
PostBatchAutoSettlement Create Batch Auto Settlement

You can use this API to create Batch Auto Settlement. <p><strong>OperationId:</strong>postBatchAutoSettlement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostBatchAutoSettlementRequest
*/
func (a *CashieringApiService) PostBatchAutoSettlement(ctx context.Context, hotelId string) ApiPostBatchAutoSettlementRequest {
	return ApiPostBatchAutoSettlementRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostBatchAutoSettlementExecute(r ApiPostBatchAutoSettlementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBatchAutoSettlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoSettlements/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.batchAutoSettlementCriteria == nil {
		return localVarReturnValue, nil, reportError("batchAutoSettlementCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchAutoSettlementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBatchCCSettlementsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccBatchSettlementsProcessCriteria *PostBatchCCSettlementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBatchCCSettlementsRequest) Authorization(authorization string) ApiPostBatchCCSettlementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBatchCCSettlementsRequest) XAppKey(xAppKey string) ApiPostBatchCCSettlementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBatchCCSettlementsRequest) XHotelid(xHotelid string) ApiPostBatchCCSettlementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to process batch settlements
func (r ApiPostBatchCCSettlementsRequest) CcBatchSettlementsProcessCriteria(ccBatchSettlementsProcessCriteria PostBatchCCSettlementsRequest) ApiPostBatchCCSettlementsRequest {
	r.ccBatchSettlementsProcessCriteria = &ccBatchSettlementsProcessCriteria
	return r
}

// External system code.
func (r ApiPostBatchCCSettlementsRequest) XExternalsystem(xExternalsystem string) ApiPostBatchCCSettlementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBatchCCSettlementsRequest) AcceptLanguage(acceptLanguage string) ApiPostBatchCCSettlementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBatchCCSettlementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchCCSettlementsExecute(r)
}

/*
PostBatchCCSettlements Create Batch CC Settlements

You can use this API to create Batch CC Settlements. <p><strong>OperationId:</strong>postBatchCCSettlements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostBatchCCSettlementsRequest
*/
func (a *CashieringApiService) PostBatchCCSettlements(ctx context.Context, hotelId string) ApiPostBatchCCSettlementsRequest {
	return ApiPostBatchCCSettlementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostBatchCCSettlementsExecute(r ApiPostBatchCCSettlementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBatchCCSettlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ccSettlements/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.ccBatchSettlementsProcessCriteria == nil {
		return localVarReturnValue, nil, reportError("ccBatchSettlementsProcessCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccBatchSettlementsProcessCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBatchDepositRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchDeposit *PostBatchDepositRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBatchDepositRequest) Authorization(authorization string) ApiPostBatchDepositRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBatchDepositRequest) XAppKey(xAppKey string) ApiPostBatchDepositRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBatchDepositRequest) XHotelid(xHotelid string) ApiPostBatchDepositRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for submitting batch deposit for reservations.
func (r ApiPostBatchDepositRequest) BatchDeposit(batchDeposit PostBatchDepositRequest) ApiPostBatchDepositRequest {
	r.batchDeposit = &batchDeposit
	return r
}

// External system code.
func (r ApiPostBatchDepositRequest) XExternalsystem(xExternalsystem string) ApiPostBatchDepositRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBatchDepositRequest) AcceptLanguage(acceptLanguage string) ApiPostBatchDepositRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBatchDepositRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchDepositExecute(r)
}

/*
PostBatchDeposit Create batch deposits

You can use this API to create batch deposits. <p><strong>OperationId:</strong>postBatchDeposit</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostBatchDepositRequest
*/
func (a *CashieringApiService) PostBatchDeposit(ctx context.Context, hotelId string) ApiPostBatchDepositRequest {
	return ApiPostBatchDepositRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostBatchDepositExecute(r ApiPostBatchDepositRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBatchDeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/batchDeposits"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.batchDeposit == nil {
		return localVarReturnValue, nil, reportError("batchDeposit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchDeposit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	bedTaxCriteria *PostBedTaxInfoRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBedTaxInfoRequest) Authorization(authorization string) ApiPostBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBedTaxInfoRequest) XAppKey(xAppKey string) ApiPostBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBedTaxInfoRequest) XHotelid(xHotelid string) ApiPostBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for create bed transaction info
func (r ApiPostBedTaxInfoRequest) BedTaxCriteria(bedTaxCriteria PostBedTaxInfoRequest) ApiPostBedTaxInfoRequest {
	r.bedTaxCriteria = &bedTaxCriteria
	return r
}

// External system code.
func (r ApiPostBedTaxInfoRequest) XExternalsystem(xExternalsystem string) ApiPostBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) ApiPostBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBedTaxInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBedTaxInfoExecute(r)
}

/*
PostBedTaxInfo Create bed tax information

You can use this API to create new bed tax information for a property. <p><strong>OperationId:</strong>postBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostBedTaxInfoRequest
*/
func (a *CashieringApiService) PostBedTaxInfo(ctx context.Context, hotelId string) ApiPostBedTaxInfoRequest {
	return ApiPostBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostBedTaxInfoExecute(r ApiPostBedTaxInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.bedTaxCriteria == nil {
		return localVarReturnValue, nil, reportError("bedTaxCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.bedTaxCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBillingChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingCharges *PostBillingChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBillingChargesRequest) Authorization(authorization string) ApiPostBillingChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBillingChargesRequest) XAppKey(xAppKey string) ApiPostBillingChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBillingChargesRequest) XHotelid(xHotelid string) ApiPostBillingChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a charge on a reservation&#39;s folio.
func (r ApiPostBillingChargesRequest) BillingCharges(billingCharges PostBillingChargesRequest) ApiPostBillingChargesRequest {
	r.billingCharges = &billingCharges
	return r
}

// External system code.
func (r ApiPostBillingChargesRequest) XExternalsystem(xExternalsystem string) ApiPostBillingChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBillingChargesRequest) AcceptLanguage(acceptLanguage string) ApiPostBillingChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBillingChargesRequest) Execute() (*BillingChargesDetails, *http.Response, error) {
	return r.ApiService.PostBillingChargesExecute(r)
}

/*
PostBillingCharges Post Charge to a folio

You can use this API to post a charge to a folio window. <p><strong>OperationId:</strong>postBillingCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostBillingChargesRequest
*/
func (a *CashieringApiService) PostBillingCharges(ctx context.Context, reservationId string, hotelId string) ApiPostBillingChargesRequest {
	return ApiPostBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingChargesDetails
func (a *CashieringApiService) PostBillingChargesExecute(r ApiPostBillingChargesRequest) (*BillingChargesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.billingCharges == nil {
		return localVarReturnValue, nil, reportError("billingCharges is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBillingChargesInBatchRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingChargesInBatchCriteria *PostBillingChargesInBatchRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBillingChargesInBatchRequest) Authorization(authorization string) ApiPostBillingChargesInBatchRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBillingChargesInBatchRequest) XAppKey(xAppKey string) ApiPostBillingChargesInBatchRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBillingChargesInBatchRequest) XHotelid(xHotelid string) ApiPostBillingChargesInBatchRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to post billing charge to list of reservations.
func (r ApiPostBillingChargesInBatchRequest) BillingChargesInBatchCriteria(billingChargesInBatchCriteria PostBillingChargesInBatchRequest) ApiPostBillingChargesInBatchRequest {
	r.billingChargesInBatchCriteria = &billingChargesInBatchCriteria
	return r
}

// External system code.
func (r ApiPostBillingChargesInBatchRequest) XExternalsystem(xExternalsystem string) ApiPostBillingChargesInBatchRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBillingChargesInBatchRequest) AcceptLanguage(acceptLanguage string) ApiPostBillingChargesInBatchRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBillingChargesInBatchRequest) Execute() (*PostedBillingChargesInBatch, *http.Response, error) {
	return r.ApiService.PostBillingChargesInBatchExecute(r)
}

/*
PostBillingChargesInBatch Create Billing Charges in Batch

You can use this API to create Billing Charges in Batch. <p><strong>OperationId:</strong>postBillingChargesInBatch</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostBillingChargesInBatchRequest
*/
func (a *CashieringApiService) PostBillingChargesInBatch(ctx context.Context, hotelId string) ApiPostBillingChargesInBatchRequest {
	return ApiPostBillingChargesInBatchRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedBillingChargesInBatch
func (a *CashieringApiService) PostBillingChargesInBatchExecute(r ApiPostBillingChargesInBatchRequest) (*PostedBillingChargesInBatch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedBillingChargesInBatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBillingChargesInBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/billingCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.billingChargesInBatchCriteria == nil {
		return localVarReturnValue, nil, reportError("billingChargesInBatchCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingChargesInBatchCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBillingCheckChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	checkNumber string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingCheckChargesCriteria *PostBillingCheckChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBillingCheckChargesRequest) Authorization(authorization string) ApiPostBillingCheckChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBillingCheckChargesRequest) XAppKey(xAppKey string) ApiPostBillingCheckChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBillingCheckChargesRequest) XHotelid(xHotelid string) ApiPostBillingCheckChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for PostBillingCheckCharges operation.
func (r ApiPostBillingCheckChargesRequest) BillingCheckChargesCriteria(billingCheckChargesCriteria PostBillingCheckChargesRequest) ApiPostBillingCheckChargesRequest {
	r.billingCheckChargesCriteria = &billingCheckChargesCriteria
	return r
}

// External system code.
func (r ApiPostBillingCheckChargesRequest) XExternalsystem(xExternalsystem string) ApiPostBillingCheckChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBillingCheckChargesRequest) AcceptLanguage(acceptLanguage string) ApiPostBillingCheckChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBillingCheckChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBillingCheckChargesExecute(r)
}

/*
PostBillingCheckCharges Pre-validate the Billing Charge

You can use this API to validate the posting prior to posting the charge to the folio <p><strong>OperationId:</strong>postBillingCheckCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiPostBillingCheckChargesRequest
*/
func (a *CashieringApiService) PostBillingCheckCharges(ctx context.Context, checkNumber string, reservationId string, hotelId string) ApiPostBillingCheckChargesRequest {
	return ApiPostBillingCheckChargesRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostBillingCheckChargesExecute(r ApiPostBillingCheckChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBillingCheckCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/check/{checkNumber}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.billingCheckChargesCriteria == nil {
		return localVarReturnValue, nil, reportError("billingCheckChargesCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingCheckChargesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBillingPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingPayment *PostBillingPaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBillingPaymentRequest) Authorization(authorization string) ApiPostBillingPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBillingPaymentRequest) XAppKey(xAppKey string) ApiPostBillingPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBillingPaymentRequest) XHotelid(xHotelid string) ApiPostBillingPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a payment on a reservation&#39;s folio.
func (r ApiPostBillingPaymentRequest) BillingPayment(billingPayment PostBillingPaymentRequest) ApiPostBillingPaymentRequest {
	r.billingPayment = &billingPayment
	return r
}

// External system code.
func (r ApiPostBillingPaymentRequest) XExternalsystem(xExternalsystem string) ApiPostBillingPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBillingPaymentRequest) AcceptLanguage(acceptLanguage string) ApiPostBillingPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBillingPaymentRequest) Execute() (*PostedBillingPayment, *http.Response, error) {
	return r.ApiService.PostBillingPaymentExecute(r)
}

/*
PostBillingPayment Create Billing Payment

You can use this API to create Billing Payment on the folio of a Reservation. <p><strong>OperationId:</strong>postBillingPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostBillingPaymentRequest
*/
func (a *CashieringApiService) PostBillingPayment(ctx context.Context, reservationId string, hotelId string) ApiPostBillingPaymentRequest {
	return ApiPostBillingPaymentRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedBillingPayment
func (a *CashieringApiService) PostBillingPaymentExecute(r ApiPostBillingPaymentRequest) (*PostedBillingPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedBillingPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostBillingPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.billingPayment == nil {
		return localVarReturnValue, nil, reportError("billingPayment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingPayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCCSettlementRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccSettlementCriteria *PostCCSettlementRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCCSettlementRequest) Authorization(authorization string) ApiPostCCSettlementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCCSettlementRequest) XAppKey(xAppKey string) ApiPostCCSettlementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCCSettlementRequest) XHotelid(xHotelid string) ApiPostCCSettlementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change credit card settlement information.
func (r ApiPostCCSettlementRequest) CcSettlementCriteria(ccSettlementCriteria PostCCSettlementRequest) ApiPostCCSettlementRequest {
	r.ccSettlementCriteria = &ccSettlementCriteria
	return r
}

// External system code.
func (r ApiPostCCSettlementRequest) XExternalsystem(xExternalsystem string) ApiPostCCSettlementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCCSettlementRequest) AcceptLanguage(acceptLanguage string) ApiPostCCSettlementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCCSettlementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCCSettlementExecute(r)
}

/*
PostCCSettlement Create CreditCard Settlement

You can use this API to create cc Settlement. <p><strong>OperationId:</strong>postCCSettlement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostCCSettlementRequest
*/
func (a *CashieringApiService) PostCCSettlement(ctx context.Context, hotelId string) ApiPostCCSettlementRequest {
	return ApiPostCCSettlementRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostCCSettlementExecute(r ApiPostCCSettlementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCCSettlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ccSettlement"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.ccSettlementCriteria == nil {
		return localVarReturnValue, nil, reportError("ccSettlementCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccSettlementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCheckOutRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservation *PostCheckOutRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCheckOutRequest) Authorization(authorization string) ApiPostCheckOutRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCheckOutRequest) XAppKey(xAppKey string) ApiPostCheckOutRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCheckOutRequest) XHotelid(xHotelid string) ApiPostCheckOutRequest {
	r.xHotelid = &xHotelid
	return r
}

// Checkout request can be used to verify a reservation for checkout and do an actual checkout. In case the verificationOnly attribute is sent false, the operation will perform an actual checkout. In case the verificationOnly attribute is sent true, the operation goes through the reservation in question and verifies if it&#39;s Ok to checkout, otherwise the verification status element will provide you the verification code. The verification codes are described in the documentation of verificationOnly attribute.
func (r ApiPostCheckOutRequest) Reservation(reservation PostCheckOutRequest) ApiPostCheckOutRequest {
	r.reservation = &reservation
	return r
}

// External system code.
func (r ApiPostCheckOutRequest) XExternalsystem(xExternalsystem string) ApiPostCheckOutRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCheckOutRequest) AcceptLanguage(acceptLanguage string) ApiPostCheckOutRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCheckOutRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCheckOutExecute(r)
}

/*
PostCheckOut Check out a guest

This API enables you to check out a guest reservation which is in due out status, with options to update the room's housekeeping status and set a flag to email the guests folio. <p><strong>OperationId:</strong>postCheckOut</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostCheckOutRequest
*/
func (a *CashieringApiService) PostCheckOut(ctx context.Context, reservationId string, hotelId string) ApiPostCheckOutRequest {
	return ApiPostCheckOutRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostCheckOutExecute(r ApiPostCheckOutRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCheckOut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkOuts"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reservation == nil {
		return localVarReturnValue, nil, reportError("reservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postCompRedemptions *PostCompRedemptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCompRedemptionsRequest) Authorization(authorization string) ApiPostCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCompRedemptionsRequest) XAppKey(xAppKey string) ApiPostCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCompRedemptionsRequest) XHotelid(xHotelid string) ApiPostCompRedemptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type of Complimentary Bucket Redemptions posting.
func (r ApiPostCompRedemptionsRequest) PostCompRedemptions(postCompRedemptions PostCompRedemptionsRequest) ApiPostCompRedemptionsRequest {
	r.postCompRedemptions = &postCompRedemptions
	return r
}

// External system code.
func (r ApiPostCompRedemptionsRequest) XExternalsystem(xExternalsystem string) ApiPostCompRedemptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) ApiPostCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCompRedemptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompRedemptionsExecute(r)
}

/*
PostCompRedemptions Operation to post complimentary bucket redemptions for a guest having PTS Membership Type

You can use this API to post complimentary bucket redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>postCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostCompRedemptionsRequest
*/
func (a *CashieringApiService) PostCompRedemptions(ctx context.Context, reservationId string, hotelId string) ApiPostCompRedemptionsRequest {
	return ApiPostCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostCompRedemptionsExecute(r ApiPostCompRedemptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/compRedemptionPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.postCompRedemptions == nil {
		return localVarReturnValue, nil, reportError("postCompRedemptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCompTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTransactionCriteria *PostCompTransactionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCompTransactionRequest) Authorization(authorization string) ApiPostCompTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCompTransactionRequest) XAppKey(xAppKey string) ApiPostCompTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCompTransactionRequest) XHotelid(xHotelid string) ApiPostCompTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to submit a comp transaction to gaming system
func (r ApiPostCompTransactionRequest) CompTransactionCriteria(compTransactionCriteria PostCompTransactionRequest) ApiPostCompTransactionRequest {
	r.compTransactionCriteria = &compTransactionCriteria
	return r
}

// External system code.
func (r ApiPostCompTransactionRequest) XExternalsystem(xExternalsystem string) ApiPostCompTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCompTransactionRequest) AcceptLanguage(acceptLanguage string) ApiPostCompTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCompTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompTransactionExecute(r)
}

/*
PostCompTransaction Submit Comp Transaction

You can use this API to submit Comp Transactions. <p><strong>OperationId:</strong>postCompTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction.
 @param hotelId Unique ID of the hotel
 @return ApiPostCompTransactionRequest
*/
func (a *CashieringApiService) PostCompTransaction(ctx context.Context, transactionId string, hotelId string) ApiPostCompTransactionRequest {
	return ApiPostCompTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostCompTransactionExecute(r ApiPostCompTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCompTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.compTransactionCriteria == nil {
		return localVarReturnValue, nil, reportError("compTransactionCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTransactionCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreditBillRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditBillCriteria *PostCreditBillRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCreditBillRequest) Authorization(authorization string) ApiPostCreditBillRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCreditBillRequest) XAppKey(xAppKey string) ApiPostCreditBillRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCreditBillRequest) XHotelid(xHotelid string) ApiPostCreditBillRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a Credit Folio for an existing Folio. Credit Bill Functionality parameter is required.
func (r ApiPostCreditBillRequest) CreditBillCriteria(creditBillCriteria PostCreditBillRequest) ApiPostCreditBillRequest {
	r.creditBillCriteria = &creditBillCriteria
	return r
}

// External system code.
func (r ApiPostCreditBillRequest) XExternalsystem(xExternalsystem string) ApiPostCreditBillRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCreditBillRequest) AcceptLanguage(acceptLanguage string) ApiPostCreditBillRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCreditBillRequest) Execute() (*PostedCreditBill, *http.Response, error) {
	return r.ApiService.PostCreditBillExecute(r)
}

/*
PostCreditBill Create Credit Bill

You can use this API to create Credit Bill. <p><strong>OperationId:</strong>postCreditBill</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostCreditBillRequest
*/
func (a *CashieringApiService) PostCreditBill(ctx context.Context, hotelId string) ApiPostCreditBillRequest {
	return ApiPostCreditBillRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedCreditBill
func (a *CashieringApiService) PostCreditBillExecute(r ApiPostCreditBillRequest) (*PostedCreditBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedCreditBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCreditBill")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditBill"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.creditBillCriteria == nil {
		return localVarReturnValue, nil, reportError("creditBillCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditBillCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreditLimitOveragePaymentsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditLimitOveragePayments *PostCreditLimitOveragePaymentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCreditLimitOveragePaymentsRequest) Authorization(authorization string) ApiPostCreditLimitOveragePaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCreditLimitOveragePaymentsRequest) XAppKey(xAppKey string) ApiPostCreditLimitOveragePaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCreditLimitOveragePaymentsRequest) XHotelid(xHotelid string) ApiPostCreditLimitOveragePaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to start the Credit Limit Overage process for the reservations with a folio window balance equal or higher to the credit limit set for the credit card payment method of that folio window.
func (r ApiPostCreditLimitOveragePaymentsRequest) CreditLimitOveragePayments(creditLimitOveragePayments PostCreditLimitOveragePaymentsRequest) ApiPostCreditLimitOveragePaymentsRequest {
	r.creditLimitOveragePayments = &creditLimitOveragePayments
	return r
}

// External system code.
func (r ApiPostCreditLimitOveragePaymentsRequest) XExternalsystem(xExternalsystem string) ApiPostCreditLimitOveragePaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCreditLimitOveragePaymentsRequest) AcceptLanguage(acceptLanguage string) ApiPostCreditLimitOveragePaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCreditLimitOveragePaymentsRequest) Execute() (*CreditLimitOveragePaymentsDetails, *http.Response, error) {
	return r.ApiService.PostCreditLimitOveragePaymentsExecute(r)
}

/*
PostCreditLimitOveragePayments Create Credit Limit Overage Payments

You can use this API to create Credit Limit Overage Payments. <p><strong>OperationId:</strong>postCreditLimitOveragePayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostCreditLimitOveragePaymentsRequest
*/
func (a *CashieringApiService) PostCreditLimitOveragePayments(ctx context.Context, hotelId string) ApiPostCreditLimitOveragePaymentsRequest {
	return ApiPostCreditLimitOveragePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreditLimitOveragePaymentsDetails
func (a *CashieringApiService) PostCreditLimitOveragePaymentsExecute(r ApiPostCreditLimitOveragePaymentsRequest) (*CreditLimitOveragePaymentsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditLimitOveragePaymentsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCreditLimitOveragePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditLimitsOveragePayments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.creditLimitOveragePayments == nil {
		return localVarReturnValue, nil, reportError("creditLimitOveragePayments is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditLimitOveragePayments
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeferredTaxesProcessRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	deferredTaxesProcess *PostDeferredTaxesProcessRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostDeferredTaxesProcessRequest) Authorization(authorization string) ApiPostDeferredTaxesProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostDeferredTaxesProcessRequest) XAppKey(xAppKey string) ApiPostDeferredTaxesProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostDeferredTaxesProcessRequest) XHotelid(xHotelid string) ApiPostDeferredTaxesProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to submit a job to post the deferred taxes.
func (r ApiPostDeferredTaxesProcessRequest) DeferredTaxesProcess(deferredTaxesProcess PostDeferredTaxesProcessRequest) ApiPostDeferredTaxesProcessRequest {
	r.deferredTaxesProcess = &deferredTaxesProcess
	return r
}

// External system code.
func (r ApiPostDeferredTaxesProcessRequest) XExternalsystem(xExternalsystem string) ApiPostDeferredTaxesProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostDeferredTaxesProcessRequest) AcceptLanguage(acceptLanguage string) ApiPostDeferredTaxesProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostDeferredTaxesProcessRequest) Execute() (*DeferredTaxesProcessDetails, *http.Response, error) {
	return r.ApiService.PostDeferredTaxesProcessExecute(r)
}

/*
PostDeferredTaxesProcess Request to submit a job to post the deferred taxes.

Request to submit a job to post the deferred taxes. <p><strong>OperationId:</strong>postDeferredTaxesProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostDeferredTaxesProcessRequest
*/
func (a *CashieringApiService) PostDeferredTaxesProcess(ctx context.Context, reservationId string, hotelId string) ApiPostDeferredTaxesProcessRequest {
	return ApiPostDeferredTaxesProcessRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DeferredTaxesProcessDetails
func (a *CashieringApiService) PostDeferredTaxesProcessExecute(r ApiPostDeferredTaxesProcessRequest) (*DeferredTaxesProcessDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeferredTaxesProcessDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostDeferredTaxesProcess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/deferredTaxesProcess"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.deferredTaxesProcess == nil {
		return localVarReturnValue, nil, reportError("deferredTaxesProcess is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.deferredTaxesProcess
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDepositFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositFolioCriteria *PostDepositFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostDepositFolioRequest) Authorization(authorization string) ApiPostDepositFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostDepositFolioRequest) XAppKey(xAppKey string) ApiPostDepositFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostDepositFolioRequest) XHotelid(xHotelid string) ApiPostDepositFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Deposit Folio for a reservation.
func (r ApiPostDepositFolioRequest) DepositFolioCriteria(depositFolioCriteria PostDepositFolioRequest) ApiPostDepositFolioRequest {
	r.depositFolioCriteria = &depositFolioCriteria
	return r
}

// External system code.
func (r ApiPostDepositFolioRequest) XExternalsystem(xExternalsystem string) ApiPostDepositFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostDepositFolioRequest) AcceptLanguage(acceptLanguage string) ApiPostDepositFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostDepositFolioRequest) Execute() (*PostedDepositFolio, *http.Response, error) {
	return r.ApiService.PostDepositFolioExecute(r)
}

/*
PostDepositFolio Create Deposit Folio

You can use this API to create Deposit Folio. <p><strong>OperationId:</strong>postDepositFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiPostDepositFolioRequest
*/
func (a *CashieringApiService) PostDepositFolio(ctx context.Context, reservationId string, hotelId string) ApiPostDepositFolioRequest {
	return ApiPostDepositFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedDepositFolio
func (a *CashieringApiService) PostDepositFolioExecute(r ApiPostDepositFolioRequest) (*PostedDepositFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedDepositFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostDepositFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositFolios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.depositFolioCriteria == nil {
		return localVarReturnValue, nil, reportError("depositFolioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDepositPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositPayment *PostDepositPaymentByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostDepositPaymentRequest) Authorization(authorization string) ApiPostDepositPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostDepositPaymentRequest) XAppKey(xAppKey string) ApiPostDepositPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostDepositPaymentRequest) XHotelid(xHotelid string) ApiPostDepositPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a deposit payment to a reservation.
func (r ApiPostDepositPaymentRequest) DepositPayment(depositPayment PostDepositPaymentByExtIdRequest) ApiPostDepositPaymentRequest {
	r.depositPayment = &depositPayment
	return r
}

// External system code.
func (r ApiPostDepositPaymentRequest) XExternalsystem(xExternalsystem string) ApiPostDepositPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostDepositPaymentRequest) AcceptLanguage(acceptLanguage string) ApiPostDepositPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostDepositPaymentRequest) Execute() (*DepositedPayment, *http.Response, error) {
	return r.ApiService.PostDepositPaymentExecute(r)
}

/*
PostDepositPayment Create Deposit Payment

You can use this API to create Deposit Payment. <p><strong>OperationId:</strong>postDepositPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostDepositPaymentRequest
*/
func (a *CashieringApiService) PostDepositPayment(ctx context.Context, reservationId string, hotelId string) ApiPostDepositPaymentRequest {
	return ApiPostDepositPaymentRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositedPayment
func (a *CashieringApiService) PostDepositPaymentExecute(r ApiPostDepositPaymentRequest) (*DepositedPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositedPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostDepositPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.depositPayment == nil {
		return localVarReturnValue, nil, reportError("depositPayment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositPayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDepositPaymentByExtIdRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	externalSysCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositPayment *PostDepositPaymentByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostDepositPaymentByExtIdRequest) Authorization(authorization string) ApiPostDepositPaymentByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostDepositPaymentByExtIdRequest) XAppKey(xAppKey string) ApiPostDepositPaymentByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostDepositPaymentByExtIdRequest) XHotelid(xHotelid string) ApiPostDepositPaymentByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a deposit payment to a reservation.
func (r ApiPostDepositPaymentByExtIdRequest) DepositPayment(depositPayment PostDepositPaymentByExtIdRequest) ApiPostDepositPaymentByExtIdRequest {
	r.depositPayment = &depositPayment
	return r
}

// External system code.
func (r ApiPostDepositPaymentByExtIdRequest) XExternalsystem(xExternalsystem string) ApiPostDepositPaymentByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostDepositPaymentByExtIdRequest) AcceptLanguage(acceptLanguage string) ApiPostDepositPaymentByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostDepositPaymentByExtIdRequest) Execute() (*DepositedPayment, *http.Response, error) {
	return r.ApiService.PostDepositPaymentByExtIdExecute(r)
}

/*
PostDepositPaymentByExtId Create Deposit Payment using external reference.

You can use this API to create Deposit Payment with external reference. <p><strong>OperationId:</strong>postDepositPaymentByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId External System's reservation ID.
 @param externalSysCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel
 @return ApiPostDepositPaymentByExtIdRequest
*/
func (a *CashieringApiService) PostDepositPaymentByExtId(ctx context.Context, reservationId string, externalSysCode string, hotelId string) ApiPostDepositPaymentByExtIdRequest {
	return ApiPostDepositPaymentByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		externalSysCode: externalSysCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositedPayment
func (a *CashieringApiService) PostDepositPaymentByExtIdExecute(r ApiPostDepositPaymentByExtIdRequest) (*DepositedPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositedPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostDepositPaymentByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSysCode}/reservations/{reservationId}/depositPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSysCode"+"}", url.PathEscape(parameterValueToString(r.externalSysCode, "externalSysCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.externalSysCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSysCode must have at least 1 elements")
	}
	if strlen(r.externalSysCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSysCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.depositPayment == nil {
		return localVarReturnValue, nil, reportError("depositPayment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositPayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFBAReimbursementRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fbaReimbursementCriteria *PostFBAReimbursementRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostFBAReimbursementRequest) Authorization(authorization string) ApiPostFBAReimbursementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostFBAReimbursementRequest) XAppKey(xAppKey string) ApiPostFBAReimbursementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostFBAReimbursementRequest) XHotelid(xHotelid string) ApiPostFBAReimbursementRequest {
	r.xHotelid = &xHotelid
	return r
}

// PostFBAReimbursement operation posts reimbursement against the selected certificate records.
func (r ApiPostFBAReimbursementRequest) FbaReimbursementCriteria(fbaReimbursementCriteria PostFBAReimbursementRequest) ApiPostFBAReimbursementRequest {
	r.fbaReimbursementCriteria = &fbaReimbursementCriteria
	return r
}

// External system code.
func (r ApiPostFBAReimbursementRequest) XExternalsystem(xExternalsystem string) ApiPostFBAReimbursementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostFBAReimbursementRequest) AcceptLanguage(acceptLanguage string) ApiPostFBAReimbursementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostFBAReimbursementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFBAReimbursementExecute(r)
}

/*
PostFBAReimbursement Create FBA Reimbursement

You can use this API to create FBA Reimbursement. <p><strong>OperationId:</strong>postFBAReimbursement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFBAReimbursementRequest
*/
func (a *CashieringApiService) PostFBAReimbursement(ctx context.Context) ApiPostFBAReimbursementRequest {
	return ApiPostFBAReimbursementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostFBAReimbursementExecute(r ApiPostFBAReimbursementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostFBAReimbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fbaReimbursements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fbaReimbursementCriteria == nil {
		return localVarReturnValue, nil, reportError("fbaReimbursementCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fbaReimbursementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFBASettlementRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fbaReimbursementCriteria *PostFBAReimbursementRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostFBASettlementRequest) Authorization(authorization string) ApiPostFBASettlementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostFBASettlementRequest) XAppKey(xAppKey string) ApiPostFBASettlementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostFBASettlementRequest) XHotelid(xHotelid string) ApiPostFBASettlementRequest {
	r.xHotelid = &xHotelid
	return r
}

// PostFBASettlement operation posts settlement against the selected certificate records.
func (r ApiPostFBASettlementRequest) FbaReimbursementCriteria(fbaReimbursementCriteria PostFBAReimbursementRequest) ApiPostFBASettlementRequest {
	r.fbaReimbursementCriteria = &fbaReimbursementCriteria
	return r
}

// External system code.
func (r ApiPostFBASettlementRequest) XExternalsystem(xExternalsystem string) ApiPostFBASettlementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostFBASettlementRequest) AcceptLanguage(acceptLanguage string) ApiPostFBASettlementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostFBASettlementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFBASettlementExecute(r)
}

/*
PostFBASettlement Create FBA Settlement

You can use this API to create FBA Settlement. <p><strong>OperationId:</strong>postFBASettlement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFBASettlementRequest
*/
func (a *CashieringApiService) PostFBASettlement(ctx context.Context) ApiPostFBASettlementRequest {
	return ApiPostFBASettlementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostFBASettlementExecute(r ApiPostFBASettlementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostFBASettlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fbaSettlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fbaReimbursementCriteria == nil {
		return localVarReturnValue, nil, reportError("fbaReimbursementCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fbaReimbursementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFiscalCommandInvoiceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioCriteria *PostFiscalCommandInvoiceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostFiscalCommandInvoiceRequest) Authorization(authorization string) ApiPostFiscalCommandInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostFiscalCommandInvoiceRequest) XAppKey(xAppKey string) ApiPostFiscalCommandInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostFiscalCommandInvoiceRequest) XHotelid(xHotelid string) ApiPostFiscalCommandInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate commands and communicate with fiscal service from fiscal terminals screen..
func (r ApiPostFiscalCommandInvoiceRequest) FiscalFolioCriteria(fiscalFolioCriteria PostFiscalCommandInvoiceRequest) ApiPostFiscalCommandInvoiceRequest {
	r.fiscalFolioCriteria = &fiscalFolioCriteria
	return r
}

// External system code.
func (r ApiPostFiscalCommandInvoiceRequest) XExternalsystem(xExternalsystem string) ApiPostFiscalCommandInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostFiscalCommandInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiPostFiscalCommandInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostFiscalCommandInvoiceRequest) Execute() (*FiscalCommandsResponseInfo, *http.Response, error) {
	return r.ApiService.PostFiscalCommandInvoiceExecute(r)
}

/*
PostFiscalCommandInvoice Create Fiscal Invoice

You can use this API to create Fiscal Invoice. <p><strong>OperationId:</strong>postFiscalCommandInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostFiscalCommandInvoiceRequest
*/
func (a *CashieringApiService) PostFiscalCommandInvoice(ctx context.Context, hotelId string) ApiPostFiscalCommandInvoiceRequest {
	return ApiPostFiscalCommandInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCommandsResponseInfo
func (a *CashieringApiService) PostFiscalCommandInvoiceExecute(r ApiPostFiscalCommandInvoiceRequest) (*FiscalCommandsResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCommandsResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostFiscalCommandInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalCommands"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fiscalFolioCriteria == nil {
		return localVarReturnValue, nil, reportError("fiscalFolioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFiscalInvoiceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioCriteria *PostFiscalCommandInvoiceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostFiscalInvoiceRequest) Authorization(authorization string) ApiPostFiscalInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostFiscalInvoiceRequest) XAppKey(xAppKey string) ApiPostFiscalInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostFiscalInvoiceRequest) XHotelid(xHotelid string) ApiPostFiscalInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate commands and communicate with fiscal service from fiscal terminals screen..
func (r ApiPostFiscalInvoiceRequest) FiscalFolioCriteria(fiscalFolioCriteria PostFiscalCommandInvoiceRequest) ApiPostFiscalInvoiceRequest {
	r.fiscalFolioCriteria = &fiscalFolioCriteria
	return r
}

// External system code.
func (r ApiPostFiscalInvoiceRequest) XExternalsystem(xExternalsystem string) ApiPostFiscalInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostFiscalInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiPostFiscalInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostFiscalInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalInvoiceExecute(r)
}

/*
PostFiscalInvoice Create Fiscal Invoice

You can use this API to create Fiscal Invoice.<br><p><strong><mark>This API is deprecated. Please use postFiscalCommandInvoice instead</mark></strong></p> <p><strong>OperationId:</strong>postFiscalInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return ApiPostFiscalInvoiceRequest

Deprecated
*/
func (a *CashieringApiService) PostFiscalInvoice(ctx context.Context, folioId string, hotelId string) ApiPostFiscalInvoiceRequest {
	return ApiPostFiscalInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringApiService) PostFiscalInvoiceExecute(r ApiPostFiscalInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostFiscalInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folio/{folioId}/fiscalCommands"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fiscalFolioCriteria == nil {
		return localVarReturnValue, nil, reportError("fiscalFolioCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fixedCharges *UpdateFixedChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostFixedChargesRequest) Authorization(authorization string) ApiPostFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostFixedChargesRequest) XAppKey(xAppKey string) ApiPostFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostFixedChargesRequest) XHotelid(xHotelid string) ApiPostFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to create fixed charges of a reservation.
func (r ApiPostFixedChargesRequest) FixedCharges(fixedCharges UpdateFixedChargesRequest) ApiPostFixedChargesRequest {
	r.fixedCharges = &fixedCharges
	return r
}

// External system code.
func (r ApiPostFixedChargesRequest) XExternalsystem(xExternalsystem string) ApiPostFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostFixedChargesRequest) AcceptLanguage(acceptLanguage string) ApiPostFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostFixedChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFixedChargesExecute(r)
}

/*
PostFixedCharges Create Fixed Charges

You can use this API to create a fixed Charge for a reservation. <p><strong>OperationId:</strong>postFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostFixedChargesRequest
*/
func (a *CashieringApiService) PostFixedCharges(ctx context.Context, reservationId string, hotelId string) ApiPostFixedChargesRequest {
	return ApiPostFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostFixedChargesExecute(r ApiPostFixedChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fixedCharges == nil {
		return localVarReturnValue, nil, reportError("fixedCharges is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fixedCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostForeignCurrencyExchangeRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	foreignCurrencyExchange *PostForeignCurrencyExchangeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostForeignCurrencyExchangeRequest) Authorization(authorization string) ApiPostForeignCurrencyExchangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostForeignCurrencyExchangeRequest) XAppKey(xAppKey string) ApiPostForeignCurrencyExchangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostForeignCurrencyExchangeRequest) XHotelid(xHotelid string) ApiPostForeignCurrencyExchangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// A set of posting transactions that need to be posted with regards to exchange.
func (r ApiPostForeignCurrencyExchangeRequest) ForeignCurrencyExchange(foreignCurrencyExchange PostForeignCurrencyExchangeRequest) ApiPostForeignCurrencyExchangeRequest {
	r.foreignCurrencyExchange = &foreignCurrencyExchange
	return r
}

// External system code.
func (r ApiPostForeignCurrencyExchangeRequest) XExternalsystem(xExternalsystem string) ApiPostForeignCurrencyExchangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostForeignCurrencyExchangeRequest) AcceptLanguage(acceptLanguage string) ApiPostForeignCurrencyExchangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostForeignCurrencyExchangeRequest) Execute() (*ForeignCurrencyExchangeTransaction, *http.Response, error) {
	return r.ApiService.PostForeignCurrencyExchangeExecute(r)
}

/*
PostForeignCurrencyExchange Create Foreign Currency Exchange

You can use this API to Create Foreign Currency Exchange. <p><strong>OperationId:</strong>postForeignCurrencyExchange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostForeignCurrencyExchangeRequest
*/
func (a *CashieringApiService) PostForeignCurrencyExchange(ctx context.Context) ApiPostForeignCurrencyExchangeRequest {
	return ApiPostForeignCurrencyExchangeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForeignCurrencyExchangeTransaction
func (a *CashieringApiService) PostForeignCurrencyExchangeExecute(r ApiPostForeignCurrencyExchangeRequest) (*ForeignCurrencyExchangeTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForeignCurrencyExchangeTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostForeignCurrencyExchange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrencyExchange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.foreignCurrencyExchange == nil {
		return localVarReturnValue, nil, reportError("foreignCurrencyExchange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.foreignCurrencyExchange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGuestCheckDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	checkNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestCheckDetails *PostGuestCheckDetailsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostGuestCheckDetailsRequest) Authorization(authorization string) ApiPostGuestCheckDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostGuestCheckDetailsRequest) XAppKey(xAppKey string) ApiPostGuestCheckDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostGuestCheckDetailsRequest) XHotelid(xHotelid string) ApiPostGuestCheckDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to process a guest check detail.
func (r ApiPostGuestCheckDetailsRequest) GuestCheckDetails(guestCheckDetails PostGuestCheckDetailsRequest) ApiPostGuestCheckDetailsRequest {
	r.guestCheckDetails = &guestCheckDetails
	return r
}

// External system code.
func (r ApiPostGuestCheckDetailsRequest) XExternalsystem(xExternalsystem string) ApiPostGuestCheckDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostGuestCheckDetailsRequest) AcceptLanguage(acceptLanguage string) ApiPostGuestCheckDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostGuestCheckDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuestCheckDetailsExecute(r)
}

/*
PostGuestCheckDetails Post Guest Check Details

This operation is to add guest check details for posted check transactions. <p><strong>OperationId:</strong>postGuestCheckDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check
 @param hotelId Unique ID of the hotel
 @return ApiPostGuestCheckDetailsRequest
*/
func (a *CashieringApiService) PostGuestCheckDetails(ctx context.Context, checkNumber string, hotelId string) ApiPostGuestCheckDetailsRequest {
	return ApiPostGuestCheckDetailsRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostGuestCheckDetailsExecute(r ApiPostGuestCheckDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostGuestCheckDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/check/{checkNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.guestCheckDetails == nil {
		return localVarReturnValue, nil, reportError("guestCheckDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestCheckDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPasserBySaleRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	passerBySalesCriteria *PostPasserBySaleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostPasserBySaleRequest) Authorization(authorization string) ApiPostPasserBySaleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostPasserBySaleRequest) XAppKey(xAppKey string) ApiPostPasserBySaleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostPasserBySaleRequest) XHotelid(xHotelid string) ApiPostPasserBySaleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a set of charges, payments and generate a bill for a PasserBy or for the Post-It functionality . A PasserBy is someone who is not staying at the Property. A PasserBy transaction requires a Profile in Opera for whom the the folio is being created.
func (r ApiPostPasserBySaleRequest) PasserBySalesCriteria(passerBySalesCriteria PostPasserBySaleRequest) ApiPostPasserBySaleRequest {
	r.passerBySalesCriteria = &passerBySalesCriteria
	return r
}

// External system code.
func (r ApiPostPasserBySaleRequest) XExternalsystem(xExternalsystem string) ApiPostPasserBySaleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostPasserBySaleRequest) AcceptLanguage(acceptLanguage string) ApiPostPasserBySaleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostPasserBySaleRequest) Execute() (*PasserBySale, *http.Response, error) {
	return r.ApiService.PostPasserBySaleExecute(r)
}

/*
PostPasserBySale Create passer by sale

You can use this API to create passer by sale. <p><strong>OperationId:</strong>postPasserBySale</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostPasserBySaleRequest
*/
func (a *CashieringApiService) PostPasserBySale(ctx context.Context, hotelId string) ApiPostPasserBySaleRequest {
	return ApiPostPasserBySaleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PasserBySale
func (a *CashieringApiService) PostPasserBySaleExecute(r ApiPostPasserBySaleRequest) (*PasserBySale, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PasserBySale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostPasserBySale")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/passerBySale"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.passerBySalesCriteria == nil {
		return localVarReturnValue, nil, reportError("passerBySalesCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.passerBySalesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPrepaidCardsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	prepaidCardCriteria *PostPrepaidCardsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostPrepaidCardsRequest) Authorization(authorization string) ApiPostPrepaidCardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostPrepaidCardsRequest) XAppKey(xAppKey string) ApiPostPrepaidCardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostPrepaidCardsRequest) XHotelid(xHotelid string) ApiPostPrepaidCardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for Prepaid card creation process
func (r ApiPostPrepaidCardsRequest) PrepaidCardCriteria(prepaidCardCriteria PostPrepaidCardsRequest) ApiPostPrepaidCardsRequest {
	r.prepaidCardCriteria = &prepaidCardCriteria
	return r
}

// External system code.
func (r ApiPostPrepaidCardsRequest) XExternalsystem(xExternalsystem string) ApiPostPrepaidCardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostPrepaidCardsRequest) AcceptLanguage(acceptLanguage string) ApiPostPrepaidCardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostPrepaidCardsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPrepaidCardsExecute(r)
}

/*
PostPrepaidCards Create Prepaid Cards

You can use this API to create Prepaid Cards. <p><strong>OperationId:</strong>postPrepaidCards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostPrepaidCardsRequest
*/
func (a *CashieringApiService) PostPrepaidCards(ctx context.Context, hotelId string) ApiPostPrepaidCardsRequest {
	return ApiPostPrepaidCardsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostPrepaidCardsExecute(r ApiPostPrepaidCardsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostPrepaidCards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.prepaidCardCriteria == nil {
		return localVarReturnValue, nil, reportError("prepaidCardCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.prepaidCardCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProformaRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationFolio *PostProformaRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostProformaRequest) Authorization(authorization string) ApiPostProformaRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostProformaRequest) XAppKey(xAppKey string) ApiPostProformaRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostProformaRequest) XHotelid(xHotelid string) ApiPostProformaRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Proforma(folio) transactions for a reservation. The request generates the internal transactions required to create a Proforma report. After this request is called , the Opera Proforma report should be called so that these transactions can be used in the report. If the report is called without this request, the report will be incorrect and will not have the complete information. If the report is not used after this request, the internal transactions will be removed either by night audit or by the next request.
func (r ApiPostProformaRequest) ReservationFolio(reservationFolio PostProformaRequest) ApiPostProformaRequest {
	r.reservationFolio = &reservationFolio
	return r
}

// External system code.
func (r ApiPostProformaRequest) XExternalsystem(xExternalsystem string) ApiPostProformaRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostProformaRequest) AcceptLanguage(acceptLanguage string) ApiPostProformaRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostProformaRequest) Execute() (*ReservationFolioInformation, *http.Response, error) {
	return r.ApiService.PostProformaExecute(r)
}

/*
PostProforma Create proforma

You can use this API to create proforma for a specific reservation. <p><strong>OperationId:</strong>postProforma</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPostProformaRequest
*/
func (a *CashieringApiService) PostProforma(ctx context.Context, reservationId string, hotelId string) ApiPostProformaRequest {
	return ApiPostProformaRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationFolioInformation
func (a *CashieringApiService) PostProformaExecute(r ApiPostProformaRequest) (*ReservationFolioInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationFolioInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostProforma")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/proforma"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reservationFolio == nil {
		return localVarReturnValue, nil, reportError("reservationFolio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRateCodeRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	rateCode string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postRateCodeCriteria *PostRateCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostRateCodeRequest) Authorization(authorization string) ApiPostRateCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostRateCodeRequest) XAppKey(xAppKey string) ApiPostRateCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostRateCodeRequest) XHotelid(xHotelid string) ApiPostRateCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to post a Rate Code amount to the Reservation. Based on the criteria, Products(Packages) which are included as part of the Rate Code may be posted along with the room rate amount.
func (r ApiPostRateCodeRequest) PostRateCodeCriteria(postRateCodeCriteria PostRateCodeRequest) ApiPostRateCodeRequest {
	r.postRateCodeCriteria = &postRateCodeCriteria
	return r
}

// External system code.
func (r ApiPostRateCodeRequest) XExternalsystem(xExternalsystem string) ApiPostRateCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostRateCodeRequest) AcceptLanguage(acceptLanguage string) ApiPostRateCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostRateCodeRequest) Execute() (*PostedRateCode, *http.Response, error) {
	return r.ApiService.PostRateCodeExecute(r)
}

/*
PostRateCode Create rate codes

You can use this API to create rate codes. <p><strong>OperationId:</strong>postRateCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode The Rate Code which is to be posted on the Guest Folio.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiPostRateCodeRequest
*/
func (a *CashieringApiService) PostRateCode(ctx context.Context, rateCode string, reservationId string, hotelId string) ApiPostRateCodeRequest {
	return ApiPostRateCodeRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedRateCode
func (a *CashieringApiService) PostRateCodeExecute(r ApiPostRateCodeRequest) (*PostedRateCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedRateCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostRateCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservation/{reservationId}/rateCode/{rateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.postRateCodeCriteria == nil {
		return localVarReturnValue, nil, reportError("postRateCodeCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postRateCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReversePaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	paymentReversalCriteria *PostReversePaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostReversePaymentRequest) Authorization(authorization string) ApiPostReversePaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostReversePaymentRequest) XAppKey(xAppKey string) ApiPostReversePaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostReversePaymentRequest) XHotelid(xHotelid string) ApiPostReversePaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for posting payment reversal.
func (r ApiPostReversePaymentRequest) PaymentReversalCriteria(paymentReversalCriteria PostReversePaymentRequest) ApiPostReversePaymentRequest {
	r.paymentReversalCriteria = &paymentReversalCriteria
	return r
}

// External system code.
func (r ApiPostReversePaymentRequest) XExternalsystem(xExternalsystem string) ApiPostReversePaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostReversePaymentRequest) AcceptLanguage(acceptLanguage string) ApiPostReversePaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostReversePaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReversePaymentExecute(r)
}

/*
PostReversePayment Create reverse payments

You can use this API to create reverse payments. <p><strong>OperationId:</strong>postReversePayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the Transaction
 @param hotelId Unique ID of the hotel
 @return ApiPostReversePaymentRequest
*/
func (a *CashieringApiService) PostReversePayment(ctx context.Context, transactionId string, hotelId string) ApiPostReversePaymentRequest {
	return ApiPostReversePaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostReversePaymentExecute(r ApiPostReversePaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostReversePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/reversePayments"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.paymentReversalCriteria == nil {
		return localVarReturnValue, nil, reportError("paymentReversalCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.paymentReversalCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRoomAndTaxForDayUseRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postRoomAndTaxForDayUse *PostRoomAndTaxForDayUseRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostRoomAndTaxForDayUseRequest) Authorization(authorization string) ApiPostRoomAndTaxForDayUseRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostRoomAndTaxForDayUseRequest) XAppKey(xAppKey string) ApiPostRoomAndTaxForDayUseRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostRoomAndTaxForDayUseRequest) XHotelid(xHotelid string) ApiPostRoomAndTaxForDayUseRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to calculate room and tax.
func (r ApiPostRoomAndTaxForDayUseRequest) PostRoomAndTaxForDayUse(postRoomAndTaxForDayUse PostRoomAndTaxForDayUseRequest) ApiPostRoomAndTaxForDayUseRequest {
	r.postRoomAndTaxForDayUse = &postRoomAndTaxForDayUse
	return r
}

// External system code.
func (r ApiPostRoomAndTaxForDayUseRequest) XExternalsystem(xExternalsystem string) ApiPostRoomAndTaxForDayUseRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostRoomAndTaxForDayUseRequest) AcceptLanguage(acceptLanguage string) ApiPostRoomAndTaxForDayUseRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostRoomAndTaxForDayUseRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomAndTaxForDayUseExecute(r)
}

/*
PostRoomAndTaxForDayUse Operation to post room and tax for day use.

You can use this API to post post Room And Tax For DayUse <p><strong>OperationId:</strong>postRoomAndTaxForDayUse</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @return ApiPostRoomAndTaxForDayUseRequest
*/
func (a *CashieringApiService) PostRoomAndTaxForDayUse(ctx context.Context, reservationId string) ApiPostRoomAndTaxForDayUseRequest {
	return ApiPostRoomAndTaxForDayUseRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostRoomAndTaxForDayUseExecute(r ApiPostRoomAndTaxForDayUseRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostRoomAndTaxForDayUse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/{reservationId}/postRoomAndTaxForDayUse"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.postRoomAndTaxForDayUse == nil {
		return localVarReturnValue, nil, reportError("postRoomAndTaxForDayUse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postRoomAndTaxForDayUse
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostStoredFolioDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	storedFolioDetails *PostStoredFolioDetailsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostStoredFolioDetailsRequest) Authorization(authorization string) ApiPostStoredFolioDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostStoredFolioDetailsRequest) XAppKey(xAppKey string) ApiPostStoredFolioDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostStoredFolioDetailsRequest) XHotelid(xHotelid string) ApiPostStoredFolioDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update stored folio details.
func (r ApiPostStoredFolioDetailsRequest) StoredFolioDetails(storedFolioDetails PostStoredFolioDetailsRequest) ApiPostStoredFolioDetailsRequest {
	r.storedFolioDetails = &storedFolioDetails
	return r
}

// External system code.
func (r ApiPostStoredFolioDetailsRequest) XExternalsystem(xExternalsystem string) ApiPostStoredFolioDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostStoredFolioDetailsRequest) AcceptLanguage(acceptLanguage string) ApiPostStoredFolioDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostStoredFolioDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostStoredFolioDetailsExecute(r)
}

/*
PostStoredFolioDetails Create Stored Folio Details

You can use this API to create Stored Folio Details. <p><strong>OperationId:</strong>postStoredFolioDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return ApiPostStoredFolioDetailsRequest
*/
func (a *CashieringApiService) PostStoredFolioDetails(ctx context.Context, folioId string, hotelId string) ApiPostStoredFolioDetailsRequest {
	return ApiPostStoredFolioDetailsRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PostStoredFolioDetailsExecute(r ApiPostStoredFolioDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostStoredFolioDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/storedFolios/{folioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.storedFolioDetails == nil {
		return localVarReturnValue, nil, reportError("storedFolioDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.storedFolioDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSupplementalFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postSupplementalFolio *PostSupplementalFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostSupplementalFolioRequest) Authorization(authorization string) ApiPostSupplementalFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostSupplementalFolioRequest) XAppKey(xAppKey string) ApiPostSupplementalFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostSupplementalFolioRequest) XHotelid(xHotelid string) ApiPostSupplementalFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a Supplemental Folio for an existing Folio. Debit Bill ( Supplemental Folio ) Functionality parameter is required
func (r ApiPostSupplementalFolioRequest) PostSupplementalFolio(postSupplementalFolio PostSupplementalFolioRequest) ApiPostSupplementalFolioRequest {
	r.postSupplementalFolio = &postSupplementalFolio
	return r
}

// External system code.
func (r ApiPostSupplementalFolioRequest) XExternalsystem(xExternalsystem string) ApiPostSupplementalFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostSupplementalFolioRequest) AcceptLanguage(acceptLanguage string) ApiPostSupplementalFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostSupplementalFolioRequest) Execute() (*PostSupplementalFolioStatus, *http.Response, error) {
	return r.ApiService.PostSupplementalFolioExecute(r)
}

/*
PostSupplementalFolio Post supplemental folio

You can use this API to post supplemental folio. <p><strong>OperationId:</strong>postSupplementalFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostSupplementalFolioRequest
*/
func (a *CashieringApiService) PostSupplementalFolio(ctx context.Context, hotelId string) ApiPostSupplementalFolioRequest {
	return ApiPostSupplementalFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostSupplementalFolioStatus
func (a *CashieringApiService) PostSupplementalFolioExecute(r ApiPostSupplementalFolioRequest) (*PostSupplementalFolioStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostSupplementalFolioStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostSupplementalFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/supplementFolios"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.postSupplementalFolio == nil {
		return localVarReturnValue, nil, reportError("postSupplementalFolio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postSupplementalFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostZeroBalanceCheckoutReservationsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchZeroBalanceCheckoutReservation *PostZeroBalanceCheckoutReservationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostZeroBalanceCheckoutReservationsRequest) Authorization(authorization string) ApiPostZeroBalanceCheckoutReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostZeroBalanceCheckoutReservationsRequest) XAppKey(xAppKey string) ApiPostZeroBalanceCheckoutReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostZeroBalanceCheckoutReservationsRequest) XHotelid(xHotelid string) ApiPostZeroBalanceCheckoutReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for batch zero balance checkout
func (r ApiPostZeroBalanceCheckoutReservationsRequest) BatchZeroBalanceCheckoutReservation(batchZeroBalanceCheckoutReservation PostZeroBalanceCheckoutReservationsRequest) ApiPostZeroBalanceCheckoutReservationsRequest {
	r.batchZeroBalanceCheckoutReservation = &batchZeroBalanceCheckoutReservation
	return r
}

// External system code.
func (r ApiPostZeroBalanceCheckoutReservationsRequest) XExternalsystem(xExternalsystem string) ApiPostZeroBalanceCheckoutReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostZeroBalanceCheckoutReservationsRequest) AcceptLanguage(acceptLanguage string) ApiPostZeroBalanceCheckoutReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostZeroBalanceCheckoutReservationsRequest) Execute() (*BatchZeroBalanceCheckoutDetails, *http.Response, error) {
	return r.ApiService.PostZeroBalanceCheckoutReservationsExecute(r)
}

/*
PostZeroBalanceCheckoutReservations Create Zero Balance Checkout Reservation Batch 

You can use this API to create Zero Balance Checkout Reservation Batch. <p><strong>OperationId:</strong>postZeroBalanceCheckoutReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostZeroBalanceCheckoutReservationsRequest
*/
func (a *CashieringApiService) PostZeroBalanceCheckoutReservations(ctx context.Context, hotelId string) ApiPostZeroBalanceCheckoutReservationsRequest {
	return ApiPostZeroBalanceCheckoutReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BatchZeroBalanceCheckoutDetails
func (a *CashieringApiService) PostZeroBalanceCheckoutReservationsExecute(r ApiPostZeroBalanceCheckoutReservationsRequest) (*BatchZeroBalanceCheckoutDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchZeroBalanceCheckoutDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostZeroBalanceCheckoutReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/zeroBalanceCheckoutReservations/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.batchZeroBalanceCheckoutReservation == nil {
		return localVarReturnValue, nil, reportError("batchZeroBalanceCheckoutReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchZeroBalanceCheckoutReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessFiscalRetryRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	processFiscalRetry *ProcessFiscalRetryRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiProcessFiscalRetryRequest) Authorization(authorization string) ApiProcessFiscalRetryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiProcessFiscalRetryRequest) XAppKey(xAppKey string) ApiProcessFiscalRetryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiProcessFiscalRetryRequest) XHotelid(xHotelid string) ApiProcessFiscalRetryRequest {
	r.xHotelid = &xHotelid
	return r
}

// The request object to process fiscal retry functionality.
func (r ApiProcessFiscalRetryRequest) ProcessFiscalRetry(processFiscalRetry ProcessFiscalRetryRequest) ApiProcessFiscalRetryRequest {
	r.processFiscalRetry = &processFiscalRetry
	return r
}

// External system code.
func (r ApiProcessFiscalRetryRequest) XExternalsystem(xExternalsystem string) ApiProcessFiscalRetryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiProcessFiscalRetryRequest) AcceptLanguage(acceptLanguage string) ApiProcessFiscalRetryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiProcessFiscalRetryRequest) Execute() (*ProcessFiscalRetryStatus, *http.Response, error) {
	return r.ApiService.ProcessFiscalRetryExecute(r)
}

/*
ProcessFiscalRetry Process Fiscal retry

You can use this API to process fiscal retry status. <p><strong>OperationId:</strong>processFiscalRetry</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return ApiProcessFiscalRetryRequest
*/
func (a *CashieringApiService) ProcessFiscalRetry(ctx context.Context, folioId string, hotelId string) ApiProcessFiscalRetryRequest {
	return ApiProcessFiscalRetryRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ProcessFiscalRetryStatus
func (a *CashieringApiService) ProcessFiscalRetryExecute(r ApiProcessFiscalRetryRequest) (*ProcessFiscalRetryStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessFiscalRetryStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ProcessFiscalRetry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folios/{folioId}/fiscal"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.processFiscalRetry == nil {
		return localVarReturnValue, nil, reportError("processFiscalRetry is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.processFiscalRetry
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessReservationDepositRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationDepositCriteria *ProcessReservationDepositRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiProcessReservationDepositRequest) Authorization(authorization string) ApiProcessReservationDepositRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiProcessReservationDepositRequest) XAppKey(xAppKey string) ApiProcessReservationDepositRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiProcessReservationDepositRequest) XHotelid(xHotelid string) ApiProcessReservationDepositRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to process reservation deposit.
func (r ApiProcessReservationDepositRequest) ReservationDepositCriteria(reservationDepositCriteria ProcessReservationDepositRequest) ApiProcessReservationDepositRequest {
	r.reservationDepositCriteria = &reservationDepositCriteria
	return r
}

// External system code.
func (r ApiProcessReservationDepositRequest) XExternalsystem(xExternalsystem string) ApiProcessReservationDepositRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiProcessReservationDepositRequest) AcceptLanguage(acceptLanguage string) ApiProcessReservationDepositRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiProcessReservationDepositRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ProcessReservationDepositExecute(r)
}

/*
ProcessReservationDeposit Process Reservations deposit

You can use this API to Process reservations deposit. <p><strong>OperationId:</strong>processReservationDeposit</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiProcessReservationDepositRequest
*/
func (a *CashieringApiService) ProcessReservationDeposit(ctx context.Context, reservationId string, hotelId string) ApiProcessReservationDepositRequest {
	return ApiProcessReservationDepositRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ProcessReservationDepositExecute(r ApiProcessReservationDepositRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ProcessReservationDeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reservationDepositCriteria == nil {
		return localVarReturnValue, nil, reportError("reservationDepositCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationDepositCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessRoomRoutingRefreshRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	targetReservationId string
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRoutingRefresh *ProcessRoomRoutingRefreshRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiProcessRoomRoutingRefreshRequest) Authorization(authorization string) ApiProcessRoomRoutingRefreshRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiProcessRoomRoutingRefreshRequest) XAppKey(xAppKey string) ApiProcessRoomRoutingRefreshRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiProcessRoomRoutingRefreshRequest) XHotelid(xHotelid string) ApiProcessRoomRoutingRefreshRequest {
	r.xHotelid = &xHotelid
	return r
}

// The request object for processing refreshing of a routing instruction set. This operation transfers the postings to the respective reservation as per the routing instruction set which is created, edited, deleted or refreshed.
func (r ApiProcessRoomRoutingRefreshRequest) RoomRoutingRefresh(roomRoutingRefresh ProcessRoomRoutingRefreshRequest) ApiProcessRoomRoutingRefreshRequest {
	r.roomRoutingRefresh = &roomRoutingRefresh
	return r
}

// External system code.
func (r ApiProcessRoomRoutingRefreshRequest) XExternalsystem(xExternalsystem string) ApiProcessRoomRoutingRefreshRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiProcessRoomRoutingRefreshRequest) AcceptLanguage(acceptLanguage string) ApiProcessRoomRoutingRefreshRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiProcessRoomRoutingRefreshRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ProcessRoomRoutingRefreshExecute(r)
}

/*
ProcessRoomRoutingRefresh Process Room Routing Refresh

You can use this API to change Room Routing Refresh. <p><strong>OperationId:</strong>processRoomRoutingRefresh</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetReservationId Unique ID of the target reservation
 @param sourceReservationId Unique ID of the source reservation
 @param hotelId Unique ID of the hotel
 @return ApiProcessRoomRoutingRefreshRequest
*/
func (a *CashieringApiService) ProcessRoomRoutingRefresh(ctx context.Context, targetReservationId string, sourceReservationId string, hotelId string) ApiProcessRoomRoutingRefreshRequest {
	return ApiProcessRoomRoutingRefreshRequest{
		ApiService: a,
		ctx: ctx,
		targetReservationId: targetReservationId,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ProcessRoomRoutingRefreshExecute(r ApiProcessRoomRoutingRefreshRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ProcessRoomRoutingRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/targetReservations/{targetReservationId}/roomRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"targetReservationId"+"}", url.PathEscape(parameterValueToString(r.targetReservationId, "targetReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetReservationId) < 1 {
		return localVarReturnValue, nil, reportError("targetReservationId must have at least 1 elements")
	}
	if strlen(r.targetReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("targetReservationId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.roomRoutingRefresh == nil {
		return localVarReturnValue, nil, reportError("roomRoutingRefresh is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRoutingRefresh
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	taxRegistraitionNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	bedTaxCriteria *PostBedTaxInfoRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutBedTaxInfoRequest) Authorization(authorization string) ApiPutBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutBedTaxInfoRequest) XAppKey(xAppKey string) ApiPutBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutBedTaxInfoRequest) XHotelid(xHotelid string) ApiPutBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for change bed transaction info
func (r ApiPutBedTaxInfoRequest) BedTaxCriteria(bedTaxCriteria PostBedTaxInfoRequest) ApiPutBedTaxInfoRequest {
	r.bedTaxCriteria = &bedTaxCriteria
	return r
}

// External system code.
func (r ApiPutBedTaxInfoRequest) XExternalsystem(xExternalsystem string) ApiPutBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) ApiPutBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutBedTaxInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBedTaxInfoExecute(r)
}

/*
PutBedTaxInfo Change bed tax information

You can use this API to Update bed tax information for a property. <p><strong>OperationId:</strong>putBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxRegistraitionNo Unique number of the tax registration.
 @param hotelId Unique ID of the hotel
 @return ApiPutBedTaxInfoRequest
*/
func (a *CashieringApiService) PutBedTaxInfo(ctx context.Context, taxRegistraitionNo string, hotelId string) ApiPutBedTaxInfoRequest {
	return ApiPutBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		taxRegistraitionNo: taxRegistraitionNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PutBedTaxInfoExecute(r ApiPutBedTaxInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax/{taxRegistraitionNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxRegistraitionNo"+"}", url.PathEscape(parameterValueToString(r.taxRegistraitionNo, "taxRegistraitionNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxRegistraitionNo) < 1 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have at least 1 elements")
	}
	if strlen(r.taxRegistraitionNo) > 2000 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.bedTaxCriteria == nil {
		return localVarReturnValue, nil, reportError("bedTaxCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.bedTaxCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBillingChargeRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingCharge *PutBillingChargeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutBillingChargeRequest) Authorization(authorization string) ApiPutBillingChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutBillingChargeRequest) XAppKey(xAppKey string) ApiPutBillingChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutBillingChargeRequest) XHotelid(xHotelid string) ApiPutBillingChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to edit a billing charge information.
func (r ApiPutBillingChargeRequest) BillingCharge(billingCharge PutBillingChargeRequest) ApiPutBillingChargeRequest {
	r.billingCharge = &billingCharge
	return r
}

// External system code.
func (r ApiPutBillingChargeRequest) XExternalsystem(xExternalsystem string) ApiPutBillingChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutBillingChargeRequest) AcceptLanguage(acceptLanguage string) ApiPutBillingChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutBillingChargeRequest) Execute() (*BillingChargeStatus, *http.Response, error) {
	return r.ApiService.PutBillingChargeExecute(r)
}

/*
PutBillingCharge Change Billing Charge

You can use this API to change Billing Charges. <p><strong>OperationId:</strong>putBillingCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiPutBillingChargeRequest
*/
func (a *CashieringApiService) PutBillingCharge(ctx context.Context, transactionId string, hotelId string) ApiPutBillingChargeRequest {
	return ApiPutBillingChargeRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingChargeStatus
func (a *CashieringApiService) PutBillingChargeExecute(r ApiPutBillingChargeRequest) (*BillingChargeStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargeStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutBillingCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.billingCharge == nil {
		return localVarReturnValue, nil, reportError("billingCharge is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingCharge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBillingChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	putBillingCharges *PutBillingChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutBillingChargesRequest) Authorization(authorization string) ApiPutBillingChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutBillingChargesRequest) XAppKey(xAppKey string) ApiPutBillingChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutBillingChargesRequest) XHotelid(xHotelid string) ApiPutBillingChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to edit multiple billing charge information.
func (r ApiPutBillingChargesRequest) PutBillingCharges(putBillingCharges PutBillingChargesRequest) ApiPutBillingChargesRequest {
	r.putBillingCharges = &putBillingCharges
	return r
}

// External system code.
func (r ApiPutBillingChargesRequest) XExternalsystem(xExternalsystem string) ApiPutBillingChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutBillingChargesRequest) AcceptLanguage(acceptLanguage string) ApiPutBillingChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutBillingChargesRequest) Execute() (*PutBillingChargesStatus, *http.Response, error) {
	return r.ApiService.PutBillingChargesExecute(r)
}

/*
PutBillingCharges Change Billing Charges

You can use this API to change Billing Charges. <p><strong>OperationId:</strong>putBillingCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPutBillingChargesRequest
*/
func (a *CashieringApiService) PutBillingCharges(ctx context.Context, hotelId string) ApiPutBillingChargesRequest {
	return ApiPutBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PutBillingChargesStatus
func (a *CashieringApiService) PutBillingChargesExecute(r ApiPutBillingChargesRequest) (*PutBillingChargesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PutBillingChargesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/billingCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.putBillingCharges == nil {
		return localVarReturnValue, nil, reportError("putBillingCharges is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.putBillingCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCashierRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierClosure *PutCashierRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCashierRequest) Authorization(authorization string) ApiPutCashierRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCashierRequest) XAppKey(xAppKey string) ApiPutCashierRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCashierRequest) XHotelid(xHotelid string) ApiPutCashierRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to close cashier&#39;s shift.
func (r ApiPutCashierRequest) CashierClosure(cashierClosure PutCashierRequest) ApiPutCashierRequest {
	r.cashierClosure = &cashierClosure
	return r
}

// External system code.
func (r ApiPutCashierRequest) XExternalsystem(xExternalsystem string) ApiPutCashierRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCashierRequest) AcceptLanguage(acceptLanguage string) ApiPutCashierRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCashierRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCashierExecute(r)
}

/*
PutCashier Close Cashier

You can use this API to change Cashier Closure. <p><strong>OperationId:</strong>putCashier</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return ApiPutCashierRequest
*/
func (a *CashieringApiService) PutCashier(ctx context.Context, cashierId string) ApiPutCashierRequest {
	return ApiPutCashierRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PutCashierExecute(r ApiPutCashierRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutCashier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/closure"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cashierClosure == nil {
		return localVarReturnValue, nil, reportError("cashierClosure is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashierClosure
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	lockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierLockCriteriaToExtend *PutCashierLockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCashierLockRequest) Authorization(authorization string) ApiPutCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCashierLockRequest) XAppKey(xAppKey string) ApiPutCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCashierLockRequest) XHotelid(xHotelid string) ApiPutCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation for extending the lifetime of a lock on a cashier.
func (r ApiPutCashierLockRequest) CashierLockCriteriaToExtend(cashierLockCriteriaToExtend PutCashierLockRequest) ApiPutCashierLockRequest {
	r.cashierLockCriteriaToExtend = &cashierLockCriteriaToExtend
	return r
}

// External system code.
func (r ApiPutCashierLockRequest) XExternalsystem(xExternalsystem string) ApiPutCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCashierLockRequest) AcceptLanguage(acceptLanguage string) ApiPutCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCashierLockRequest) Execute() (*ExtendedCashierLock, *http.Response, error) {
	return r.ApiService.PutCashierLockExecute(r)
}

/*
PutCashierLock Extend Cashier Lock

You can use this API to Extend cashiers lock. <p><strong>OperationId:</strong>putCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lockId Unique ID of the lock.
 @param hotelId Unique ID of the hotel
 @return ApiPutCashierLockRequest
*/
func (a *CashieringApiService) PutCashierLock(ctx context.Context, lockId string, hotelId string) ApiPutCashierLockRequest {
	return ApiPutCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		lockId: lockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExtendedCashierLock
func (a *CashieringApiService) PutCashierLockExecute(r ApiPutCashierLockRequest) (*ExtendedCashierLock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedCashierLock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashierslock/{lockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockId"+"}", url.PathEscape(parameterValueToString(r.lockId, "lockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lockId) < 1 {
		return localVarReturnValue, nil, reportError("lockId must have at least 1 elements")
	}
	if strlen(r.lockId) > 2000 {
		return localVarReturnValue, nil, reportError("lockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cashierLockCriteriaToExtend == nil {
		return localVarReturnValue, nil, reportError("cashierLockCriteriaToExtend is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashierLockCriteriaToExtend
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutForEarlyDepartureRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	earlyDeparture *PutForEarlyDepartureRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutForEarlyDepartureRequest) Authorization(authorization string) ApiPutForEarlyDepartureRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutForEarlyDepartureRequest) XAppKey(xAppKey string) ApiPutForEarlyDepartureRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutForEarlyDepartureRequest) XHotelid(xHotelid string) ApiPutForEarlyDepartureRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change a reservation to an Early Departure. As part of this process the reservation will be changed to a Due Out status with the departure date being the current business date. Only Inhouse reservations can be changed to Early Departure. Before changing the reservation to early departure, rate restrictions on the rate code used and any allowances consumed by the guest for today will be checked. If there is a penalty applicable this can be posted to the reservation.
func (r ApiPutForEarlyDepartureRequest) EarlyDeparture(earlyDeparture PutForEarlyDepartureRequest) ApiPutForEarlyDepartureRequest {
	r.earlyDeparture = &earlyDeparture
	return r
}

// External system code.
func (r ApiPutForEarlyDepartureRequest) XExternalsystem(xExternalsystem string) ApiPutForEarlyDepartureRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutForEarlyDepartureRequest) AcceptLanguage(acceptLanguage string) ApiPutForEarlyDepartureRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutForEarlyDepartureRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutForEarlyDepartureExecute(r)
}

/*
PutForEarlyDeparture Change early Departure

You can use this API to change early Departure. <p><strong>OperationId:</strong>putForEarlyDeparture</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPutForEarlyDepartureRequest
*/
func (a *CashieringApiService) PutForEarlyDeparture(ctx context.Context, reservationId string, hotelId string) ApiPutForEarlyDepartureRequest {
	return ApiPutForEarlyDepartureRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PutForEarlyDepartureExecute(r ApiPutForEarlyDepartureRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutForEarlyDeparture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/earlyDeparture"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.earlyDeparture == nil {
		return localVarReturnValue, nil, reportError("earlyDeparture is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.earlyDeparture
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutPayeeTaxNumberRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	payeeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	payeeTaxNumber *PutPayeeTaxNumberRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutPayeeTaxNumberRequest) Authorization(authorization string) ApiPutPayeeTaxNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutPayeeTaxNumberRequest) XAppKey(xAppKey string) ApiPutPayeeTaxNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutPayeeTaxNumberRequest) XHotelid(xHotelid string) ApiPutPayeeTaxNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate and change Payee Tax Number.
func (r ApiPutPayeeTaxNumberRequest) PayeeTaxNumber(payeeTaxNumber PutPayeeTaxNumberRequest) ApiPutPayeeTaxNumberRequest {
	r.payeeTaxNumber = &payeeTaxNumber
	return r
}

// External system code.
func (r ApiPutPayeeTaxNumberRequest) XExternalsystem(xExternalsystem string) ApiPutPayeeTaxNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutPayeeTaxNumberRequest) AcceptLanguage(acceptLanguage string) ApiPutPayeeTaxNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutPayeeTaxNumberRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPayeeTaxNumberExecute(r)
}

/*
PutPayeeTaxNumber Change Payee Tax Number

You can use this API to change Payee Tax Number. <p><strong>OperationId:</strong>putPayeeTaxNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payeeId Unique ID of the payee
 @param hotelId Unique ID of the hotel
 @return ApiPutPayeeTaxNumberRequest
*/
func (a *CashieringApiService) PutPayeeTaxNumber(ctx context.Context, payeeId string, hotelId string) ApiPutPayeeTaxNumberRequest {
	return ApiPutPayeeTaxNumberRequest{
		ApiService: a,
		ctx: ctx,
		payeeId: payeeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PutPayeeTaxNumberExecute(r ApiPutPayeeTaxNumberRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutPayeeTaxNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/payees/{payeeId}/taxNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"payeeId"+"}", url.PathEscape(parameterValueToString(r.payeeId, "payeeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.payeeId) < 1 {
		return localVarReturnValue, nil, reportError("payeeId must have at least 1 elements")
	}
	if strlen(r.payeeId) > 2000 {
		return localVarReturnValue, nil, reportError("payeeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.payeeTaxNumber == nil {
		return localVarReturnValue, nil, reportError("payeeTaxNumber is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.payeeTaxNumber
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutReservationDepositTransferRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositTransferCriteria *PutReservationDepositTransferRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutReservationDepositTransferRequest) Authorization(authorization string) ApiPutReservationDepositTransferRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutReservationDepositTransferRequest) XAppKey(xAppKey string) ApiPutReservationDepositTransferRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutReservationDepositTransferRequest) XHotelid(xHotelid string) ApiPutReservationDepositTransferRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to transfer a deposit amount from one reservation to one or more reservations.
func (r ApiPutReservationDepositTransferRequest) DepositTransferCriteria(depositTransferCriteria PutReservationDepositTransferRequest) ApiPutReservationDepositTransferRequest {
	r.depositTransferCriteria = &depositTransferCriteria
	return r
}

// External system code.
func (r ApiPutReservationDepositTransferRequest) XExternalsystem(xExternalsystem string) ApiPutReservationDepositTransferRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutReservationDepositTransferRequest) AcceptLanguage(acceptLanguage string) ApiPutReservationDepositTransferRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutReservationDepositTransferRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutReservationDepositTransferExecute(r)
}

/*
PutReservationDepositTransfer Change Reservation Deposit Transfer.

You can use this API to change Reservation Deposit Transfer. <p><strong>OperationId:</strong>putReservationDepositTransfer</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceReservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPutReservationDepositTransferRequest
*/
func (a *CashieringApiService) PutReservationDepositTransfer(ctx context.Context, sourceReservationId string, hotelId string) ApiPutReservationDepositTransferRequest {
	return ApiPutReservationDepositTransferRequest{
		ApiService: a,
		ctx: ctx,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) PutReservationDepositTransferExecute(r ApiPutReservationDepositTransferRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutReservationDepositTransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{sourceReservationId}/deposit/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.depositTransferCriteria == nil {
		return localVarReturnValue, nil, reportError("depositTransferCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositTransferCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructions *PutRoutingInstructionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutRoutingInstructionsRequest) Authorization(authorization string) ApiPutRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutRoutingInstructionsRequest) XAppKey(xAppKey string) ApiPutRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutRoutingInstructionsRequest) XHotelid(xHotelid string) ApiPutRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a routing instruction.
func (r ApiPutRoutingInstructionsRequest) RoutingInstructions(routingInstructions PutRoutingInstructionsRequest) ApiPutRoutingInstructionsRequest {
	r.routingInstructions = &routingInstructions
	return r
}

// External system code.
func (r ApiPutRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ApiPutRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ApiPutRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutRoutingInstructionsRequest) Execute() (*CreatedRoutingInstructions, *http.Response, error) {
	return r.ApiService.PutRoutingInstructionsExecute(r)
}

/*
PutRoutingInstructions Create routing instructions

You can use this API to add routing instructions to a reservation. <p><strong>OperationId:</strong>putRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiPutRoutingInstructionsRequest
*/
func (a *CashieringApiService) PutRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ApiPutRoutingInstructionsRequest {
	return ApiPutRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreatedRoutingInstructions
func (a *CashieringApiService) PutRoutingInstructionsExecute(r ApiPutRoutingInstructionsRequest) (*CreatedRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatedRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PutRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/create"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.routingInstructions == nil {
		return localVarReturnValue, nil, reportError("routingInstructions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRedeemPrepaidCardsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	redeemPrepaidCards *RedeemPrepaidCardsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRedeemPrepaidCardsRequest) Authorization(authorization string) ApiRedeemPrepaidCardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRedeemPrepaidCardsRequest) XAppKey(xAppKey string) ApiRedeemPrepaidCardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRedeemPrepaidCardsRequest) XHotelid(xHotelid string) ApiRedeemPrepaidCardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for Prepaid card redeem amount request.
func (r ApiRedeemPrepaidCardsRequest) RedeemPrepaidCards(redeemPrepaidCards RedeemPrepaidCardsRequest) ApiRedeemPrepaidCardsRequest {
	r.redeemPrepaidCards = &redeemPrepaidCards
	return r
}

// External system code.
func (r ApiRedeemPrepaidCardsRequest) XExternalsystem(xExternalsystem string) ApiRedeemPrepaidCardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRedeemPrepaidCardsRequest) AcceptLanguage(acceptLanguage string) ApiRedeemPrepaidCardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRedeemPrepaidCardsRequest) Execute() (*RedeemPrepaidCardsStatus, *http.Response, error) {
	return r.ApiService.RedeemPrepaidCardsExecute(r)
}

/*
RedeemPrepaidCards Operation to redeem prepaid cards.

You can use this API to redeem Prepaid Cards <p><strong>OperationId:</strong>redeemPrepaidCards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiRedeemPrepaidCardsRequest
*/
func (a *CashieringApiService) RedeemPrepaidCards(ctx context.Context, reservationId string, hotelId string) ApiRedeemPrepaidCardsRequest {
	return ApiRedeemPrepaidCardsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RedeemPrepaidCardsStatus
func (a *CashieringApiService) RedeemPrepaidCardsExecute(r ApiRedeemPrepaidCardsRequest) (*RedeemPrepaidCardsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RedeemPrepaidCardsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.RedeemPrepaidCards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/prepaidCards/redemptions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.redeemPrepaidCards == nil {
		return localVarReturnValue, nil, reportError("redeemPrepaidCards is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.redeemPrepaidCards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterManualAuthorizationRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccManualAuthorizationCriteria *RegisterManualAuthorizationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRegisterManualAuthorizationRequest) Authorization(authorization string) ApiRegisterManualAuthorizationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRegisterManualAuthorizationRequest) XAppKey(xAppKey string) ApiRegisterManualAuthorizationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRegisterManualAuthorizationRequest) XHotelid(xHotelid string) ApiRegisterManualAuthorizationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for registering a Manual Authorization.
func (r ApiRegisterManualAuthorizationRequest) CcManualAuthorizationCriteria(ccManualAuthorizationCriteria RegisterManualAuthorizationRequest) ApiRegisterManualAuthorizationRequest {
	r.ccManualAuthorizationCriteria = &ccManualAuthorizationCriteria
	return r
}

// External system code.
func (r ApiRegisterManualAuthorizationRequest) XExternalsystem(xExternalsystem string) ApiRegisterManualAuthorizationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRegisterManualAuthorizationRequest) AcceptLanguage(acceptLanguage string) ApiRegisterManualAuthorizationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRegisterManualAuthorizationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RegisterManualAuthorizationExecute(r)
}

/*
RegisterManualAuthorization Register Manual Authorization

You can use this API to register Manual Authorization. <p><strong>OperationId:</strong>registerManualAuthorization</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiRegisterManualAuthorizationRequest
*/
func (a *CashieringApiService) RegisterManualAuthorization(ctx context.Context, reservationId string, hotelId string) ApiRegisterManualAuthorizationRequest {
	return ApiRegisterManualAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) RegisterManualAuthorizationExecute(r ApiRegisterManualAuthorizationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.RegisterManualAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods/creditCard/authorize/manual"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.ccManualAuthorizationCriteria == nil {
		return localVarReturnValue, nil, reportError("ccManualAuthorizationCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccManualAuthorizationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterVaultTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	vaultTransaction *RegisterVaultTransactionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRegisterVaultTransactionRequest) Authorization(authorization string) ApiRegisterVaultTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRegisterVaultTransactionRequest) XAppKey(xAppKey string) ApiRegisterVaultTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRegisterVaultTransactionRequest) XHotelid(xHotelid string) ApiRegisterVaultTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to register the vault HTTP transaction.
func (r ApiRegisterVaultTransactionRequest) VaultTransaction(vaultTransaction RegisterVaultTransactionRequest) ApiRegisterVaultTransactionRequest {
	r.vaultTransaction = &vaultTransaction
	return r
}

// External system code.
func (r ApiRegisterVaultTransactionRequest) XExternalsystem(xExternalsystem string) ApiRegisterVaultTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRegisterVaultTransactionRequest) AcceptLanguage(acceptLanguage string) ApiRegisterVaultTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRegisterVaultTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RegisterVaultTransactionExecute(r)
}

/*
RegisterVaultTransaction Register Vault Transaction

You can use this API to create vault transaction. <p><strong>OperationId:</strong>registerVaultTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiRegisterVaultTransactionRequest
*/
func (a *CashieringApiService) RegisterVaultTransaction(ctx context.Context, hotelId string) ApiRegisterVaultTransactionRequest {
	return ApiRegisterVaultTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) RegisterVaultTransactionExecute(r ApiRegisterVaultTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.RegisterVaultTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardTransaction/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.vaultTransaction == nil {
		return localVarReturnValue, nil, reportError("vaultTransaction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.vaultTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReinstateCheckOutRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reinstateCheckedOutReservation *ReinstateCheckOutRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReinstateCheckOutRequest) Authorization(authorization string) ApiReinstateCheckOutRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReinstateCheckOutRequest) XAppKey(xAppKey string) ApiReinstateCheckOutRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReinstateCheckOutRequest) XHotelid(xHotelid string) ApiReinstateCheckOutRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to reinstate checkout reservation in order to post additional transactions, etc.
func (r ApiReinstateCheckOutRequest) ReinstateCheckedOutReservation(reinstateCheckedOutReservation ReinstateCheckOutRequest) ApiReinstateCheckOutRequest {
	r.reinstateCheckedOutReservation = &reinstateCheckedOutReservation
	return r
}

// External system code.
func (r ApiReinstateCheckOutRequest) XExternalsystem(xExternalsystem string) ApiReinstateCheckOutRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReinstateCheckOutRequest) AcceptLanguage(acceptLanguage string) ApiReinstateCheckOutRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReinstateCheckOutRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReinstateCheckOutExecute(r)
}

/*
ReinstateCheckOut Reinstate Checked Out Reservation

You can use this API to reinstate Checked Out Reservation. <p><strong>OperationId:</strong>reinstateCheckOut</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiReinstateCheckOutRequest
*/
func (a *CashieringApiService) ReinstateCheckOut(ctx context.Context, reservationId string, hotelId string) ApiReinstateCheckOutRequest {
	return ApiReinstateCheckOutRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReinstateCheckOutExecute(r ApiReinstateCheckOutRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReinstateCheckOut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkOuts/reinstate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reinstateCheckedOutReservation == nil {
		return localVarReturnValue, nil, reportError("reinstateCheckedOutReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reinstateCheckedOutReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReleaseCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	lockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReleaseCashierLockRequest) Authorization(authorization string) ApiReleaseCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReleaseCashierLockRequest) XAppKey(xAppKey string) ApiReleaseCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReleaseCashierLockRequest) XHotelid(xHotelid string) ApiReleaseCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiReleaseCashierLockRequest) XExternalsystem(xExternalsystem string) ApiReleaseCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReleaseCashierLockRequest) AcceptLanguage(acceptLanguage string) ApiReleaseCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReleaseCashierLockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReleaseCashierLockExecute(r)
}

/*
ReleaseCashierLock Release Cashier Lock

You can use this API to Release Cashier Lock. <p><strong>OperationId:</strong>releaseCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lockId Unique ID of the lock.
 @return ApiReleaseCashierLockRequest
*/
func (a *CashieringApiService) ReleaseCashierLock(ctx context.Context, lockId string) ApiReleaseCashierLockRequest {
	return ApiReleaseCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		lockId: lockId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReleaseCashierLockExecute(r ApiReleaseCashierLockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReleaseCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiersLock/{lockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockId"+"}", url.PathEscape(parameterValueToString(r.lockId, "lockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lockId) < 1 {
		return localVarReturnValue, nil, reportError("lockId must have at least 1 elements")
	}
	if strlen(r.lockId) > 2000 {
		return localVarReturnValue, nil, reportError("lockId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadPrepaidCardRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reloadPrepaidCard *ReloadPrepaidCardRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReloadPrepaidCardRequest) Authorization(authorization string) ApiReloadPrepaidCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReloadPrepaidCardRequest) XAppKey(xAppKey string) ApiReloadPrepaidCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReloadPrepaidCardRequest) XHotelid(xHotelid string) ApiReloadPrepaidCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for reload prepaid card.
func (r ApiReloadPrepaidCardRequest) ReloadPrepaidCard(reloadPrepaidCard ReloadPrepaidCardRequest) ApiReloadPrepaidCardRequest {
	r.reloadPrepaidCard = &reloadPrepaidCard
	return r
}

// External system code.
func (r ApiReloadPrepaidCardRequest) XExternalsystem(xExternalsystem string) ApiReloadPrepaidCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReloadPrepaidCardRequest) AcceptLanguage(acceptLanguage string) ApiReloadPrepaidCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReloadPrepaidCardRequest) Execute() (*ReloadPrepaidCardStatus, *http.Response, error) {
	return r.ApiService.ReloadPrepaidCardExecute(r)
}

/*
ReloadPrepaidCard Operation to reload prepaid card.

You can use this API to reload Prepaid Card. <p><strong>OperationId:</strong>reloadPrepaidCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiReloadPrepaidCardRequest
*/
func (a *CashieringApiService) ReloadPrepaidCard(ctx context.Context, hotelId string) ApiReloadPrepaidCardRequest {
	return ApiReloadPrepaidCardRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReloadPrepaidCardStatus
func (a *CashieringApiService) ReloadPrepaidCardExecute(r ApiReloadPrepaidCardRequest) (*ReloadPrepaidCardStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReloadPrepaidCardStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReloadPrepaidCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reloadPrepaidCard == nil {
		return localVarReturnValue, nil, reportError("reloadPrepaidCard is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reloadPrepaidCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	taxRegistraitionNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveBedTaxInfoRequest) Authorization(authorization string) ApiRemoveBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveBedTaxInfoRequest) XAppKey(xAppKey string) ApiRemoveBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveBedTaxInfoRequest) XHotelid(xHotelid string) ApiRemoveBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiRemoveBedTaxInfoRequest) XExternalsystem(xExternalsystem string) ApiRemoveBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) ApiRemoveBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveBedTaxInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveBedTaxInfoExecute(r)
}

/*
RemoveBedTaxInfo Delete bed tax information

You can use this API to delete bed tax information for a property. <p><strong>OperationId:</strong>removeBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxRegistraitionNo Unique number of the tax registration.
 @param hotelId Unique ID of the hotel
 @return ApiRemoveBedTaxInfoRequest
*/
func (a *CashieringApiService) RemoveBedTaxInfo(ctx context.Context, taxRegistraitionNo string, hotelId string) ApiRemoveBedTaxInfoRequest {
	return ApiRemoveBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		taxRegistraitionNo: taxRegistraitionNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) RemoveBedTaxInfoExecute(r ApiRemoveBedTaxInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.RemoveBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax/{taxRegistraitionNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxRegistraitionNo"+"}", url.PathEscape(parameterValueToString(r.taxRegistraitionNo, "taxRegistraitionNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxRegistraitionNo) < 1 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have at least 1 elements")
	}
	if strlen(r.taxRegistraitionNo) > 2000 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fixedChargeID *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveFixedChargesRequest) Authorization(authorization string) ApiRemoveFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveFixedChargesRequest) XAppKey(xAppKey string) ApiRemoveFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveFixedChargesRequest) XHotelid(xHotelid string) ApiRemoveFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiRemoveFixedChargesRequest) FixedChargeID(fixedChargeID []string) ApiRemoveFixedChargesRequest {
	r.fixedChargeID = &fixedChargeID
	return r
}

// External system code.
func (r ApiRemoveFixedChargesRequest) XExternalsystem(xExternalsystem string) ApiRemoveFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveFixedChargesRequest) AcceptLanguage(acceptLanguage string) ApiRemoveFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveFixedChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFixedChargesExecute(r)
}

/*
RemoveFixedCharges Delete Fixed Charges 

You can use this API to remove fixed Charges for a reservation. <p><strong>OperationId:</strong>removeFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiRemoveFixedChargesRequest
*/
func (a *CashieringApiService) RemoveFixedCharges(ctx context.Context, reservationId string, hotelId string) ApiRemoveFixedChargesRequest {
	return ApiRemoveFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) RemoveFixedChargesExecute(r ApiRemoveFixedChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.RemoveFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fixedChargeID != nil {
		t := *r.fixedChargeID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fixedChargeID", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fixedChargeID", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseARInvoiceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reasonCode *string
	cashierId *float32
	transactionCodes *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseARInvoiceRequest) Authorization(authorization string) ApiReverseARInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReverseARInvoiceRequest) XAppKey(xAppKey string) ApiReverseARInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReverseARInvoiceRequest) XHotelid(xHotelid string) ApiReverseARInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The reason code for the deletion.
func (r ApiReverseARInvoiceRequest) ReasonCode(reasonCode string) ApiReverseARInvoiceRequest {
	r.reasonCode = &reasonCode
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiReverseARInvoiceRequest) CashierId(cashierId float32) ApiReverseARInvoiceRequest {
	r.cashierId = &cashierId
	return r
}

// The unique transaction number of this transaction.
func (r ApiReverseARInvoiceRequest) TransactionCodes(transactionCodes []float32) ApiReverseARInvoiceRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// External system code.
func (r ApiReverseARInvoiceRequest) XExternalsystem(xExternalsystem string) ApiReverseARInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReverseARInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiReverseARInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseARInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseARInvoiceExecute(r)
}

/*
ReverseARInvoice Reverse AR Invoice

You can use this API to reverse an AR Invoice. <p><strong>OperationId:</strong>reverseARInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiReverseARInvoiceRequest
*/
func (a *CashieringApiService) ReverseARInvoice(ctx context.Context, hotelId string) ApiReverseARInvoiceRequest {
	return ApiReverseARInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseARInvoiceExecute(r ApiReverseARInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseARInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/arInvoices/reverse"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.reasonCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reasonCode", r.reasonCode, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseCertificatePostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reverseCertificatePostingsCriteria *ReverseCertificatePostingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseCertificatePostingsRequest) Authorization(authorization string) ApiReverseCertificatePostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReverseCertificatePostingsRequest) XAppKey(xAppKey string) ApiReverseCertificatePostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReverseCertificatePostingsRequest) XHotelid(xHotelid string) ApiReverseCertificatePostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to reverse the certificate postings of transactions.
func (r ApiReverseCertificatePostingsRequest) ReverseCertificatePostingsCriteria(reverseCertificatePostingsCriteria ReverseCertificatePostingsRequest) ApiReverseCertificatePostingsRequest {
	r.reverseCertificatePostingsCriteria = &reverseCertificatePostingsCriteria
	return r
}

// External system code.
func (r ApiReverseCertificatePostingsRequest) XExternalsystem(xExternalsystem string) ApiReverseCertificatePostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReverseCertificatePostingsRequest) AcceptLanguage(acceptLanguage string) ApiReverseCertificatePostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseCertificatePostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCertificatePostingsExecute(r)
}

/*
ReverseCertificatePostings Reverse certificate postings

You can use this API to Reverse certificate postings. <p><strong>OperationId:</strong>reverseCertificatePostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiReverseCertificatePostingsRequest
*/
func (a *CashieringApiService) ReverseCertificatePostings(ctx context.Context, reservationId string, hotelId string) ApiReverseCertificatePostingsRequest {
	return ApiReverseCertificatePostingsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseCertificatePostingsExecute(r ApiReverseCertificatePostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseCertificatePostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/reverseCertificate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reverseCertificatePostingsCriteria == nil {
		return localVarReturnValue, nil, reportError("reverseCertificatePostingsCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseCertificatePostingsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reverseCompRedemptions *ReverseCompRedemptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseCompRedemptionsRequest) Authorization(authorization string) ApiReverseCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReverseCompRedemptionsRequest) XAppKey(xAppKey string) ApiReverseCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReverseCompRedemptionsRequest) XHotelid(xHotelid string) ApiReverseCompRedemptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type of Complimentary Bucket Redemptions reversal.
func (r ApiReverseCompRedemptionsRequest) ReverseCompRedemptions(reverseCompRedemptions ReverseCompRedemptionsRequest) ApiReverseCompRedemptionsRequest {
	r.reverseCompRedemptions = &reverseCompRedemptions
	return r
}

// External system code.
func (r ApiReverseCompRedemptionsRequest) XExternalsystem(xExternalsystem string) ApiReverseCompRedemptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReverseCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) ApiReverseCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseCompRedemptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCompRedemptionsExecute(r)
}

/*
ReverseCompRedemptions Operation to reverse complimentary bucket redemptions for a guest having PTS Membership Type

You can use this API to reverse complimentary bucket redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>reverseCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiReverseCompRedemptionsRequest
*/
func (a *CashieringApiService) ReverseCompRedemptions(ctx context.Context, reservationId string, hotelId string) ApiReverseCompRedemptionsRequest {
	return ApiReverseCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseCompRedemptionsExecute(r ApiReverseCompRedemptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/compRedemptionReversals"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reverseCompRedemptions == nil {
		return localVarReturnValue, nil, reportError("reverseCompRedemptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseFlexibleBenefitPostingRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseFlexibleBenefitPostingRequest) Authorization(authorization string) ApiReverseFlexibleBenefitPostingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReverseFlexibleBenefitPostingRequest) XAppKey(xAppKey string) ApiReverseFlexibleBenefitPostingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReverseFlexibleBenefitPostingRequest) XHotelid(xHotelid string) ApiReverseFlexibleBenefitPostingRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiReverseFlexibleBenefitPostingRequest) XExternalsystem(xExternalsystem string) ApiReverseFlexibleBenefitPostingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReverseFlexibleBenefitPostingRequest) AcceptLanguage(acceptLanguage string) ApiReverseFlexibleBenefitPostingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseFlexibleBenefitPostingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseFlexibleBenefitPostingExecute(r)
}

/*
ReverseFlexibleBenefitPosting Delete flexible benefit postings

You can use this API to delete flexible benefit postings. <p><strong>OperationId:</strong>reverseFlexibleBenefitPosting</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiReverseFlexibleBenefitPostingRequest
*/
func (a *CashieringApiService) ReverseFlexibleBenefitPosting(ctx context.Context, transactionId string, hotelId string) ApiReverseFlexibleBenefitPostingRequest {
	return ApiReverseFlexibleBenefitPostingRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseFlexibleBenefitPostingExecute(r ApiReverseFlexibleBenefitPostingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseFlexibleBenefitPosting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/flexibleBenefitPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseFolioTaxPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	cashierId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionReversal *ReverseFolioTaxPaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReverseFolioTaxPaymentRequest) Authorization(authorization string) ApiReverseFolioTaxPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReverseFolioTaxPaymentRequest) XAppKey(xAppKey string) ApiReverseFolioTaxPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReverseFolioTaxPaymentRequest) XHotelid(xHotelid string) ApiReverseFolioTaxPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to reverse a Payment Tax record for Thailand Tax requirement.
func (r ApiReverseFolioTaxPaymentRequest) TransactionReversal(transactionReversal ReverseFolioTaxPaymentRequest) ApiReverseFolioTaxPaymentRequest {
	r.transactionReversal = &transactionReversal
	return r
}

// External system code.
func (r ApiReverseFolioTaxPaymentRequest) XExternalsystem(xExternalsystem string) ApiReverseFolioTaxPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReverseFolioTaxPaymentRequest) AcceptLanguage(acceptLanguage string) ApiReverseFolioTaxPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReverseFolioTaxPaymentRequest) Execute() (*FolioTaxPaymentReversal, *http.Response, error) {
	return r.ApiService.ReverseFolioTaxPaymentExecute(r)
}

/*
ReverseFolioTaxPayment Change folio tax payments

You can use this API to change folio tax payments. <p><strong>OperationId:</strong>reverseFolioTaxPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @param hotelId Unique ID of the hotel
 @return ApiReverseFolioTaxPaymentRequest
*/
func (a *CashieringApiService) ReverseFolioTaxPayment(ctx context.Context, cashierId string, hotelId string) ApiReverseFolioTaxPaymentRequest {
	return ApiReverseFolioTaxPaymentRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTaxPaymentReversal
func (a *CashieringApiService) ReverseFolioTaxPaymentExecute(r ApiReverseFolioTaxPaymentRequest) (*FolioTaxPaymentReversal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTaxPaymentReversal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseFolioTaxPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashiers/{cashierId}/folioTaxPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transactionReversal == nil {
		return localVarReturnValue, nil, reportError("transactionReversal is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionReversal
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSplitAndTransferTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionToSplitAndTransfer *SplitAndTransferTransactionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiSplitAndTransferTransactionRequest) Authorization(authorization string) ApiSplitAndTransferTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiSplitAndTransferTransactionRequest) XAppKey(xAppKey string) ApiSplitAndTransferTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiSplitAndTransferTransactionRequest) XHotelid(xHotelid string) ApiSplitAndTransferTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split a transaction on a reservation and transfer the new transaction to a different reservation or a different window on the same reservation. Splitting of transactions requires a Inhouse target reservation, a list of transactions for a Inhouse reservation and a valid amount or a percentage by which the amount can be split. Based on parameters, certain transactions cannot be split. Transaction which are included in an invoice cannot be split Transactions where the generates resides elsewhere(reservation or window) cannot be split. Automatically generated transactions such as taxes, cannot be split by itself. Deposits which were part of a deposit folio cannot be split. After the split is done the transaction is transferred to the target reservation/window.
func (r ApiSplitAndTransferTransactionRequest) TransactionToSplitAndTransfer(transactionToSplitAndTransfer SplitAndTransferTransactionRequest) ApiSplitAndTransferTransactionRequest {
	r.transactionToSplitAndTransfer = &transactionToSplitAndTransfer
	return r
}

// External system code.
func (r ApiSplitAndTransferTransactionRequest) XExternalsystem(xExternalsystem string) ApiSplitAndTransferTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiSplitAndTransferTransactionRequest) AcceptLanguage(acceptLanguage string) ApiSplitAndTransferTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiSplitAndTransferTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SplitAndTransferTransactionExecute(r)
}

/*
SplitAndTransferTransaction Split and transfer transactions

You can use this API to split and transfer transactions. <p><strong>OperationId:</strong>splitAndTransferTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiSplitAndTransferTransactionRequest
*/
func (a *CashieringApiService) SplitAndTransferTransaction(ctx context.Context, hotelId string) ApiSplitAndTransferTransactionRequest {
	return ApiSplitAndTransferTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) SplitAndTransferTransactionExecute(r ApiSplitAndTransferTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.SplitAndTransferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/splitAndTransfer"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transactionToSplitAndTransfer == nil {
		return localVarReturnValue, nil, reportError("transactionToSplitAndTransfer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionToSplitAndTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSplitDepositTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	splitDepositTransaction *SplitDepositTransactionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiSplitDepositTransactionRequest) Authorization(authorization string) ApiSplitDepositTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiSplitDepositTransactionRequest) XAppKey(xAppKey string) ApiSplitDepositTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiSplitDepositTransactionRequest) XHotelid(xHotelid string) ApiSplitDepositTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split deposit transaction for a reservation.
func (r ApiSplitDepositTransactionRequest) SplitDepositTransaction(splitDepositTransaction SplitDepositTransactionRequest) ApiSplitDepositTransactionRequest {
	r.splitDepositTransaction = &splitDepositTransaction
	return r
}

// External system code.
func (r ApiSplitDepositTransactionRequest) XExternalsystem(xExternalsystem string) ApiSplitDepositTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiSplitDepositTransactionRequest) AcceptLanguage(acceptLanguage string) ApiSplitDepositTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiSplitDepositTransactionRequest) Execute() (*SplitDepositTransactionStatus, *http.Response, error) {
	return r.ApiService.SplitDepositTransactionExecute(r)
}

/*
SplitDepositTransaction Split deposit transaction

You can use this API to Split deposit transaction. <p><strong>OperationId:</strong>splitDepositTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiSplitDepositTransactionRequest
*/
func (a *CashieringApiService) SplitDepositTransaction(ctx context.Context, transactionId string, reservationId string, hotelId string) ApiSplitDepositTransactionRequest {
	return ApiSplitDepositTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SplitDepositTransactionStatus
func (a *CashieringApiService) SplitDepositTransactionExecute(r ApiSplitDepositTransactionRequest) (*SplitDepositTransactionStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SplitDepositTransactionStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.SplitDepositTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.splitDepositTransaction == nil {
		return localVarReturnValue, nil, reportError("splitDepositTransaction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.splitDepositTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSplitTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionToSplit *SplitTransactionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiSplitTransactionRequest) Authorization(authorization string) ApiSplitTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiSplitTransactionRequest) XAppKey(xAppKey string) ApiSplitTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiSplitTransactionRequest) XHotelid(xHotelid string) ApiSplitTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split a transaction on a reservation. Splitting of transactions requires a list of transactions and a valid amount or a percentage by which the amount can be split. Based on parameters, certain transactions cannot be split. Transaction which are included in an invoice cannot be split Transactions where the generates resides elsewhere(reservation or window) cannot be split. Automatically generated transactions such as taxes, cannot be split by itself. Deposits which were part of a deposit folio cannot be split. After the split is done the transaction resides on the same folio window as the original transaction.
func (r ApiSplitTransactionRequest) TransactionToSplit(transactionToSplit SplitTransactionRequest) ApiSplitTransactionRequest {
	r.transactionToSplit = &transactionToSplit
	return r
}

// External system code.
func (r ApiSplitTransactionRequest) XExternalsystem(xExternalsystem string) ApiSplitTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiSplitTransactionRequest) AcceptLanguage(acceptLanguage string) ApiSplitTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiSplitTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SplitTransactionExecute(r)
}

/*
SplitTransaction Split transactions

You can use this API to Split transactions. <p><strong>OperationId:</strong>splitTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiSplitTransactionRequest
*/
func (a *CashieringApiService) SplitTransaction(ctx context.Context, hotelId string) ApiSplitTransactionRequest {
	return ApiSplitTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) SplitTransactionExecute(r ApiSplitTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.SplitTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/split"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transactionToSplit == nil {
		return localVarReturnValue, nil, reportError("transactionToSplit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionToSplit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferCompTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transferCompTransactions *TransferCompTransactionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferCompTransactionsRequest) Authorization(authorization string) ApiTransferCompTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferCompTransactionsRequest) XAppKey(xAppKey string) ApiTransferCompTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferCompTransactionsRequest) XHotelid(xHotelid string) ApiTransferCompTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object of comp transactions transfer.
func (r ApiTransferCompTransactionsRequest) TransferCompTransactions(transferCompTransactions TransferCompTransactionsRequest) ApiTransferCompTransactionsRequest {
	r.transferCompTransactions = &transferCompTransactions
	return r
}

// External system code.
func (r ApiTransferCompTransactionsRequest) XExternalsystem(xExternalsystem string) ApiTransferCompTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferCompTransactionsRequest) AcceptLanguage(acceptLanguage string) ApiTransferCompTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferCompTransactionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferCompTransactionsExecute(r)
}

/*
TransferCompTransactions Transfer comp transactions to window

You can use this API to transfer comp transactions to window <p><strong>OperationId:</strong>transferCompTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiTransferCompTransactionsRequest
*/
func (a *CashieringApiService) TransferCompTransactions(ctx context.Context, hotelId string) ApiTransferCompTransactionsRequest {
	return ApiTransferCompTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) TransferCompTransactionsExecute(r ApiTransferCompTransactionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.TransferCompTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transferCompTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transferCompTransactions == nil {
		return localVarReturnValue, nil, reportError("transferCompTransactions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transferCompTransactions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferFolioToWindowRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioToWindow *TransferFolioToWindowRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferFolioToWindowRequest) Authorization(authorization string) ApiTransferFolioToWindowRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferFolioToWindowRequest) XAppKey(xAppKey string) ApiTransferFolioToWindowRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferFolioToWindowRequest) XHotelid(xHotelid string) ApiTransferFolioToWindowRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transaction folio(s) to specific window
func (r ApiTransferFolioToWindowRequest) FolioToWindow(folioToWindow TransferFolioToWindowRequest) ApiTransferFolioToWindowRequest {
	r.folioToWindow = &folioToWindow
	return r
}

// External system code.
func (r ApiTransferFolioToWindowRequest) XExternalsystem(xExternalsystem string) ApiTransferFolioToWindowRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferFolioToWindowRequest) AcceptLanguage(acceptLanguage string) ApiTransferFolioToWindowRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferFolioToWindowRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferFolioToWindowExecute(r)
}

/*
TransferFolioToWindow Transfer Folio to Window.

You can use this API to transfer Folio to Window. <p><strong>OperationId:</strong>transferFolioToWindow</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiTransferFolioToWindowRequest
*/
func (a *CashieringApiService) TransferFolioToWindow(ctx context.Context, reservationId string, hotelId string) ApiTransferFolioToWindowRequest {
	return ApiTransferFolioToWindowRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) TransferFolioToWindowExecute(r ApiTransferFolioToWindowRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.TransferFolioToWindow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transferFolioTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.folioToWindow == nil {
		return localVarReturnValue, nil, reportError("folioToWindow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioToWindow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferTransactionToReservationRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	toReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationTransaction *TransferTransactionToReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferTransactionToReservationRequest) Authorization(authorization string) ApiTransferTransactionToReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferTransactionToReservationRequest) XAppKey(xAppKey string) ApiTransferTransactionToReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferTransactionToReservationRequest) XHotelid(xHotelid string) ApiTransferTransactionToReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to transfer a transaction(s) to a reservation. In the criteria, the target Reservation Id is required for the transfer.
func (r ApiTransferTransactionToReservationRequest) ReservationTransaction(reservationTransaction TransferTransactionToReservationRequest) ApiTransferTransactionToReservationRequest {
	r.reservationTransaction = &reservationTransaction
	return r
}

// External system code.
func (r ApiTransferTransactionToReservationRequest) XExternalsystem(xExternalsystem string) ApiTransferTransactionToReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferTransactionToReservationRequest) AcceptLanguage(acceptLanguage string) ApiTransferTransactionToReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferTransactionToReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferTransactionToReservationExecute(r)
}

/*
TransferTransactionToReservation Transfer Transaction to Reservation

You can use this API to Transfer Transaction to Reservation. <p><strong>OperationId:</strong>transferTransactionToReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param toReservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiTransferTransactionToReservationRequest
*/
func (a *CashieringApiService) TransferTransactionToReservation(ctx context.Context, toReservationId string, hotelId string) ApiTransferTransactionToReservationRequest {
	return ApiTransferTransactionToReservationRequest{
		ApiService: a,
		ctx: ctx,
		toReservationId: toReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) TransferTransactionToReservationExecute(r ApiTransferTransactionToReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.TransferTransactionToReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{toReservationId}/transferTransaction"
	localVarPath = strings.Replace(localVarPath, "{"+"toReservationId"+"}", url.PathEscape(parameterValueToString(r.toReservationId, "toReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.toReservationId) < 1 {
		return localVarReturnValue, nil, reportError("toReservationId must have at least 1 elements")
	}
	if strlen(r.toReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("toReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reservationTransaction == nil {
		return localVarReturnValue, nil, reportError("reservationTransaction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferTransactionToWindowRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionToWindow *TransferTransactionToWindowRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferTransactionToWindowRequest) Authorization(authorization string) ApiTransferTransactionToWindowRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferTransactionToWindowRequest) XAppKey(xAppKey string) ApiTransferTransactionToWindowRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferTransactionToWindowRequest) XHotelid(xHotelid string) ApiTransferTransactionToWindowRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transaction transfer
func (r ApiTransferTransactionToWindowRequest) TransactionToWindow(transactionToWindow TransferTransactionToWindowRequest) ApiTransferTransactionToWindowRequest {
	r.transactionToWindow = &transactionToWindow
	return r
}

// External system code.
func (r ApiTransferTransactionToWindowRequest) XExternalsystem(xExternalsystem string) ApiTransferTransactionToWindowRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferTransactionToWindowRequest) AcceptLanguage(acceptLanguage string) ApiTransferTransactionToWindowRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferTransactionToWindowRequest) Execute() (*TransferTransactionToWindow, *http.Response, error) {
	return r.ApiService.TransferTransactionToWindowExecute(r)
}

/*
TransferTransactionToWindow Transfer Transaction to Window

You can use this API to transfer Transaction to Window. <p><strong>OperationId:</strong>transferTransactionToWindow</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiTransferTransactionToWindowRequest
*/
func (a *CashieringApiService) TransferTransactionToWindow(ctx context.Context, reservationId string, hotelId string) ApiTransferTransactionToWindowRequest {
	return ApiTransferTransactionToWindowRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransferTransactionToWindow
func (a *CashieringApiService) TransferTransactionToWindowExecute(r ApiTransferTransactionToWindowRequest) (*TransferTransactionToWindow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransferTransactionToWindow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.TransferTransactionToWindow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transferTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transactionToWindow == nil {
		return localVarReturnValue, nil, reportError("transactionToWindow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionToWindow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransitionDepositToGuestFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositToGuestFolio *TransitionDepositToGuestFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransitionDepositToGuestFolioRequest) Authorization(authorization string) ApiTransitionDepositToGuestFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransitionDepositToGuestFolioRequest) XAppKey(xAppKey string) ApiTransitionDepositToGuestFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransitionDepositToGuestFolioRequest) XHotelid(xHotelid string) ApiTransitionDepositToGuestFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post an existing deposit on a reservation to the Guest Folio for No Show or Cancelled Reservations. Deposits remain in the deposit ledger until Checkin/Checkout. In the case of No Show or Cancelled reservations they remain in the deposit ledger until this request is done.
func (r ApiTransitionDepositToGuestFolioRequest) DepositToGuestFolio(depositToGuestFolio TransitionDepositToGuestFolioRequest) ApiTransitionDepositToGuestFolioRequest {
	r.depositToGuestFolio = &depositToGuestFolio
	return r
}

// External system code.
func (r ApiTransitionDepositToGuestFolioRequest) XExternalsystem(xExternalsystem string) ApiTransitionDepositToGuestFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransitionDepositToGuestFolioRequest) AcceptLanguage(acceptLanguage string) ApiTransitionDepositToGuestFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransitionDepositToGuestFolioRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransitionDepositToGuestFolioExecute(r)
}

/*
TransitionDepositToGuestFolio Transition Deposit to Guest Folio

You can use this API to Transfer Deposit to Guest Folio. <p><strong>OperationId:</strong>transitionDepositToGuestFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiTransitionDepositToGuestFolioRequest
*/
func (a *CashieringApiService) TransitionDepositToGuestFolio(ctx context.Context, reservationId string, hotelId string) ApiTransitionDepositToGuestFolioRequest {
	return ApiTransitionDepositToGuestFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) TransitionDepositToGuestFolioExecute(r ApiTransitionDepositToGuestFolioRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.TransitionDepositToGuestFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositTransition"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.depositToGuestFolio == nil {
		return localVarReturnValue, nil, reportError("depositToGuestFolio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositToGuestFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlinkReservationPackageAllowanceRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiUnlinkReservationPackageAllowanceRequest) Authorization(authorization string) ApiUnlinkReservationPackageAllowanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiUnlinkReservationPackageAllowanceRequest) XAppKey(xAppKey string) ApiUnlinkReservationPackageAllowanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiUnlinkReservationPackageAllowanceRequest) XHotelid(xHotelid string) ApiUnlinkReservationPackageAllowanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiUnlinkReservationPackageAllowanceRequest) XExternalsystem(xExternalsystem string) ApiUnlinkReservationPackageAllowanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiUnlinkReservationPackageAllowanceRequest) AcceptLanguage(acceptLanguage string) ApiUnlinkReservationPackageAllowanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiUnlinkReservationPackageAllowanceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UnlinkReservationPackageAllowanceExecute(r)
}

/*
UnlinkReservationPackageAllowance Unlink reservation package allowance

You can use this API to unlink reservation package allowance. <p><strong>OperationId:</strong>unlinkReservationPackageAllowance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiUnlinkReservationPackageAllowanceRequest
*/
func (a *CashieringApiService) UnlinkReservationPackageAllowance(ctx context.Context, reservationId string, hotelId string) ApiUnlinkReservationPackageAllowanceRequest {
	return ApiUnlinkReservationPackageAllowanceRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) UnlinkReservationPackageAllowanceExecute(r ApiUnlinkReservationPackageAllowanceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.UnlinkReservationPackageAllowance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packageAllowance/links"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fixedCharges *UpdateFixedChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiUpdateFixedChargesRequest) Authorization(authorization string) ApiUpdateFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiUpdateFixedChargesRequest) XAppKey(xAppKey string) ApiUpdateFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiUpdateFixedChargesRequest) XHotelid(xHotelid string) ApiUpdateFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to update fixed charges of a reservation.
func (r ApiUpdateFixedChargesRequest) FixedCharges(fixedCharges UpdateFixedChargesRequest) ApiUpdateFixedChargesRequest {
	r.fixedCharges = &fixedCharges
	return r
}

// External system code.
func (r ApiUpdateFixedChargesRequest) XExternalsystem(xExternalsystem string) ApiUpdateFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiUpdateFixedChargesRequest) AcceptLanguage(acceptLanguage string) ApiUpdateFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiUpdateFixedChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UpdateFixedChargesExecute(r)
}

/*
UpdateFixedCharges Updates Fixed Charges 

You can use this API to update fixed Charges for a reservation. <p><strong>OperationId:</strong>updateFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiUpdateFixedChargesRequest
*/
func (a *CashieringApiService) UpdateFixedCharges(ctx context.Context, reservationId string, hotelId string) ApiUpdateFixedChargesRequest {
	return ApiUpdateFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) UpdateFixedChargesExecute(r ApiUpdateFixedChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.UpdateFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fixedCharges == nil {
		return localVarReturnValue, nil, reportError("fixedCharges is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fixedCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCreditBillRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditBillCriteria *PostCreditBillRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiValidateCreditBillRequest) Authorization(authorization string) ApiValidateCreditBillRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiValidateCreditBillRequest) XAppKey(xAppKey string) ApiValidateCreditBillRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiValidateCreditBillRequest) XHotelid(xHotelid string) ApiValidateCreditBillRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to check if a Folio is valid for Credit Bill.
func (r ApiValidateCreditBillRequest) CreditBillCriteria(creditBillCriteria PostCreditBillRequest) ApiValidateCreditBillRequest {
	r.creditBillCriteria = &creditBillCriteria
	return r
}

// External system code.
func (r ApiValidateCreditBillRequest) XExternalsystem(xExternalsystem string) ApiValidateCreditBillRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiValidateCreditBillRequest) AcceptLanguage(acceptLanguage string) ApiValidateCreditBillRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiValidateCreditBillRequest) Execute() (*ValidatedCreditBill, *http.Response, error) {
	return r.ApiService.ValidateCreditBillExecute(r)
}

/*
ValidateCreditBill Validate Credit Bill

You can use this API to validate credit Bill. <p><strong>OperationId:</strong>validateCreditBill</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiValidateCreditBillRequest
*/
func (a *CashieringApiService) ValidateCreditBill(ctx context.Context, hotelId string) ApiValidateCreditBillRequest {
	return ApiValidateCreditBillRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidatedCreditBill
func (a *CashieringApiService) ValidateCreditBillExecute(r ApiValidateCreditBillRequest) (*ValidatedCreditBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedCreditBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ValidateCreditBill")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditBill/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.creditBillCriteria == nil {
		return localVarReturnValue, nil, reportError("creditBillCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditBillCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateDepositFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositFolioValidateCriteria *ValidateDepositFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiValidateDepositFolioRequest) Authorization(authorization string) ApiValidateDepositFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiValidateDepositFolioRequest) XAppKey(xAppKey string) ApiValidateDepositFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiValidateDepositFolioRequest) XHotelid(xHotelid string) ApiValidateDepositFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate a Deposit Folio for a reservation.
func (r ApiValidateDepositFolioRequest) DepositFolioValidateCriteria(depositFolioValidateCriteria ValidateDepositFolioRequest) ApiValidateDepositFolioRequest {
	r.depositFolioValidateCriteria = &depositFolioValidateCriteria
	return r
}

// External system code.
func (r ApiValidateDepositFolioRequest) XExternalsystem(xExternalsystem string) ApiValidateDepositFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiValidateDepositFolioRequest) AcceptLanguage(acceptLanguage string) ApiValidateDepositFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiValidateDepositFolioRequest) Execute() (*DepositedFolioValidate, *http.Response, error) {
	return r.ApiService.ValidateDepositFolioExecute(r)
}

/*
ValidateDepositFolio Validate Deposit Folio

You can use this API to validate Deposit Folio. <p><strong>OperationId:</strong>validateDepositFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiValidateDepositFolioRequest
*/
func (a *CashieringApiService) ValidateDepositFolio(ctx context.Context, hotelId string) ApiValidateDepositFolioRequest {
	return ApiValidateDepositFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositedFolioValidate
func (a *CashieringApiService) ValidateDepositFolioExecute(r ApiValidateDepositFolioRequest) (*DepositedFolioValidate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositedFolioValidate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ValidateDepositFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositfolios/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.depositFolioValidateCriteria == nil {
		return localVarReturnValue, nil, reportError("depositFolioValidateCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositFolioValidateCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiValidateTransactionCodesRequest) Authorization(authorization string) ApiValidateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiValidateTransactionCodesRequest) XAppKey(xAppKey string) ApiValidateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiValidateTransactionCodesRequest) XHotelid(xHotelid string) ApiValidateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r ApiValidateTransactionCodesRequest) Event(event string) ApiValidateTransactionCodesRequest {
	r.event = &event
	return r
}

// The Fiscal Bill number of this posting
func (r ApiValidateTransactionCodesRequest) FiscalBillNo(fiscalBillNo string) ApiValidateTransactionCodesRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiValidateTransactionCodesRequest) FolioDate(folioDate string) ApiValidateTransactionCodesRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r ApiValidateTransactionCodesRequest) FolioNo(folioNo float32) ApiValidateTransactionCodesRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiValidateTransactionCodesRequest) FolioStatus(folioStatus string) ApiValidateTransactionCodesRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiValidateTransactionCodesRequest) FolioTypeName(folioTypeName string) ApiValidateTransactionCodesRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiValidateTransactionCodesRequest) InternalFolioWindowID(internalFolioWindowID string) ApiValidateTransactionCodesRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiValidateTransactionCodesRequest) InvoiceNo(invoiceNo float32) ApiValidateTransactionCodesRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiValidateTransactionCodesRequest) XExternalsystem(xExternalsystem string) ApiValidateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiValidateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) ApiValidateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiValidateTransactionCodesRequest) Execute() (*ValidatedTransactionCode, *http.Response, error) {
	return r.ApiService.ValidateTransactionCodesExecute(r)
}

/*
ValidateTransactionCodes Validate Transaction Codes

You can use this API to validate Transaction Codes. <p><strong>OperationId:</strong>validateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiValidateTransactionCodesRequest
*/
func (a *CashieringApiService) ValidateTransactionCodes(ctx context.Context, transactionId string, hotelId string) ApiValidateTransactionCodesRequest {
	return ApiValidateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidatedTransactionCode
func (a *CashieringApiService) ValidateTransactionCodesExecute(r ApiValidateTransactionCodesRequest) (*ValidatedTransactionCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedTransactionCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ValidateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
	}
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
	}
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
	}
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyForEarlyDepartureRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ignoreCheckOnTieredRate *bool
	ignoreRateRestriction *bool
	postConsumedAllowanceToGuest *bool
	postEarlyDeparturePenalty *bool
	cashierId *float32
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiVerifyForEarlyDepartureRequest) Authorization(authorization string) ApiVerifyForEarlyDepartureRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiVerifyForEarlyDepartureRequest) XAppKey(xAppKey string) ApiVerifyForEarlyDepartureRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiVerifyForEarlyDepartureRequest) XHotelid(xHotelid string) ApiVerifyForEarlyDepartureRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if check has to be done for Rate Tiers.
func (r ApiVerifyForEarlyDepartureRequest) IgnoreCheckOnTieredRate(ignoreCheckOnTieredRate bool) ApiVerifyForEarlyDepartureRequest {
	r.ignoreCheckOnTieredRate = &ignoreCheckOnTieredRate
	return r
}

// Indicates if Rate Restriction check should be overridden.
func (r ApiVerifyForEarlyDepartureRequest) IgnoreRateRestriction(ignoreRateRestriction bool) ApiVerifyForEarlyDepartureRequest {
	r.ignoreRateRestriction = &ignoreRateRestriction
	return r
}

// Indicates if any allowance consumed by the guest for today can be posted to the Guest Folio. If this cannot be done then the Early Departure cannot proceed.
func (r ApiVerifyForEarlyDepartureRequest) PostConsumedAllowanceToGuest(postConsumedAllowanceToGuest bool) ApiVerifyForEarlyDepartureRequest {
	r.postConsumedAllowanceToGuest = &postConsumedAllowanceToGuest
	return r
}

// Indicates if the early departure penalty should be posted .
func (r ApiVerifyForEarlyDepartureRequest) PostEarlyDeparturePenalty(postEarlyDeparturePenalty bool) ApiVerifyForEarlyDepartureRequest {
	r.postEarlyDeparturePenalty = &postEarlyDeparturePenalty
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiVerifyForEarlyDepartureRequest) CashierId(cashierId float32) ApiVerifyForEarlyDepartureRequest {
	r.cashierId = &cashierId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiVerifyForEarlyDepartureRequest) IdContext(idContext []string) ApiVerifyForEarlyDepartureRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiVerifyForEarlyDepartureRequest) Type_(type_ []string) ApiVerifyForEarlyDepartureRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiVerifyForEarlyDepartureRequest) XExternalsystem(xExternalsystem string) ApiVerifyForEarlyDepartureRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiVerifyForEarlyDepartureRequest) AcceptLanguage(acceptLanguage string) ApiVerifyForEarlyDepartureRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiVerifyForEarlyDepartureRequest) Execute() (*EarlyDepartureInfo, *http.Response, error) {
	return r.ApiService.VerifyForEarlyDepartureExecute(r)
}

/*
VerifyForEarlyDeparture Verify for early Departure

You can use this API to verify early Departure. <p><strong>OperationId:</strong>verifyForEarlyDeparture</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return ApiVerifyForEarlyDepartureRequest
*/
func (a *CashieringApiService) VerifyForEarlyDeparture(ctx context.Context, reservationId string, hotelId string) ApiVerifyForEarlyDepartureRequest {
	return ApiVerifyForEarlyDepartureRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EarlyDepartureInfo
func (a *CashieringApiService) VerifyForEarlyDepartureExecute(r ApiVerifyForEarlyDepartureRequest) (*EarlyDepartureInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EarlyDepartureInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.VerifyForEarlyDeparture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/earlyDeparture/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.ignoreCheckOnTieredRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreCheckOnTieredRate", r.ignoreCheckOnTieredRate, "")
	}
	if r.ignoreRateRestriction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreRateRestriction", r.ignoreRateRestriction, "")
	}
	if r.postConsumedAllowanceToGuest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postConsumedAllowanceToGuest", r.postConsumedAllowanceToGuest, "")
	}
	if r.postEarlyDeparturePenalty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postEarlyDeparturePenalty", r.postEarlyDeparturePenalty, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVoidBillingCheckChargesRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	checkNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueDate *string
	amount *float32
	currencyCode *string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	checkId *string
	checkIdContext *string
	checkIdType *string
	cashierId *float32
	postingRemark *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiVoidBillingCheckChargesRequest) Authorization(authorization string) ApiVoidBillingCheckChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiVoidBillingCheckChargesRequest) XAppKey(xAppKey string) ApiVoidBillingCheckChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiVoidBillingCheckChargesRequest) XHotelid(xHotelid string) ApiVoidBillingCheckChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The date against which void (reverse) charges are posted.
func (r ApiVoidBillingCheckChargesRequest) RevenueDate(revenueDate string) ApiVoidBillingCheckChargesRequest {
	r.revenueDate = &revenueDate
	return r
}

// A monetary amount.
func (r ApiVoidBillingCheckChargesRequest) Amount(amount float32) ApiVoidBillingCheckChargesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiVoidBillingCheckChargesRequest) CurrencyCode(currencyCode string) ApiVoidBillingCheckChargesRequest {
	r.currencyCode = &currencyCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiVoidBillingCheckChargesRequest) ReservationId(reservationId string) ApiVoidBillingCheckChargesRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiVoidBillingCheckChargesRequest) ReservationIdContext(reservationIdContext string) ApiVoidBillingCheckChargesRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiVoidBillingCheckChargesRequest) ReservationIdType(reservationIdType string) ApiVoidBillingCheckChargesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiVoidBillingCheckChargesRequest) CheckId(checkId string) ApiVoidBillingCheckChargesRequest {
	r.checkId = &checkId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiVoidBillingCheckChargesRequest) CheckIdContext(checkIdContext string) ApiVoidBillingCheckChargesRequest {
	r.checkIdContext = &checkIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiVoidBillingCheckChargesRequest) CheckIdType(checkIdType string) ApiVoidBillingCheckChargesRequest {
	r.checkIdType = &checkIdType
	return r
}

// Cashier Id of the Cashier.
func (r ApiVoidBillingCheckChargesRequest) CashierId(cashierId float32) ApiVoidBillingCheckChargesRequest {
	r.cashierId = &cashierId
	return r
}

// Text describing any applicable detail of the posting.
func (r ApiVoidBillingCheckChargesRequest) PostingRemark(postingRemark string) ApiVoidBillingCheckChargesRequest {
	r.postingRemark = &postingRemark
	return r
}

// External system code.
func (r ApiVoidBillingCheckChargesRequest) XExternalsystem(xExternalsystem string) ApiVoidBillingCheckChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiVoidBillingCheckChargesRequest) AcceptLanguage(acceptLanguage string) ApiVoidBillingCheckChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiVoidBillingCheckChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.VoidBillingCheckChargesExecute(r)
}

/*
VoidBillingCheckCharges Delete Billing Check Charges

You can use this API to delete (void) Billing Check Charges. <p><strong>OperationId:</strong>voidBillingCheckCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check.
 @param hotelId Unique ID of the hotel
 @return ApiVoidBillingCheckChargesRequest
*/
func (a *CashieringApiService) VoidBillingCheckCharges(ctx context.Context, checkNumber string, hotelId string) ApiVoidBillingCheckChargesRequest {
	return ApiVoidBillingCheckChargesRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) VoidBillingCheckChargesExecute(r ApiVoidBillingCheckChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.VoidBillingCheckCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/check/{checkNumber}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.revenueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", r.revenueDate, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.checkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkId", r.checkId, "")
	}
	if r.checkIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkIdContext", r.checkIdContext, "")
	}
	if r.checkIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkIdType", r.checkIdType, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.postingRemark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", r.postingRemark, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVoidFolioRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	folioId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioToVoid *VoidFolioRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiVoidFolioRequest) Authorization(authorization string) ApiVoidFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiVoidFolioRequest) XAppKey(xAppKey string) ApiVoidFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiVoidFolioRequest) XHotelid(xHotelid string) ApiVoidFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Void a Guest Folio when the Void Functionality is active.
func (r ApiVoidFolioRequest) FolioToVoid(folioToVoid VoidFolioRequest) ApiVoidFolioRequest {
	r.folioToVoid = &folioToVoid
	return r
}

// External system code.
func (r ApiVoidFolioRequest) XExternalsystem(xExternalsystem string) ApiVoidFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiVoidFolioRequest) AcceptLanguage(acceptLanguage string) ApiVoidFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiVoidFolioRequest) Execute() (*VoidedFolio, *http.Response, error) {
	return r.ApiService.VoidFolioExecute(r)
}

/*
VoidFolio Void folio

You can use this API to void a folio. <p><strong>OperationId:</strong>voidFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return ApiVoidFolioRequest
*/
func (a *CashieringApiService) VoidFolio(ctx context.Context, folioId string, reservationId string, hotelId string) ApiVoidFolioRequest {
	return ApiVoidFolioRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return VoidedFolio
func (a *CashieringApiService) VoidFolioExecute(r ApiVoidFolioRequest) (*VoidedFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VoidedFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.VoidFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/voidfolios/{folioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.folioToVoid == nil {
		return localVarReturnValue, nil, reportError("folioToVoid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioToVoid
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
