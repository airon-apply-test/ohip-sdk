/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CashieringConfigApiService CashieringConfigApi service
type CashieringConfigApiService service

type ApiChangeCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesToBeChanged *ChangeCompTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiChangeCompTypesRequest) Authorization(authorization string) ApiChangeCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiChangeCompTypesRequest) XAppKey(xAppKey string) ApiChangeCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiChangeCompTypesRequest) XHotelid(xHotelid string) ApiChangeCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Comp Types.
func (r ApiChangeCompTypesRequest) CompTypesToBeChanged(compTypesToBeChanged ChangeCompTypesRequest) ApiChangeCompTypesRequest {
	r.compTypesToBeChanged = &compTypesToBeChanged
	return r
}

// External system code.
func (r ApiChangeCompTypesRequest) XExternalsystem(xExternalsystem string) ApiChangeCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiChangeCompTypesRequest) AcceptLanguage(acceptLanguage string) ApiChangeCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiChangeCompTypesRequest) Execute() (*CompTypesStatus, *http.Response, error) {
	return r.ApiService.ChangeCompTypesExecute(r)
}

/*
ChangeCompTypes Operation to Change Comp Types.

Operation to Change Comp Types. <p><strong>OperationId:</strong>changeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangeCompTypesRequest
*/
func (a *CashieringConfigApiService) ChangeCompTypes(ctx context.Context) ApiChangeCompTypesRequest {
	return ApiChangeCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompTypesStatus
func (a *CashieringConfigApiService) ChangeCompTypesExecute(r ApiChangeCompTypesRequest) (*CompTypesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.ChangeCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.compTypesToBeChanged == nil {
		return localVarReturnValue, nil, reportError("compTypesToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigToBeChanged *ChangeFolioTypeLegendMappingConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiChangeFolioTypeLegendMappingConfigRequest) Authorization(authorization string) ApiChangeFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiChangeFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) ApiChangeFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiChangeFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) ApiChangeFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit folio type legend mapping information.
func (r ApiChangeFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigToBeChanged(folioTypeLegendMappingConfigToBeChanged ChangeFolioTypeLegendMappingConfigRequest) ApiChangeFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigToBeChanged = &folioTypeLegendMappingConfigToBeChanged
	return r
}

// External system code.
func (r ApiChangeFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) ApiChangeFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiChangeFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) ApiChangeFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiChangeFolioTypeLegendMappingConfigRequest) Execute() (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	return r.ApiService.ChangeFolioTypeLegendMappingConfigExecute(r)
}

/*
ChangeFolioTypeLegendMappingConfig Operation to change folio type legend mappings config.

Operation to change folio type legend mappings config. <p><strong>OperationId:</strong>changeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangeFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) ChangeFolioTypeLegendMappingConfig(ctx context.Context) ApiChangeFolioTypeLegendMappingConfigRequest {
	return ApiChangeFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingConfigStatus
func (a *CashieringConfigApiService) ChangeFolioTypeLegendMappingConfigExecute(r ApiChangeFolioTypeLegendMappingConfigRequest) (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingConfigStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.ChangeFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.folioTypeLegendMappingConfigToBeChanged == nil {
		return localVarReturnValue, nil, reportError("folioTypeLegendMappingConfigToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCode *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAdjustmentCodesRequest) Authorization(authorization string) ApiDeleteAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAdjustmentCodesRequest) XAppKey(xAppKey string) ApiDeleteAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAdjustmentCodesRequest) XHotelid(xHotelid string) ApiDeleteAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r ApiDeleteAdjustmentCodesRequest) AdjustmentCode(adjustmentCode string) ApiDeleteAdjustmentCodesRequest {
	r.adjustmentCode = &adjustmentCode
	return r
}

// Hotel where the code is configured.
func (r ApiDeleteAdjustmentCodesRequest) HotelId(hotelId string) ApiDeleteAdjustmentCodesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ApiDeleteAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) ApiDeleteAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdjustmentCodesExecute(r)
}

/*
DeleteAdjustmentCodes Operation to delete AdjustmentCodes.

Operation to remove Adjustment Codes. <p><strong>OperationId:</strong>deleteAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) DeleteAdjustmentCodes(ctx context.Context) ApiDeleteAdjustmentCodesRequest {
	return ApiDeleteAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAdjustmentCodesExecute(r ApiDeleteAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.adjustmentCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCode", r.adjustmentCode, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	articleCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	articleHotelId *[]string
	inactive *[]bool
	orderSequence *[]float32
	description *[]string
	transactionCode *[]string
	amount *float32
	currencyCode *string
	availableForPostIt *bool
	color *string
	universalProductCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiDeleteArticlesRequest) HotelId(hotelId string) ApiDeleteArticlesRequest {
	r.hotelId = &hotelId
	return r
}

// Unique code of the article.
func (r ApiDeleteArticlesRequest) ArticleCodes(articleCodes []string) ApiDeleteArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteArticlesRequest) Authorization(authorization string) ApiDeleteArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteArticlesRequest) XAppKey(xAppKey string) ApiDeleteArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteArticlesRequest) XHotelid(xHotelid string) ApiDeleteArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code to which the article belongs.
func (r ApiDeleteArticlesRequest) ArticleHotelId(articleHotelId []string) ApiDeleteArticlesRequest {
	r.articleHotelId = &articleHotelId
	return r
}

// Indicates whether the article is inactive or not.
func (r ApiDeleteArticlesRequest) Inactive(inactive []bool) ApiDeleteArticlesRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r ApiDeleteArticlesRequest) OrderSequence(orderSequence []float32) ApiDeleteArticlesRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r ApiDeleteArticlesRequest) Description(description []string) ApiDeleteArticlesRequest {
	r.description = &description
	return r
}

// Transaction code to which the article belongs.
func (r ApiDeleteArticlesRequest) TransactionCode(transactionCode []string) ApiDeleteArticlesRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r ApiDeleteArticlesRequest) Amount(amount float32) ApiDeleteArticlesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiDeleteArticlesRequest) CurrencyCode(currencyCode string) ApiDeleteArticlesRequest {
	r.currencyCode = &currencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r ApiDeleteArticlesRequest) AvailableForPostIt(availableForPostIt bool) ApiDeleteArticlesRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r ApiDeleteArticlesRequest) Color(color string) ApiDeleteArticlesRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r ApiDeleteArticlesRequest) UniversalProductCode(universalProductCode []string) ApiDeleteArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r ApiDeleteArticlesRequest) XExternalsystem(xExternalsystem string) ApiDeleteArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteArticlesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteArticlesExecute(r)
}

/*
DeleteArticles Operation to delete Articles.

Operation to remove articles. <p><strong>OperationId:</strong>deleteArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteArticlesRequest
*/
func (a *CashieringConfigApiService) DeleteArticles(ctx context.Context) ApiDeleteArticlesRequest {
	return ApiDeleteArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteArticlesExecute(r ApiDeleteArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelId == nil {
		return localVarReturnValue, nil, reportError("hotelId is required and must be specified")
	}
	if r.articleCodes == nil {
		return localVarReturnValue, nil, reportError("articleCodes is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	{
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.articleHotelId != nil {
		t := *r.articleHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.universalProductCode != nil {
		t := *r.universalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *[]string
	roomClassHotelId *string
	roomClassCode *string
	sourceCodeHotelId *string
	sourceCode *string
	rateCategory *string
	rateCode *[]string
	guaranteeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with authorization rule
func (r ApiDeleteAuthorizationConfigRuleRequest) HotelId(hotelId []string) ApiDeleteAuthorizationConfigRuleRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAuthorizationConfigRuleRequest) Authorization(authorization string) ApiDeleteAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAuthorizationConfigRuleRequest) XAppKey(xAppKey string) ApiDeleteAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAuthorizationConfigRuleRequest) XHotelid(xHotelid string) ApiDeleteAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Authorization rule Room type.
func (r ApiDeleteAuthorizationConfigRuleRequest) RoomType(roomType []string) ApiDeleteAuthorizationConfigRuleRequest {
	r.roomType = &roomType
	return r
}

func (r ApiDeleteAuthorizationConfigRuleRequest) RoomClassHotelId(roomClassHotelId string) ApiDeleteAuthorizationConfigRuleRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r ApiDeleteAuthorizationConfigRuleRequest) RoomClassCode(roomClassCode string) ApiDeleteAuthorizationConfigRuleRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r ApiDeleteAuthorizationConfigRuleRequest) SourceCodeHotelId(sourceCodeHotelId string) ApiDeleteAuthorizationConfigRuleRequest {
	r.sourceCodeHotelId = &sourceCodeHotelId
	return r
}

func (r ApiDeleteAuthorizationConfigRuleRequest) SourceCode(sourceCode string) ApiDeleteAuthorizationConfigRuleRequest {
	r.sourceCode = &sourceCode
	return r
}

// Rate category Code.
func (r ApiDeleteAuthorizationConfigRuleRequest) RateCategory(rateCategory string) ApiDeleteAuthorizationConfigRuleRequest {
	r.rateCategory = &rateCategory
	return r
}

// Rate code associated to this rule.
func (r ApiDeleteAuthorizationConfigRuleRequest) RateCode(rateCode []string) ApiDeleteAuthorizationConfigRuleRequest {
	r.rateCode = &rateCode
	return r
}

// Guarantee code associated to this rule.
func (r ApiDeleteAuthorizationConfigRuleRequest) GuaranteeCode(guaranteeCode []string) ApiDeleteAuthorizationConfigRuleRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// External system code.
func (r ApiDeleteAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) ApiDeleteAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationConfigRuleExecute(r)
}

/*
DeleteAuthorizationConfigRule Operation to delete AuthorizationConfigRule.

 <p><strong>OperationId:</strong>deleteAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) DeleteAuthorizationConfigRule(ctx context.Context) ApiDeleteAuthorizationConfigRuleRequest {
	return ApiDeleteAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAuthorizationConfigRuleExecute(r ApiDeleteAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelId == nil {
		return localVarReturnValue, nil, reportError("hotelId is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
	}
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
	}
	if r.sourceCodeHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodeHotelId", r.sourceCodeHotelId, "")
	}
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
	}
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
	}
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		t := *r.guaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroup *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAuthorizerGroupsRequest) Authorization(authorization string) ApiDeleteAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAuthorizerGroupsRequest) XAppKey(xAppKey string) ApiDeleteAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAuthorizerGroupsRequest) XHotelid(xHotelid string) ApiDeleteAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r ApiDeleteAuthorizerGroupsRequest) AuthorizerGroup(authorizerGroup string) ApiDeleteAuthorizerGroupsRequest {
	r.authorizerGroup = &authorizerGroup
	return r
}

// Hotel where the code is configured.
func (r ApiDeleteAuthorizerGroupsRequest) HotelId(hotelId string) ApiDeleteAuthorizerGroupsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ApiDeleteAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) ApiDeleteAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizerGroupsExecute(r)
}

/*
DeleteAuthorizerGroups Operation to delete AuthorizerGroups.

Operation to remove Authorizer Groups. <p><strong>OperationId:</strong>deleteAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) DeleteAuthorizerGroups(ctx context.Context) ApiDeleteAuthorizerGroupsRequest {
	return ApiDeleteAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAuthorizerGroupsExecute(r ApiDeleteAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.authorizerGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroup", r.authorizerGroup, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with currency exchange service tax
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) HotelId(hotelId []string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency exchange service tax code
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxCode(currencyExchangeServiceTaxCode []string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxCode = &currencyExchangeServiceTaxCode
	return r
}

// External system code.
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCurrencyExchangeServiceTaxesExecute(r)
}

/*
DeleteCurrencyExchangeServiceTaxes Operation to delete CurrencyExchangeServiceTaxes.

Operation to remove currency exchange service taxes. <p><strong>OperationId:</strong>deleteCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) DeleteCurrencyExchangeServiceTaxes(ctx context.Context) ApiDeleteCurrencyExchangeServiceTaxesRequest {
	return ApiDeleteCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteCurrencyExchangeServiceTaxesExecute(r ApiDeleteCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelId == nil {
		return localVarReturnValue, nil, reportError("hotelId is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.currencyExchangeServiceTaxCode != nil {
		t := *r.currencyExchangeServiceTaxCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r ApiDeleteExpenseArrangementCodesRequest) HotelId(hotelId []string) ApiDeleteExpenseArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteExpenseArrangementCodesRequest) Authorization(authorization string) ApiDeleteExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteExpenseArrangementCodesRequest) XAppKey(xAppKey string) ApiDeleteExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteExpenseArrangementCodesRequest) XHotelid(xHotelid string) ApiDeleteExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r ApiDeleteExpenseArrangementCodesRequest) Code(code []string) ApiDeleteExpenseArrangementCodesRequest {
	r.code = &code
	return r
}

// External system code.
func (r ApiDeleteExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) ApiDeleteExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExpenseArrangementCodesExecute(r)
}

/*
DeleteExpenseArrangementCodes Operation to delete ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>deleteExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) DeleteExpenseArrangementCodes(ctx context.Context) ApiDeleteExpenseArrangementCodesRequest {
	return ApiDeleteExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteExpenseArrangementCodesExecute(r ApiDeleteExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelId == nil {
		return localVarReturnValue, nil, reportError("hotelId is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	partner *[]string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteFiscalFolioParametersRequest) Authorization(authorization string) ApiDeleteFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteFiscalFolioParametersRequest) XAppKey(xAppKey string) ApiDeleteFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteFiscalFolioParametersRequest) XHotelid(xHotelid string) ApiDeleteFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code of the Hotel.
func (r ApiDeleteFiscalFolioParametersRequest) HotelId(hotelId []string) ApiDeleteFiscalFolioParametersRequest {
	r.hotelId = &hotelId
	return r
}

// Fiscal folio parameter associated with Partner.
func (r ApiDeleteFiscalFolioParametersRequest) Partner(partner []string) ApiDeleteFiscalFolioParametersRequest {
	r.partner = &partner
	return r
}

// Code of the Fiscal Folio Parameter.
func (r ApiDeleteFiscalFolioParametersRequest) Code(code []string) ApiDeleteFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// External system code.
func (r ApiDeleteFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) ApiDeleteFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) ApiDeleteFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFiscalFolioParametersExecute(r)
}

/*
DeleteFiscalFolioParameters Operation to delete FiscalFolioParameters.

Operation to remove Fiscal Folio Parameters. <p><strong>OperationId:</strong>deleteFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) DeleteFiscalFolioParameters(ctx context.Context) ApiDeleteFiscalFolioParametersRequest {
	return ApiDeleteFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteFiscalFolioParametersExecute(r ApiDeleteFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.partner != nil {
		t := *r.partner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partner", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partner", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetAdjustmentCodesRequest) HotelIds(hotelIds []string) ApiGetAdjustmentCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAdjustmentCodesRequest) Authorization(authorization string) ApiGetAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAdjustmentCodesRequest) XAppKey(xAppKey string) ApiGetAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAdjustmentCodesRequest) XHotelid(xHotelid string) ApiGetAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ApiGetAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes []string) ApiGetAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// Wildcard search on the code.
func (r ApiGetAdjustmentCodesRequest) WildCard(wildCard string) ApiGetAdjustmentCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ApiGetAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) ApiGetAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) ApiGetAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAdjustmentCodesRequest) Execute() (*AdjustmentCodes, *http.Response, error) {
	return r.ApiService.GetAdjustmentCodesExecute(r)
}

/*
GetAdjustmentCodes Operation to fetch AdjustmentCodes.

Operation to fetch Adjustment Codes. <p><strong>OperationId:</strong>getAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) GetAdjustmentCodes(ctx context.Context) ApiGetAdjustmentCodesRequest {
	return ApiGetAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdjustmentCodes
func (a *CashieringConfigApiService) GetAdjustmentCodesExecute(r ApiGetAdjustmentCodesRequest) (*AdjustmentCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustmentCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.adjustmentCodes != nil {
		t := *r.adjustmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodes *[]string
	articleCodes *[]string
	universalProductCode *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetArticlesRequest) HotelIds(hotelIds []string) ApiGetArticlesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetArticlesRequest) Authorization(authorization string) ApiGetArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetArticlesRequest) XAppKey(xAppKey string) ApiGetArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetArticlesRequest) XHotelid(xHotelid string) ApiGetArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetArticlesRequest) TransactionCodes(transactionCodes []string) ApiGetArticlesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r ApiGetArticlesRequest) ArticleCodes(articleCodes []string) ApiGetArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Unique Universal product code search criteria.
func (r ApiGetArticlesRequest) UniversalProductCode(universalProductCode string) ApiGetArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// Indicator that tells whether to include inactive articles in search results.
func (r ApiGetArticlesRequest) IncludeInactive(includeInactive bool) ApiGetArticlesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetArticlesRequest) XExternalsystem(xExternalsystem string) ApiGetArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetArticlesRequest) AcceptLanguage(acceptLanguage string) ApiGetArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetArticlesRequest) Execute() (*ArticlesInfo, *http.Response, error) {
	return r.ApiService.GetArticlesExecute(r)
}

/*
GetArticles Get articles

Use this API to return articles for one or multiple properties based on search criteria such as hotelIds, transactionCodes, articleCodes, etc. One transaction code can sometimes serve as an umbrella for multiple articles, which can be posted using that transaction code.  For example, a single mini bar food transaction code might cover potato chips, crackers, peanuts, pretzels, and so on.<p><strong>OperationId:</strong>getArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArticlesRequest
*/
func (a *CashieringConfigApiService) GetArticles(ctx context.Context) ApiGetArticlesRequest {
	return ApiGetArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArticlesInfo
func (a *CashieringConfigApiService) GetArticlesExecute(r ApiGetArticlesRequest) (*ArticlesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArticlesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	if r.articleCodes != nil {
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetAuthorizerGroupsRequest) HotelIds(hotelIds []string) ApiGetAuthorizerGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAuthorizerGroupsRequest) Authorization(authorization string) ApiGetAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAuthorizerGroupsRequest) XAppKey(xAppKey string) ApiGetAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAuthorizerGroupsRequest) XHotelid(xHotelid string) ApiGetAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ApiGetAuthorizerGroupsRequest) AuthorizerGroupsCodes(authorizerGroupsCodes []string) ApiGetAuthorizerGroupsRequest {
	r.authorizerGroupsCodes = &authorizerGroupsCodes
	return r
}

// Wildcard search on the code.
func (r ApiGetAuthorizerGroupsRequest) WildCard(wildCard string) ApiGetAuthorizerGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ApiGetAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) ApiGetAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) ApiGetAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAuthorizerGroupsRequest) Execute() (*AuthorizerGroups, *http.Response, error) {
	return r.ApiService.GetAuthorizerGroupsExecute(r)
}

/*
GetAuthorizerGroups Operation to fetch AuthorizerGroups.

Operation to fetch Authorizer Groups. <p><strong>OperationId:</strong>getAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) GetAuthorizerGroups(ctx context.Context) ApiGetAuthorizerGroupsRequest {
	return ApiGetAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizerGroups
func (a *CashieringConfigApiService) GetAuthorizerGroupsExecute(r ApiGetAuthorizerGroupsRequest) (*AuthorizerGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizerGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.authorizerGroupsCodes != nil {
		t := *r.authorizerGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableCashierNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAvailableCashierNumberRequest) Authorization(authorization string) ApiGetAvailableCashierNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAvailableCashierNumberRequest) XAppKey(xAppKey string) ApiGetAvailableCashierNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAvailableCashierNumberRequest) XHotelid(xHotelid string) ApiGetAvailableCashierNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetAvailableCashierNumberRequest) XExternalsystem(xExternalsystem string) ApiGetAvailableCashierNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAvailableCashierNumberRequest) AcceptLanguage(acceptLanguage string) ApiGetAvailableCashierNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAvailableCashierNumberRequest) Execute() (*CashierNumber, *http.Response, error) {
	return r.ApiService.GetAvailableCashierNumberExecute(r)
}

/*
GetAvailableCashierNumber Operation to fetch AvailableCashierNumber.

The operation returns a next available Cashier Number to be used while creating a new Cashier. <p><strong>OperationId:</strong>getAvailableCashierNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvailableCashierNumberRequest
*/
func (a *CashieringConfigApiService) GetAvailableCashierNumber(ctx context.Context) ApiGetAvailableCashierNumberRequest {
	return ApiGetAvailableCashierNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashierNumber
func (a *CashieringConfigApiService) GetAvailableCashierNumberExecute(r ApiGetAvailableCashierNumberRequest) (*CashierNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAvailableCashierNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/nextAvailable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	cashierIDs *[]float32
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Numberic code for cashier ID.
func (r ApiGetCashiersRequest) CashierIDs(cashierIDs []float32) ApiGetCashiersRequest {
	r.cashierIDs = &cashierIDs
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashiersRequest) Authorization(authorization string) ApiGetCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashiersRequest) XAppKey(xAppKey string) ApiGetCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashiersRequest) XHotelid(xHotelid string) ApiGetCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetCashiersRequest) Limit(limit int32) ApiGetCashiersRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetCashiersRequest) Offset(offset int32) ApiGetCashiersRequest {
	r.offset = &offset
	return r
}

// Partial name of a cashier.
func (r ApiGetCashiersRequest) Name(name string) ApiGetCashiersRequest {
	r.name = &name
	return r
}

// Indicator that tells whether to include inactive cashiers in search results.
func (r ApiGetCashiersRequest) IncludeInactive(includeInactive bool) ApiGetCashiersRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetCashiersRequest) XExternalsystem(xExternalsystem string) ApiGetCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashiersRequest) AcceptLanguage(acceptLanguage string) ApiGetCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashiersRequest) Execute() (*CashiersDetails, *http.Response, error) {
	return r.ApiService.GetCashiersExecute(r)
}

/*
GetCashiers Get cashiers

Use this API to return Cashier information based on search criteria such as cashierIDs, limit, name. <p><strong>OperationId:</strong>getCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCashiersRequest
*/
func (a *CashieringConfigApiService) GetCashiers(ctx context.Context) ApiGetCashiersRequest {
	return ApiGetCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashiersDetails
func (a *CashieringConfigApiService) GetCashiersExecute(r ApiGetCashiersRequest) (*CashiersDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashiersDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierDetails/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cashierIDs == nil {
		return localVarReturnValue, nil, reportError("cashierIDs is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.cashierIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypeCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompTypesRequest) Authorization(authorization string) ApiGetCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompTypesRequest) XAppKey(xAppKey string) ApiGetCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompTypesRequest) XHotelid(xHotelid string) ApiGetCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code is used to identify the CompType.
func (r ApiGetCompTypesRequest) CompTypeCode(compTypeCode string) ApiGetCompTypesRequest {
	r.compTypeCode = &compTypeCode
	return r
}

// External system code.
func (r ApiGetCompTypesRequest) XExternalsystem(xExternalsystem string) ApiGetCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompTypesRequest) AcceptLanguage(acceptLanguage string) ApiGetCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompTypesRequest) Execute() (*CompTypesDetails, *http.Response, error) {
	return r.ApiService.GetCompTypesExecute(r)
}

/*
GetCompTypes Operation to Fetch Comp Types.

Operation to Fetch Comp TYpes. <p><strong>OperationId:</strong>getCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the source hotel in OPERA
 @return ApiGetCompTypesRequest
*/
func (a *CashieringConfigApiService) GetCompTypes(ctx context.Context, hotelId string) ApiGetCompTypesRequest {
	return ApiGetCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompTypesDetails
func (a *CashieringConfigApiService) GetCompTypesExecute(r ApiGetCompTypesRequest) (*CompTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.compTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTypeCode", r.compTypeCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetCurrencyExchangeServiceTaxesRequest) HotelIds(hotelIds []string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetCurrencyExchangeServiceTaxesRequest) Codes(codes []string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r ApiGetCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) ApiGetCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCurrencyExchangeServiceTaxesRequest) Execute() (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeServiceTaxesExecute(r)
}

/*
GetCurrencyExchangeServiceTaxes Operation to fetch CurrencyExchangeServiceTaxes.

Operation to fetch currency exchange service taxes. <p><strong>OperationId:</strong>getCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) GetCurrencyExchangeServiceTaxes(ctx context.Context) ApiGetCurrencyExchangeServiceTaxesRequest {
	return ApiGetCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrencyExchangeServiceTaxes
func (a *CashieringConfigApiService) GetCurrencyExchangeServiceTaxesExecute(r ApiGetCurrencyExchangeServiceTaxesRequest) (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrencyExchangeServiceTaxes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetDailyPlanCodesRequest) HotelIds(hotelIds []string) ApiGetDailyPlanCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDailyPlanCodesRequest) Authorization(authorization string) ApiGetDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDailyPlanCodesRequest) XAppKey(xAppKey string) ApiGetDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDailyPlanCodesRequest) XHotelid(xHotelid string) ApiGetDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r ApiGetDailyPlanCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) ApiGetDailyPlanCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r ApiGetDailyPlanCodesRequest) ArrangementCodes(arrangementCodes []string) ApiGetDailyPlanCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r ApiGetDailyPlanCodesRequest) WildCard(wildCard string) ApiGetDailyPlanCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ApiGetDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) ApiGetDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) ApiGetDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDailyPlanCodesRequest) Execute() (*DailyPlanCodes, *http.Response, error) {
	return r.ApiService.GetDailyPlanCodesExecute(r)
}

/*
GetDailyPlanCodes Operation to fetch DailyPlanCodes.

 <p><strong>OperationId:</strong>getDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDailyPlanCodesRequest
*/
func (a *CashieringConfigApiService) GetDailyPlanCodes(ctx context.Context) ApiGetDailyPlanCodesRequest {
	return ApiGetDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DailyPlanCodes
func (a *CashieringConfigApiService) GetDailyPlanCodesExecute(r ApiGetDailyPlanCodesRequest) (*DailyPlanCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyPlanCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetExpenseArrangementCodesRequest) HotelIds(hotelIds []string) ApiGetExpenseArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExpenseArrangementCodesRequest) Authorization(authorization string) ApiGetExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExpenseArrangementCodesRequest) XAppKey(xAppKey string) ApiGetExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExpenseArrangementCodesRequest) XHotelid(xHotelid string) ApiGetExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r ApiGetExpenseArrangementCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) ApiGetExpenseArrangementCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r ApiGetExpenseArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) ApiGetExpenseArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r ApiGetExpenseArrangementCodesRequest) WildCard(wildCard string) ApiGetExpenseArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ApiGetExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) ApiGetExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) ApiGetExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExpenseArrangementCodesRequest) Execute() (*ExpenseArrangementCodes, *http.Response, error) {
	return r.ApiService.GetExpenseArrangementCodesExecute(r)
}

/*
GetExpenseArrangementCodes Operation to fetch ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>getExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) GetExpenseArrangementCodes(ctx context.Context) ApiGetExpenseArrangementCodesRequest {
	return ApiGetExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExpenseArrangementCodes
func (a *CashieringConfigApiService) GetExpenseArrangementCodesExecute(r ApiGetExpenseArrangementCodesRequest) (*ExpenseArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	codes *[]string
	wildCard *string
	internal *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetFiscalFolioParametersRequest) HotelIds(hotelIds []string) ApiGetFiscalFolioParametersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFiscalFolioParametersRequest) Authorization(authorization string) ApiGetFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFiscalFolioParametersRequest) XAppKey(xAppKey string) ApiGetFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFiscalFolioParametersRequest) XHotelid(xHotelid string) ApiGetFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetFiscalFolioParametersRequest) Code(code []string) ApiGetFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// Codes to be searched.
func (r ApiGetFiscalFolioParametersRequest) Codes(codes []string) ApiGetFiscalFolioParametersRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ApiGetFiscalFolioParametersRequest) WildCard(wildCard string) ApiGetFiscalFolioParametersRequest {
	r.wildCard = &wildCard
	return r
}

// Indicates whether the Fiscal Folio Parameter is user created or from seed data. Set this true to see the standard Fiscal Folio Parameters that are seeded along with the manually created Fiscal Folio Parameters.
func (r ApiGetFiscalFolioParametersRequest) Internal(internal bool) ApiGetFiscalFolioParametersRequest {
	r.internal = &internal
	return r
}

// External system code.
func (r ApiGetFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) ApiGetFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) ApiGetFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFiscalFolioParametersRequest) Execute() (*FiscalFolioParameters, *http.Response, error) {
	return r.ApiService.GetFiscalFolioParametersExecute(r)
}

/*
GetFiscalFolioParameters Operation to fetch FiscalFolioParameters.

Operation to fetch Fiscal Folio Parameters. <p><strong>OperationId:</strong>getFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) GetFiscalFolioParameters(ctx context.Context) ApiGetFiscalFolioParametersRequest {
	return ApiGetFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalFolioParameters
func (a *CashieringConfigApiService) GetFiscalFolioParametersExecute(r ApiGetFiscalFolioParametersRequest) (*FiscalFolioParameters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalFolioParameters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioTypeLegendMappingsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	legendCode *string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with folio type legend mapping
func (r ApiGetFolioTypeLegendMappingsConfigRequest) HotelId(hotelId string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.hotelId = &hotelId
	return r
}

// Legend code to which folio types attached.
func (r ApiGetFolioTypeLegendMappingsConfigRequest) LegendCode(legendCode string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.legendCode = &legendCode
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioTypeLegendMappingsConfigRequest) Authorization(authorization string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioTypeLegendMappingsConfigRequest) XAppKey(xAppKey string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioTypeLegendMappingsConfigRequest) XHotelid(xHotelid string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio type to be searched.
func (r ApiGetFolioTypeLegendMappingsConfigRequest) FolioType(folioType string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.folioType = &folioType
	return r
}

// External system code.
func (r ApiGetFolioTypeLegendMappingsConfigRequest) XExternalsystem(xExternalsystem string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioTypeLegendMappingsConfigRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioTypeLegendMappingsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioTypeLegendMappingsConfigRequest) Execute() (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	return r.ApiService.GetFolioTypeLegendMappingsConfigExecute(r)
}

/*
GetFolioTypeLegendMappingsConfig Operation to fetch folio type legend mappings config.

Operation to fetch folio type legend mappings config. <p><strong>OperationId:</strong>getFolioTypeLegendMappingsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFolioTypeLegendMappingsConfigRequest
*/
func (a *CashieringConfigApiService) GetFolioTypeLegendMappingsConfig(ctx context.Context) ApiGetFolioTypeLegendMappingsConfigRequest {
	return ApiGetFolioTypeLegendMappingsConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingsConfigDetails
func (a *CashieringConfigApiService) GetFolioTypeLegendMappingsConfigExecute(r ApiGetFolioTypeLegendMappingsConfigRequest) (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingsConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFolioTypeLegendMappingsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelId == nil {
		return localVarReturnValue, nil, reportError("hotelId is required and must be specified")
	}
	if r.legendCode == nil {
		return localVarReturnValue, nil, reportError("legendCode is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "legendCode", r.legendCode, "")
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFuturePastExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	currencyCode string
	hotelId string
	exchangeTypes *string
	authorization *string
	xAppKey *string
	xHotelid *string
	dateRangeStart *string
	dateRangeEnd *string
	xExternalsystem *string
	acceptLanguage *string
}

// E-certificate conversion.
func (r ApiGetFuturePastExchangeRatesRequest) ExchangeTypes(exchangeTypes string) ApiGetFuturePastExchangeRatesRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFuturePastExchangeRatesRequest) Authorization(authorization string) ApiGetFuturePastExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFuturePastExchangeRatesRequest) XAppKey(xAppKey string) ApiGetFuturePastExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFuturePastExchangeRatesRequest) XHotelid(xHotelid string) ApiGetFuturePastExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetFuturePastExchangeRatesRequest) DateRangeStart(dateRangeStart string) ApiGetFuturePastExchangeRatesRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

func (r ApiGetFuturePastExchangeRatesRequest) DateRangeEnd(dateRangeEnd string) ApiGetFuturePastExchangeRatesRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// External system code.
func (r ApiGetFuturePastExchangeRatesRequest) XExternalsystem(xExternalsystem string) ApiGetFuturePastExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFuturePastExchangeRatesRequest) AcceptLanguage(acceptLanguage string) ApiGetFuturePastExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFuturePastExchangeRatesRequest) Execute() ([]ExchangeRateType, *http.Response, error) {
	return r.ApiService.GetFuturePastExchangeRatesExecute(r)
}

/*
GetFuturePastExchangeRates Operation to fetch FuturePastExchangeRates.

Operation to Fetch Future Past Exchange Rates. <p><strong>OperationId:</strong>getFuturePastExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyCode Currency Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return ApiGetFuturePastExchangeRatesRequest
*/
func (a *CashieringConfigApiService) GetFuturePastExchangeRates(ctx context.Context, currencyCode string, hotelId string) ApiGetFuturePastExchangeRatesRequest {
	return ApiGetFuturePastExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
		currencyCode: currencyCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []ExchangeRateType
func (a *CashieringConfigApiService) GetFuturePastExchangeRatesExecute(r ApiGetFuturePastExchangeRatesRequest) ([]ExchangeRateType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExchangeRateType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFuturePastExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exchangeRates/{currencyCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.exchangeTypes == nil {
		return localVarReturnValue, nil, reportError("exchangeTypes is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", r.exchangeTypes, "")
	if r.dateRangeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
	}
	if r.dateRangeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypeCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetTaxTypesRequest) HotelIds(hotelIds []string) ApiGetTaxTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaxTypesRequest) Authorization(authorization string) ApiGetTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaxTypesRequest) XAppKey(xAppKey string) ApiGetTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaxTypesRequest) XHotelid(xHotelid string) ApiGetTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ApiGetTaxTypesRequest) TaxTypeCodes(taxTypeCodes []string) ApiGetTaxTypesRequest {
	r.taxTypeCodes = &taxTypeCodes
	return r
}

// Wildcard search on the code.
func (r ApiGetTaxTypesRequest) WildCard(wildCard string) ApiGetTaxTypesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ApiGetTaxTypesRequest) XExternalsystem(xExternalsystem string) ApiGetTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaxTypesRequest) AcceptLanguage(acceptLanguage string) ApiGetTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaxTypesRequest) Execute() (*TaxTypes, *http.Response, error) {
	return r.ApiService.GetTaxTypesExecute(r)
}

/*
GetTaxTypes Operation to fetch TaxTypes.

Operation to fetch Tax Types. <p><strong>OperationId:</strong>getTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTaxTypesRequest
*/
func (a *CashieringConfigApiService) GetTaxTypes(ctx context.Context) ApiGetTaxTypesRequest {
	return ApiGetTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxTypes
func (a *CashieringConfigApiService) GetTaxTypesExecute(r ApiGetTaxTypesRequest) (*TaxTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.taxTypeCodes != nil {
		t := *r.taxTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *PutAdjustmentCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAdjustmentCodesRequest) Authorization(authorization string) ApiPostAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAdjustmentCodesRequest) XAppKey(xAppKey string) ApiPostAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAdjustmentCodesRequest) XHotelid(xHotelid string) ApiPostAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Adjustment Code Configurations.
func (r ApiPostAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes PutAdjustmentCodesRequest) ApiPostAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r ApiPostAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) ApiPostAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) ApiPostAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdjustmentCodesExecute(r)
}

/*
PostAdjustmentCodes Operation to create AdjustmentCodes.

Operation to create Adjustment Codes. <p><strong>OperationId:</strong>postAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) PostAdjustmentCodes(ctx context.Context) ApiPostAdjustmentCodesRequest {
	return ApiPostAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAdjustmentCodesExecute(r ApiPostAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.adjustmentCodes == nil {
		return localVarReturnValue, nil, reportError("adjustmentCodes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *PutArticlesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostArticlesRequest) Authorization(authorization string) ApiPostArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostArticlesRequest) XAppKey(xAppKey string) ApiPostArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostArticlesRequest) XHotelid(xHotelid string) ApiPostArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create articles.
func (r ApiPostArticlesRequest) Articles(articles PutArticlesRequest) ApiPostArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r ApiPostArticlesRequest) XExternalsystem(xExternalsystem string) ApiPostArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostArticlesRequest) AcceptLanguage(acceptLanguage string) ApiPostArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostArticlesExecute(r)
}

/*
PostArticles Operation to create Articles.

Operation to create articles. <p><strong>OperationId:</strong>postArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostArticlesRequest
*/
func (a *CashieringConfigApiService) PostArticles(ctx context.Context) ApiPostArticlesRequest {
	return ApiPostArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostArticlesExecute(r ApiPostArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.articles == nil {
		return localVarReturnValue, nil, reportError("articles is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *PutAuthorizationConfigRuleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAuthorizationConfigRuleRequest) Authorization(authorization string) ApiPostAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAuthorizationConfigRuleRequest) XAppKey(xAppKey string) ApiPostAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAuthorizationConfigRuleRequest) XHotelid(xHotelid string) ApiPostAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new authorization rule for given hotel code.
func (r ApiPostAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules PutAuthorizationConfigRuleRequest) ApiPostAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r ApiPostAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) ApiPostAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) ApiPostAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizationConfigRuleExecute(r)
}

/*
PostAuthorizationConfigRule Operation to create AuthorizationConfigRule.

 <p><strong>OperationId:</strong>postAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) PostAuthorizationConfigRule(ctx context.Context) ApiPostAuthorizationConfigRuleRequest {
	return ApiPostAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAuthorizationConfigRuleExecute(r ApiPostAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.authorizationConfigRules == nil {
		return localVarReturnValue, nil, reportError("authorizationConfigRules is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroups *PostAuthorizerGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAuthorizerGroupsRequest) Authorization(authorization string) ApiPostAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAuthorizerGroupsRequest) XAppKey(xAppKey string) ApiPostAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAuthorizerGroupsRequest) XHotelid(xHotelid string) ApiPostAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Authorizer Group Configuration.
func (r ApiPostAuthorizerGroupsRequest) AuthorizerGroups(authorizerGroups PostAuthorizerGroupsRequest) ApiPostAuthorizerGroupsRequest {
	r.authorizerGroups = &authorizerGroups
	return r
}

// External system code.
func (r ApiPostAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) ApiPostAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) ApiPostAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizerGroupsExecute(r)
}

/*
PostAuthorizerGroups Operation to create AuthorizerGroups.

Operation to create Authorizer Groups. <p><strong>OperationId:</strong>postAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) PostAuthorizerGroups(ctx context.Context) ApiPostAuthorizerGroupsRequest {
	return ApiPostAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAuthorizerGroupsExecute(r ApiPostAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.authorizerGroups == nil {
		return localVarReturnValue, nil, reportError("authorizerGroups is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *PutCashiersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCashiersRequest) Authorization(authorization string) ApiPostCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCashiersRequest) XAppKey(xAppKey string) ApiPostCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCashiersRequest) XHotelid(xHotelid string) ApiPostCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating cashiers.
func (r ApiPostCashiersRequest) Cashiers(cashiers PutCashiersRequest) ApiPostCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r ApiPostCashiersRequest) XExternalsystem(xExternalsystem string) ApiPostCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCashiersRequest) AcceptLanguage(acceptLanguage string) ApiPostCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCashiersExecute(r)
}

/*
PostCashiers Operation to create Cashiers.

Operation to Create Cashier. <p><strong>OperationId:</strong>postCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCashiersRequest
*/
func (a *CashieringConfigApiService) PostCashiers(ctx context.Context) ApiPostCashiersRequest {
	return ApiPostCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCashiersExecute(r ApiPostCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cashiers == nil {
		return localVarReturnValue, nil, reportError("cashiers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesCriteria *PostCompTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCompTypesRequest) Authorization(authorization string) ApiPostCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCompTypesRequest) XAppKey(xAppKey string) ApiPostCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCompTypesRequest) XHotelid(xHotelid string) ApiPostCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating CompTypes.
func (r ApiPostCompTypesRequest) CompTypesCriteria(compTypesCriteria PostCompTypesRequest) ApiPostCompTypesRequest {
	r.compTypesCriteria = &compTypesCriteria
	return r
}

// External system code.
func (r ApiPostCompTypesRequest) XExternalsystem(xExternalsystem string) ApiPostCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCompTypesRequest) AcceptLanguage(acceptLanguage string) ApiPostCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompTypesExecute(r)
}

/*
PostCompTypes Operation to Create Comp Types

Operation to Create Comp Types <p><strong>OperationId:</strong>postCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCompTypesRequest
*/
func (a *CashieringConfigApiService) PostCompTypes(ctx context.Context) ApiPostCompTypesRequest {
	return ApiPostCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCompTypesExecute(r ApiPostCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.compTypesCriteria == nil {
		return localVarReturnValue, nil, reportError("compTypesCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *PutCurrencyExchangeServiceTaxesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) ApiPostCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) ApiPostCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) ApiPostCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new currency exchange service taxes
func (r ApiPostCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes PutCurrencyExchangeServiceTaxesRequest) ApiPostCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r ApiPostCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) ApiPostCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) ApiPostCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCurrencyExchangeServiceTaxesExecute(r)
}

/*
PostCurrencyExchangeServiceTaxes Operation to create CurrencyExchangeServiceTaxes.

Operation to create currency exchange service taxes. <p><strong>OperationId:</strong>postCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) PostCurrencyExchangeServiceTaxes(ctx context.Context) ApiPostCurrencyExchangeServiceTaxesRequest {
	return ApiPostCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCurrencyExchangeServiceTaxesExecute(r ApiPostCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.currencyExchangeServiceTaxes == nil {
		return localVarReturnValue, nil, reportError("currencyExchangeServiceTaxes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *PutExpenseArrangementCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostExpenseArrangementCodesRequest) Authorization(authorization string) ApiPostExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostExpenseArrangementCodesRequest) XAppKey(xAppKey string) ApiPostExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostExpenseArrangementCodesRequest) XHotelid(xHotelid string) ApiPostExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new expense arrangement codes.
func (r ApiPostExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes PutExpenseArrangementCodesRequest) ApiPostExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r ApiPostExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) ApiPostExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) ApiPostExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExpenseArrangementCodesExecute(r)
}

/*
PostExpenseArrangementCodes Operation to create ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>postExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) PostExpenseArrangementCodes(ctx context.Context) ApiPostExpenseArrangementCodesRequest {
	return ApiPostExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostExpenseArrangementCodesExecute(r ApiPostExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.expenseArrangementCodes == nil {
		return localVarReturnValue, nil, reportError("expenseArrangementCodes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigCriteria *PostFolioTypeLegendMappingConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostFolioTypeLegendMappingConfigRequest) Authorization(authorization string) ApiPostFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) ApiPostFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) ApiPostFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create folio type legend mapping information.
func (r ApiPostFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigCriteria(folioTypeLegendMappingConfigCriteria PostFolioTypeLegendMappingConfigRequest) ApiPostFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigCriteria = &folioTypeLegendMappingConfigCriteria
	return r
}

// External system code.
func (r ApiPostFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) ApiPostFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) ApiPostFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioTypeLegendMappingConfigExecute(r)
}

/*
PostFolioTypeLegendMappingConfig Operation to create folio type legend mappings config.

Operation to create folio type legend mappings config. <p><strong>OperationId:</strong>postFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) PostFolioTypeLegendMappingConfig(ctx context.Context) ApiPostFolioTypeLegendMappingConfigRequest {
	return ApiPostFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostFolioTypeLegendMappingConfigExecute(r ApiPostFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.folioTypeLegendMappingConfigCriteria == nil {
		return localVarReturnValue, nil, reportError("folioTypeLegendMappingConfigCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *PutAdjustmentCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAdjustmentCodesRequest) Authorization(authorization string) ApiPutAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAdjustmentCodesRequest) XAppKey(xAppKey string) ApiPutAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAdjustmentCodesRequest) XHotelid(xHotelid string) ApiPutAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Adjustment Code Configurations.
func (r ApiPutAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes PutAdjustmentCodesRequest) ApiPutAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r ApiPutAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) ApiPutAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) ApiPutAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAdjustmentCodesExecute(r)
}

/*
PutAdjustmentCodes Operation to change AdjustmentCodes.

Operation to change Adjustment Codes. <p><strong>OperationId:</strong>putAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) PutAdjustmentCodes(ctx context.Context) ApiPutAdjustmentCodesRequest {
	return ApiPutAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAdjustmentCodesExecute(r ApiPutAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.adjustmentCodes == nil {
		return localVarReturnValue, nil, reportError("adjustmentCodes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *PutArticlesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutArticlesRequest) Authorization(authorization string) ApiPutArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutArticlesRequest) XAppKey(xAppKey string) ApiPutArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutArticlesRequest) XHotelid(xHotelid string) ApiPutArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change articles.
func (r ApiPutArticlesRequest) Articles(articles PutArticlesRequest) ApiPutArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r ApiPutArticlesRequest) XExternalsystem(xExternalsystem string) ApiPutArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutArticlesRequest) AcceptLanguage(acceptLanguage string) ApiPutArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutArticlesExecute(r)
}

/*
PutArticles Operation to change Articles.

Operation to change articles. <p><strong>OperationId:</strong>putArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutArticlesRequest
*/
func (a *CashieringConfigApiService) PutArticles(ctx context.Context) ApiPutArticlesRequest {
	return ApiPutArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutArticlesExecute(r ApiPutArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.articles == nil {
		return localVarReturnValue, nil, reportError("articles is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *PutAuthorizationConfigRuleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAuthorizationConfigRuleRequest) Authorization(authorization string) ApiPutAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAuthorizationConfigRuleRequest) XAppKey(xAppKey string) ApiPutAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAuthorizationConfigRuleRequest) XHotelid(xHotelid string) ApiPutAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change authorization rule.
func (r ApiPutAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules PutAuthorizationConfigRuleRequest) ApiPutAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r ApiPutAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) ApiPutAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) ApiPutAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizationConfigRuleExecute(r)
}

/*
PutAuthorizationConfigRule Operation to change AuthorizationConfigRule.

 <p><strong>OperationId:</strong>putAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) PutAuthorizationConfigRule(ctx context.Context) ApiPutAuthorizationConfigRuleRequest {
	return ApiPutAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAuthorizationConfigRuleExecute(r ApiPutAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.authorizationConfigRules == nil {
		return localVarReturnValue, nil, reportError("authorizationConfigRules is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsToChange *PutAuthorizerGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAuthorizerGroupsRequest) Authorization(authorization string) ApiPutAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAuthorizerGroupsRequest) XAppKey(xAppKey string) ApiPutAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAuthorizerGroupsRequest) XHotelid(xHotelid string) ApiPutAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Authorizer Group Configuration.
func (r ApiPutAuthorizerGroupsRequest) AuthorizerGroupsToChange(authorizerGroupsToChange PutAuthorizerGroupsRequest) ApiPutAuthorizerGroupsRequest {
	r.authorizerGroupsToChange = &authorizerGroupsToChange
	return r
}

// External system code.
func (r ApiPutAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) ApiPutAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) ApiPutAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizerGroupsExecute(r)
}

/*
PutAuthorizerGroups Operation to change AuthorizerGroups.

Operation to change Authorizer Groups. <p><strong>OperationId:</strong>putAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) PutAuthorizerGroups(ctx context.Context) ApiPutAuthorizerGroupsRequest {
	return ApiPutAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAuthorizerGroupsExecute(r ApiPutAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.authorizerGroupsToChange == nil {
		return localVarReturnValue, nil, reportError("authorizerGroupsToChange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroupsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *PutCashiersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCashiersRequest) Authorization(authorization string) ApiPutCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCashiersRequest) XAppKey(xAppKey string) ApiPutCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCashiersRequest) XHotelid(xHotelid string) ApiPutCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request objects for modifying cashiers
func (r ApiPutCashiersRequest) Cashiers(cashiers PutCashiersRequest) ApiPutCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r ApiPutCashiersRequest) XExternalsystem(xExternalsystem string) ApiPutCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCashiersRequest) AcceptLanguage(acceptLanguage string) ApiPutCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCashiersExecute(r)
}

/*
PutCashiers Operation to change CashiersDetails.

This Operation to Change a Cashier. <p><strong>OperationId:</strong>putCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCashiersRequest
*/
func (a *CashieringConfigApiService) PutCashiers(ctx context.Context) ApiPutCashiersRequest {
	return ApiPutCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutCashiersExecute(r ApiPutCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cashiers == nil {
		return localVarReturnValue, nil, reportError("cashiers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *PutCurrencyExchangeServiceTaxesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) ApiPutCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) ApiPutCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) ApiPutCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing currency exchange service taxes
func (r ApiPutCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes PutCurrencyExchangeServiceTaxesRequest) ApiPutCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r ApiPutCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) ApiPutCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) ApiPutCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCurrencyExchangeServiceTaxesExecute(r)
}

/*
PutCurrencyExchangeServiceTaxes Operation to change ExchangeServiceTaxes.

Operation to change currency exchange service taxes. <p><strong>OperationId:</strong>putCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) PutCurrencyExchangeServiceTaxes(ctx context.Context) ApiPutCurrencyExchangeServiceTaxesRequest {
	return ApiPutCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutCurrencyExchangeServiceTaxesExecute(r ApiPutCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.currencyExchangeServiceTaxes == nil {
		return localVarReturnValue, nil, reportError("currencyExchangeServiceTaxes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyPlanCodes *PutDailyPlanCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutDailyPlanCodesRequest) Authorization(authorization string) ApiPutDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutDailyPlanCodesRequest) XAppKey(xAppKey string) ApiPutDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutDailyPlanCodesRequest) XHotelid(xHotelid string) ApiPutDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing daily plan codes.
func (r ApiPutDailyPlanCodesRequest) DailyPlanCodes(dailyPlanCodes PutDailyPlanCodesRequest) ApiPutDailyPlanCodesRequest {
	r.dailyPlanCodes = &dailyPlanCodes
	return r
}

// External system code.
func (r ApiPutDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) ApiPutDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) ApiPutDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutDailyPlanCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDailyPlanCodesExecute(r)
}

/*
PutDailyPlanCodes Operation to change DailyPlanCodes.

 <p><strong>OperationId:</strong>putDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutDailyPlanCodesRequest
*/
func (a *CashieringConfigApiService) PutDailyPlanCodes(ctx context.Context) ApiPutDailyPlanCodesRequest {
	return ApiPutDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutDailyPlanCodesExecute(r ApiPutDailyPlanCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.dailyPlanCodes == nil {
		return localVarReturnValue, nil, reportError("dailyPlanCodes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyPlanCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *PutExpenseArrangementCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutExpenseArrangementCodesRequest) Authorization(authorization string) ApiPutExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutExpenseArrangementCodesRequest) XAppKey(xAppKey string) ApiPutExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutExpenseArrangementCodesRequest) XHotelid(xHotelid string) ApiPutExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing expense arrangement codes.
func (r ApiPutExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes PutExpenseArrangementCodesRequest) ApiPutExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r ApiPutExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) ApiPutExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) ApiPutExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutExpenseArrangementCodesExecute(r)
}

/*
PutExpenseArrangementCodes Operation to change ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>putExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) PutExpenseArrangementCodes(ctx context.Context) ApiPutExpenseArrangementCodesRequest {
	return ApiPutExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutExpenseArrangementCodesExecute(r ApiPutExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.expenseArrangementCodes == nil {
		return localVarReturnValue, nil, reportError("expenseArrangementCodes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioParameters *PutFiscalFolioParametersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutFiscalFolioParametersRequest) Authorization(authorization string) ApiPutFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutFiscalFolioParametersRequest) XAppKey(xAppKey string) ApiPutFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutFiscalFolioParametersRequest) XHotelid(xHotelid string) ApiPutFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Fiscal Folio Parameter Configurations.
func (r ApiPutFiscalFolioParametersRequest) FiscalFolioParameters(fiscalFolioParameters PutFiscalFolioParametersRequest) ApiPutFiscalFolioParametersRequest {
	r.fiscalFolioParameters = &fiscalFolioParameters
	return r
}

// External system code.
func (r ApiPutFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) ApiPutFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) ApiPutFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFiscalFolioParametersExecute(r)
}

/*
PutFiscalFolioParameters Operation to change FiscalFolioParameters.

Operation to change Fiscal Folio Parameters. <p><strong>OperationId:</strong>putFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) PutFiscalFolioParameters(ctx context.Context) ApiPutFiscalFolioParametersRequest {
	return ApiPutFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutFiscalFolioParametersExecute(r ApiPutFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fiscalFolioParameters == nil {
		return localVarReturnValue, nil, reportError("fiscalFolioParameters is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	compTypesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveCompTypesRequest) Authorization(authorization string) ApiRemoveCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveCompTypesRequest) XAppKey(xAppKey string) ApiRemoveCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveCompTypesRequest) XHotelid(xHotelid string) ApiRemoveCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiRemoveCompTypesRequest) XExternalsystem(xExternalsystem string) ApiRemoveCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveCompTypesRequest) AcceptLanguage(acceptLanguage string) ApiRemoveCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCompTypesExecute(r)
}

/*
RemoveCompTypes Operation to Remove Comp Types.

Operation to Remove Comp Types. <p><strong>OperationId:</strong>removeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param compTypesCode Comp Types Code to be deleted.
 @return ApiRemoveCompTypesRequest
*/
func (a *CashieringConfigApiService) RemoveCompTypes(ctx context.Context, compTypesCode string) ApiRemoveCompTypesRequest {
	return ApiRemoveCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		compTypesCode: compTypesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) RemoveCompTypesExecute(r ApiRemoveCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.RemoveCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes/codes/{compTypesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"compTypesCode"+"}", url.PathEscape(parameterValueToString(r.compTypesCode, "compTypesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.compTypesCode) < 1 {
		return localVarReturnValue, nil, reportError("compTypesCode must have at least 1 elements")
	}
	if strlen(r.compTypesCode) > 2000 {
		return localVarReturnValue, nil, reportError("compTypesCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	legendCode string
	folioType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveFolioTypeLegendMappingConfigRequest) Authorization(authorization string) ApiRemoveFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) ApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) ApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiRemoveFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) ApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) ApiRemoveFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFolioTypeLegendMappingConfigExecute(r)
}

/*
RemoveFolioTypeLegendMappingConfig Operation to remove folio type legend mappings config.

Operation to remove folio type legend mappings config. <p><strong>OperationId:</strong>removeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param legendCode Legend Code
 @param folioType Folio Type
 @param hotelId Unique ID of the source hotel in OPERA
 @return ApiRemoveFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) RemoveFolioTypeLegendMappingConfig(ctx context.Context, legendCode string, folioType string, hotelId string) ApiRemoveFolioTypeLegendMappingConfigRequest {
	return ApiRemoveFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
		legendCode: legendCode,
		folioType: folioType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) RemoveFolioTypeLegendMappingConfigExecute(r ApiRemoveFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.RemoveFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folios/{folioType}/legends/{legendCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"legendCode"+"}", url.PathEscape(parameterValueToString(r.legendCode, "legendCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folioType"+"}", url.PathEscape(parameterValueToString(r.folioType, "folioType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.legendCode) < 1 {
		return localVarReturnValue, nil, reportError("legendCode must have at least 1 elements")
	}
	if strlen(r.legendCode) > 2000 {
		return localVarReturnValue, nil, reportError("legendCode must have less than 2000 elements")
	}
	if strlen(r.folioType) < 1 {
		return localVarReturnValue, nil, reportError("folioType must have at least 1 elements")
	}
	if strlen(r.folioType) > 2000 {
		return localVarReturnValue, nil, reportError("folioType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
