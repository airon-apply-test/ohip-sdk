/*
OPERA Cloud Xchange Interface OXI API

APIs to create and manage OPERA Xchange Interface (OXI) configurations for OPERA Cloud Exchange module functionality.<br /><br /> Compatible with OPERA Cloud release 23.0.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 23.0.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package oxi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// OperaExchangeInterfaceConfigApiService OperaExchangeInterfaceConfigApi service
type OperaExchangeInterfaceConfigApiService service

type OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	messageId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutomaticTransmissionSchedulesExecute(r)
}

/*
DeleteAutomaticTransmissionSchedules Remove Automatic Transmission Schedules

API to Delete  Automatic Transmission Schedules by Scheduled Message Id. <p><strong>OperationId:</strong>deleteAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId Unique OPERA internal ID used to identify a hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteAutomaticTransmissionSchedules(ctx context.Context, messageId string) OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest {
	return OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteAutomaticTransmissionSchedulesExecute(r OperaExchangeInterfaceConfigApiDeleteAutomaticTransmissionSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/automaticTransmissionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.messageId) < 1 {
		return localVarReturnValue, nil, reportError("messageId must have at least 1 elements")
	}
	if strlen(r.messageId) > 2000 {
		return localVarReturnValue, nil, reportError("messageId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	id string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteConversionCodeMappingsExecute(r)
}

/*
DeleteConversionCodeMappings Remove Conversion Codes Mappings

API to Delete  Interface Mapping Conversion Codes by Conversion Code Mapping Id. <p><strong>OperationId:</strong>deleteConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Unique OPERA internal ID used to identify a Conversion Code Mapping in OPERA.
 @return OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteConversionCodeMappings(ctx context.Context, id string) OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest {
	return OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteConversionCodeMappingsExecute(r OperaExchangeInterfaceConfigApiDeleteConversionCodeMappingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversionCodeMappingID/{id}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.id) < 1 {
		return localVarReturnValue, nil, reportError("id must have at least 1 elements")
	}
	if strlen(r.id) > 2000 {
		return localVarReturnValue, nil, reportError("id must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExternalInterfaceSetupsExecute(r)
}

/*
DeleteExternalInterfaceSetups Delete external Interface Setup details

API to Delete Interface Setup configuration by Hotel Id and Interface Id. <p><strong>OperationId:</strong>deleteExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @param hotelId Unique OPERA internal ID used to find hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteExternalInterfaceSetups(ctx context.Context, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest {
	return OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteExternalInterfaceSetupsExecute(r OperaExchangeInterfaceConfigApiDeleteExternalInterfaceSetupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/externalInterfaceSetups"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	profileType string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileMatchRulesExecute(r)
}

/*
DeleteProfileMatchRules Delete profile match rules

API to Delete  Profile Match Rules by Hotel Id, Interface Id and Profile Type. <p><strong>OperationId:</strong>deleteProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileType Unique OPERA internal ID used to identify an Profile in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify an hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteProfileMatchRules(ctx context.Context, profileType string, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest {
	return OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
		profileType: profileType,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteProfileMatchRulesExecute(r OperaExchangeInterfaceConfigApiDeleteProfileMatchRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/profiles/{profileType}/profileMatchRules"
	localVarPath = strings.Replace(localVarPath, "{"+"profileType"+"}", url.PathEscape(parameterValueToString(r.profileType, "profileType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileType) < 1 {
		return localVarReturnValue, nil, reportError("profileType must have at least 1 elements")
	}
	if strlen(r.profileType) > 2000 {
		return localVarReturnValue, nil, reportError("profileType must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	operaValue string
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Profile type of the user-defined function (UDF) definition.
func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) ProfileType(profileType string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	r.profileType = &profileType
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteUDFMappingsExecute(r)
}

/*
DeleteUDFMappings Remove UDF Mappings

API to Delete Interface Mapping UDF Conversion Codes by Hotel Id, Interface Id and Conversion Code. <p><strong>OperationId:</strong>deleteUDFMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operaValue PMS Conversion Code value.
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteUDFMappings(ctx context.Context, operaValue string, conversionCode string, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest {
	return OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest{
		ApiService: a,
		ctx: ctx,
		operaValue: operaValue,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteUDFMappingsExecute(r OperaExchangeInterfaceConfigApiDeleteUDFMappingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteUDFMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversionCode/{conversionCode}/operaValue/{operaValue}/udfMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"operaValue"+"}", url.PathEscape(parameterValueToString(r.operaValue, "operaValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.operaValue) < 1 {
		return localVarReturnValue, nil, reportError("operaValue must have at least 1 elements")
	}
	if strlen(r.operaValue) > 2000 {
		return localVarReturnValue, nil, reportError("operaValue must have less than 2000 elements")
	}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	modules *[]string
	endDate *string
	startDate *string
	primaryKey *string
	status *string
	hotelIds *[]string
	integrationSystem *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) Limit(limit int32) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) Offset(offset int32) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.offset = &offset
	return r
}

// Accumulated Business Event Module
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) Modules(modules []string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.modules = &modules
	return r
}

// The ending value of the date range.
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) EndDate(endDate string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) StartDate(startDate string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.startDate = &startDate
	return r
}

// Specify primary key identifier to search for
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) PrimaryKey(primaryKey string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.primaryKey = &primaryKey
	return r
}

// State of Accumulated Business Event
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) Status(status string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.status = &status
	return r
}

func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) HotelIds(hotelIds []string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) IntegrationSystem(integrationSystem string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) Execute() (*FetchAccumulatedBusinessEvents, *http.Response, error) {
	return r.ApiService.GetAccumulatedBusinessEventsExecute(r)
}

/*
GetAccumulatedBusinessEvents Fetch accumulated business events

API to Fetch  Accumulated Business Event Messages for External Systems by Hotel Id, Interface Id. <p><strong>OperationId:</strong>getAccumulatedBusinessEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetAccumulatedBusinessEvents(ctx context.Context, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest {
	return OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchAccumulatedBusinessEvents
func (a *OperaExchangeInterfaceConfigApiService) GetAccumulatedBusinessEventsExecute(r OperaExchangeInterfaceConfigApiGetAccumulatedBusinessEventsRequest) (*FetchAccumulatedBusinessEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchAccumulatedBusinessEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetAccumulatedBusinessEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/accumulatedBusinessEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.modules != nil {
		t := *r.modules
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "modules", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "modules", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.primaryKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryKey", r.primaryKey, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	interfaceList *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) HotelIds(hotelIds []string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Interfaces configured for automatic transmission schedules
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) InterfaceList(interfaceList []string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.interfaceList = &interfaceList
	return r
}

// If true, this flag will set the criteria to return Inactive records along with active records.
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) IncludeInactive(includeInactive bool) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) Execute() (*FetchAutomaticTransmissionSchedules, *http.Response, error) {
	return r.ApiService.GetAutomaticTransmissionSchedulesExecute(r)
}

/*
GetAutomaticTransmissionSchedules Fetch Automatic Transmission Schedules

API to Fetch Automatic Transmission Schedules by Hotel Id. <p><strong>OperationId:</strong>getAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA internal ID used to identify a hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetAutomaticTransmissionSchedules(ctx context.Context, hotelId string) OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest {
	return OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchAutomaticTransmissionSchedules
func (a *OperaExchangeInterfaceConfigApiService) GetAutomaticTransmissionSchedulesExecute(r OperaExchangeInterfaceConfigApiGetAutomaticTransmissionSchedulesRequest) (*FetchAutomaticTransmissionSchedules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchAutomaticTransmissionSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/automaticTransmissionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceList != nil {
		t := *r.interfaceList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceList", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	isGlobal *bool
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	interfaceIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// SID Resort
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) IsGlobal(isGlobal bool) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.isGlobal = &isGlobal
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) HotelId(hotelId []string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.hotelId = &hotelId
	return r
}

// InterfaceID
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) InterfaceIds(interfaceIds []string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.interfaceIds = &interfaceIds
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) Execute() (*FetchCommunicationMethods, *http.Response, error) {
	return r.ApiService.GetCommunicationMethodsExecute(r)
}

/*
GetCommunicationMethods Fetch Communication Methods

API to Fetch Communication Methods. <p><strong>OperationId:</strong>getCommunicationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @return OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetCommunicationMethods(ctx context.Context, interfaceId string) OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest {
	return OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return FetchCommunicationMethods
func (a *OperaExchangeInterfaceConfigApiService) GetCommunicationMethodsExecute(r OperaExchangeInterfaceConfigApiGetCommunicationMethodsRequest) (*FetchCommunicationMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchCommunicationMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetCommunicationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/intefaces/{interfaceId}/communicationMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "isGlobal", r.isGlobal, "")
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
	}
	if r.interfaceIds != nil {
		t := *r.interfaceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	udfCode *bool
	mappingValue *string
	searchBy *string
	includeGlobal *bool
	profileType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) IntegrationSystem(integrationSystem string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// A flag that is true if the conversion code is an user-defined function (UDF) module code.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) UdfCode(udfCode bool) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.udfCode = &udfCode
	return r
}

// This value is used for wild card search on OPERA Code/External code.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) MappingValue(mappingValue string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.mappingValue = &mappingValue
	return r
}

// Search for both OPERA and External mapping value.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) SearchBy(searchBy string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.searchBy = &searchBy
	return r
}

// A flag to indicate whether to include Global Mappings or not.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) IncludeGlobal(includeGlobal bool) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.includeGlobal = &includeGlobal
	return r
}

// Profile type by which the user-defined function (UDF) mappings should be filtered.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) ProfileType(profileType string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.profileType = &profileType
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) Execute() (*FetchConversionCodeMappings, *http.Response, error) {
	return r.ApiService.GetConversionCodeMappingsExecute(r)
}

/*
GetConversionCodeMappings Fetch Conversion Code Mappings

API to Fetch Interface Mapping  Conversion Codes by Hotel Id, Interface Id and Conversion Code. <p><strong>OperationId:</strong>getConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodeMappings(ctx context.Context, conversionCode string, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest {
	return OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchConversionCodeMappings
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodeMappingsExecute(r OperaExchangeInterfaceConfigApiGetConversionCodeMappingsRequest) (*FetchConversionCodeMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchConversionCodeMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversions/{conversionCode}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.udfCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udfCode", r.udfCode, "")
	}
	if r.mappingValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mappingValue", r.mappingValue, "")
	}
	if r.searchBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", r.searchBy, "")
	}
	if r.includeGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGlobal", r.includeGlobal, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetConversionCodesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	conversionCode *string
	udfCode *bool
	includeInactive *bool
	group *string
	includeUDFCodes *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) IntegrationSystem(integrationSystem string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// Type of Conversion Code or user-defined function (UDF) module name configured in the system.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) ConversionCode(conversionCode string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.conversionCode = &conversionCode
	return r
}

// A flag that is true if the conversion code is an user-defined function (UDF) module code.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) UdfCode(udfCode bool) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.udfCode = &udfCode
	return r
}

// A flag to indicate whether to include inactive Conversion Codes.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) IncludeInactive(includeInactive bool) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// XML Type by which the Conversion Codes should be filtered.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) Group(group string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.group = &group
	return r
}

// A flag to indicate whether user-defined function (UDF) module names should be included in the results or not.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) IncludeUDFCodes(includeUDFCodes bool) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.includeUDFCodes = &includeUDFCodes
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) Execute() (*FetchConversionCodes, *http.Response, error) {
	return r.ApiService.GetConversionCodesExecute(r)
}

/*
GetConversionCodes Fetch Conversion Codes

API to Fetch Interface Mappings UDF Conversion Codes by Hotel Id and Interface Id. <p><strong>OperationId:</strong>getConversionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetConversionCodesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodes(ctx context.Context, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiGetConversionCodesRequest {
	return OperaExchangeInterfaceConfigApiGetConversionCodesRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchConversionCodes
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodesExecute(r OperaExchangeInterfaceConfigApiGetConversionCodesRequest) (*FetchConversionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchConversionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetConversionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/intefaces/{interfaceId}/conversionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.conversionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conversionCode", r.conversionCode, "")
	}
	if r.udfCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udfCode", r.udfCode, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.includeUDFCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUDFCodes", r.includeUDFCodes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	interfaceIds *[]string
	hotelIds *[]string
	includeXmlVersion *bool
	systemType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// InterfaceID
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) InterfaceIds(interfaceIds []string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.interfaceIds = &interfaceIds
	return r
}

func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) HotelIds(hotelIds []string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Attribute that decides whether the search results include the XML Schema version details
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) IncludeXmlVersion(includeXmlVersion bool) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.includeXmlVersion = &includeXmlVersion
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) SystemType(systemType string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.systemType = &systemType
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) Execute() (*FetchExternalInterfaceSetups, *http.Response, error) {
	return r.ApiService.GetExternalInterfaceSetupsExecute(r)
}

/*
GetExternalInterfaceSetups fetch external Interface Setup details

API to Fetch Interface Setup configurations by Interface Ids and Hotel Ids. <p><strong>OperationId:</strong>getExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetExternalInterfaceSetups(ctx context.Context) OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest {
	return OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchExternalInterfaceSetups
func (a *OperaExchangeInterfaceConfigApiService) GetExternalInterfaceSetupsExecute(r OperaExchangeInterfaceConfigApiGetExternalInterfaceSetupsRequest) (*FetchExternalInterfaceSetups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchExternalInterfaceSetups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceSetups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interfaceIds != nil {
		t := *r.interfaceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeXmlVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeXmlVersion", r.includeXmlVersion, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	integrationSystem string
	interfaceId string
	externalHotelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	externalHotelCodes *[]string
	messageTypes *[]string
	endDate *string
	startDate *string
	includeReviewed *bool
	fromMessageID *string
	toMessageID *string
	messageStatus *[]string
	messageReference *string
	errorMessageWildCard *string
	errorMessageType *string
	msgContains *string
	anyOneOfTheMsg *bool
	valuesOnly *bool
	limit *int32
	offset *int32
	includeErrors *bool
	actionId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Unique External hotel IDs used to identify external Hotel in OPERA
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) ExternalHotelCodes(externalHotelCodes []string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.externalHotelCodes = &externalHotelCodes
	return r
}

// Sepcify Message type to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) MessageTypes(messageTypes []string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.messageTypes = &messageTypes
	return r
}

// The ending value of the date range.
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) EndDate(endDate string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) StartDate(startDate string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.startDate = &startDate
	return r
}

// If true, messages that are marked as reviewed will also be fetched
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) IncludeReviewed(includeReviewed bool) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.includeReviewed = &includeReviewed
	return r
}

// The starting value of the range
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) FromMessageID(fromMessageID string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.fromMessageID = &fromMessageID
	return r
}

// The ending value of the range
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) ToMessageID(toMessageID string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.toMessageID = &toMessageID
	return r
}

// Specify Integration message reference value to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) MessageStatus(messageStatus []string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.messageStatus = &messageStatus
	return r
}

// Specify Integration message reference value to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) MessageReference(messageReference string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.messageReference = &messageReference
	return r
}

// Specify partial or complete error message to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) ErrorMessageWildCard(errorMessageWildCard string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.errorMessageWildCard = &errorMessageWildCard
	return r
}

// This value is only applicable for outbound messages
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) ErrorMessageType(errorMessageType string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.errorMessageType = &errorMessageType
	return r
}

// String to search inside a message. User can specify multiple strings separated by comma
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) MsgContains(msgContains string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.msgContains = &msgContains
	return r
}

// If true then results with message that has at least one of the string specified for message contains will be returned.
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) AnyOneOfTheMsg(anyOneOfTheMsg bool) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.anyOneOfTheMsg = &anyOneOfTheMsg
	return r
}

// If true then passed string will be matched against the node values of the XML message
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) ValuesOnly(valuesOnly bool) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.valuesOnly = &valuesOnly
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) Limit(limit int32) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) Offset(offset int32) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.offset = &offset
	return r
}

// If true then errors and warnings will be fetched for action id and other criteria mentioned
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) IncludeErrors(includeErrors bool) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.includeErrors = &includeErrors
	return r
}

// Action ID for which errors and warnings should be fetched
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) ActionId(actionId string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.actionId = &actionId
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) Execute() (*FetchIntegrationInboundMessages, *http.Response, error) {
	return r.ApiService.GetIntegrationInboundMessagesExecute(r)
}

/*
GetIntegrationInboundMessages Fetch integration inbound messages 

API to Fetch Inbound Messages From External System by Hotel Id, Interface Id. <p><strong>OperationId:</strong>getIntegrationInboundMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSystem Unique OPERA IntegrationSystem used to identify a IntegrationSystem in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param externalHotelCode Unique External hotel ID used to identify a external Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationInboundMessages(ctx context.Context, integrationSystem string, interfaceId string, externalHotelCode string) OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest {
	return OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest{
		ApiService: a,
		ctx: ctx,
		integrationSystem: integrationSystem,
		interfaceId: interfaceId,
		externalHotelCode: externalHotelCode,
	}
}

// Execute executes the request
//  @return FetchIntegrationInboundMessages
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationInboundMessagesExecute(r OperaExchangeInterfaceConfigApiGetIntegrationInboundMessagesRequest) (*FetchIntegrationInboundMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchIntegrationInboundMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetIntegrationInboundMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{externalHotelCode}/interfaces/{interfaceId}/integrationSystems/{integrationSystem}/integrationInboundMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSystem"+"}", url.PathEscape(parameterValueToString(r.integrationSystem, "integrationSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalHotelCode"+"}", url.PathEscape(parameterValueToString(r.externalHotelCode, "externalHotelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.integrationSystem) < 1 {
		return localVarReturnValue, nil, reportError("integrationSystem must have at least 1 elements")
	}
	if strlen(r.integrationSystem) > 2000 {
		return localVarReturnValue, nil, reportError("integrationSystem must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.externalHotelCode) < 1 {
		return localVarReturnValue, nil, reportError("externalHotelCode must have at least 1 elements")
	}
	if strlen(r.externalHotelCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalHotelCode must have less than 2000 elements")
	}

	if r.externalHotelCodes != nil {
		t := *r.externalHotelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalHotelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalHotelCodes", t, "multi")
		}
	}
	if r.messageTypes != nil {
		t := *r.messageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.includeReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReviewed", r.includeReviewed, "")
	}
	if r.fromMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromMessageID", r.fromMessageID, "")
	}
	if r.toMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toMessageID", r.toMessageID, "")
	}
	if r.messageStatus != nil {
		t := *r.messageStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", t, "multi")
		}
	}
	if r.messageReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageReference", r.messageReference, "")
	}
	if r.errorMessageWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageWildCard", r.errorMessageWildCard, "")
	}
	if r.errorMessageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageType", r.errorMessageType, "")
	}
	if r.msgContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "msgContains", r.msgContains, "")
	}
	if r.anyOneOfTheMsg != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyOneOfTheMsg", r.anyOneOfTheMsg, "")
	}
	if r.valuesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "valuesOnly", r.valuesOnly, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.includeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeErrors", r.includeErrors, "")
	}
	if r.actionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionId", r.actionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	integrationSystem string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	actionType *string
	errorMessageWildCard *string
	errorMessageType *string
	endDate *string
	startDate *string
	includeReviewed *bool
	fromMessageID *string
	toMessageID *string
	messageStatus *[]string
	msgContains *string
	anyOneOfTheMsg *bool
	valuesOnly *bool
	messageReference *string
	messageTypes *[]string
	limit *int32
	offset *int32
	includeErrors *bool
	actionId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) HotelIds(hotelIds []string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Specify action(that has triggered the creation of message) to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) ActionType(actionType string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.actionType = &actionType
	return r
}

// Specify partial or complete error message to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) ErrorMessageWildCard(errorMessageWildCard string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.errorMessageWildCard = &errorMessageWildCard
	return r
}

// This value is only applicable for outbound messages
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) ErrorMessageType(errorMessageType string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.errorMessageType = &errorMessageType
	return r
}

// The ending value of the date range.
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) EndDate(endDate string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) StartDate(startDate string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.startDate = &startDate
	return r
}

// If true, messages that are marked as reviewed will also be fetched
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) IncludeReviewed(includeReviewed bool) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.includeReviewed = &includeReviewed
	return r
}

// The starting value of the range
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) FromMessageID(fromMessageID string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.fromMessageID = &fromMessageID
	return r
}

// The ending value of the range
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) ToMessageID(toMessageID string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.toMessageID = &toMessageID
	return r
}

// Specify Integration message reference value to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) MessageStatus(messageStatus []string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.messageStatus = &messageStatus
	return r
}

// String to search inside a message. User can specify multiple strings separated by comma
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) MsgContains(msgContains string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.msgContains = &msgContains
	return r
}

// If true then results with message that has at least one of the string specified for message contains will be returned.
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) AnyOneOfTheMsg(anyOneOfTheMsg bool) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.anyOneOfTheMsg = &anyOneOfTheMsg
	return r
}

// If true then passed string will be matched against the node values of the XML message
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) ValuesOnly(valuesOnly bool) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.valuesOnly = &valuesOnly
	return r
}

// Specify Integration message reference value to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) MessageReference(messageReference string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.messageReference = &messageReference
	return r
}

// Sepcify Message type to restrict results
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) MessageTypes(messageTypes []string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.messageTypes = &messageTypes
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) Limit(limit int32) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) Offset(offset int32) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.offset = &offset
	return r
}

// If true then errors and warnings will be fetched for action id and other criteria mentioned
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) IncludeErrors(includeErrors bool) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.includeErrors = &includeErrors
	return r
}

// Action ID for which errors and warnings should be fetched
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) ActionId(actionId string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.actionId = &actionId
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) Execute() (*FetchIntegrationOutboundMessages, *http.Response, error) {
	return r.ApiService.GetIntegrationOutboundMessagesExecute(r)
}

/*
GetIntegrationOutboundMessages fetch integration outbound messages

API to Fetch Outbound Messages To External System by Hotel Id, Interface Id. <p><strong>OperationId:</strong>getIntegrationOutboundMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSystem Unique OPERA IntegrationSystem used to identify a IntegrationSystem in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationOutboundMessages(ctx context.Context, integrationSystem string, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest {
	return OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest{
		ApiService: a,
		ctx: ctx,
		integrationSystem: integrationSystem,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchIntegrationOutboundMessages
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationOutboundMessagesExecute(r OperaExchangeInterfaceConfigApiGetIntegrationOutboundMessagesRequest) (*FetchIntegrationOutboundMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchIntegrationOutboundMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetIntegrationOutboundMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/integrationSystems/{integrationSystem}/integrationOutboundMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSystem"+"}", url.PathEscape(parameterValueToString(r.integrationSystem, "integrationSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.integrationSystem) < 1 {
		return localVarReturnValue, nil, reportError("integrationSystem must have at least 1 elements")
	}
	if strlen(r.integrationSystem) > 2000 {
		return localVarReturnValue, nil, reportError("integrationSystem must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.actionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "")
	}
	if r.errorMessageWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageWildCard", r.errorMessageWildCard, "")
	}
	if r.errorMessageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageType", r.errorMessageType, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.includeReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReviewed", r.includeReviewed, "")
	}
	if r.fromMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromMessageID", r.fromMessageID, "")
	}
	if r.toMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toMessageID", r.toMessageID, "")
	}
	if r.messageStatus != nil {
		t := *r.messageStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", t, "multi")
		}
	}
	if r.msgContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "msgContains", r.msgContains, "")
	}
	if r.anyOneOfTheMsg != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyOneOfTheMsg", r.anyOneOfTheMsg, "")
	}
	if r.valuesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "valuesOnly", r.valuesOnly, "")
	}
	if r.messageReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageReference", r.messageReference, "")
	}
	if r.messageTypes != nil {
		t := *r.messageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.includeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeErrors", r.includeErrors, "")
	}
	if r.actionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionId", r.actionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	croCode *string
	parameterNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) IntegrationSystem(integrationSystem string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.integrationSystem = &integrationSystem
	return r
}

func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) CroCode(croCode string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.croCode = &croCode
	return r
}

func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) ParameterNameWildCard(parameterNameWildCard string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.parameterNameWildCard = &parameterNameWildCard
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) Execute() (*FetchInterfaceControls, *http.Response, error) {
	return r.ApiService.GetInterfaceControlsExecute(r)
}

/*
GetInterfaceControls Retrieve OXI Parameters and Defaults

API to Fetch  Interface Controls  by Hotel Id and Interface Id <p><strong>OperationId:</strong>getInterfaceControls</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetInterfaceControls(ctx context.Context, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest {
	return OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchInterfaceControls
func (a *OperaExchangeInterfaceConfigApiService) GetInterfaceControlsExecute(r OperaExchangeInterfaceConfigApiGetInterfaceControlsRequest) (*FetchInterfaceControls, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchInterfaceControls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetInterfaceControls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/interfaceControls"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.parameterNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNameWildCard", r.parameterNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) Execute() (*LegacyInterfaceStatusDetails, *http.Response, error) {
	return r.ApiService.GetLegacyInterfaceStatusExecute(r)
}

/*
GetLegacyInterfaceStatus Fetch legacy interface status

API to Fetch legacy OXI Interface Processor Status by Interface Id. <p><strong>OperationId:</strong>getLegacyInterfaceStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @return OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetLegacyInterfaceStatus(ctx context.Context, interfaceId string) OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest {
	return OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return LegacyInterfaceStatusDetails
func (a *OperaExchangeInterfaceConfigApiService) GetLegacyInterfaceStatusExecute(r OperaExchangeInterfaceConfigApiGetLegacyInterfaceStatusRequest) (*LegacyInterfaceStatusDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LegacyInterfaceStatusDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetLegacyInterfaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/legacyInterfaceStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	lovCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	includeInActive *bool
	parameterNames *[]string
	parameterValues *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) IntegrationSystem(integrationSystem string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) IncludeInActive(includeInActive bool) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.includeInActive = &includeInActive
	return r
}

// Name of the parameter.
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) ParameterNames(parameterNames []string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.parameterNames = &parameterNames
	return r
}

// Value of the parameter.
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) ParameterValues(parameterValues []string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.parameterValues = &parameterValues
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) Execute() (*FetchOXIListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIListOfValuesExecute(r)
}

/*
GetOXIListOfValues Fetch list of values details for OXI

API to Fetch list of values for all OXI interface type External Systems. <p><strong>OperationId:</strong>getOXIListOfValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lovCode OXI LOVName in OPERA.
 @return OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetOXIListOfValues(ctx context.Context, lovCode string) OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest {
	return OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest{
		ApiService: a,
		ctx: ctx,
		lovCode: lovCode,
	}
}

// Execute executes the request
//  @return FetchOXIListOfValues
func (a *OperaExchangeInterfaceConfigApiService) GetOXIListOfValuesExecute(r OperaExchangeInterfaceConfigApiGetOXIListOfValuesRequest) (*FetchOXIListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchOXIListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetOXIListOfValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lovCode/{lovCode}/listOfValuesOXI"
	localVarPath = strings.Replace(localVarPath, "{"+"lovCode"+"}", url.PathEscape(parameterValueToString(r.lovCode, "lovCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lovCode) < 1 {
		return localVarReturnValue, nil, reportError("lovCode must have at least 1 elements")
	}
	if strlen(r.lovCode) > 2000 {
		return localVarReturnValue, nil, reportError("lovCode must have less than 2000 elements")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.includeInActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInActive", r.includeInActive, "")
	}
	if r.parameterNames != nil {
		t := *r.parameterNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNames", t, "multi")
		}
	}
	if r.parameterValues != nil {
		t := *r.parameterValues
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValues", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValues", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	includeXmlVersions *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) HotelId(hotelId []string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.hotelId = &hotelId
	return r
}

// Attribute that decides whether the search results include the XML Schema version details
func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) IncludeXmlVersions(includeXmlVersions bool) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.includeXmlVersions = &includeXmlVersions
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) Execute() (*FetchProfileMatchRules, *http.Response, error) {
	return r.ApiService.GetProfileMatchRulesExecute(r)
}

/*
GetProfileMatchRules Fetch profile match rules

API to Fetch Profile Match Rules by Interface Id and Hotel Id. <p><strong>OperationId:</strong>getProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @return OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetProfileMatchRules(ctx context.Context, interfaceId string) OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest {
	return OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return FetchProfileMatchRules
func (a *OperaExchangeInterfaceConfigApiService) GetProfileMatchRulesExecute(r OperaExchangeInterfaceConfigApiGetProfileMatchRulesRequest) (*FetchProfileMatchRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchProfileMatchRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/profileMatchRules"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
	}
	if r.includeXmlVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeXmlVersions", r.includeXmlVersions, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	automaticTransmissionSchedulesToBeCreated *PostAutomaticTransmissionSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create automatic transmission schedules
func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) AutomaticTransmissionSchedulesToBeCreated(automaticTransmissionSchedulesToBeCreated PostAutomaticTransmissionSchedulesRequest) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	r.automaticTransmissionSchedulesToBeCreated = &automaticTransmissionSchedulesToBeCreated
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutomaticTransmissionSchedulesExecute(r)
}

/*
PostAutomaticTransmissionSchedules Create Automatic Transmission Schedules

API to Create Automatic Transmission Schedules. <p><strong>OperationId:</strong>postAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostAutomaticTransmissionSchedules(ctx context.Context) OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest {
	return OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) PostAutomaticTransmissionSchedulesExecute(r OperaExchangeInterfaceConfigApiPostAutomaticTransmissionSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automaticTransmissionSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.automaticTransmissionSchedulesToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	externalValue string
	operaValue string
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	conversionCodeMappingsToBeCreated *PostConversionCodeMappingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create Conversion Code Mappings.
func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) ConversionCodeMappingsToBeCreated(conversionCodeMappingsToBeCreated PostConversionCodeMappingsRequest) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	r.conversionCodeMappingsToBeCreated = &conversionCodeMappingsToBeCreated
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) Execute() (*CreatedConversionCodeMappings, *http.Response, error) {
	return r.ApiService.PostConversionCodeMappingsExecute(r)
}

/*
PostConversionCodeMappings Create Conversion Codes Mappings

API to Create  Interface Mapping Conversion Codes by Hotel Id, Interface Id and Conversion Code with OPERA value and External value. <p><strong>OperationId:</strong>postConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalValue EXTERNAL Conversion Code value.
 @param operaValue PMS Conversion Code value.
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostConversionCodeMappings(ctx context.Context, externalValue string, operaValue string, conversionCode string, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest {
	return OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		externalValue: externalValue,
		operaValue: operaValue,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreatedConversionCodeMappings
func (a *OperaExchangeInterfaceConfigApiService) PostConversionCodeMappingsExecute(r OperaExchangeInterfaceConfigApiPostConversionCodeMappingsRequest) (*CreatedConversionCodeMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatedConversionCodeMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversionCode/{conversionCode}/operaValue/{operaValue}/externalValue/{externalValue}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"externalValue"+"}", url.PathEscape(parameterValueToString(r.externalValue, "externalValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operaValue"+"}", url.PathEscape(parameterValueToString(r.operaValue, "operaValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalValue) < 1 {
		return localVarReturnValue, nil, reportError("externalValue must have at least 1 elements")
	}
	if strlen(r.externalValue) > 2000 {
		return localVarReturnValue, nil, reportError("externalValue must have less than 2000 elements")
	}
	if strlen(r.operaValue) < 1 {
		return localVarReturnValue, nil, reportError("operaValue must have at least 1 elements")
	}
	if strlen(r.operaValue) > 2000 {
		return localVarReturnValue, nil, reportError("operaValue must have less than 2000 elements")
	}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.conversionCodeMappingsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	externalInterfaceSetupsToBeCreated *PostExternalInterfaceSetupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create External Interface Setups
func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) ExternalInterfaceSetupsToBeCreated(externalInterfaceSetupsToBeCreated PostExternalInterfaceSetupsRequest) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	r.externalInterfaceSetupsToBeCreated = &externalInterfaceSetupsToBeCreated
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExternalInterfaceSetupsExecute(r)
}

/*
PostExternalInterfaceSetups Create Interface Setup details

API to Create Interface Setup configuration. <p><strong>OperationId:</strong>postExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostExternalInterfaceSetups(ctx context.Context) OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest {
	return OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) PostExternalInterfaceSetupsExecute(r OperaExchangeInterfaceConfigApiPostExternalInterfaceSetupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalInterfaceSetups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.externalInterfaceSetupsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileMatchRulesToBeCreated *PostProfileMatchRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Profile Match Rules Configuration..
func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) ProfileMatchRulesToBeCreated(profileMatchRulesToBeCreated PostProfileMatchRulesRequest) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	r.profileMatchRulesToBeCreated = &profileMatchRulesToBeCreated
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileMatchRulesExecute(r)
}

/*
PostProfileMatchRules Create profile match rules

API to Create Profile Match Rules. <p><strong>OperationId:</strong>postProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostProfileMatchRules(ctx context.Context) OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest {
	return OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) PostProfileMatchRulesExecute(r OperaExchangeInterfaceConfigApiPostProfileMatchRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileMatchRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileMatchRulesToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	automaticTransmissionSchedulesToBeChanged *PutAutomaticTransmissionSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change automatic transmission schedules
func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) AutomaticTransmissionSchedulesToBeChanged(automaticTransmissionSchedulesToBeChanged PutAutomaticTransmissionSchedulesRequest) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	r.automaticTransmissionSchedulesToBeChanged = &automaticTransmissionSchedulesToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) Execute() (*ChangedAutomaticTransmissionSchedules, *http.Response, error) {
	return r.ApiService.PutAutomaticTransmissionSchedulesExecute(r)
}

/*
PutAutomaticTransmissionSchedules Change Automatic Transmission Schedules

API to Modify  Automatic Transmission Schedules by Hotel Id. <p><strong>OperationId:</strong>putAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA internal ID used to identify a hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutAutomaticTransmissionSchedules(ctx context.Context, hotelId string) OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest {
	return OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedAutomaticTransmissionSchedules
func (a *OperaExchangeInterfaceConfigApiService) PutAutomaticTransmissionSchedulesExecute(r OperaExchangeInterfaceConfigApiPutAutomaticTransmissionSchedulesRequest) (*ChangedAutomaticTransmissionSchedules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedAutomaticTransmissionSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/automaticTransmissionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.automaticTransmissionSchedulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationMethodsToBeChanged *PutCommunicationMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying Communication Methods.
func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) CommunicationMethodsToBeChanged(communicationMethodsToBeChanged PutCommunicationMethodsRequest) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	r.communicationMethodsToBeChanged = &communicationMethodsToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) Execute() (*ChangedCommunicationMethods, *http.Response, error) {
	return r.ApiService.PutCommunicationMethodsExecute(r)
}

/*
PutCommunicationMethods Modify Communication Methods 

API to Modify Communication Methods. <p><strong>OperationId:</strong>putCommunicationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutCommunicationMethods(ctx context.Context) OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest {
	return OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedCommunicationMethods
func (a *OperaExchangeInterfaceConfigApiService) PutCommunicationMethodsExecute(r OperaExchangeInterfaceConfigApiPutCommunicationMethodsRequest) (*ChangedCommunicationMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedCommunicationMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutCommunicationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.communicationMethodsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	externalValue string
	operaValue string
	id string
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	conversionCodeMappingsToBeChanged *PutConversionCodeMappingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update existing Conversion Code Mappings.
func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) ConversionCodeMappingsToBeChanged(conversionCodeMappingsToBeChanged PutConversionCodeMappingsRequest) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	r.conversionCodeMappingsToBeChanged = &conversionCodeMappingsToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) Execute() (*ChangedConversionCodeMappings, *http.Response, error) {
	return r.ApiService.PutConversionCodeMappingsExecute(r)
}

/*
PutConversionCodeMappings Change Conversion Codes Mappings

API to Modify  Interface Mapping  Conversion Codes by Hotel Id, Interface Id and Conversion Code Id with OPERA value and External value. <p><strong>OperationId:</strong>putConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalValue EXTERNAL Conversion Code value.
 @param operaValue PMS Conversion Code value.
 @param id Unique OPERA internal ID used to identify a Conversion Code Mapping in OPERA.
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodeMappings(ctx context.Context, externalValue string, operaValue string, id string, conversionCode string, interfaceId string, hotelId string) OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest {
	return OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		externalValue: externalValue,
		operaValue: operaValue,
		id: id,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedConversionCodeMappings
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodeMappingsExecute(r OperaExchangeInterfaceConfigApiPutConversionCodeMappingsRequest) (*ChangedConversionCodeMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedConversionCodeMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversionCode/{conversionCode}/ID/{id}/operaValue/{operaValue}/externalValue/{externalValue}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"externalValue"+"}", url.PathEscape(parameterValueToString(r.externalValue, "externalValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operaValue"+"}", url.PathEscape(parameterValueToString(r.operaValue, "operaValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalValue) < 1 {
		return localVarReturnValue, nil, reportError("externalValue must have at least 1 elements")
	}
	if strlen(r.externalValue) > 2000 {
		return localVarReturnValue, nil, reportError("externalValue must have less than 2000 elements")
	}
	if strlen(r.operaValue) < 1 {
		return localVarReturnValue, nil, reportError("operaValue must have at least 1 elements")
	}
	if strlen(r.operaValue) > 2000 {
		return localVarReturnValue, nil, reportError("operaValue must have less than 2000 elements")
	}
	if strlen(r.id) < 1 {
		return localVarReturnValue, nil, reportError("id must have at least 1 elements")
	}
	if strlen(r.id) > 2000 {
		return localVarReturnValue, nil, reportError("id must have less than 2000 elements")
	}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.conversionCodeMappingsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	conversionCodesStatusToBeChanged *PutConversionCodesStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the status of given Conversion Codes.
func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) ConversionCodesStatusToBeChanged(conversionCodesStatusToBeChanged PutConversionCodesStatusRequest) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	r.conversionCodesStatusToBeChanged = &conversionCodesStatusToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) Execute() (*ChangedConversionCodesStatus, *http.Response, error) {
	return r.ApiService.PutConversionCodesStatusExecute(r)
}

/*
PutConversionCodesStatus Change Conversion codes Status

API to Modify Interface Mapping UDF Conversion Codes. <p><strong>OperationId:</strong>putConversionCodesStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodesStatus(ctx context.Context) OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest {
	return OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedConversionCodesStatus
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodesStatusExecute(r OperaExchangeInterfaceConfigApiPutConversionCodesStatusRequest) (*ChangedConversionCodesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedConversionCodesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutConversionCodesStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversionCodesStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.conversionCodesStatusToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	externalInterfaceSetupsToBeChanged *PutExternalInterfaceSetupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change External Interface Setups
func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) ExternalInterfaceSetupsToBeChanged(externalInterfaceSetupsToBeChanged PutExternalInterfaceSetupsRequest) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	r.externalInterfaceSetupsToBeChanged = &externalInterfaceSetupsToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) Execute() (*ChangedExternalInterfaceSetups, *http.Response, error) {
	return r.ApiService.PutExternalInterfaceSetupsExecute(r)
}

/*
PutExternalInterfaceSetups Modify external Interface Setup details

API to Modify  Interface Setup configuration. <p><strong>OperationId:</strong>putExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutExternalInterfaceSetups(ctx context.Context) OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest {
	return OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedExternalInterfaceSetups
func (a *OperaExchangeInterfaceConfigApiService) PutExternalInterfaceSetupsExecute(r OperaExchangeInterfaceConfigApiPutExternalInterfaceSetupsRequest) (*ChangedExternalInterfaceSetups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedExternalInterfaceSetups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceSetups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.externalInterfaceSetupsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	interfaceControlsToBeChanged *PutInterfaceControlsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing one or more OXI Parameters/Settings.
func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) InterfaceControlsToBeChanged(interfaceControlsToBeChanged PutInterfaceControlsRequest) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	r.interfaceControlsToBeChanged = &interfaceControlsToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) Execute() (*ChangedInterfaceControls, *http.Response, error) {
	return r.ApiService.PutInterfaceControlsExecute(r)
}

/*
PutInterfaceControls Change OXI Parameters and Defaults

API to Modify Interface Controls by Interface Id. <p><strong>OperationId:</strong>putInterfaceControls</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @return OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutInterfaceControls(ctx context.Context, interfaceId string) OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest {
	return OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ChangedInterfaceControls
func (a *OperaExchangeInterfaceConfigApiService) PutInterfaceControlsExecute(r OperaExchangeInterfaceConfigApiPutInterfaceControlsRequest) (*ChangedInterfaceControls, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedInterfaceControls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutInterfaceControls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/interfaceControls"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.interfaceControlsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileMatchRulesToBeChanged *PutProfileMatchRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) Authorization(authorization string) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) XAppKey(xAppKey string) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) XHotelid(xHotelid string) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Profile Match Rules Configuration.
func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) ProfileMatchRulesToBeChanged(profileMatchRulesToBeChanged PutProfileMatchRulesRequest) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	r.profileMatchRulesToBeChanged = &profileMatchRulesToBeChanged
	return r
}

// External system code.
func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) Execute() (*ChangedProfileMatchRules, *http.Response, error) {
	return r.ApiService.PutProfileMatchRulesExecute(r)
}

/*
PutProfileMatchRules Change profile match rules 

API to Modify Profile Match Rules. <p><strong>OperationId:</strong>putProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutProfileMatchRules(ctx context.Context) OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest {
	return OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedProfileMatchRules
func (a *OperaExchangeInterfaceConfigApiService) PutProfileMatchRulesExecute(r OperaExchangeInterfaceConfigApiPutProfileMatchRulesRequest) (*ChangedProfileMatchRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedProfileMatchRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileMatchRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileMatchRulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
