/*
OPERA Cloud Xchange Interface OXI API

APIs to create and manage OPERA Xchange Interface (OXI) configurations for OPERA Cloud Exchange module functionality.<br /><br /> Compatible with OPERA Cloud release 23.0.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 23.0.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// OperaExchangeInterfaceConfigApiService OperaExchangeInterfaceConfigApi service
type OperaExchangeInterfaceConfigApiService service

type ApiDeleteAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	messageId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAutomaticTransmissionSchedulesRequest) Authorization(authorization string) ApiDeleteAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) ApiDeleteAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) ApiDeleteAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) ApiDeleteAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAutomaticTransmissionSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutomaticTransmissionSchedulesExecute(r)
}

/*
DeleteAutomaticTransmissionSchedules Remove Automatic Transmission Schedules

API to Delete  Automatic Transmission Schedules by Scheduled Message Id. <p><strong>OperationId:</strong>deleteAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId Unique OPERA internal ID used to identify a hotel in OPERA.
 @return ApiDeleteAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteAutomaticTransmissionSchedules(ctx context.Context, messageId string) ApiDeleteAutomaticTransmissionSchedulesRequest {
	return ApiDeleteAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteAutomaticTransmissionSchedulesExecute(r ApiDeleteAutomaticTransmissionSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{messageId}/automaticTransmissionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.messageId) < 1 {
		return localVarReturnValue, nil, reportError("messageId must have at least 1 elements")
	}
	if strlen(r.messageId) > 2000 {
		return localVarReturnValue, nil, reportError("messageId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	id string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteConversionCodeMappingsRequest) Authorization(authorization string) ApiDeleteConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteConversionCodeMappingsRequest) XAppKey(xAppKey string) ApiDeleteConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteConversionCodeMappingsRequest) XHotelid(xHotelid string) ApiDeleteConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) ApiDeleteConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteConversionCodeMappingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteConversionCodeMappingsExecute(r)
}

/*
DeleteConversionCodeMappings Remove Conversion Codes Mappings

API to Delete  Interface Mapping Conversion Codes by Conversion Code Mapping Id. <p><strong>OperationId:</strong>deleteConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Unique OPERA internal ID used to identify a Conversion Code Mapping in OPERA.
 @return ApiDeleteConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteConversionCodeMappings(ctx context.Context, id string) ApiDeleteConversionCodeMappingsRequest {
	return ApiDeleteConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteConversionCodeMappingsExecute(r ApiDeleteConversionCodeMappingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversionCodeMappingID/{id}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.id) < 1 {
		return localVarReturnValue, nil, reportError("id must have at least 1 elements")
	}
	if strlen(r.id) > 2000 {
		return localVarReturnValue, nil, reportError("id must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteExternalInterfaceSetupsRequest) Authorization(authorization string) ApiDeleteExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteExternalInterfaceSetupsRequest) XAppKey(xAppKey string) ApiDeleteExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteExternalInterfaceSetupsRequest) XHotelid(xHotelid string) ApiDeleteExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) ApiDeleteExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteExternalInterfaceSetupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExternalInterfaceSetupsExecute(r)
}

/*
DeleteExternalInterfaceSetups Delete external Interface Setup details

API to Delete Interface Setup configuration by Hotel Id and Interface Id. <p><strong>OperationId:</strong>deleteExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @param hotelId Unique OPERA internal ID used to find hotel in OPERA.
 @return ApiDeleteExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteExternalInterfaceSetups(ctx context.Context, interfaceId string, hotelId string) ApiDeleteExternalInterfaceSetupsRequest {
	return ApiDeleteExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteExternalInterfaceSetupsExecute(r ApiDeleteExternalInterfaceSetupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/externalInterfaceSetups"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	profileType string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteProfileMatchRulesRequest) Authorization(authorization string) ApiDeleteProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteProfileMatchRulesRequest) XAppKey(xAppKey string) ApiDeleteProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteProfileMatchRulesRequest) XHotelid(xHotelid string) ApiDeleteProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) ApiDeleteProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteProfileMatchRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileMatchRulesExecute(r)
}

/*
DeleteProfileMatchRules Delete profile match rules

API to Delete  Profile Match Rules by Hotel Id, Interface Id and Profile Type. <p><strong>OperationId:</strong>deleteProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileType Unique OPERA internal ID used to identify an Profile in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify an hotel in OPERA.
 @return ApiDeleteProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteProfileMatchRules(ctx context.Context, profileType string, interfaceId string, hotelId string) ApiDeleteProfileMatchRulesRequest {
	return ApiDeleteProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
		profileType: profileType,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteProfileMatchRulesExecute(r ApiDeleteProfileMatchRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/profiles/{profileType}/profileMatchRules"
	localVarPath = strings.Replace(localVarPath, "{"+"profileType"+"}", url.PathEscape(parameterValueToString(r.profileType, "profileType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileType) < 1 {
		return localVarReturnValue, nil, reportError("profileType must have at least 1 elements")
	}
	if strlen(r.profileType) > 2000 {
		return localVarReturnValue, nil, reportError("profileType must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUDFMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	operaValue string
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteUDFMappingsRequest) Authorization(authorization string) ApiDeleteUDFMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteUDFMappingsRequest) XAppKey(xAppKey string) ApiDeleteUDFMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteUDFMappingsRequest) XHotelid(xHotelid string) ApiDeleteUDFMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Profile type of the user-defined function (UDF) definition.
func (r ApiDeleteUDFMappingsRequest) ProfileType(profileType string) ApiDeleteUDFMappingsRequest {
	r.profileType = &profileType
	return r
}

// External system code.
func (r ApiDeleteUDFMappingsRequest) XExternalsystem(xExternalsystem string) ApiDeleteUDFMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteUDFMappingsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteUDFMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteUDFMappingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteUDFMappingsExecute(r)
}

/*
DeleteUDFMappings Remove UDF Mappings

API to Delete Interface Mapping UDF Conversion Codes by Hotel Id, Interface Id and Conversion Code. <p><strong>OperationId:</strong>deleteUDFMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operaValue PMS Conversion Code value.
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiDeleteUDFMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) DeleteUDFMappings(ctx context.Context, operaValue string, conversionCode string, interfaceId string, hotelId string) ApiDeleteUDFMappingsRequest {
	return ApiDeleteUDFMappingsRequest{
		ApiService: a,
		ctx: ctx,
		operaValue: operaValue,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) DeleteUDFMappingsExecute(r ApiDeleteUDFMappingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.DeleteUDFMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversionCode/{conversionCode}/operaValue/{operaValue}/udfMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"operaValue"+"}", url.PathEscape(parameterValueToString(r.operaValue, "operaValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.operaValue) < 1 {
		return localVarReturnValue, nil, reportError("operaValue must have at least 1 elements")
	}
	if strlen(r.operaValue) > 2000 {
		return localVarReturnValue, nil, reportError("operaValue must have less than 2000 elements")
	}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccumulatedBusinessEventsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	modules *[]string
	endDate *string
	startDate *string
	primaryKey *string
	status *string
	hotelIds *[]string
	integrationSystem *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAccumulatedBusinessEventsRequest) Authorization(authorization string) ApiGetAccumulatedBusinessEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAccumulatedBusinessEventsRequest) XAppKey(xAppKey string) ApiGetAccumulatedBusinessEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAccumulatedBusinessEventsRequest) XHotelid(xHotelid string) ApiGetAccumulatedBusinessEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetAccumulatedBusinessEventsRequest) Limit(limit int32) ApiGetAccumulatedBusinessEventsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetAccumulatedBusinessEventsRequest) Offset(offset int32) ApiGetAccumulatedBusinessEventsRequest {
	r.offset = &offset
	return r
}

// Accumulated Business Event Module
func (r ApiGetAccumulatedBusinessEventsRequest) Modules(modules []string) ApiGetAccumulatedBusinessEventsRequest {
	r.modules = &modules
	return r
}

// The ending value of the date range.
func (r ApiGetAccumulatedBusinessEventsRequest) EndDate(endDate string) ApiGetAccumulatedBusinessEventsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r ApiGetAccumulatedBusinessEventsRequest) StartDate(startDate string) ApiGetAccumulatedBusinessEventsRequest {
	r.startDate = &startDate
	return r
}

// Specify primary key identifier to search for
func (r ApiGetAccumulatedBusinessEventsRequest) PrimaryKey(primaryKey string) ApiGetAccumulatedBusinessEventsRequest {
	r.primaryKey = &primaryKey
	return r
}

// State of Accumulated Business Event
func (r ApiGetAccumulatedBusinessEventsRequest) Status(status string) ApiGetAccumulatedBusinessEventsRequest {
	r.status = &status
	return r
}

func (r ApiGetAccumulatedBusinessEventsRequest) HotelIds(hotelIds []string) ApiGetAccumulatedBusinessEventsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r ApiGetAccumulatedBusinessEventsRequest) IntegrationSystem(integrationSystem string) ApiGetAccumulatedBusinessEventsRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// External system code.
func (r ApiGetAccumulatedBusinessEventsRequest) XExternalsystem(xExternalsystem string) ApiGetAccumulatedBusinessEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAccumulatedBusinessEventsRequest) AcceptLanguage(acceptLanguage string) ApiGetAccumulatedBusinessEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAccumulatedBusinessEventsRequest) Execute() (*FetchAccumulatedBusinessEvents, *http.Response, error) {
	return r.ApiService.GetAccumulatedBusinessEventsExecute(r)
}

/*
GetAccumulatedBusinessEvents Fetch accumulated business events

API to Fetch  Accumulated Business Event Messages for External Systems by Hotel Id, Interface Id. <p><strong>OperationId:</strong>getAccumulatedBusinessEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiGetAccumulatedBusinessEventsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetAccumulatedBusinessEvents(ctx context.Context, interfaceId string, hotelId string) ApiGetAccumulatedBusinessEventsRequest {
	return ApiGetAccumulatedBusinessEventsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchAccumulatedBusinessEvents
func (a *OperaExchangeInterfaceConfigApiService) GetAccumulatedBusinessEventsExecute(r ApiGetAccumulatedBusinessEventsRequest) (*FetchAccumulatedBusinessEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchAccumulatedBusinessEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetAccumulatedBusinessEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/accumulatedBusinessEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.modules != nil {
		t := *r.modules
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "modules", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "modules", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.primaryKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryKey", r.primaryKey, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	interfaceList *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAutomaticTransmissionSchedulesRequest) Authorization(authorization string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetAutomaticTransmissionSchedulesRequest) HotelIds(hotelIds []string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Interfaces configured for automatic transmission schedules
func (r ApiGetAutomaticTransmissionSchedulesRequest) InterfaceList(interfaceList []string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.interfaceList = &interfaceList
	return r
}

// If true, this flag will set the criteria to return Inactive records along with active records.
func (r ApiGetAutomaticTransmissionSchedulesRequest) IncludeInactive(includeInactive bool) ApiGetAutomaticTransmissionSchedulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) ApiGetAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAutomaticTransmissionSchedulesRequest) Execute() (*FetchAutomaticTransmissionSchedules, *http.Response, error) {
	return r.ApiService.GetAutomaticTransmissionSchedulesExecute(r)
}

/*
GetAutomaticTransmissionSchedules Fetch Automatic Transmission Schedules

API to Fetch Automatic Transmission Schedules by Hotel Id. <p><strong>OperationId:</strong>getAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA internal ID used to identify a hotel in OPERA.
 @return ApiGetAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetAutomaticTransmissionSchedules(ctx context.Context, hotelId string) ApiGetAutomaticTransmissionSchedulesRequest {
	return ApiGetAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchAutomaticTransmissionSchedules
func (a *OperaExchangeInterfaceConfigApiService) GetAutomaticTransmissionSchedulesExecute(r ApiGetAutomaticTransmissionSchedulesRequest) (*FetchAutomaticTransmissionSchedules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchAutomaticTransmissionSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/automaticTransmissionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceList != nil {
		t := *r.interfaceList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceList", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommunicationMethodsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	isGlobal *bool
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	interfaceIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// SID Resort
func (r ApiGetCommunicationMethodsRequest) IsGlobal(isGlobal bool) ApiGetCommunicationMethodsRequest {
	r.isGlobal = &isGlobal
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCommunicationMethodsRequest) Authorization(authorization string) ApiGetCommunicationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCommunicationMethodsRequest) XAppKey(xAppKey string) ApiGetCommunicationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCommunicationMethodsRequest) XHotelid(xHotelid string) ApiGetCommunicationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetCommunicationMethodsRequest) HotelId(hotelId []string) ApiGetCommunicationMethodsRequest {
	r.hotelId = &hotelId
	return r
}

// InterfaceID
func (r ApiGetCommunicationMethodsRequest) InterfaceIds(interfaceIds []string) ApiGetCommunicationMethodsRequest {
	r.interfaceIds = &interfaceIds
	return r
}

// External system code.
func (r ApiGetCommunicationMethodsRequest) XExternalsystem(xExternalsystem string) ApiGetCommunicationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCommunicationMethodsRequest) AcceptLanguage(acceptLanguage string) ApiGetCommunicationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCommunicationMethodsRequest) Execute() (*FetchCommunicationMethods, *http.Response, error) {
	return r.ApiService.GetCommunicationMethodsExecute(r)
}

/*
GetCommunicationMethods Fetch Communication Methods

API to Fetch Communication Methods. <p><strong>OperationId:</strong>getCommunicationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @return ApiGetCommunicationMethodsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetCommunicationMethods(ctx context.Context, interfaceId string) ApiGetCommunicationMethodsRequest {
	return ApiGetCommunicationMethodsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return FetchCommunicationMethods
func (a *OperaExchangeInterfaceConfigApiService) GetCommunicationMethodsExecute(r ApiGetCommunicationMethodsRequest) (*FetchCommunicationMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchCommunicationMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetCommunicationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/intefaces/{interfaceId}/communicationMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.isGlobal == nil {
		return localVarReturnValue, nil, reportError("isGlobal is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "isGlobal", r.isGlobal, "")
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
	}
	if r.interfaceIds != nil {
		t := *r.interfaceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	udfCode *bool
	mappingValue *string
	searchBy *string
	includeGlobal *bool
	profileType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConversionCodeMappingsRequest) Authorization(authorization string) ApiGetConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConversionCodeMappingsRequest) XAppKey(xAppKey string) ApiGetConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConversionCodeMappingsRequest) XHotelid(xHotelid string) ApiGetConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r ApiGetConversionCodeMappingsRequest) IntegrationSystem(integrationSystem string) ApiGetConversionCodeMappingsRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// A flag that is true if the conversion code is an user-defined function (UDF) module code.
func (r ApiGetConversionCodeMappingsRequest) UdfCode(udfCode bool) ApiGetConversionCodeMappingsRequest {
	r.udfCode = &udfCode
	return r
}

// This value is used for wild card search on OPERA Code/External code.
func (r ApiGetConversionCodeMappingsRequest) MappingValue(mappingValue string) ApiGetConversionCodeMappingsRequest {
	r.mappingValue = &mappingValue
	return r
}

// Search for both OPERA and External mapping value.
func (r ApiGetConversionCodeMappingsRequest) SearchBy(searchBy string) ApiGetConversionCodeMappingsRequest {
	r.searchBy = &searchBy
	return r
}

// A flag to indicate whether to include Global Mappings or not.
func (r ApiGetConversionCodeMappingsRequest) IncludeGlobal(includeGlobal bool) ApiGetConversionCodeMappingsRequest {
	r.includeGlobal = &includeGlobal
	return r
}

// Profile type by which the user-defined function (UDF) mappings should be filtered.
func (r ApiGetConversionCodeMappingsRequest) ProfileType(profileType string) ApiGetConversionCodeMappingsRequest {
	r.profileType = &profileType
	return r
}

// External system code.
func (r ApiGetConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) ApiGetConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) ApiGetConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConversionCodeMappingsRequest) Execute() (*FetchConversionCodeMappings, *http.Response, error) {
	return r.ApiService.GetConversionCodeMappingsExecute(r)
}

/*
GetConversionCodeMappings Fetch Conversion Code Mappings

API to Fetch Interface Mapping  Conversion Codes by Hotel Id, Interface Id and Conversion Code. <p><strong>OperationId:</strong>getConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiGetConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodeMappings(ctx context.Context, conversionCode string, interfaceId string, hotelId string) ApiGetConversionCodeMappingsRequest {
	return ApiGetConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchConversionCodeMappings
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodeMappingsExecute(r ApiGetConversionCodeMappingsRequest) (*FetchConversionCodeMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchConversionCodeMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversions/{conversionCode}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.udfCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udfCode", r.udfCode, "")
	}
	if r.mappingValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mappingValue", r.mappingValue, "")
	}
	if r.searchBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", r.searchBy, "")
	}
	if r.includeGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGlobal", r.includeGlobal, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversionCodesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	conversionCode *string
	udfCode *bool
	includeInactive *bool
	group *string
	includeUDFCodes *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConversionCodesRequest) Authorization(authorization string) ApiGetConversionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConversionCodesRequest) XAppKey(xAppKey string) ApiGetConversionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConversionCodesRequest) XHotelid(xHotelid string) ApiGetConversionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r ApiGetConversionCodesRequest) IntegrationSystem(integrationSystem string) ApiGetConversionCodesRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// Type of Conversion Code or user-defined function (UDF) module name configured in the system.
func (r ApiGetConversionCodesRequest) ConversionCode(conversionCode string) ApiGetConversionCodesRequest {
	r.conversionCode = &conversionCode
	return r
}

// A flag that is true if the conversion code is an user-defined function (UDF) module code.
func (r ApiGetConversionCodesRequest) UdfCode(udfCode bool) ApiGetConversionCodesRequest {
	r.udfCode = &udfCode
	return r
}

// A flag to indicate whether to include inactive Conversion Codes.
func (r ApiGetConversionCodesRequest) IncludeInactive(includeInactive bool) ApiGetConversionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// XML Type by which the Conversion Codes should be filtered.
func (r ApiGetConversionCodesRequest) Group(group string) ApiGetConversionCodesRequest {
	r.group = &group
	return r
}

// A flag to indicate whether user-defined function (UDF) module names should be included in the results or not.
func (r ApiGetConversionCodesRequest) IncludeUDFCodes(includeUDFCodes bool) ApiGetConversionCodesRequest {
	r.includeUDFCodes = &includeUDFCodes
	return r
}

// External system code.
func (r ApiGetConversionCodesRequest) XExternalsystem(xExternalsystem string) ApiGetConversionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConversionCodesRequest) AcceptLanguage(acceptLanguage string) ApiGetConversionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConversionCodesRequest) Execute() (*FetchConversionCodes, *http.Response, error) {
	return r.ApiService.GetConversionCodesExecute(r)
}

/*
GetConversionCodes Fetch Conversion Codes

API to Fetch Interface Mappings UDF Conversion Codes by Hotel Id and Interface Id. <p><strong>OperationId:</strong>getConversionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiGetConversionCodesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodes(ctx context.Context, interfaceId string, hotelId string) ApiGetConversionCodesRequest {
	return ApiGetConversionCodesRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchConversionCodes
func (a *OperaExchangeInterfaceConfigApiService) GetConversionCodesExecute(r ApiGetConversionCodesRequest) (*FetchConversionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchConversionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetConversionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/intefaces/{interfaceId}/conversionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.conversionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conversionCode", r.conversionCode, "")
	}
	if r.udfCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udfCode", r.udfCode, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.includeUDFCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUDFCodes", r.includeUDFCodes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	interfaceIds *[]string
	hotelIds *[]string
	includeXmlVersion *bool
	systemType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExternalInterfaceSetupsRequest) Authorization(authorization string) ApiGetExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExternalInterfaceSetupsRequest) XAppKey(xAppKey string) ApiGetExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExternalInterfaceSetupsRequest) XHotelid(xHotelid string) ApiGetExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// InterfaceID
func (r ApiGetExternalInterfaceSetupsRequest) InterfaceIds(interfaceIds []string) ApiGetExternalInterfaceSetupsRequest {
	r.interfaceIds = &interfaceIds
	return r
}

func (r ApiGetExternalInterfaceSetupsRequest) HotelIds(hotelIds []string) ApiGetExternalInterfaceSetupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Attribute that decides whether the search results include the XML Schema version details
func (r ApiGetExternalInterfaceSetupsRequest) IncludeXmlVersion(includeXmlVersion bool) ApiGetExternalInterfaceSetupsRequest {
	r.includeXmlVersion = &includeXmlVersion
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r ApiGetExternalInterfaceSetupsRequest) SystemType(systemType string) ApiGetExternalInterfaceSetupsRequest {
	r.systemType = &systemType
	return r
}

// External system code.
func (r ApiGetExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) ApiGetExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) ApiGetExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExternalInterfaceSetupsRequest) Execute() (*FetchExternalInterfaceSetups, *http.Response, error) {
	return r.ApiService.GetExternalInterfaceSetupsExecute(r)
}

/*
GetExternalInterfaceSetups fetch external Interface Setup details

API to Fetch Interface Setup configurations by Interface Ids and Hotel Ids. <p><strong>OperationId:</strong>getExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetExternalInterfaceSetups(ctx context.Context) ApiGetExternalInterfaceSetupsRequest {
	return ApiGetExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchExternalInterfaceSetups
func (a *OperaExchangeInterfaceConfigApiService) GetExternalInterfaceSetupsExecute(r ApiGetExternalInterfaceSetupsRequest) (*FetchExternalInterfaceSetups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchExternalInterfaceSetups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceSetups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.interfaceIds != nil {
		t := *r.interfaceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceIds", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeXmlVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeXmlVersion", r.includeXmlVersion, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationInboundMessagesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	integrationSystem string
	interfaceId string
	externalHotelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	externalHotelCodes *[]string
	messageTypes *[]string
	endDate *string
	startDate *string
	includeReviewed *bool
	fromMessageID *string
	toMessageID *string
	messageStatus *[]string
	messageReference *string
	errorMessageWildCard *string
	errorMessageType *string
	msgContains *string
	anyOneOfTheMsg *bool
	valuesOnly *bool
	limit *int32
	offset *int32
	includeErrors *bool
	actionId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetIntegrationInboundMessagesRequest) Authorization(authorization string) ApiGetIntegrationInboundMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetIntegrationInboundMessagesRequest) XAppKey(xAppKey string) ApiGetIntegrationInboundMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetIntegrationInboundMessagesRequest) XHotelid(xHotelid string) ApiGetIntegrationInboundMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Unique External hotel IDs used to identify external Hotel in OPERA
func (r ApiGetIntegrationInboundMessagesRequest) ExternalHotelCodes(externalHotelCodes []string) ApiGetIntegrationInboundMessagesRequest {
	r.externalHotelCodes = &externalHotelCodes
	return r
}

// Sepcify Message type to restrict results
func (r ApiGetIntegrationInboundMessagesRequest) MessageTypes(messageTypes []string) ApiGetIntegrationInboundMessagesRequest {
	r.messageTypes = &messageTypes
	return r
}

// The ending value of the date range.
func (r ApiGetIntegrationInboundMessagesRequest) EndDate(endDate string) ApiGetIntegrationInboundMessagesRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r ApiGetIntegrationInboundMessagesRequest) StartDate(startDate string) ApiGetIntegrationInboundMessagesRequest {
	r.startDate = &startDate
	return r
}

// If true, messages that are marked as reviewed will also be fetched
func (r ApiGetIntegrationInboundMessagesRequest) IncludeReviewed(includeReviewed bool) ApiGetIntegrationInboundMessagesRequest {
	r.includeReviewed = &includeReviewed
	return r
}

// The starting value of the range
func (r ApiGetIntegrationInboundMessagesRequest) FromMessageID(fromMessageID string) ApiGetIntegrationInboundMessagesRequest {
	r.fromMessageID = &fromMessageID
	return r
}

// The ending value of the range
func (r ApiGetIntegrationInboundMessagesRequest) ToMessageID(toMessageID string) ApiGetIntegrationInboundMessagesRequest {
	r.toMessageID = &toMessageID
	return r
}

// Specify Integration message reference value to restrict results
func (r ApiGetIntegrationInboundMessagesRequest) MessageStatus(messageStatus []string) ApiGetIntegrationInboundMessagesRequest {
	r.messageStatus = &messageStatus
	return r
}

// Specify Integration message reference value to restrict results
func (r ApiGetIntegrationInboundMessagesRequest) MessageReference(messageReference string) ApiGetIntegrationInboundMessagesRequest {
	r.messageReference = &messageReference
	return r
}

// Specify partial or complete error message to restrict results
func (r ApiGetIntegrationInboundMessagesRequest) ErrorMessageWildCard(errorMessageWildCard string) ApiGetIntegrationInboundMessagesRequest {
	r.errorMessageWildCard = &errorMessageWildCard
	return r
}

// This value is only applicable for outbound messages
func (r ApiGetIntegrationInboundMessagesRequest) ErrorMessageType(errorMessageType string) ApiGetIntegrationInboundMessagesRequest {
	r.errorMessageType = &errorMessageType
	return r
}

// String to search inside a message. User can specify multiple strings separated by comma
func (r ApiGetIntegrationInboundMessagesRequest) MsgContains(msgContains string) ApiGetIntegrationInboundMessagesRequest {
	r.msgContains = &msgContains
	return r
}

// If true then results with message that has at least one of the string specified for message contains will be returned.
func (r ApiGetIntegrationInboundMessagesRequest) AnyOneOfTheMsg(anyOneOfTheMsg bool) ApiGetIntegrationInboundMessagesRequest {
	r.anyOneOfTheMsg = &anyOneOfTheMsg
	return r
}

// If true then passed string will be matched against the node values of the XML message
func (r ApiGetIntegrationInboundMessagesRequest) ValuesOnly(valuesOnly bool) ApiGetIntegrationInboundMessagesRequest {
	r.valuesOnly = &valuesOnly
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetIntegrationInboundMessagesRequest) Limit(limit int32) ApiGetIntegrationInboundMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetIntegrationInboundMessagesRequest) Offset(offset int32) ApiGetIntegrationInboundMessagesRequest {
	r.offset = &offset
	return r
}

// If true then errors and warnings will be fetched for action id and other criteria mentioned
func (r ApiGetIntegrationInboundMessagesRequest) IncludeErrors(includeErrors bool) ApiGetIntegrationInboundMessagesRequest {
	r.includeErrors = &includeErrors
	return r
}

// Action ID for which errors and warnings should be fetched
func (r ApiGetIntegrationInboundMessagesRequest) ActionId(actionId string) ApiGetIntegrationInboundMessagesRequest {
	r.actionId = &actionId
	return r
}

// External system code.
func (r ApiGetIntegrationInboundMessagesRequest) XExternalsystem(xExternalsystem string) ApiGetIntegrationInboundMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetIntegrationInboundMessagesRequest) AcceptLanguage(acceptLanguage string) ApiGetIntegrationInboundMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetIntegrationInboundMessagesRequest) Execute() (*FetchIntegrationInboundMessages, *http.Response, error) {
	return r.ApiService.GetIntegrationInboundMessagesExecute(r)
}

/*
GetIntegrationInboundMessages Fetch integration inbound messages 

API to Fetch Inbound Messages From External System by Hotel Id, Interface Id. <p><strong>OperationId:</strong>getIntegrationInboundMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSystem Unique OPERA IntegrationSystem used to identify a IntegrationSystem in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param externalHotelCode Unique External hotel ID used to identify a external Hotel in OPERA.
 @return ApiGetIntegrationInboundMessagesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationInboundMessages(ctx context.Context, integrationSystem string, interfaceId string, externalHotelCode string) ApiGetIntegrationInboundMessagesRequest {
	return ApiGetIntegrationInboundMessagesRequest{
		ApiService: a,
		ctx: ctx,
		integrationSystem: integrationSystem,
		interfaceId: interfaceId,
		externalHotelCode: externalHotelCode,
	}
}

// Execute executes the request
//  @return FetchIntegrationInboundMessages
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationInboundMessagesExecute(r ApiGetIntegrationInboundMessagesRequest) (*FetchIntegrationInboundMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchIntegrationInboundMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetIntegrationInboundMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{externalHotelCode}/interfaces/{interfaceId}/integrationSystems/{integrationSystem}/integrationInboundMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSystem"+"}", url.PathEscape(parameterValueToString(r.integrationSystem, "integrationSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalHotelCode"+"}", url.PathEscape(parameterValueToString(r.externalHotelCode, "externalHotelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.integrationSystem) < 1 {
		return localVarReturnValue, nil, reportError("integrationSystem must have at least 1 elements")
	}
	if strlen(r.integrationSystem) > 2000 {
		return localVarReturnValue, nil, reportError("integrationSystem must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.externalHotelCode) < 1 {
		return localVarReturnValue, nil, reportError("externalHotelCode must have at least 1 elements")
	}
	if strlen(r.externalHotelCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalHotelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.externalHotelCodes != nil {
		t := *r.externalHotelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalHotelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalHotelCodes", t, "multi")
		}
	}
	if r.messageTypes != nil {
		t := *r.messageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.includeReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReviewed", r.includeReviewed, "")
	}
	if r.fromMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromMessageID", r.fromMessageID, "")
	}
	if r.toMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toMessageID", r.toMessageID, "")
	}
	if r.messageStatus != nil {
		t := *r.messageStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", t, "multi")
		}
	}
	if r.messageReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageReference", r.messageReference, "")
	}
	if r.errorMessageWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageWildCard", r.errorMessageWildCard, "")
	}
	if r.errorMessageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageType", r.errorMessageType, "")
	}
	if r.msgContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "msgContains", r.msgContains, "")
	}
	if r.anyOneOfTheMsg != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyOneOfTheMsg", r.anyOneOfTheMsg, "")
	}
	if r.valuesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "valuesOnly", r.valuesOnly, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.includeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeErrors", r.includeErrors, "")
	}
	if r.actionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionId", r.actionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOutboundMessagesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	integrationSystem string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	actionType *string
	errorMessageWildCard *string
	errorMessageType *string
	endDate *string
	startDate *string
	includeReviewed *bool
	fromMessageID *string
	toMessageID *string
	messageStatus *[]string
	msgContains *string
	anyOneOfTheMsg *bool
	valuesOnly *bool
	messageReference *string
	messageTypes *[]string
	limit *int32
	offset *int32
	includeErrors *bool
	actionId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetIntegrationOutboundMessagesRequest) Authorization(authorization string) ApiGetIntegrationOutboundMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetIntegrationOutboundMessagesRequest) XAppKey(xAppKey string) ApiGetIntegrationOutboundMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetIntegrationOutboundMessagesRequest) XHotelid(xHotelid string) ApiGetIntegrationOutboundMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetIntegrationOutboundMessagesRequest) HotelIds(hotelIds []string) ApiGetIntegrationOutboundMessagesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Specify action(that has triggered the creation of message) to restrict results
func (r ApiGetIntegrationOutboundMessagesRequest) ActionType(actionType string) ApiGetIntegrationOutboundMessagesRequest {
	r.actionType = &actionType
	return r
}

// Specify partial or complete error message to restrict results
func (r ApiGetIntegrationOutboundMessagesRequest) ErrorMessageWildCard(errorMessageWildCard string) ApiGetIntegrationOutboundMessagesRequest {
	r.errorMessageWildCard = &errorMessageWildCard
	return r
}

// This value is only applicable for outbound messages
func (r ApiGetIntegrationOutboundMessagesRequest) ErrorMessageType(errorMessageType string) ApiGetIntegrationOutboundMessagesRequest {
	r.errorMessageType = &errorMessageType
	return r
}

// The ending value of the date range.
func (r ApiGetIntegrationOutboundMessagesRequest) EndDate(endDate string) ApiGetIntegrationOutboundMessagesRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r ApiGetIntegrationOutboundMessagesRequest) StartDate(startDate string) ApiGetIntegrationOutboundMessagesRequest {
	r.startDate = &startDate
	return r
}

// If true, messages that are marked as reviewed will also be fetched
func (r ApiGetIntegrationOutboundMessagesRequest) IncludeReviewed(includeReviewed bool) ApiGetIntegrationOutboundMessagesRequest {
	r.includeReviewed = &includeReviewed
	return r
}

// The starting value of the range
func (r ApiGetIntegrationOutboundMessagesRequest) FromMessageID(fromMessageID string) ApiGetIntegrationOutboundMessagesRequest {
	r.fromMessageID = &fromMessageID
	return r
}

// The ending value of the range
func (r ApiGetIntegrationOutboundMessagesRequest) ToMessageID(toMessageID string) ApiGetIntegrationOutboundMessagesRequest {
	r.toMessageID = &toMessageID
	return r
}

// Specify Integration message reference value to restrict results
func (r ApiGetIntegrationOutboundMessagesRequest) MessageStatus(messageStatus []string) ApiGetIntegrationOutboundMessagesRequest {
	r.messageStatus = &messageStatus
	return r
}

// String to search inside a message. User can specify multiple strings separated by comma
func (r ApiGetIntegrationOutboundMessagesRequest) MsgContains(msgContains string) ApiGetIntegrationOutboundMessagesRequest {
	r.msgContains = &msgContains
	return r
}

// If true then results with message that has at least one of the string specified for message contains will be returned.
func (r ApiGetIntegrationOutboundMessagesRequest) AnyOneOfTheMsg(anyOneOfTheMsg bool) ApiGetIntegrationOutboundMessagesRequest {
	r.anyOneOfTheMsg = &anyOneOfTheMsg
	return r
}

// If true then passed string will be matched against the node values of the XML message
func (r ApiGetIntegrationOutboundMessagesRequest) ValuesOnly(valuesOnly bool) ApiGetIntegrationOutboundMessagesRequest {
	r.valuesOnly = &valuesOnly
	return r
}

// Specify Integration message reference value to restrict results
func (r ApiGetIntegrationOutboundMessagesRequest) MessageReference(messageReference string) ApiGetIntegrationOutboundMessagesRequest {
	r.messageReference = &messageReference
	return r
}

// Sepcify Message type to restrict results
func (r ApiGetIntegrationOutboundMessagesRequest) MessageTypes(messageTypes []string) ApiGetIntegrationOutboundMessagesRequest {
	r.messageTypes = &messageTypes
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetIntegrationOutboundMessagesRequest) Limit(limit int32) ApiGetIntegrationOutboundMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetIntegrationOutboundMessagesRequest) Offset(offset int32) ApiGetIntegrationOutboundMessagesRequest {
	r.offset = &offset
	return r
}

// If true then errors and warnings will be fetched for action id and other criteria mentioned
func (r ApiGetIntegrationOutboundMessagesRequest) IncludeErrors(includeErrors bool) ApiGetIntegrationOutboundMessagesRequest {
	r.includeErrors = &includeErrors
	return r
}

// Action ID for which errors and warnings should be fetched
func (r ApiGetIntegrationOutboundMessagesRequest) ActionId(actionId string) ApiGetIntegrationOutboundMessagesRequest {
	r.actionId = &actionId
	return r
}

// External system code.
func (r ApiGetIntegrationOutboundMessagesRequest) XExternalsystem(xExternalsystem string) ApiGetIntegrationOutboundMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetIntegrationOutboundMessagesRequest) AcceptLanguage(acceptLanguage string) ApiGetIntegrationOutboundMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetIntegrationOutboundMessagesRequest) Execute() (*FetchIntegrationOutboundMessages, *http.Response, error) {
	return r.ApiService.GetIntegrationOutboundMessagesExecute(r)
}

/*
GetIntegrationOutboundMessages fetch integration outbound messages

API to Fetch Outbound Messages To External System by Hotel Id, Interface Id. <p><strong>OperationId:</strong>getIntegrationOutboundMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSystem Unique OPERA IntegrationSystem used to identify a IntegrationSystem in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiGetIntegrationOutboundMessagesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationOutboundMessages(ctx context.Context, integrationSystem string, interfaceId string, hotelId string) ApiGetIntegrationOutboundMessagesRequest {
	return ApiGetIntegrationOutboundMessagesRequest{
		ApiService: a,
		ctx: ctx,
		integrationSystem: integrationSystem,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchIntegrationOutboundMessages
func (a *OperaExchangeInterfaceConfigApiService) GetIntegrationOutboundMessagesExecute(r ApiGetIntegrationOutboundMessagesRequest) (*FetchIntegrationOutboundMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchIntegrationOutboundMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetIntegrationOutboundMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/integrationSystems/{integrationSystem}/integrationOutboundMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSystem"+"}", url.PathEscape(parameterValueToString(r.integrationSystem, "integrationSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.integrationSystem) < 1 {
		return localVarReturnValue, nil, reportError("integrationSystem must have at least 1 elements")
	}
	if strlen(r.integrationSystem) > 2000 {
		return localVarReturnValue, nil, reportError("integrationSystem must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.actionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "")
	}
	if r.errorMessageWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageWildCard", r.errorMessageWildCard, "")
	}
	if r.errorMessageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessageType", r.errorMessageType, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.includeReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReviewed", r.includeReviewed, "")
	}
	if r.fromMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromMessageID", r.fromMessageID, "")
	}
	if r.toMessageID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toMessageID", r.toMessageID, "")
	}
	if r.messageStatus != nil {
		t := *r.messageStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", t, "multi")
		}
	}
	if r.msgContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "msgContains", r.msgContains, "")
	}
	if r.anyOneOfTheMsg != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyOneOfTheMsg", r.anyOneOfTheMsg, "")
	}
	if r.valuesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "valuesOnly", r.valuesOnly, "")
	}
	if r.messageReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageReference", r.messageReference, "")
	}
	if r.messageTypes != nil {
		t := *r.messageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageTypes", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.includeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeErrors", r.includeErrors, "")
	}
	if r.actionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionId", r.actionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceControlsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	croCode *string
	parameterNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceControlsRequest) Authorization(authorization string) ApiGetInterfaceControlsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceControlsRequest) XAppKey(xAppKey string) ApiGetInterfaceControlsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceControlsRequest) XHotelid(xHotelid string) ApiGetInterfaceControlsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r ApiGetInterfaceControlsRequest) IntegrationSystem(integrationSystem string) ApiGetInterfaceControlsRequest {
	r.integrationSystem = &integrationSystem
	return r
}

func (r ApiGetInterfaceControlsRequest) CroCode(croCode string) ApiGetInterfaceControlsRequest {
	r.croCode = &croCode
	return r
}

func (r ApiGetInterfaceControlsRequest) ParameterNameWildCard(parameterNameWildCard string) ApiGetInterfaceControlsRequest {
	r.parameterNameWildCard = &parameterNameWildCard
	return r
}

// External system code.
func (r ApiGetInterfaceControlsRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceControlsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceControlsRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceControlsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceControlsRequest) Execute() (*FetchInterfaceControls, *http.Response, error) {
	return r.ApiService.GetInterfaceControlsExecute(r)
}

/*
GetInterfaceControls Retrieve OXI Parameters and Defaults

API to Fetch  Interface Controls  by Hotel Id and Interface Id <p><strong>OperationId:</strong>getInterfaceControls</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiGetInterfaceControlsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetInterfaceControls(ctx context.Context, interfaceId string, hotelId string) ApiGetInterfaceControlsRequest {
	return ApiGetInterfaceControlsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchInterfaceControls
func (a *OperaExchangeInterfaceConfigApiService) GetInterfaceControlsExecute(r ApiGetInterfaceControlsRequest) (*FetchInterfaceControls, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchInterfaceControls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetInterfaceControls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/interfaceControls"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.parameterNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNameWildCard", r.parameterNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLegacyInterfaceStatusRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetLegacyInterfaceStatusRequest) Authorization(authorization string) ApiGetLegacyInterfaceStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetLegacyInterfaceStatusRequest) XAppKey(xAppKey string) ApiGetLegacyInterfaceStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetLegacyInterfaceStatusRequest) XHotelid(xHotelid string) ApiGetLegacyInterfaceStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetLegacyInterfaceStatusRequest) XExternalsystem(xExternalsystem string) ApiGetLegacyInterfaceStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetLegacyInterfaceStatusRequest) AcceptLanguage(acceptLanguage string) ApiGetLegacyInterfaceStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetLegacyInterfaceStatusRequest) Execute() (*LegacyInterfaceStatusDetails, *http.Response, error) {
	return r.ApiService.GetLegacyInterfaceStatusExecute(r)
}

/*
GetLegacyInterfaceStatus Fetch legacy interface status

API to Fetch legacy OXI Interface Processor Status by Interface Id. <p><strong>OperationId:</strong>getLegacyInterfaceStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to find interface in OPERA.
 @return ApiGetLegacyInterfaceStatusRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetLegacyInterfaceStatus(ctx context.Context, interfaceId string) ApiGetLegacyInterfaceStatusRequest {
	return ApiGetLegacyInterfaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return LegacyInterfaceStatusDetails
func (a *OperaExchangeInterfaceConfigApiService) GetLegacyInterfaceStatusExecute(r ApiGetLegacyInterfaceStatusRequest) (*LegacyInterfaceStatusDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LegacyInterfaceStatusDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetLegacyInterfaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/legacyInterfaceStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOXIListOfValuesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	lovCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	integrationSystem *string
	includeInActive *bool
	parameterNames *[]string
	parameterValues *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOXIListOfValuesRequest) Authorization(authorization string) ApiGetOXIListOfValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOXIListOfValuesRequest) XAppKey(xAppKey string) ApiGetOXIListOfValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOXIListOfValuesRequest) XHotelid(xHotelid string) ApiGetOXIListOfValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents both OXI and OXI HUB are installed.
func (r ApiGetOXIListOfValuesRequest) IntegrationSystem(integrationSystem string) ApiGetOXIListOfValuesRequest {
	r.integrationSystem = &integrationSystem
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOXIListOfValuesRequest) IncludeInActive(includeInActive bool) ApiGetOXIListOfValuesRequest {
	r.includeInActive = &includeInActive
	return r
}

// Name of the parameter.
func (r ApiGetOXIListOfValuesRequest) ParameterNames(parameterNames []string) ApiGetOXIListOfValuesRequest {
	r.parameterNames = &parameterNames
	return r
}

// Value of the parameter.
func (r ApiGetOXIListOfValuesRequest) ParameterValues(parameterValues []string) ApiGetOXIListOfValuesRequest {
	r.parameterValues = &parameterValues
	return r
}

// External system code.
func (r ApiGetOXIListOfValuesRequest) XExternalsystem(xExternalsystem string) ApiGetOXIListOfValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOXIListOfValuesRequest) AcceptLanguage(acceptLanguage string) ApiGetOXIListOfValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOXIListOfValuesRequest) Execute() (*FetchOXIListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIListOfValuesExecute(r)
}

/*
GetOXIListOfValues Fetch list of values details for OXI

API to Fetch list of values for all OXI interface type External Systems. <p><strong>OperationId:</strong>getOXIListOfValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lovCode OXI LOVName in OPERA.
 @return ApiGetOXIListOfValuesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetOXIListOfValues(ctx context.Context, lovCode string) ApiGetOXIListOfValuesRequest {
	return ApiGetOXIListOfValuesRequest{
		ApiService: a,
		ctx: ctx,
		lovCode: lovCode,
	}
}

// Execute executes the request
//  @return FetchOXIListOfValues
func (a *OperaExchangeInterfaceConfigApiService) GetOXIListOfValuesExecute(r ApiGetOXIListOfValuesRequest) (*FetchOXIListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchOXIListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetOXIListOfValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lovCode/{lovCode}/listOfValuesOXI"
	localVarPath = strings.Replace(localVarPath, "{"+"lovCode"+"}", url.PathEscape(parameterValueToString(r.lovCode, "lovCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lovCode) < 1 {
		return localVarReturnValue, nil, reportError("lovCode must have at least 1 elements")
	}
	if strlen(r.lovCode) > 2000 {
		return localVarReturnValue, nil, reportError("lovCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.integrationSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationSystem", r.integrationSystem, "")
	}
	if r.includeInActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInActive", r.includeInActive, "")
	}
	if r.parameterNames != nil {
		t := *r.parameterNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNames", t, "multi")
		}
	}
	if r.parameterValues != nil {
		t := *r.parameterValues
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValues", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValues", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	includeXmlVersions *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileMatchRulesRequest) Authorization(authorization string) ApiGetProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileMatchRulesRequest) XAppKey(xAppKey string) ApiGetProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileMatchRulesRequest) XHotelid(xHotelid string) ApiGetProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetProfileMatchRulesRequest) HotelId(hotelId []string) ApiGetProfileMatchRulesRequest {
	r.hotelId = &hotelId
	return r
}

// Attribute that decides whether the search results include the XML Schema version details
func (r ApiGetProfileMatchRulesRequest) IncludeXmlVersions(includeXmlVersions bool) ApiGetProfileMatchRulesRequest {
	r.includeXmlVersions = &includeXmlVersions
	return r
}

// External system code.
func (r ApiGetProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) ApiGetProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileMatchRulesRequest) Execute() (*FetchProfileMatchRules, *http.Response, error) {
	return r.ApiService.GetProfileMatchRulesExecute(r)
}

/*
GetProfileMatchRules Fetch profile match rules

API to Fetch Profile Match Rules by Interface Id and Hotel Id. <p><strong>OperationId:</strong>getProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @return ApiGetProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) GetProfileMatchRules(ctx context.Context, interfaceId string) ApiGetProfileMatchRulesRequest {
	return ApiGetProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return FetchProfileMatchRules
func (a *OperaExchangeInterfaceConfigApiService) GetProfileMatchRulesExecute(r ApiGetProfileMatchRulesRequest) (*FetchProfileMatchRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchProfileMatchRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.GetProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/profileMatchRules"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
	}
	if r.includeXmlVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeXmlVersions", r.includeXmlVersions, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	automaticTransmissionSchedulesToBeCreated *PostAutomaticTransmissionSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAutomaticTransmissionSchedulesRequest) Authorization(authorization string) ApiPostAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) ApiPostAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) ApiPostAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create automatic transmission schedules
func (r ApiPostAutomaticTransmissionSchedulesRequest) AutomaticTransmissionSchedulesToBeCreated(automaticTransmissionSchedulesToBeCreated PostAutomaticTransmissionSchedulesRequest) ApiPostAutomaticTransmissionSchedulesRequest {
	r.automaticTransmissionSchedulesToBeCreated = &automaticTransmissionSchedulesToBeCreated
	return r
}

// External system code.
func (r ApiPostAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) ApiPostAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) ApiPostAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAutomaticTransmissionSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutomaticTransmissionSchedulesExecute(r)
}

/*
PostAutomaticTransmissionSchedules Create Automatic Transmission Schedules

API to Create Automatic Transmission Schedules. <p><strong>OperationId:</strong>postAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostAutomaticTransmissionSchedules(ctx context.Context) ApiPostAutomaticTransmissionSchedulesRequest {
	return ApiPostAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) PostAutomaticTransmissionSchedulesExecute(r ApiPostAutomaticTransmissionSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automaticTransmissionSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.automaticTransmissionSchedulesToBeCreated == nil {
		return localVarReturnValue, nil, reportError("automaticTransmissionSchedulesToBeCreated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.automaticTransmissionSchedulesToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	externalValue string
	operaValue string
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	conversionCodeMappingsToBeCreated *PostConversionCodeMappingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostConversionCodeMappingsRequest) Authorization(authorization string) ApiPostConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostConversionCodeMappingsRequest) XAppKey(xAppKey string) ApiPostConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostConversionCodeMappingsRequest) XHotelid(xHotelid string) ApiPostConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create Conversion Code Mappings.
func (r ApiPostConversionCodeMappingsRequest) ConversionCodeMappingsToBeCreated(conversionCodeMappingsToBeCreated PostConversionCodeMappingsRequest) ApiPostConversionCodeMappingsRequest {
	r.conversionCodeMappingsToBeCreated = &conversionCodeMappingsToBeCreated
	return r
}

// External system code.
func (r ApiPostConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) ApiPostConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) ApiPostConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostConversionCodeMappingsRequest) Execute() (*CreatedConversionCodeMappings, *http.Response, error) {
	return r.ApiService.PostConversionCodeMappingsExecute(r)
}

/*
PostConversionCodeMappings Create Conversion Codes Mappings

API to Create  Interface Mapping Conversion Codes by Hotel Id, Interface Id and Conversion Code with OPERA value and External value. <p><strong>OperationId:</strong>postConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalValue EXTERNAL Conversion Code value.
 @param operaValue PMS Conversion Code value.
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiPostConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostConversionCodeMappings(ctx context.Context, externalValue string, operaValue string, conversionCode string, interfaceId string, hotelId string) ApiPostConversionCodeMappingsRequest {
	return ApiPostConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		externalValue: externalValue,
		operaValue: operaValue,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreatedConversionCodeMappings
func (a *OperaExchangeInterfaceConfigApiService) PostConversionCodeMappingsExecute(r ApiPostConversionCodeMappingsRequest) (*CreatedConversionCodeMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatedConversionCodeMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversionCode/{conversionCode}/operaValue/{operaValue}/externalValue/{externalValue}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"externalValue"+"}", url.PathEscape(parameterValueToString(r.externalValue, "externalValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operaValue"+"}", url.PathEscape(parameterValueToString(r.operaValue, "operaValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalValue) < 1 {
		return localVarReturnValue, nil, reportError("externalValue must have at least 1 elements")
	}
	if strlen(r.externalValue) > 2000 {
		return localVarReturnValue, nil, reportError("externalValue must have less than 2000 elements")
	}
	if strlen(r.operaValue) < 1 {
		return localVarReturnValue, nil, reportError("operaValue must have at least 1 elements")
	}
	if strlen(r.operaValue) > 2000 {
		return localVarReturnValue, nil, reportError("operaValue must have less than 2000 elements")
	}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.conversionCodeMappingsToBeCreated == nil {
		return localVarReturnValue, nil, reportError("conversionCodeMappingsToBeCreated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.conversionCodeMappingsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	externalInterfaceSetupsToBeCreated *PostExternalInterfaceSetupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostExternalInterfaceSetupsRequest) Authorization(authorization string) ApiPostExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostExternalInterfaceSetupsRequest) XAppKey(xAppKey string) ApiPostExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostExternalInterfaceSetupsRequest) XHotelid(xHotelid string) ApiPostExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create External Interface Setups
func (r ApiPostExternalInterfaceSetupsRequest) ExternalInterfaceSetupsToBeCreated(externalInterfaceSetupsToBeCreated PostExternalInterfaceSetupsRequest) ApiPostExternalInterfaceSetupsRequest {
	r.externalInterfaceSetupsToBeCreated = &externalInterfaceSetupsToBeCreated
	return r
}

// External system code.
func (r ApiPostExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) ApiPostExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) ApiPostExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostExternalInterfaceSetupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExternalInterfaceSetupsExecute(r)
}

/*
PostExternalInterfaceSetups Create Interface Setup details

API to Create Interface Setup configuration. <p><strong>OperationId:</strong>postExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostExternalInterfaceSetups(ctx context.Context) ApiPostExternalInterfaceSetupsRequest {
	return ApiPostExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) PostExternalInterfaceSetupsExecute(r ApiPostExternalInterfaceSetupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalInterfaceSetups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.externalInterfaceSetupsToBeCreated == nil {
		return localVarReturnValue, nil, reportError("externalInterfaceSetupsToBeCreated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.externalInterfaceSetupsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileMatchRulesToBeCreated *PostProfileMatchRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostProfileMatchRulesRequest) Authorization(authorization string) ApiPostProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostProfileMatchRulesRequest) XAppKey(xAppKey string) ApiPostProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostProfileMatchRulesRequest) XHotelid(xHotelid string) ApiPostProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Profile Match Rules Configuration..
func (r ApiPostProfileMatchRulesRequest) ProfileMatchRulesToBeCreated(profileMatchRulesToBeCreated PostProfileMatchRulesRequest) ApiPostProfileMatchRulesRequest {
	r.profileMatchRulesToBeCreated = &profileMatchRulesToBeCreated
	return r
}

// External system code.
func (r ApiPostProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) ApiPostProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) ApiPostProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostProfileMatchRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileMatchRulesExecute(r)
}

/*
PostProfileMatchRules Create profile match rules

API to Create Profile Match Rules. <p><strong>OperationId:</strong>postProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PostProfileMatchRules(ctx context.Context) ApiPostProfileMatchRulesRequest {
	return ApiPostProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceConfigApiService) PostProfileMatchRulesExecute(r ApiPostProfileMatchRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PostProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileMatchRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profileMatchRulesToBeCreated == nil {
		return localVarReturnValue, nil, reportError("profileMatchRulesToBeCreated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileMatchRulesToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAutomaticTransmissionSchedulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	automaticTransmissionSchedulesToBeChanged *PutAutomaticTransmissionSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAutomaticTransmissionSchedulesRequest) Authorization(authorization string) ApiPutAutomaticTransmissionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAutomaticTransmissionSchedulesRequest) XAppKey(xAppKey string) ApiPutAutomaticTransmissionSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAutomaticTransmissionSchedulesRequest) XHotelid(xHotelid string) ApiPutAutomaticTransmissionSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change automatic transmission schedules
func (r ApiPutAutomaticTransmissionSchedulesRequest) AutomaticTransmissionSchedulesToBeChanged(automaticTransmissionSchedulesToBeChanged PutAutomaticTransmissionSchedulesRequest) ApiPutAutomaticTransmissionSchedulesRequest {
	r.automaticTransmissionSchedulesToBeChanged = &automaticTransmissionSchedulesToBeChanged
	return r
}

// External system code.
func (r ApiPutAutomaticTransmissionSchedulesRequest) XExternalsystem(xExternalsystem string) ApiPutAutomaticTransmissionSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAutomaticTransmissionSchedulesRequest) AcceptLanguage(acceptLanguage string) ApiPutAutomaticTransmissionSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAutomaticTransmissionSchedulesRequest) Execute() (*ChangedAutomaticTransmissionSchedules, *http.Response, error) {
	return r.ApiService.PutAutomaticTransmissionSchedulesExecute(r)
}

/*
PutAutomaticTransmissionSchedules Change Automatic Transmission Schedules

API to Modify  Automatic Transmission Schedules by Hotel Id. <p><strong>OperationId:</strong>putAutomaticTransmissionSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA internal ID used to identify a hotel in OPERA.
 @return ApiPutAutomaticTransmissionSchedulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutAutomaticTransmissionSchedules(ctx context.Context, hotelId string) ApiPutAutomaticTransmissionSchedulesRequest {
	return ApiPutAutomaticTransmissionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedAutomaticTransmissionSchedules
func (a *OperaExchangeInterfaceConfigApiService) PutAutomaticTransmissionSchedulesExecute(r ApiPutAutomaticTransmissionSchedulesRequest) (*ChangedAutomaticTransmissionSchedules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedAutomaticTransmissionSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutAutomaticTransmissionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/automaticTransmissionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.automaticTransmissionSchedulesToBeChanged == nil {
		return localVarReturnValue, nil, reportError("automaticTransmissionSchedulesToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.automaticTransmissionSchedulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCommunicationMethodsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationMethodsToBeChanged *PutCommunicationMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCommunicationMethodsRequest) Authorization(authorization string) ApiPutCommunicationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCommunicationMethodsRequest) XAppKey(xAppKey string) ApiPutCommunicationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCommunicationMethodsRequest) XHotelid(xHotelid string) ApiPutCommunicationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying Communication Methods.
func (r ApiPutCommunicationMethodsRequest) CommunicationMethodsToBeChanged(communicationMethodsToBeChanged PutCommunicationMethodsRequest) ApiPutCommunicationMethodsRequest {
	r.communicationMethodsToBeChanged = &communicationMethodsToBeChanged
	return r
}

// External system code.
func (r ApiPutCommunicationMethodsRequest) XExternalsystem(xExternalsystem string) ApiPutCommunicationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCommunicationMethodsRequest) AcceptLanguage(acceptLanguage string) ApiPutCommunicationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCommunicationMethodsRequest) Execute() (*ChangedCommunicationMethods, *http.Response, error) {
	return r.ApiService.PutCommunicationMethodsExecute(r)
}

/*
PutCommunicationMethods Modify Communication Methods 

API to Modify Communication Methods. <p><strong>OperationId:</strong>putCommunicationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCommunicationMethodsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutCommunicationMethods(ctx context.Context) ApiPutCommunicationMethodsRequest {
	return ApiPutCommunicationMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedCommunicationMethods
func (a *OperaExchangeInterfaceConfigApiService) PutCommunicationMethodsExecute(r ApiPutCommunicationMethodsRequest) (*ChangedCommunicationMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedCommunicationMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutCommunicationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.communicationMethodsToBeChanged == nil {
		return localVarReturnValue, nil, reportError("communicationMethodsToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.communicationMethodsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutConversionCodeMappingsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	externalValue string
	operaValue string
	id string
	conversionCode string
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	conversionCodeMappingsToBeChanged *PutConversionCodeMappingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutConversionCodeMappingsRequest) Authorization(authorization string) ApiPutConversionCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutConversionCodeMappingsRequest) XAppKey(xAppKey string) ApiPutConversionCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutConversionCodeMappingsRequest) XHotelid(xHotelid string) ApiPutConversionCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update existing Conversion Code Mappings.
func (r ApiPutConversionCodeMappingsRequest) ConversionCodeMappingsToBeChanged(conversionCodeMappingsToBeChanged PutConversionCodeMappingsRequest) ApiPutConversionCodeMappingsRequest {
	r.conversionCodeMappingsToBeChanged = &conversionCodeMappingsToBeChanged
	return r
}

// External system code.
func (r ApiPutConversionCodeMappingsRequest) XExternalsystem(xExternalsystem string) ApiPutConversionCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutConversionCodeMappingsRequest) AcceptLanguage(acceptLanguage string) ApiPutConversionCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutConversionCodeMappingsRequest) Execute() (*ChangedConversionCodeMappings, *http.Response, error) {
	return r.ApiService.PutConversionCodeMappingsExecute(r)
}

/*
PutConversionCodeMappings Change Conversion Codes Mappings

API to Modify  Interface Mapping  Conversion Codes by Hotel Id, Interface Id and Conversion Code Id with OPERA value and External value. <p><strong>OperationId:</strong>putConversionCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalValue EXTERNAL Conversion Code value.
 @param operaValue PMS Conversion Code value.
 @param id Unique OPERA internal ID used to identify a Conversion Code Mapping in OPERA.
 @param conversionCode Conversion Code in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @param hotelId Unique OPERA internal ID used to identify a Hotel in OPERA.
 @return ApiPutConversionCodeMappingsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodeMappings(ctx context.Context, externalValue string, operaValue string, id string, conversionCode string, interfaceId string, hotelId string) ApiPutConversionCodeMappingsRequest {
	return ApiPutConversionCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		externalValue: externalValue,
		operaValue: operaValue,
		id: id,
		conversionCode: conversionCode,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedConversionCodeMappings
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodeMappingsExecute(r ApiPutConversionCodeMappingsRequest) (*ChangedConversionCodeMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedConversionCodeMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutConversionCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/conversionCode/{conversionCode}/ID/{id}/operaValue/{operaValue}/externalValue/{externalValue}/conversionCodeMapping"
	localVarPath = strings.Replace(localVarPath, "{"+"externalValue"+"}", url.PathEscape(parameterValueToString(r.externalValue, "externalValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operaValue"+"}", url.PathEscape(parameterValueToString(r.operaValue, "operaValue")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversionCode"+"}", url.PathEscape(parameterValueToString(r.conversionCode, "conversionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalValue) < 1 {
		return localVarReturnValue, nil, reportError("externalValue must have at least 1 elements")
	}
	if strlen(r.externalValue) > 2000 {
		return localVarReturnValue, nil, reportError("externalValue must have less than 2000 elements")
	}
	if strlen(r.operaValue) < 1 {
		return localVarReturnValue, nil, reportError("operaValue must have at least 1 elements")
	}
	if strlen(r.operaValue) > 2000 {
		return localVarReturnValue, nil, reportError("operaValue must have less than 2000 elements")
	}
	if strlen(r.id) < 1 {
		return localVarReturnValue, nil, reportError("id must have at least 1 elements")
	}
	if strlen(r.id) > 2000 {
		return localVarReturnValue, nil, reportError("id must have less than 2000 elements")
	}
	if strlen(r.conversionCode) < 1 {
		return localVarReturnValue, nil, reportError("conversionCode must have at least 1 elements")
	}
	if strlen(r.conversionCode) > 2000 {
		return localVarReturnValue, nil, reportError("conversionCode must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.conversionCodeMappingsToBeChanged == nil {
		return localVarReturnValue, nil, reportError("conversionCodeMappingsToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.conversionCodeMappingsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutConversionCodesStatusRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	conversionCodesStatusToBeChanged *PutConversionCodesStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutConversionCodesStatusRequest) Authorization(authorization string) ApiPutConversionCodesStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutConversionCodesStatusRequest) XAppKey(xAppKey string) ApiPutConversionCodesStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutConversionCodesStatusRequest) XHotelid(xHotelid string) ApiPutConversionCodesStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the status of given Conversion Codes.
func (r ApiPutConversionCodesStatusRequest) ConversionCodesStatusToBeChanged(conversionCodesStatusToBeChanged PutConversionCodesStatusRequest) ApiPutConversionCodesStatusRequest {
	r.conversionCodesStatusToBeChanged = &conversionCodesStatusToBeChanged
	return r
}

// External system code.
func (r ApiPutConversionCodesStatusRequest) XExternalsystem(xExternalsystem string) ApiPutConversionCodesStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutConversionCodesStatusRequest) AcceptLanguage(acceptLanguage string) ApiPutConversionCodesStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutConversionCodesStatusRequest) Execute() (*ChangedConversionCodesStatus, *http.Response, error) {
	return r.ApiService.PutConversionCodesStatusExecute(r)
}

/*
PutConversionCodesStatus Change Conversion codes Status

API to Modify Interface Mapping UDF Conversion Codes. <p><strong>OperationId:</strong>putConversionCodesStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutConversionCodesStatusRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodesStatus(ctx context.Context) ApiPutConversionCodesStatusRequest {
	return ApiPutConversionCodesStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedConversionCodesStatus
func (a *OperaExchangeInterfaceConfigApiService) PutConversionCodesStatusExecute(r ApiPutConversionCodesStatusRequest) (*ChangedConversionCodesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedConversionCodesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutConversionCodesStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversionCodesStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.conversionCodesStatusToBeChanged == nil {
		return localVarReturnValue, nil, reportError("conversionCodesStatusToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.conversionCodesStatusToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutExternalInterfaceSetupsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	externalInterfaceSetupsToBeChanged *PutExternalInterfaceSetupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutExternalInterfaceSetupsRequest) Authorization(authorization string) ApiPutExternalInterfaceSetupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutExternalInterfaceSetupsRequest) XAppKey(xAppKey string) ApiPutExternalInterfaceSetupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutExternalInterfaceSetupsRequest) XHotelid(xHotelid string) ApiPutExternalInterfaceSetupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change External Interface Setups
func (r ApiPutExternalInterfaceSetupsRequest) ExternalInterfaceSetupsToBeChanged(externalInterfaceSetupsToBeChanged PutExternalInterfaceSetupsRequest) ApiPutExternalInterfaceSetupsRequest {
	r.externalInterfaceSetupsToBeChanged = &externalInterfaceSetupsToBeChanged
	return r
}

// External system code.
func (r ApiPutExternalInterfaceSetupsRequest) XExternalsystem(xExternalsystem string) ApiPutExternalInterfaceSetupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutExternalInterfaceSetupsRequest) AcceptLanguage(acceptLanguage string) ApiPutExternalInterfaceSetupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutExternalInterfaceSetupsRequest) Execute() (*ChangedExternalInterfaceSetups, *http.Response, error) {
	return r.ApiService.PutExternalInterfaceSetupsExecute(r)
}

/*
PutExternalInterfaceSetups Modify external Interface Setup details

API to Modify  Interface Setup configuration. <p><strong>OperationId:</strong>putExternalInterfaceSetups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutExternalInterfaceSetupsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutExternalInterfaceSetups(ctx context.Context) ApiPutExternalInterfaceSetupsRequest {
	return ApiPutExternalInterfaceSetupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedExternalInterfaceSetups
func (a *OperaExchangeInterfaceConfigApiService) PutExternalInterfaceSetupsExecute(r ApiPutExternalInterfaceSetupsRequest) (*ChangedExternalInterfaceSetups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedExternalInterfaceSetups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutExternalInterfaceSetups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceSetups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.externalInterfaceSetupsToBeChanged == nil {
		return localVarReturnValue, nil, reportError("externalInterfaceSetupsToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.externalInterfaceSetupsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutInterfaceControlsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	interfaceControlsToBeChanged *PutInterfaceControlsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutInterfaceControlsRequest) Authorization(authorization string) ApiPutInterfaceControlsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutInterfaceControlsRequest) XAppKey(xAppKey string) ApiPutInterfaceControlsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutInterfaceControlsRequest) XHotelid(xHotelid string) ApiPutInterfaceControlsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing one or more OXI Parameters/Settings.
func (r ApiPutInterfaceControlsRequest) InterfaceControlsToBeChanged(interfaceControlsToBeChanged PutInterfaceControlsRequest) ApiPutInterfaceControlsRequest {
	r.interfaceControlsToBeChanged = &interfaceControlsToBeChanged
	return r
}

// External system code.
func (r ApiPutInterfaceControlsRequest) XExternalsystem(xExternalsystem string) ApiPutInterfaceControlsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutInterfaceControlsRequest) AcceptLanguage(acceptLanguage string) ApiPutInterfaceControlsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutInterfaceControlsRequest) Execute() (*ChangedInterfaceControls, *http.Response, error) {
	return r.ApiService.PutInterfaceControlsExecute(r)
}

/*
PutInterfaceControls Change OXI Parameters and Defaults

API to Modify Interface Controls by Interface Id. <p><strong>OperationId:</strong>putInterfaceControls</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA.
 @return ApiPutInterfaceControlsRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutInterfaceControls(ctx context.Context, interfaceId string) ApiPutInterfaceControlsRequest {
	return ApiPutInterfaceControlsRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ChangedInterfaceControls
func (a *OperaExchangeInterfaceConfigApiService) PutInterfaceControlsExecute(r ApiPutInterfaceControlsRequest) (*ChangedInterfaceControls, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedInterfaceControls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutInterfaceControls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/interfaceControls"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.interfaceControlsToBeChanged == nil {
		return localVarReturnValue, nil, reportError("interfaceControlsToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.interfaceControlsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutProfileMatchRulesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileMatchRulesToBeChanged *PutProfileMatchRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutProfileMatchRulesRequest) Authorization(authorization string) ApiPutProfileMatchRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutProfileMatchRulesRequest) XAppKey(xAppKey string) ApiPutProfileMatchRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutProfileMatchRulesRequest) XHotelid(xHotelid string) ApiPutProfileMatchRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Profile Match Rules Configuration.
func (r ApiPutProfileMatchRulesRequest) ProfileMatchRulesToBeChanged(profileMatchRulesToBeChanged PutProfileMatchRulesRequest) ApiPutProfileMatchRulesRequest {
	r.profileMatchRulesToBeChanged = &profileMatchRulesToBeChanged
	return r
}

// External system code.
func (r ApiPutProfileMatchRulesRequest) XExternalsystem(xExternalsystem string) ApiPutProfileMatchRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutProfileMatchRulesRequest) AcceptLanguage(acceptLanguage string) ApiPutProfileMatchRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutProfileMatchRulesRequest) Execute() (*ChangedProfileMatchRules, *http.Response, error) {
	return r.ApiService.PutProfileMatchRulesExecute(r)
}

/*
PutProfileMatchRules Change profile match rules 

API to Modify Profile Match Rules. <p><strong>OperationId:</strong>putProfileMatchRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutProfileMatchRulesRequest
*/
func (a *OperaExchangeInterfaceConfigApiService) PutProfileMatchRules(ctx context.Context) ApiPutProfileMatchRulesRequest {
	return ApiPutProfileMatchRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedProfileMatchRules
func (a *OperaExchangeInterfaceConfigApiService) PutProfileMatchRulesExecute(r ApiPutProfileMatchRulesRequest) (*ChangedProfileMatchRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedProfileMatchRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceConfigApiService.PutProfileMatchRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileMatchRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.profileMatchRulesToBeChanged == nil {
		return localVarReturnValue, nil, reportError("profileMatchRulesToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileMatchRulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
