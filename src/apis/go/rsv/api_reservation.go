/*
OPERA Cloud Reservation API

APIs to cater for Reservation functionality in OPERA Cloud. <br /><br />OPERA Cloud Reservations provides a complete set of capabilities for creating and updating reservations. Reservations are a central feature of OPERA Cloud. As a key source of information, the reservation specifies a guest&apos;s arrival date, departure date, room type, rate, packages, and many other details. It is also a gateway to dozens of other functions that contribute to the guest&apos;s experience.  All reservations in OPERA Cloud require a guest profile.<br /><br /> You can create profiles while booking a reservation. If a profile already exists, you can look it up (using getProfiles in the Customer Relationship Management module) and attach it to the reservation during the reservation booking process using the profileId.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// ReservationApiService ReservationApi service
type ReservationApiService service

type ApiDeletePreCheckInReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	resvIDExtension *int32
	arrivalTime *time.Time
	roomNumber *string
	guestPreferredCurrency *string
	allowMobileViewFolio *bool
	paymentMethodDescription *[]string
	paymentMethodFolioView *[]int32
	paymentMethod *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	cardId *string
	cardIdIDExtension *int32
	cardIdIDContext *string
	cardIdType *string
	currentAuthorizedAmount *float32
	authorizedAmountCurrencyCode *string
	approvalAmountNeeded *float32
	approvalAmountCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	authorizationRuleCode *int32
	authorizationRuleAmount *float32
	authorizationRuleCurrencyCode *string
	authorizationRulePercent *float32
	emailFolio *bool
	emailFolioID *string
	emailFolioIDExtension *int32
	emailFolioIDContext *string
	emailFolioIDType *string
	emailFolioCreateDateTime *time.Time
	emailFolioCreatorID *string
	emailFolioEmailAddress *string
	emailFolioEmailFormat *string
	emailFolioLastModifierID *string
	emailFolioLastModifyDateTime *time.Time
	emailFolioOrderSequence *float32
	emailFolioPrimaryInd *bool
	emailFolioPurgeDate *string
	emailFolioType *string
	emailFolioTypeDescription *string
	arrivalCarrierCode *string
	arrivalDateTime *time.Time
	arrivalStationCode *string
	arrivalTransportCode *string
	arrivalTransportationReqd *bool
	arrivalType *string
	arrivalComments *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeletePreCheckInReservationRequest) Authorization(authorization string) ApiDeletePreCheckInReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiDeletePreCheckInReservationRequest) XAppKey(xAppKey string) ApiDeletePreCheckInReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeletePreCheckInReservationRequest) XHotelid(xHotelid string) ApiDeletePreCheckInReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeletePreCheckInReservationRequest) ResvIDExtension(resvIDExtension int32) ApiDeletePreCheckInReservationRequest {
	r.resvIDExtension = &resvIDExtension
	return r
}

// The time at which the guest arrives at the hotel.
func (r ApiDeletePreCheckInReservationRequest) ArrivalTime(arrivalTime time.Time) ApiDeletePreCheckInReservationRequest {
	r.arrivalTime = &arrivalTime
	return r
}

// Room Number to be assigned to the reservation.
func (r ApiDeletePreCheckInReservationRequest) RoomNumber(roomNumber string) ApiDeletePreCheckInReservationRequest {
	r.roomNumber = &roomNumber
	return r
}

// Currency code preferred by guest.
func (r ApiDeletePreCheckInReservationRequest) GuestPreferredCurrency(guestPreferredCurrency string) ApiDeletePreCheckInReservationRequest {
	r.guestPreferredCurrency = &guestPreferredCurrency
	return r
}

// Attribute AllowMobileViewFolio is set to true when the reservation is eligible for viewing folio using mobile device.
func (r ApiDeletePreCheckInReservationRequest) AllowMobileViewFolio(allowMobileViewFolio bool) ApiDeletePreCheckInReservationRequest {
	r.allowMobileViewFolio = &allowMobileViewFolio
	return r
}

func (r ApiDeletePreCheckInReservationRequest) PaymentMethodDescription(paymentMethodDescription []string) ApiDeletePreCheckInReservationRequest {
	r.paymentMethodDescription = &paymentMethodDescription
	return r
}

func (r ApiDeletePreCheckInReservationRequest) PaymentMethodFolioView(paymentMethodFolioView []int32) ApiDeletePreCheckInReservationRequest {
	r.paymentMethodFolioView = &paymentMethodFolioView
	return r
}

func (r ApiDeletePreCheckInReservationRequest) PaymentMethod(paymentMethod []string) ApiDeletePreCheckInReservationRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Attach the credit card to profile.
func (r ApiDeletePreCheckInReservationRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiDeletePreCheckInReservationRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiDeletePreCheckInReservationRequest) CardHolderName(cardHolderName string) ApiDeletePreCheckInReservationRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiDeletePreCheckInReservationRequest) CardNumber(cardNumber string) ApiDeletePreCheckInReservationRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiDeletePreCheckInReservationRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiDeletePreCheckInReservationRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiDeletePreCheckInReservationRequest) CardNumberMasked(cardNumberMasked string) ApiDeletePreCheckInReservationRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiDeletePreCheckInReservationRequest) CardOrToken(cardOrToken string) ApiDeletePreCheckInReservationRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiDeletePreCheckInReservationRequest) CardType(cardType string) ApiDeletePreCheckInReservationRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiDeletePreCheckInReservationRequest) ExpirationDate(expirationDate string) ApiDeletePreCheckInReservationRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ExpirationDateExpired(expirationDateExpired bool) ApiDeletePreCheckInReservationRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiDeletePreCheckInReservationRequest) ExpirationDateMasked(expirationDateMasked string) ApiDeletePreCheckInReservationRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiDeletePreCheckInReservationRequest) Processing(processing string) ApiDeletePreCheckInReservationRequest {
	r.processing = &processing
	return r
}

func (r ApiDeletePreCheckInReservationRequest) Swiped(swiped bool) ApiDeletePreCheckInReservationRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiDeletePreCheckInReservationRequest) UserDefinedCardType(userDefinedCardType string) ApiDeletePreCheckInReservationRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeletePreCheckInReservationRequest) CardId(cardId string) ApiDeletePreCheckInReservationRequest {
	r.cardId = &cardId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeletePreCheckInReservationRequest) CardIdIDExtension(cardIdIDExtension int32) ApiDeletePreCheckInReservationRequest {
	r.cardIdIDExtension = &cardIdIDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeletePreCheckInReservationRequest) CardIdIDContext(cardIdIDContext string) ApiDeletePreCheckInReservationRequest {
	r.cardIdIDContext = &cardIdIDContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeletePreCheckInReservationRequest) CardIdType(cardIdType string) ApiDeletePreCheckInReservationRequest {
	r.cardIdType = &cardIdType
	return r
}

// A monetary amount.
func (r ApiDeletePreCheckInReservationRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) ApiDeletePreCheckInReservationRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiDeletePreCheckInReservationRequest) AuthorizedAmountCurrencyCode(authorizedAmountCurrencyCode string) ApiDeletePreCheckInReservationRequest {
	r.authorizedAmountCurrencyCode = &authorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiDeletePreCheckInReservationRequest) ApprovalAmountNeeded(approvalAmountNeeded float32) ApiDeletePreCheckInReservationRequest {
	r.approvalAmountNeeded = &approvalAmountNeeded
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiDeletePreCheckInReservationRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiDeletePreCheckInReservationRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiDeletePreCheckInReservationRequest) BalanceAmount(balanceAmount float32) ApiDeletePreCheckInReservationRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiDeletePreCheckInReservationRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiDeletePreCheckInReservationRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ApiDeletePreCheckInReservationRequest) AuthorizationRuleCode(authorizationRuleCode int32) ApiDeletePreCheckInReservationRequest {
	r.authorizationRuleCode = &authorizationRuleCode
	return r
}

// A monetary amount.
func (r ApiDeletePreCheckInReservationRequest) AuthorizationRuleAmount(authorizationRuleAmount float32) ApiDeletePreCheckInReservationRequest {
	r.authorizationRuleAmount = &authorizationRuleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiDeletePreCheckInReservationRequest) AuthorizationRuleCurrencyCode(authorizationRuleCurrencyCode string) ApiDeletePreCheckInReservationRequest {
	r.authorizationRuleCurrencyCode = &authorizationRuleCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ApiDeletePreCheckInReservationRequest) AuthorizationRulePercent(authorizationRulePercent float32) ApiDeletePreCheckInReservationRequest {
	r.authorizationRulePercent = &authorizationRulePercent
	return r
}

func (r ApiDeletePreCheckInReservationRequest) EmailFolio(emailFolio bool) ApiDeletePreCheckInReservationRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioID(emailFolioID string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioID = &emailFolioID
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioIDExtension(emailFolioIDExtension int32) ApiDeletePreCheckInReservationRequest {
	r.emailFolioIDExtension = &emailFolioIDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeletePreCheckInReservationRequest) EmailFolioIDContext(emailFolioIDContext string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioIDContext = &emailFolioIDContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioIDType(emailFolioIDType string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioIDType = &emailFolioIDType
	return r
}

// Time stamp of the creation.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioCreateDateTime(emailFolioCreateDateTime time.Time) ApiDeletePreCheckInReservationRequest {
	r.emailFolioCreateDateTime = &emailFolioCreateDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioCreatorID(emailFolioCreatorID string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioCreatorID = &emailFolioCreatorID
	return r
}

// Defines the e-mail address.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioEmailAddress(emailFolioEmailAddress string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioEmailAddress = &emailFolioEmailAddress
	return r
}

// Supported Email format.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioEmailFormat(emailFolioEmailFormat string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioEmailFormat = &emailFolioEmailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioLastModifierID(emailFolioLastModifierID string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioLastModifierID = &emailFolioLastModifierID
	return r
}

// Time stamp of last modification.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioLastModifyDateTime(emailFolioLastModifyDateTime time.Time) ApiDeletePreCheckInReservationRequest {
	r.emailFolioLastModifyDateTime = &emailFolioLastModifyDateTime
	return r
}

// Display Order sequence.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioOrderSequence(emailFolioOrderSequence float32) ApiDeletePreCheckInReservationRequest {
	r.emailFolioOrderSequence = &emailFolioOrderSequence
	return r
}

// When true, indicates a primary information.
func (r ApiDeletePreCheckInReservationRequest) EmailFolioPrimaryInd(emailFolioPrimaryInd bool) ApiDeletePreCheckInReservationRequest {
	r.emailFolioPrimaryInd = &emailFolioPrimaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ApiDeletePreCheckInReservationRequest) EmailFolioPurgeDate(emailFolioPurgeDate string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioPurgeDate = &emailFolioPurgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ApiDeletePreCheckInReservationRequest) EmailFolioType(emailFolioType string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioType = &emailFolioType
	return r
}

// Describes the Type code
func (r ApiDeletePreCheckInReservationRequest) EmailFolioTypeDescription(emailFolioTypeDescription string) ApiDeletePreCheckInReservationRequest {
	r.emailFolioTypeDescription = &emailFolioTypeDescription
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalCarrierCode(arrivalCarrierCode string) ApiDeletePreCheckInReservationRequest {
	r.arrivalCarrierCode = &arrivalCarrierCode
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalDateTime(arrivalDateTime time.Time) ApiDeletePreCheckInReservationRequest {
	r.arrivalDateTime = &arrivalDateTime
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalStationCode(arrivalStationCode string) ApiDeletePreCheckInReservationRequest {
	r.arrivalStationCode = &arrivalStationCode
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalTransportCode(arrivalTransportCode string) ApiDeletePreCheckInReservationRequest {
	r.arrivalTransportCode = &arrivalTransportCode
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalTransportationReqd(arrivalTransportationReqd bool) ApiDeletePreCheckInReservationRequest {
	r.arrivalTransportationReqd = &arrivalTransportationReqd
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalType(arrivalType string) ApiDeletePreCheckInReservationRequest {
	r.arrivalType = &arrivalType
	return r
}

func (r ApiDeletePreCheckInReservationRequest) ArrivalComments(arrivalComments string) ApiDeletePreCheckInReservationRequest {
	r.arrivalComments = &arrivalComments
	return r
}

// External system code.
func (r ApiDeletePreCheckInReservationRequest) XExternalsystem(xExternalsystem string) ApiDeletePreCheckInReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeletePreCheckInReservationRequest) AcceptLanguage(acceptLanguage string) ApiDeletePreCheckInReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeletePreCheckInReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePreCheckInReservationExecute(r)
}

/*
DeletePreCheckInReservation Revert a PreCheckIn Reservation

This will cancel or rather revert the pre-checkin action for a guest's reservation. The reservation will return to DUEIN status. <p><strong>OperationId:</strong>deletePreCheckInReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiDeletePreCheckInReservationRequest
*/
func (a *ReservationApiService) DeletePreCheckInReservation(ctx context.Context, reservationId string, hotelId string) ApiDeletePreCheckInReservationRequest {
	return ApiDeletePreCheckInReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeletePreCheckInReservationExecute(r ApiDeletePreCheckInReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeletePreCheckInReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preCheckIn"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.resvIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resvIDExtension", r.resvIDExtension, "")
	}
	if r.arrivalTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalTime", r.arrivalTime, "")
	}
	if r.roomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumber", r.roomNumber, "")
	}
	if r.guestPreferredCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestPreferredCurrency", r.guestPreferredCurrency, "")
	}
	if r.allowMobileViewFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowMobileViewFolio", r.allowMobileViewFolio, "")
	}
	if r.paymentMethodDescription != nil {
		t := *r.paymentMethodDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodDescription", t, "multi")
		}
	}
	if r.paymentMethodFolioView != nil {
		t := *r.paymentMethodFolioView
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodFolioView", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodFolioView", t, "multi")
		}
	}
	if r.paymentMethod != nil {
		t := *r.paymentMethod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", t, "multi")
		}
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.cardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardId", r.cardId, "")
	}
	if r.cardIdIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIDExtension", r.cardIdIDExtension, "")
	}
	if r.cardIdIDContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIDContext", r.cardIdIDContext, "")
	}
	if r.cardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdType", r.cardIdType, "")
	}
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
	}
	if r.authorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedAmountCurrencyCode", r.authorizedAmountCurrencyCode, "")
	}
	if r.approvalAmountNeeded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeeded", r.approvalAmountNeeded, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.authorizationRuleCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRuleCode", r.authorizationRuleCode, "")
	}
	if r.authorizationRuleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRuleAmount", r.authorizationRuleAmount, "")
	}
	if r.authorizationRuleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRuleCurrencyCode", r.authorizationRuleCurrencyCode, "")
	}
	if r.authorizationRulePercent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRulePercent", r.authorizationRulePercent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.emailFolioID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioID", r.emailFolioID, "")
	}
	if r.emailFolioIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioIDExtension", r.emailFolioIDExtension, "")
	}
	if r.emailFolioIDContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioIDContext", r.emailFolioIDContext, "")
	}
	if r.emailFolioIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioIDType", r.emailFolioIDType, "")
	}
	if r.emailFolioCreateDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioCreateDateTime", r.emailFolioCreateDateTime, "")
	}
	if r.emailFolioCreatorID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioCreatorID", r.emailFolioCreatorID, "")
	}
	if r.emailFolioEmailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioEmailAddress", r.emailFolioEmailAddress, "")
	}
	if r.emailFolioEmailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioEmailFormat", r.emailFolioEmailFormat, "")
	}
	if r.emailFolioLastModifierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioLastModifierID", r.emailFolioLastModifierID, "")
	}
	if r.emailFolioLastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioLastModifyDateTime", r.emailFolioLastModifyDateTime, "")
	}
	if r.emailFolioOrderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioOrderSequence", r.emailFolioOrderSequence, "")
	}
	if r.emailFolioPrimaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioPrimaryInd", r.emailFolioPrimaryInd, "")
	}
	if r.emailFolioPurgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioPurgeDate", r.emailFolioPurgeDate, "")
	}
	if r.emailFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioType", r.emailFolioType, "")
	}
	if r.emailFolioTypeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioTypeDescription", r.emailFolioTypeDescription, "")
	}
	if r.arrivalCarrierCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalCarrierCode", r.arrivalCarrierCode, "")
	}
	if r.arrivalDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalDateTime", r.arrivalDateTime, "")
	}
	if r.arrivalStationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStationCode", r.arrivalStationCode, "")
	}
	if r.arrivalTransportCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalTransportCode", r.arrivalTransportCode, "")
	}
	if r.arrivalTransportationReqd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalTransportationReqd", r.arrivalTransportationReqd, "")
	}
	if r.arrivalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalType", r.arrivalType, "")
	}
	if r.arrivalComments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalComments", r.arrivalComments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteReservationLinksRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteReservationLinksRequest) Authorization(authorization string) ApiDeleteReservationLinksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiDeleteReservationLinksRequest) XAppKey(xAppKey string) ApiDeleteReservationLinksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteReservationLinksRequest) XHotelid(xHotelid string) ApiDeleteReservationLinksRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteReservationLinksRequest) XExternalsystem(xExternalsystem string) ApiDeleteReservationLinksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteReservationLinksRequest) AcceptLanguage(acceptLanguage string) ApiDeleteReservationLinksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteReservationLinksRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationLinksExecute(r)
}

/*
DeleteReservationLinks Remove Reservation Links

Use this API to unlink a reservation from its currently associated reservation. <p><strong>OperationId:</strong>deleteReservationLinks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiDeleteReservationLinksRequest
*/
func (a *ReservationApiService) DeleteReservationLinks(ctx context.Context, reservationId string, hotelId string) ApiDeleteReservationLinksRequest {
	return ApiDeleteReservationLinksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationLinksExecute(r ApiDeleteReservationLinksRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalSystemReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	extSystemCode string
	externalReferenceList *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	recentlyAccessed *bool
	limit *int32
	offset *int32
	searchType *string
	hotelIds *[]string
	text *string
	arrivalEndDate *string
	arrivalStartDate *string
	departureEndDate *string
	departureStartDate *string
	expectedArrivalStartTime *time.Time
	expectedArrivalEndTime *time.Time
	expectedReturnEndTime *time.Time
	expectedReturnStartTime *time.Time
	companyNames *[]string
	travelAgentIds *[]string
	companyIds *[]string
	sourceIds *[]string
	contactIds *[]string
	groupIds *[]string
	billingContactIds *[]string
	profileIds *[]string
	membershipCardNumber *string
	membershipLevels *[]string
	membershipTypes *[]string
	surname *string
	givenName *string
	anyVIPStatus *bool
	vipCodes *[]string
	guaranteeCode *string
	paymentMethod *string
	discountApplied *bool
	user *[]string
	createdBy *string
	cancelledByList *[]string
	cancelledOn *string
	ratePlanCodes *[]string
	sourceCodes *[]string
	marketCodes *[]string
	excludeBlockReservations *bool
	blockName *string
	blockIds *[]string
	blockCodes *[]string
	customReference *string
	recordLocator *string
	orderBy *[]string
	sortOrder *[]string
	roomAssignedOnly *bool
	roomUnassignedOnly *bool
	roomId *string
	roomType *[]string
	roomFeatures *[]string
	roomSpecials *[]string
	roomSmokingPreference *string
	roomFloorPreferences *[]string
	housekeepingRoomStatuses *[]string
	roomClasses *[]string
	roomRangeFrom *string
	roomRangeTo *string
	communication *string
	fetchInstructions *[]string
	allowPreRegistration *bool
	hasDepositBalance *bool
	hasOpenBalance *bool
	hasOpenFolio *bool
	includeScheduledCheckOut *bool
	linkedOnly *bool
	unlinkedOnly *bool
	actualArrivals *bool
	actualDepartures *bool
	complimentaryReservations *bool
	dayOfArrivalCancels *bool
	dayUse *bool
	earlyDepartures *bool
	expectedArrivals *bool
	expectedDepartures *bool
	extendedStays *bool
	houseUseReservations *bool
	stayovers *bool
	stayDate *string
	roomRoutingId *string
	excludePseudoRoomReservations *bool
	excludeReservationIds *[]string
	excludeVIPStatusCodes *[]string
	excludeSpecials *[]string
	excludeFloorPreferences *[]string
	excludeAdvanceCheckedIn *bool
	playerId *string
	gamingBalanceFrom *float32
	gamingBalanceTo *float32
	compAccountingBalanceFrom *float32
	compAccountingBalanceTo *float32
	searchTypes *[]string
	reservationStatuses *[]string
	transportationCodes *[]string
	roomReadyStatuses *[]string
	checkoutMessageReceived *bool
	optedForCommunication *bool
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) ExternalReferenceList(externalReferenceList []string) ApiGetExternalSystemReservationsRequest {
	r.externalReferenceList = &externalReferenceList
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExternalSystemReservationsRequest) Authorization(authorization string) ApiGetExternalSystemReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetExternalSystemReservationsRequest) XAppKey(xAppKey string) ApiGetExternalSystemReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExternalSystemReservationsRequest) XHotelid(xHotelid string) ApiGetExternalSystemReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this reservation as recently accessed.
func (r ApiGetExternalSystemReservationsRequest) RecentlyAccessed(recentlyAccessed bool) ApiGetExternalSystemReservationsRequest {
	r.recentlyAccessed = &recentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetExternalSystemReservationsRequest) Limit(limit int32) ApiGetExternalSystemReservationsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetExternalSystemReservationsRequest) Offset(offset int32) ApiGetExternalSystemReservationsRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ApiGetExternalSystemReservationsRequest) SearchType(searchType string) ApiGetExternalSystemReservationsRequest {
	r.searchType = &searchType
	return r
}

// List of Hotels to support searches with multiple resorts for which traces are to be fetched.
func (r ApiGetExternalSystemReservationsRequest) HotelIds(hotelIds []string) ApiGetExternalSystemReservationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Free form text field for searching all reservation fields
func (r ApiGetExternalSystemReservationsRequest) Text(text string) ApiGetExternalSystemReservationsRequest {
	r.text = &text
	return r
}

// The ending value of the date range.
func (r ApiGetExternalSystemReservationsRequest) ArrivalEndDate(arrivalEndDate string) ApiGetExternalSystemReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetExternalSystemReservationsRequest) ArrivalStartDate(arrivalStartDate string) ApiGetExternalSystemReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r ApiGetExternalSystemReservationsRequest) DepartureEndDate(departureEndDate string) ApiGetExternalSystemReservationsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetExternalSystemReservationsRequest) DepartureStartDate(departureStartDate string) ApiGetExternalSystemReservationsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The ending value of the time span.
func (r ApiGetExternalSystemReservationsRequest) ExpectedArrivalStartTime(expectedArrivalStartTime time.Time) ApiGetExternalSystemReservationsRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// The starting value of the time span.
func (r ApiGetExternalSystemReservationsRequest) ExpectedArrivalEndTime(expectedArrivalEndTime time.Time) ApiGetExternalSystemReservationsRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The ending value of the time span.
func (r ApiGetExternalSystemReservationsRequest) ExpectedReturnEndTime(expectedReturnEndTime time.Time) ApiGetExternalSystemReservationsRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r ApiGetExternalSystemReservationsRequest) ExpectedReturnStartTime(expectedReturnStartTime time.Time) ApiGetExternalSystemReservationsRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Attached profile name
func (r ApiGetExternalSystemReservationsRequest) CompanyNames(companyNames []string) ApiGetExternalSystemReservationsRequest {
	r.companyNames = &companyNames
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) TravelAgentIds(travelAgentIds []string) ApiGetExternalSystemReservationsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) CompanyIds(companyIds []string) ApiGetExternalSystemReservationsRequest {
	r.companyIds = &companyIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) SourceIds(sourceIds []string) ApiGetExternalSystemReservationsRequest {
	r.sourceIds = &sourceIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) ContactIds(contactIds []string) ApiGetExternalSystemReservationsRequest {
	r.contactIds = &contactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) GroupIds(groupIds []string) ApiGetExternalSystemReservationsRequest {
	r.groupIds = &groupIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) BillingContactIds(billingContactIds []string) ApiGetExternalSystemReservationsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) ProfileIds(profileIds []string) ApiGetExternalSystemReservationsRequest {
	r.profileIds = &profileIds
	return r
}

// Membership ID criteria.
func (r ApiGetExternalSystemReservationsRequest) MembershipCardNumber(membershipCardNumber string) ApiGetExternalSystemReservationsRequest {
	r.membershipCardNumber = &membershipCardNumber
	return r
}

func (r ApiGetExternalSystemReservationsRequest) MembershipLevels(membershipLevels []string) ApiGetExternalSystemReservationsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

func (r ApiGetExternalSystemReservationsRequest) MembershipTypes(membershipTypes []string) ApiGetExternalSystemReservationsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Family name, last name.
func (r ApiGetExternalSystemReservationsRequest) Surname(surname string) ApiGetExternalSystemReservationsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ApiGetExternalSystemReservationsRequest) GivenName(givenName string) ApiGetExternalSystemReservationsRequest {
	r.givenName = &givenName
	return r
}

// VIP status of the customer.
func (r ApiGetExternalSystemReservationsRequest) AnyVIPStatus(anyVIPStatus bool) ApiGetExternalSystemReservationsRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r ApiGetExternalSystemReservationsRequest) VipCodes(vipCodes []string) ApiGetExternalSystemReservationsRequest {
	r.vipCodes = &vipCodes
	return r
}

// Fetches the reservation having Guarantee Code(Reservation Type) supplied here.
func (r ApiGetExternalSystemReservationsRequest) GuaranteeCode(guaranteeCode string) ApiGetExternalSystemReservationsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Fetches the reservation having method of payment supplied here.
func (r ApiGetExternalSystemReservationsRequest) PaymentMethod(paymentMethod string) ApiGetExternalSystemReservationsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Fetches the reservation for which discount is applied
func (r ApiGetExternalSystemReservationsRequest) DiscountApplied(discountApplied bool) ApiGetExternalSystemReservationsRequest {
	r.discountApplied = &discountApplied
	return r
}

func (r ApiGetExternalSystemReservationsRequest) User(user []string) ApiGetExternalSystemReservationsRequest {
	r.user = &user
	return r
}

// Fetches reservation created by specified user. If both CreatedByUsers and CreatedBy is specified, CreatedByUsers will take precedence.
func (r ApiGetExternalSystemReservationsRequest) CreatedBy(createdBy string) ApiGetExternalSystemReservationsRequest {
	r.createdBy = &createdBy
	return r
}

// Fetches reservations cancelled by list of users.
func (r ApiGetExternalSystemReservationsRequest) CancelledByList(cancelledByList []string) ApiGetExternalSystemReservationsRequest {
	r.cancelledByList = &cancelledByList
	return r
}

// Fetches the reservations which are cancelled on a specific date.
func (r ApiGetExternalSystemReservationsRequest) CancelledOn(cancelledOn string) ApiGetExternalSystemReservationsRequest {
	r.cancelledOn = &cancelledOn
	return r
}

func (r ApiGetExternalSystemReservationsRequest) RatePlanCodes(ratePlanCodes []string) ApiGetExternalSystemReservationsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ApiGetExternalSystemReservationsRequest) SourceCodes(sourceCodes []string) ApiGetExternalSystemReservationsRequest {
	r.sourceCodes = &sourceCodes
	return r
}

func (r ApiGetExternalSystemReservationsRequest) MarketCodes(marketCodes []string) ApiGetExternalSystemReservationsRequest {
	r.marketCodes = &marketCodes
	return r
}

// If true the search result will exclude the blocks reservations.
func (r ApiGetExternalSystemReservationsRequest) ExcludeBlockReservations(excludeBlockReservations bool) ApiGetExternalSystemReservationsRequest {
	r.excludeBlockReservations = &excludeBlockReservations
	return r
}

// The Name of the block that is attached to the reservation.
func (r ApiGetExternalSystemReservationsRequest) BlockName(blockName string) ApiGetExternalSystemReservationsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) BlockIds(blockIds []string) ApiGetExternalSystemReservationsRequest {
	r.blockIds = &blockIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) BlockCodes(blockCodes []string) ApiGetExternalSystemReservationsRequest {
	r.blockCodes = &blockCodes
	return r
}

// Custom reference
func (r ApiGetExternalSystemReservationsRequest) CustomReference(customReference string) ApiGetExternalSystemReservationsRequest {
	r.customReference = &customReference
	return r
}

// GDS Record Locator for reservation.
func (r ApiGetExternalSystemReservationsRequest) RecordLocator(recordLocator string) ApiGetExternalSystemReservationsRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r ApiGetExternalSystemReservationsRequest) OrderBy(orderBy []string) ApiGetExternalSystemReservationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetExternalSystemReservationsRequest) SortOrder(sortOrder []string) ApiGetExternalSystemReservationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Indicator to query reservations which have a room number assigned.
func (r ApiGetExternalSystemReservationsRequest) RoomAssignedOnly(roomAssignedOnly bool) ApiGetExternalSystemReservationsRequest {
	r.roomAssignedOnly = &roomAssignedOnly
	return r
}

// Indicator to query reservations which does not have a room number assigned.
func (r ApiGetExternalSystemReservationsRequest) RoomUnassignedOnly(roomUnassignedOnly bool) ApiGetExternalSystemReservationsRequest {
	r.roomUnassignedOnly = &roomUnassignedOnly
	return r
}

// Room number of the reservation to search by.
func (r ApiGetExternalSystemReservationsRequest) RoomId(roomId string) ApiGetExternalSystemReservationsRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r ApiGetExternalSystemReservationsRequest) RoomType(roomType []string) ApiGetExternalSystemReservationsRequest {
	r.roomType = &roomType
	return r
}

// A code representing a room feature.
func (r ApiGetExternalSystemReservationsRequest) RoomFeatures(roomFeatures []string) ApiGetExternalSystemReservationsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// Preference value for display purposes.
func (r ApiGetExternalSystemReservationsRequest) RoomSpecials(roomSpecials []string) ApiGetExternalSystemReservationsRequest {
	r.roomSpecials = &roomSpecials
	return r
}

// Preference value for display purposes.
func (r ApiGetExternalSystemReservationsRequest) RoomSmokingPreference(roomSmokingPreference string) ApiGetExternalSystemReservationsRequest {
	r.roomSmokingPreference = &roomSmokingPreference
	return r
}

// Preference value for display purposes.
func (r ApiGetExternalSystemReservationsRequest) RoomFloorPreferences(roomFloorPreferences []string) ApiGetExternalSystemReservationsRequest {
	r.roomFloorPreferences = &roomFloorPreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ApiGetExternalSystemReservationsRequest) HousekeepingRoomStatuses(housekeepingRoomStatuses []string) ApiGetExternalSystemReservationsRequest {
	r.housekeepingRoomStatuses = &housekeepingRoomStatuses
	return r
}

func (r ApiGetExternalSystemReservationsRequest) RoomClasses(roomClasses []string) ApiGetExternalSystemReservationsRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r ApiGetExternalSystemReservationsRequest) RoomRangeFrom(roomRangeFrom string) ApiGetExternalSystemReservationsRequest {
	r.roomRangeFrom = &roomRangeFrom
	return r
}

func (r ApiGetExternalSystemReservationsRequest) RoomRangeTo(roomRangeTo string) ApiGetExternalSystemReservationsRequest {
	r.roomRangeTo = &roomRangeTo
	return r
}

// Filter by the last digits of a reservation&#39;s phone number.
func (r ApiGetExternalSystemReservationsRequest) Communication(communication string) ApiGetExternalSystemReservationsRequest {
	r.communication = &communication
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ApiGetExternalSystemReservationsRequest) FetchInstructions(fetchInstructions []string) ApiGetExternalSystemReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag containing true or false value for reservation to be eligible for prior check in by guest using mobile device. Pass the â€˜trueâ€™ or â€˜falseâ€™ values when creating / modifying reservation to indicate whether a reservation is eligible for mobile check in yes / no. Upon fetch, the current state of the flag will show true or false.
func (r ApiGetExternalSystemReservationsRequest) AllowPreRegistration(allowPreRegistration bool) ApiGetExternalSystemReservationsRequest {
	r.allowPreRegistration = &allowPreRegistration
	return r
}

// Indicates that only reservations with deposit balance should be expected from the result.
func (r ApiGetExternalSystemReservationsRequest) HasDepositBalance(hasDepositBalance bool) ApiGetExternalSystemReservationsRequest {
	r.hasDepositBalance = &hasDepositBalance
	return r
}

// Indicates that only reservations with open balance should be expected from the result.
func (r ApiGetExternalSystemReservationsRequest) HasOpenBalance(hasOpenBalance bool) ApiGetExternalSystemReservationsRequest {
	r.hasOpenBalance = &hasOpenBalance
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r ApiGetExternalSystemReservationsRequest) HasOpenFolio(hasOpenFolio bool) ApiGetExternalSystemReservationsRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// Criteria that indicates whether to scheduled checkouts or not.
func (r ApiGetExternalSystemReservationsRequest) IncludeScheduledCheckOut(includeScheduledCheckOut bool) ApiGetExternalSystemReservationsRequest {
	r.includeScheduledCheckOut = &includeScheduledCheckOut
	return r
}

// Indicates that only linked reservations should be expected from the result.
func (r ApiGetExternalSystemReservationsRequest) LinkedOnly(linkedOnly bool) ApiGetExternalSystemReservationsRequest {
	r.linkedOnly = &linkedOnly
	return r
}

// Indicates that only unlinked reservations should be expected from the result.
func (r ApiGetExternalSystemReservationsRequest) UnlinkedOnly(unlinkedOnly bool) ApiGetExternalSystemReservationsRequest {
	r.unlinkedOnly = &unlinkedOnly
	return r
}

// Indicates if reservations which have already arrived on the Search Date is required.
func (r ApiGetExternalSystemReservationsRequest) ActualArrivals(actualArrivals bool) ApiGetExternalSystemReservationsRequest {
	r.actualArrivals = &actualArrivals
	return r
}

// Indicates if reservations which were expected to depart on the Search Date and have already checked, is required.
func (r ApiGetExternalSystemReservationsRequest) ActualDepartures(actualDepartures bool) ApiGetExternalSystemReservationsRequest {
	r.actualDepartures = &actualDepartures
	return r
}

// Indicates if reservations where rate codes are marked as Complimentary Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ApiGetExternalSystemReservationsRequest) ComplimentaryReservations(complimentaryReservations bool) ApiGetExternalSystemReservationsRequest {
	r.complimentaryReservations = &complimentaryReservations
	return r
}

// Indicates if reservations which have cancelled on the Search Date which is also the day of arrival is required.
func (r ApiGetExternalSystemReservationsRequest) DayOfArrivalCancels(dayOfArrivalCancels bool) ApiGetExternalSystemReservationsRequest {
	r.dayOfArrivalCancels = &dayOfArrivalCancels
	return r
}

// Indicates if reservations which are day use reservation on the Search Date, is required.
func (r ApiGetExternalSystemReservationsRequest) DayUse(dayUse bool) ApiGetExternalSystemReservationsRequest {
	r.dayUse = &dayUse
	return r
}

// Indicates if reservations which checked out early on the Search Date, is required.
func (r ApiGetExternalSystemReservationsRequest) EarlyDepartures(earlyDepartures bool) ApiGetExternalSystemReservationsRequest {
	r.earlyDepartures = &earlyDepartures
	return r
}

// Indicates if reservations which are expected arrivals for the Search Date and who have not yet arrived, is required.
func (r ApiGetExternalSystemReservationsRequest) ExpectedArrivals(expectedArrivals bool) ApiGetExternalSystemReservationsRequest {
	r.expectedArrivals = &expectedArrivals
	return r
}

// Indicates if reservations which are expected departures for the Search Date and who have not yet departed, is required.
func (r ApiGetExternalSystemReservationsRequest) ExpectedDepartures(expectedDepartures bool) ApiGetExternalSystemReservationsRequest {
	r.expectedDepartures = &expectedDepartures
	return r
}

// Indicates if reservations which have extended their stays on the Search Date, is required.
func (r ApiGetExternalSystemReservationsRequest) ExtendedStays(extendedStays bool) ApiGetExternalSystemReservationsRequest {
	r.extendedStays = &extendedStays
	return r
}

// Indicates if reservations where rate codes are marked as House Use Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ApiGetExternalSystemReservationsRequest) HouseUseReservations(houseUseReservations bool) ApiGetExternalSystemReservationsRequest {
	r.houseUseReservations = &houseUseReservations
	return r
}

// Indicates if reservations which are StayOvers on the Search Date, is required.
func (r ApiGetExternalSystemReservationsRequest) Stayovers(stayovers bool) ApiGetExternalSystemReservationsRequest {
	r.stayovers = &stayovers
	return r
}

// Date for searching the reservations. This is the date for which the search types are applicable. If date is not available, the business date will be used by default.
func (r ApiGetExternalSystemReservationsRequest) StayDate(stayDate string) ApiGetExternalSystemReservationsRequest {
	r.stayDate = &stayDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) RoomRoutingId(roomRoutingId string) ApiGetExternalSystemReservationsRequest {
	r.roomRoutingId = &roomRoutingId
	return r
}

// Indicates to exclude Pseudo room reservations.
func (r ApiGetExternalSystemReservationsRequest) ExcludePseudoRoomReservations(excludePseudoRoomReservations bool) ApiGetExternalSystemReservationsRequest {
	r.excludePseudoRoomReservations = &excludePseudoRoomReservations
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalSystemReservationsRequest) ExcludeReservationIds(excludeReservationIds []string) ApiGetExternalSystemReservationsRequest {
	r.excludeReservationIds = &excludeReservationIds
	return r
}

// VIP status of the customer.
func (r ApiGetExternalSystemReservationsRequest) ExcludeVIPStatusCodes(excludeVIPStatusCodes []string) ApiGetExternalSystemReservationsRequest {
	r.excludeVIPStatusCodes = &excludeVIPStatusCodes
	return r
}

// Preference value for display purposes.
func (r ApiGetExternalSystemReservationsRequest) ExcludeSpecials(excludeSpecials []string) ApiGetExternalSystemReservationsRequest {
	r.excludeSpecials = &excludeSpecials
	return r
}

// Preference value for display purposes.
func (r ApiGetExternalSystemReservationsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) ApiGetExternalSystemReservationsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r ApiGetExternalSystemReservationsRequest) ExcludeAdvanceCheckedIn(excludeAdvanceCheckedIn bool) ApiGetExternalSystemReservationsRequest {
	r.excludeAdvanceCheckedIn = &excludeAdvanceCheckedIn
	return r
}

// Player ID associated to the reservation.
func (r ApiGetExternalSystemReservationsRequest) PlayerId(playerId string) ApiGetExternalSystemReservationsRequest {
	r.playerId = &playerId
	return r
}

// Balance from.
func (r ApiGetExternalSystemReservationsRequest) GamingBalanceFrom(gamingBalanceFrom float32) ApiGetExternalSystemReservationsRequest {
	r.gamingBalanceFrom = &gamingBalanceFrom
	return r
}

// Balance to.
func (r ApiGetExternalSystemReservationsRequest) GamingBalanceTo(gamingBalanceTo float32) ApiGetExternalSystemReservationsRequest {
	r.gamingBalanceTo = &gamingBalanceTo
	return r
}

// Comp Balance From
func (r ApiGetExternalSystemReservationsRequest) CompAccountingBalanceFrom(compAccountingBalanceFrom float32) ApiGetExternalSystemReservationsRequest {
	r.compAccountingBalanceFrom = &compAccountingBalanceFrom
	return r
}

// Comp Balance To
func (r ApiGetExternalSystemReservationsRequest) CompAccountingBalanceTo(compAccountingBalanceTo float32) ApiGetExternalSystemReservationsRequest {
	r.compAccountingBalanceTo = &compAccountingBalanceTo
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ApiGetExternalSystemReservationsRequest) SearchTypes(searchTypes []string) ApiGetExternalSystemReservationsRequest {
	r.searchTypes = &searchTypes
	return r
}

// Reservation status type for reservations search.
func (r ApiGetExternalSystemReservationsRequest) ReservationStatuses(reservationStatuses []string) ApiGetExternalSystemReservationsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

// Codes to be searched.
func (r ApiGetExternalSystemReservationsRequest) TransportationCodes(transportationCodes []string) ApiGetExternalSystemReservationsRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Enum to denote the Status of Readiness messages sent to Guest Devices.
func (r ApiGetExternalSystemReservationsRequest) RoomReadyStatuses(roomReadyStatuses []string) ApiGetExternalSystemReservationsRequest {
	r.roomReadyStatuses = &roomReadyStatuses
	return r
}

// Fetches the reservations for which Checkout Message is received.
func (r ApiGetExternalSystemReservationsRequest) CheckoutMessageReceived(checkoutMessageReceived bool) ApiGetExternalSystemReservationsRequest {
	r.checkoutMessageReceived = &checkoutMessageReceived
	return r
}

// Fetches the reservations for which reservation communication has been opted.
func (r ApiGetExternalSystemReservationsRequest) OptedForCommunication(optedForCommunication bool) ApiGetExternalSystemReservationsRequest {
	r.optedForCommunication = &optedForCommunication
	return r
}

// External system code.
func (r ApiGetExternalSystemReservationsRequest) XExternalsystem(xExternalsystem string) ApiGetExternalSystemReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExternalSystemReservationsRequest) AcceptLanguage(acceptLanguage string) ApiGetExternalSystemReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExternalSystemReservationsRequest) Execute() (*ReservationsDetails, *http.Response, error) {
	return r.ApiService.GetExternalSystemReservationsExecute(r)
}

/*
GetExternalSystemReservations Get Reservations for a hotel

This API will allow a user to retrieve a list of reservations based on the search criteria specified in the request body. For example you can search for reservations using query parameters like first name, last name, arrival/departure date, external confirmation number. <p><strong>OperationId:</strong>getExternalSystemReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @return ApiGetExternalSystemReservationsRequest
*/
func (a *ReservationApiService) GetExternalSystemReservations(ctx context.Context, extSystemCode string) ApiGetExternalSystemReservationsRequest {
	return ApiGetExternalSystemReservationsRequest{
		ApiService: a,
		ctx: ctx,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return ReservationsDetails
func (a *ReservationApiService) GetExternalSystemReservationsExecute(r ApiGetExternalSystemReservationsRequest) (*ReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetExternalSystemReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if r.externalReferenceList == nil {
		return localVarReturnValue, nil, reportError("externalReferenceList is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.externalReferenceList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceList", t, "multi")
		}
	}
	if r.recentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentlyAccessed", r.recentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
	}
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.companyNames != nil {
		t := *r.companyNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", t, "multi")
		}
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
	}
	if r.membershipCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNumber", r.membershipCardNumber, "")
	}
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
	}
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.discountApplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountApplied", r.discountApplied, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.cancelledByList != nil {
		t := *r.cancelledByList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", t, "multi")
		}
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.excludeBlockReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeBlockReservations", r.excludeBlockReservations, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockIds != nil {
		t := *r.blockIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", t, "multi")
		}
	}
	if r.blockCodes != nil {
		t := *r.blockCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", t, "multi")
		}
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.roomAssignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignedOnly", r.roomAssignedOnly, "")
	}
	if r.roomUnassignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomUnassignedOnly", r.roomUnassignedOnly, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.roomSpecials != nil {
		t := *r.roomSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", t, "multi")
		}
	}
	if r.roomSmokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreference", r.roomSmokingPreference, "")
	}
	if r.roomFloorPreferences != nil {
		t := *r.roomFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", t, "multi")
		}
	}
	if r.housekeepingRoomStatuses != nil {
		t := *r.housekeepingRoomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomRangeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeFrom", r.roomRangeFrom, "")
	}
	if r.roomRangeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeTo", r.roomRangeTo, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowPreRegistration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPreRegistration", r.allowPreRegistration, "")
	}
	if r.hasDepositBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasDepositBalance", r.hasDepositBalance, "")
	}
	if r.hasOpenBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenBalance", r.hasOpenBalance, "")
	}
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
	}
	if r.includeScheduledCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScheduledCheckOut", r.includeScheduledCheckOut, "")
	}
	if r.linkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedOnly", r.linkedOnly, "")
	}
	if r.unlinkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unlinkedOnly", r.unlinkedOnly, "")
	}
	if r.actualArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualArrivals", r.actualArrivals, "")
	}
	if r.actualDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualDepartures", r.actualDepartures, "")
	}
	if r.complimentaryReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "complimentaryReservations", r.complimentaryReservations, "")
	}
	if r.dayOfArrivalCancels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayOfArrivalCancels", r.dayOfArrivalCancels, "")
	}
	if r.dayUse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUse", r.dayUse, "")
	}
	if r.earlyDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "earlyDepartures", r.earlyDepartures, "")
	}
	if r.expectedArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivals", r.expectedArrivals, "")
	}
	if r.expectedDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedDepartures", r.expectedDepartures, "")
	}
	if r.extendedStays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extendedStays", r.extendedStays, "")
	}
	if r.houseUseReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseUseReservations", r.houseUseReservations, "")
	}
	if r.stayovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayovers", r.stayovers, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.roomRoutingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRoutingId", r.roomRoutingId, "")
	}
	if r.excludePseudoRoomReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePseudoRoomReservations", r.excludePseudoRoomReservations, "")
	}
	if r.excludeReservationIds != nil {
		t := *r.excludeReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", t, "multi")
		}
	}
	if r.excludeVIPStatusCodes != nil {
		t := *r.excludeVIPStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", t, "multi")
		}
	}
	if r.excludeSpecials != nil {
		t := *r.excludeSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", t, "multi")
		}
	}
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
	}
	if r.excludeAdvanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAdvanceCheckedIn", r.excludeAdvanceCheckedIn, "")
	}
	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.gamingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceFrom", r.gamingBalanceFrom, "")
	}
	if r.gamingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceTo", r.gamingBalanceTo, "")
	}
	if r.compAccountingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceFrom", r.compAccountingBalanceFrom, "")
	}
	if r.compAccountingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceTo", r.compAccountingBalanceTo, "")
	}
	if r.searchTypes != nil {
		t := *r.searchTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.roomReadyStatuses != nil {
		t := *r.roomReadyStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", t, "multi")
		}
	}
	if r.checkoutMessageReceived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkoutMessageReceived", r.checkoutMessageReceived, "")
	}
	if r.optedForCommunication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optedForCommunication", r.optedForCommunication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	recentlyAccessed *bool
	limit *int32
	offset *int32
	searchType *string
	text *string
	reservationIdList *[]string
	confirmationNumberList *[]string
	cancellationNumberList *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	arrivalEndDate *string
	arrivalStartDate *string
	departureEndDate *string
	departureStartDate *string
	stayOnStartDate *string
	createdOnStartDate *string
	expectedArrivalEndTime *time.Time
	expectedArrivalStartTime *time.Time
	expectedReturnEndTime *time.Time
	expectedReturnStartTime *time.Time
	companyNames *[]string
	sourceNames *[]string
	travelAgentNames *[]string
	groupNames *[]string
	travelAgentIds *[]string
	companyIds *[]string
	sourceIds *[]string
	contactIds *[]string
	groupIds *[]string
	billingContactIds *[]string
	profileId *string
	membershipCardNumber *string
	membershipLevels *[]string
	membershipTypes *[]string
	surname *string
	givenName *string
	anyVIPStatus *bool
	vipCodes *[]string
	guaranteeCode *string
	paymentMethod *string
	discountApplied *bool
	user *[]string
	createdBy *string
	cancelledByList *[]string
	cancelledOn *string
	ratePlanCodes *[]string
	sourceCodes *[]string
	marketCodes *[]string
	excludeBlockReservations *bool
	blockCriteriaHotelCode *string
	blockName *string
	blockIds *[]string
	blockCodes *[]string
	customReference *string
	recordLocator *string
	orderBy *[]string
	sortOrder *[]string
	roomAssignedOnly *bool
	roomUnassignedOnly *bool
	roomId *string
	roomType *[]string
	roomFeatures *[]string
	roomSpecials *[]string
	roomSmokingPreference *string
	roomFloorPreferences *[]string
	housekeepingRoomStatuses *[]string
	roomClasses *[]string
	roomRangeFrom *string
	roomRangeTo *string
	communication *string
	fetchInstructions *[]string
	allowedReservationActions *[]string
	allowPreRegistration *bool
	excludeNoPost *bool
	excludePMRooms *bool
	hasDepositBalance *bool
	hasOpenBalance *bool
	hasOpenFolio *bool
	includeScheduledCheckOut *bool
	linkedOnly *bool
	unlinkedOnly *bool
	actualArrivals *bool
	actualDepartures *bool
	complimentaryReservations *bool
	dayOfArrivalCancels *bool
	dayUse *bool
	earlyDepartures *bool
	expectedArrivals *bool
	expectedDepartures *bool
	extendedStays *bool
	houseUseReservations *bool
	stayovers *bool
	stayDate *string
	roomRoutingId *string
	periodicFolio *string
	folioSettlementTypes *string
	defaultDays *bool
	excludePseudoRoomReservations *bool
	excludeReservationIds *[]string
	excludeVIPStatusCodes *[]string
	excludeSpecials *[]string
	excludeFloorPreferences *[]string
	excludeAdvanceCheckedIn *bool
	playerId *string
	gamingBalanceFrom *float32
	gamingBalanceTo *float32
	compAccountingBalanceFrom *float32
	compAccountingBalanceTo *float32
	searchTypes *[]string
	reservationStatuses *[]string
	transportationCodes *[]string
	roomReadyStatuses *[]string
	checkoutMessageReceived *bool
	optedForCommunication *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelReservationsRequest) Authorization(authorization string) ApiGetHotelReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetHotelReservationsRequest) XAppKey(xAppKey string) ApiGetHotelReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelReservationsRequest) XHotelid(xHotelid string) ApiGetHotelReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this reservation as recently accessed.
func (r ApiGetHotelReservationsRequest) RecentlyAccessed(recentlyAccessed bool) ApiGetHotelReservationsRequest {
	r.recentlyAccessed = &recentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetHotelReservationsRequest) Limit(limit int32) ApiGetHotelReservationsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetHotelReservationsRequest) Offset(offset int32) ApiGetHotelReservationsRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ApiGetHotelReservationsRequest) SearchType(searchType string) ApiGetHotelReservationsRequest {
	r.searchType = &searchType
	return r
}

// Free form text field for searching all reservation fields
func (r ApiGetHotelReservationsRequest) Text(text string) ApiGetHotelReservationsRequest {
	r.text = &text
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) ReservationIdList(reservationIdList []string) ApiGetHotelReservationsRequest {
	r.reservationIdList = &reservationIdList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) ConfirmationNumberList(confirmationNumberList []string) ApiGetHotelReservationsRequest {
	r.confirmationNumberList = &confirmationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) CancellationNumberList(cancellationNumberList []string) ApiGetHotelReservationsRequest {
	r.cancellationNumberList = &cancellationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) ExternalReferenceIds(externalReferenceIds []string) ApiGetHotelReservationsRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetHotelReservationsRequest) ExternalSystemCodes(externalSystemCodes []string) ApiGetHotelReservationsRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// The ending value of the date range.
func (r ApiGetHotelReservationsRequest) ArrivalEndDate(arrivalEndDate string) ApiGetHotelReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetHotelReservationsRequest) ArrivalStartDate(arrivalStartDate string) ApiGetHotelReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r ApiGetHotelReservationsRequest) DepartureEndDate(departureEndDate string) ApiGetHotelReservationsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetHotelReservationsRequest) DepartureStartDate(departureStartDate string) ApiGetHotelReservationsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The starting value of the date range.
func (r ApiGetHotelReservationsRequest) StayOnStartDate(stayOnStartDate string) ApiGetHotelReservationsRequest {
	r.stayOnStartDate = &stayOnStartDate
	return r
}

// The starting value of the date range.
func (r ApiGetHotelReservationsRequest) CreatedOnStartDate(createdOnStartDate string) ApiGetHotelReservationsRequest {
	r.createdOnStartDate = &createdOnStartDate
	return r
}

// The ending value of the time span.
func (r ApiGetHotelReservationsRequest) ExpectedArrivalEndTime(expectedArrivalEndTime time.Time) ApiGetHotelReservationsRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The starting value of the time span.
func (r ApiGetHotelReservationsRequest) ExpectedArrivalStartTime(expectedArrivalStartTime time.Time) ApiGetHotelReservationsRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// The ending value of the time span.
func (r ApiGetHotelReservationsRequest) ExpectedReturnEndTime(expectedReturnEndTime time.Time) ApiGetHotelReservationsRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r ApiGetHotelReservationsRequest) ExpectedReturnStartTime(expectedReturnStartTime time.Time) ApiGetHotelReservationsRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Attached profile name
func (r ApiGetHotelReservationsRequest) CompanyNames(companyNames []string) ApiGetHotelReservationsRequest {
	r.companyNames = &companyNames
	return r
}

// Attached profile name
func (r ApiGetHotelReservationsRequest) SourceNames(sourceNames []string) ApiGetHotelReservationsRequest {
	r.sourceNames = &sourceNames
	return r
}

// Attached profile name
func (r ApiGetHotelReservationsRequest) TravelAgentNames(travelAgentNames []string) ApiGetHotelReservationsRequest {
	r.travelAgentNames = &travelAgentNames
	return r
}

// Attached profile name
func (r ApiGetHotelReservationsRequest) GroupNames(groupNames []string) ApiGetHotelReservationsRequest {
	r.groupNames = &groupNames
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ApiGetHotelReservationsRequest) TravelAgentIds(travelAgentIds []string) ApiGetHotelReservationsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ApiGetHotelReservationsRequest) CompanyIds(companyIds []string) ApiGetHotelReservationsRequest {
	r.companyIds = &companyIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ApiGetHotelReservationsRequest) SourceIds(sourceIds []string) ApiGetHotelReservationsRequest {
	r.sourceIds = &sourceIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ApiGetHotelReservationsRequest) ContactIds(contactIds []string) ApiGetHotelReservationsRequest {
	r.contactIds = &contactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ApiGetHotelReservationsRequest) GroupIds(groupIds []string) ApiGetHotelReservationsRequest {
	r.groupIds = &groupIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ApiGetHotelReservationsRequest) BillingContactIds(billingContactIds []string) ApiGetHotelReservationsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) ProfileId(profileId string) ApiGetHotelReservationsRequest {
	r.profileId = &profileId
	return r
}

// Membership ID criteria.
func (r ApiGetHotelReservationsRequest) MembershipCardNumber(membershipCardNumber string) ApiGetHotelReservationsRequest {
	r.membershipCardNumber = &membershipCardNumber
	return r
}

func (r ApiGetHotelReservationsRequest) MembershipLevels(membershipLevels []string) ApiGetHotelReservationsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

func (r ApiGetHotelReservationsRequest) MembershipTypes(membershipTypes []string) ApiGetHotelReservationsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Family name, last name.
func (r ApiGetHotelReservationsRequest) Surname(surname string) ApiGetHotelReservationsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ApiGetHotelReservationsRequest) GivenName(givenName string) ApiGetHotelReservationsRequest {
	r.givenName = &givenName
	return r
}

// VIP status of the customer.
func (r ApiGetHotelReservationsRequest) AnyVIPStatus(anyVIPStatus bool) ApiGetHotelReservationsRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r ApiGetHotelReservationsRequest) VipCodes(vipCodes []string) ApiGetHotelReservationsRequest {
	r.vipCodes = &vipCodes
	return r
}

// Fetches the reservation having Guarantee Code(Reservation Type) supplied here.
func (r ApiGetHotelReservationsRequest) GuaranteeCode(guaranteeCode string) ApiGetHotelReservationsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Fetches the reservation having method of payment supplied here.
func (r ApiGetHotelReservationsRequest) PaymentMethod(paymentMethod string) ApiGetHotelReservationsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Fetches the reservation for which discount is applied
func (r ApiGetHotelReservationsRequest) DiscountApplied(discountApplied bool) ApiGetHotelReservationsRequest {
	r.discountApplied = &discountApplied
	return r
}

func (r ApiGetHotelReservationsRequest) User(user []string) ApiGetHotelReservationsRequest {
	r.user = &user
	return r
}

// Fetches reservation created by specified user. If both CreatedByUsers and CreatedBy is specified, CreatedByUsers will take precedence.
func (r ApiGetHotelReservationsRequest) CreatedBy(createdBy string) ApiGetHotelReservationsRequest {
	r.createdBy = &createdBy
	return r
}

// Fetches reservations cancelled by list of users.
func (r ApiGetHotelReservationsRequest) CancelledByList(cancelledByList []string) ApiGetHotelReservationsRequest {
	r.cancelledByList = &cancelledByList
	return r
}

// Fetches the reservations which are cancelled on a specific date.
func (r ApiGetHotelReservationsRequest) CancelledOn(cancelledOn string) ApiGetHotelReservationsRequest {
	r.cancelledOn = &cancelledOn
	return r
}

func (r ApiGetHotelReservationsRequest) RatePlanCodes(ratePlanCodes []string) ApiGetHotelReservationsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ApiGetHotelReservationsRequest) SourceCodes(sourceCodes []string) ApiGetHotelReservationsRequest {
	r.sourceCodes = &sourceCodes
	return r
}

func (r ApiGetHotelReservationsRequest) MarketCodes(marketCodes []string) ApiGetHotelReservationsRequest {
	r.marketCodes = &marketCodes
	return r
}

// If true the search result will exclude the blocks reservations.
func (r ApiGetHotelReservationsRequest) ExcludeBlockReservations(excludeBlockReservations bool) ApiGetHotelReservationsRequest {
	r.excludeBlockReservations = &excludeBlockReservations
	return r
}

// The Hotel Code of the Block.
func (r ApiGetHotelReservationsRequest) BlockCriteriaHotelCode(blockCriteriaHotelCode string) ApiGetHotelReservationsRequest {
	r.blockCriteriaHotelCode = &blockCriteriaHotelCode
	return r
}

// The Name of the block that is attached to the reservation.
func (r ApiGetHotelReservationsRequest) BlockName(blockName string) ApiGetHotelReservationsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) BlockIds(blockIds []string) ApiGetHotelReservationsRequest {
	r.blockIds = &blockIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) BlockCodes(blockCodes []string) ApiGetHotelReservationsRequest {
	r.blockCodes = &blockCodes
	return r
}

// Custom reference
func (r ApiGetHotelReservationsRequest) CustomReference(customReference string) ApiGetHotelReservationsRequest {
	r.customReference = &customReference
	return r
}

// GDS Record Locator for reservation.
func (r ApiGetHotelReservationsRequest) RecordLocator(recordLocator string) ApiGetHotelReservationsRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r ApiGetHotelReservationsRequest) OrderBy(orderBy []string) ApiGetHotelReservationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetHotelReservationsRequest) SortOrder(sortOrder []string) ApiGetHotelReservationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Indicator to query reservations which have a room number assigned.
func (r ApiGetHotelReservationsRequest) RoomAssignedOnly(roomAssignedOnly bool) ApiGetHotelReservationsRequest {
	r.roomAssignedOnly = &roomAssignedOnly
	return r
}

// Indicator to query reservations which does not have a room number assigned.
func (r ApiGetHotelReservationsRequest) RoomUnassignedOnly(roomUnassignedOnly bool) ApiGetHotelReservationsRequest {
	r.roomUnassignedOnly = &roomUnassignedOnly
	return r
}

// Room number of the reservation to search by.
func (r ApiGetHotelReservationsRequest) RoomId(roomId string) ApiGetHotelReservationsRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r ApiGetHotelReservationsRequest) RoomType(roomType []string) ApiGetHotelReservationsRequest {
	r.roomType = &roomType
	return r
}

// A code representing a room feature.
func (r ApiGetHotelReservationsRequest) RoomFeatures(roomFeatures []string) ApiGetHotelReservationsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// Preference value for display purposes.
func (r ApiGetHotelReservationsRequest) RoomSpecials(roomSpecials []string) ApiGetHotelReservationsRequest {
	r.roomSpecials = &roomSpecials
	return r
}

// Preference value for display purposes.
func (r ApiGetHotelReservationsRequest) RoomSmokingPreference(roomSmokingPreference string) ApiGetHotelReservationsRequest {
	r.roomSmokingPreference = &roomSmokingPreference
	return r
}

// Preference value for display purposes.
func (r ApiGetHotelReservationsRequest) RoomFloorPreferences(roomFloorPreferences []string) ApiGetHotelReservationsRequest {
	r.roomFloorPreferences = &roomFloorPreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ApiGetHotelReservationsRequest) HousekeepingRoomStatuses(housekeepingRoomStatuses []string) ApiGetHotelReservationsRequest {
	r.housekeepingRoomStatuses = &housekeepingRoomStatuses
	return r
}

func (r ApiGetHotelReservationsRequest) RoomClasses(roomClasses []string) ApiGetHotelReservationsRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r ApiGetHotelReservationsRequest) RoomRangeFrom(roomRangeFrom string) ApiGetHotelReservationsRequest {
	r.roomRangeFrom = &roomRangeFrom
	return r
}

func (r ApiGetHotelReservationsRequest) RoomRangeTo(roomRangeTo string) ApiGetHotelReservationsRequest {
	r.roomRangeTo = &roomRangeTo
	return r
}

// Filter by the last digits of a reservation&#39;s phone number.
func (r ApiGetHotelReservationsRequest) Communication(communication string) ApiGetHotelReservationsRequest {
	r.communication = &communication
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ApiGetHotelReservationsRequest) FetchInstructions(fetchInstructions []string) ApiGetHotelReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r ApiGetHotelReservationsRequest) AllowedReservationActions(allowedReservationActions []string) ApiGetHotelReservationsRequest {
	r.allowedReservationActions = &allowedReservationActions
	return r
}

// Flag containing true or false value for reservation to be eligible for prior check in by guest using mobile device. Pass the â€˜trueâ€™ or â€˜falseâ€™ values when creating / modifying reservation to indicate whether a reservation is eligible for mobile check in yes / no. Upon fetch, the current state of the flag will show true or false.
func (r ApiGetHotelReservationsRequest) AllowPreRegistration(allowPreRegistration bool) ApiGetHotelReservationsRequest {
	r.allowPreRegistration = &allowPreRegistration
	return r
}

// Indicates that reservations with No Post flag should not be expected from the result.
func (r ApiGetHotelReservationsRequest) ExcludeNoPost(excludeNoPost bool) ApiGetHotelReservationsRequest {
	r.excludeNoPost = &excludeNoPost
	return r
}

// Indicates that reservations with PM room type should not be expected from the result.
func (r ApiGetHotelReservationsRequest) ExcludePMRooms(excludePMRooms bool) ApiGetHotelReservationsRequest {
	r.excludePMRooms = &excludePMRooms
	return r
}

// Indicates that only reservations with deposit balance should be expected from the result.
func (r ApiGetHotelReservationsRequest) HasDepositBalance(hasDepositBalance bool) ApiGetHotelReservationsRequest {
	r.hasDepositBalance = &hasDepositBalance
	return r
}

// Indicates that only reservations with open balance should be expected from the result.
func (r ApiGetHotelReservationsRequest) HasOpenBalance(hasOpenBalance bool) ApiGetHotelReservationsRequest {
	r.hasOpenBalance = &hasOpenBalance
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r ApiGetHotelReservationsRequest) HasOpenFolio(hasOpenFolio bool) ApiGetHotelReservationsRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// Criteria that indicates whether to scheduled checkouts or not.
func (r ApiGetHotelReservationsRequest) IncludeScheduledCheckOut(includeScheduledCheckOut bool) ApiGetHotelReservationsRequest {
	r.includeScheduledCheckOut = &includeScheduledCheckOut
	return r
}

// Indicates that only linked reservations should be expected from the result.
func (r ApiGetHotelReservationsRequest) LinkedOnly(linkedOnly bool) ApiGetHotelReservationsRequest {
	r.linkedOnly = &linkedOnly
	return r
}

// Indicates that only unlinked reservations should be expected from the result.
func (r ApiGetHotelReservationsRequest) UnlinkedOnly(unlinkedOnly bool) ApiGetHotelReservationsRequest {
	r.unlinkedOnly = &unlinkedOnly
	return r
}

// Indicates if reservations which have already arrived on the Search Date is required.
func (r ApiGetHotelReservationsRequest) ActualArrivals(actualArrivals bool) ApiGetHotelReservationsRequest {
	r.actualArrivals = &actualArrivals
	return r
}

// Indicates if reservations which were expected to depart on the Search Date and have already checked, is required.
func (r ApiGetHotelReservationsRequest) ActualDepartures(actualDepartures bool) ApiGetHotelReservationsRequest {
	r.actualDepartures = &actualDepartures
	return r
}

// Indicates if reservations where rate codes are marked as Complimentary Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ApiGetHotelReservationsRequest) ComplimentaryReservations(complimentaryReservations bool) ApiGetHotelReservationsRequest {
	r.complimentaryReservations = &complimentaryReservations
	return r
}

// Indicates if reservations which have cancelled on the Search Date which is also the day of arrival is required.
func (r ApiGetHotelReservationsRequest) DayOfArrivalCancels(dayOfArrivalCancels bool) ApiGetHotelReservationsRequest {
	r.dayOfArrivalCancels = &dayOfArrivalCancels
	return r
}

// Indicates if reservations which are day use reservation on the Search Date, is required.
func (r ApiGetHotelReservationsRequest) DayUse(dayUse bool) ApiGetHotelReservationsRequest {
	r.dayUse = &dayUse
	return r
}

// Indicates if reservations which checked out early on the Search Date, is required.
func (r ApiGetHotelReservationsRequest) EarlyDepartures(earlyDepartures bool) ApiGetHotelReservationsRequest {
	r.earlyDepartures = &earlyDepartures
	return r
}

// Indicates if reservations which are expected arrivals for the Search Date and who have not yet arrived, is required.
func (r ApiGetHotelReservationsRequest) ExpectedArrivals(expectedArrivals bool) ApiGetHotelReservationsRequest {
	r.expectedArrivals = &expectedArrivals
	return r
}

// Indicates if reservations which are expected departures for the Search Date and who have not yet departed, is required.
func (r ApiGetHotelReservationsRequest) ExpectedDepartures(expectedDepartures bool) ApiGetHotelReservationsRequest {
	r.expectedDepartures = &expectedDepartures
	return r
}

// Indicates if reservations which have extended their stays on the Search Date, is required.
func (r ApiGetHotelReservationsRequest) ExtendedStays(extendedStays bool) ApiGetHotelReservationsRequest {
	r.extendedStays = &extendedStays
	return r
}

// Indicates if reservations where rate codes are marked as House Use Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ApiGetHotelReservationsRequest) HouseUseReservations(houseUseReservations bool) ApiGetHotelReservationsRequest {
	r.houseUseReservations = &houseUseReservations
	return r
}

// Indicates if reservations which are StayOvers on the Search Date, is required.
func (r ApiGetHotelReservationsRequest) Stayovers(stayovers bool) ApiGetHotelReservationsRequest {
	r.stayovers = &stayovers
	return r
}

// Date for searching the reservations. This is the date for which the search types are applicable. If date is not available, the business date will be used by default.
func (r ApiGetHotelReservationsRequest) StayDate(stayDate string) ApiGetHotelReservationsRequest {
	r.stayDate = &stayDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) RoomRoutingId(roomRoutingId string) ApiGetHotelReservationsRequest {
	r.roomRoutingId = &roomRoutingId
	return r
}

// Periodic folio type.
func (r ApiGetHotelReservationsRequest) PeriodicFolio(periodicFolio string) ApiGetHotelReservationsRequest {
	r.periodicFolio = &periodicFolio
	return r
}

// Comma-delimited list of Folio Settlement Type codes.
func (r ApiGetHotelReservationsRequest) FolioSettlementTypes(folioSettlementTypes string) ApiGetHotelReservationsRequest {
	r.folioSettlementTypes = &folioSettlementTypes
	return r
}

// Use the Number of Days For Settlement, defined for the Reservation.
func (r ApiGetHotelReservationsRequest) DefaultDays(defaultDays bool) ApiGetHotelReservationsRequest {
	r.defaultDays = &defaultDays
	return r
}

// Indicates to exclude Pseudo room reservations.
func (r ApiGetHotelReservationsRequest) ExcludePseudoRoomReservations(excludePseudoRoomReservations bool) ApiGetHotelReservationsRequest {
	r.excludePseudoRoomReservations = &excludePseudoRoomReservations
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelReservationsRequest) ExcludeReservationIds(excludeReservationIds []string) ApiGetHotelReservationsRequest {
	r.excludeReservationIds = &excludeReservationIds
	return r
}

// VIP status of the customer.
func (r ApiGetHotelReservationsRequest) ExcludeVIPStatusCodes(excludeVIPStatusCodes []string) ApiGetHotelReservationsRequest {
	r.excludeVIPStatusCodes = &excludeVIPStatusCodes
	return r
}

// Preference value for display purposes.
func (r ApiGetHotelReservationsRequest) ExcludeSpecials(excludeSpecials []string) ApiGetHotelReservationsRequest {
	r.excludeSpecials = &excludeSpecials
	return r
}

// Preference value for display purposes.
func (r ApiGetHotelReservationsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) ApiGetHotelReservationsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r ApiGetHotelReservationsRequest) ExcludeAdvanceCheckedIn(excludeAdvanceCheckedIn bool) ApiGetHotelReservationsRequest {
	r.excludeAdvanceCheckedIn = &excludeAdvanceCheckedIn
	return r
}

// Player ID associated to the reservation.
func (r ApiGetHotelReservationsRequest) PlayerId(playerId string) ApiGetHotelReservationsRequest {
	r.playerId = &playerId
	return r
}

// Balance from.
func (r ApiGetHotelReservationsRequest) GamingBalanceFrom(gamingBalanceFrom float32) ApiGetHotelReservationsRequest {
	r.gamingBalanceFrom = &gamingBalanceFrom
	return r
}

// Balance to.
func (r ApiGetHotelReservationsRequest) GamingBalanceTo(gamingBalanceTo float32) ApiGetHotelReservationsRequest {
	r.gamingBalanceTo = &gamingBalanceTo
	return r
}

// Comp Balance From
func (r ApiGetHotelReservationsRequest) CompAccountingBalanceFrom(compAccountingBalanceFrom float32) ApiGetHotelReservationsRequest {
	r.compAccountingBalanceFrom = &compAccountingBalanceFrom
	return r
}

// Comp Balance To
func (r ApiGetHotelReservationsRequest) CompAccountingBalanceTo(compAccountingBalanceTo float32) ApiGetHotelReservationsRequest {
	r.compAccountingBalanceTo = &compAccountingBalanceTo
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ApiGetHotelReservationsRequest) SearchTypes(searchTypes []string) ApiGetHotelReservationsRequest {
	r.searchTypes = &searchTypes
	return r
}

// Reservation status type for reservations search.
func (r ApiGetHotelReservationsRequest) ReservationStatuses(reservationStatuses []string) ApiGetHotelReservationsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

// Codes to be searched.
func (r ApiGetHotelReservationsRequest) TransportationCodes(transportationCodes []string) ApiGetHotelReservationsRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Enum to denote the Status of Readiness messages sent to Guest Devices.
func (r ApiGetHotelReservationsRequest) RoomReadyStatuses(roomReadyStatuses []string) ApiGetHotelReservationsRequest {
	r.roomReadyStatuses = &roomReadyStatuses
	return r
}

// Fetches the reservations for which Checkout Message is received.
func (r ApiGetHotelReservationsRequest) CheckoutMessageReceived(checkoutMessageReceived bool) ApiGetHotelReservationsRequest {
	r.checkoutMessageReceived = &checkoutMessageReceived
	return r
}

// Fetches the reservations for which reservation communication has been opted.
func (r ApiGetHotelReservationsRequest) OptedForCommunication(optedForCommunication bool) ApiGetHotelReservationsRequest {
	r.optedForCommunication = &optedForCommunication
	return r
}

// External system code.
func (r ApiGetHotelReservationsRequest) XExternalsystem(xExternalsystem string) ApiGetHotelReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelReservationsRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelReservationsRequest) Execute() (*ReservationsDetails, *http.Response, error) {
	return r.ApiService.GetHotelReservationsExecute(r)
}

/*
GetHotelReservations Get and search for reservations in a hotel

Use this API to search reservations in a hotel, filtering by whether they are Day Use, Due In, Checked In, Due Out, Checked Out, Cancelled, No Show and Complimentary or any other of the large selection of search criteria. It also serves as an entry way for changing existing reservation information, canceling reservations, checking in guests, canceling check ins, etc. You can use further query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data.<p><strong>OperationId:</strong>getHotelReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiGetHotelReservationsRequest
*/
func (a *ReservationApiService) GetHotelReservations(ctx context.Context, hotelId string) ApiGetHotelReservationsRequest {
	return ApiGetHotelReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsDetails
func (a *ReservationApiService) GetHotelReservationsExecute(r ApiGetHotelReservationsRequest) (*ReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetHotelReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.recentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentlyAccessed", r.recentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.reservationIdList != nil {
		t := *r.reservationIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", t, "multi")
		}
	}
	if r.confirmationNumberList != nil {
		t := *r.confirmationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", t, "multi")
		}
	}
	if r.cancellationNumberList != nil {
		t := *r.cancellationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
	}
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
	}
	if r.stayOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOnStartDate", r.stayOnStartDate, "")
	}
	if r.createdOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnStartDate", r.createdOnStartDate, "")
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.companyNames != nil {
		t := *r.companyNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", t, "multi")
		}
	}
	if r.sourceNames != nil {
		t := *r.sourceNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNames", t, "multi")
		}
	}
	if r.travelAgentNames != nil {
		t := *r.travelAgentNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentNames", t, "multi")
		}
	}
	if r.groupNames != nil {
		t := *r.groupNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupNames", t, "multi")
		}
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.membershipCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNumber", r.membershipCardNumber, "")
	}
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
	}
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.discountApplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountApplied", r.discountApplied, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.cancelledByList != nil {
		t := *r.cancelledByList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", t, "multi")
		}
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.excludeBlockReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeBlockReservations", r.excludeBlockReservations, "")
	}
	if r.blockCriteriaHotelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCriteriaHotelCode", r.blockCriteriaHotelCode, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockIds != nil {
		t := *r.blockIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", t, "multi")
		}
	}
	if r.blockCodes != nil {
		t := *r.blockCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", t, "multi")
		}
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.roomAssignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignedOnly", r.roomAssignedOnly, "")
	}
	if r.roomUnassignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomUnassignedOnly", r.roomUnassignedOnly, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.roomSpecials != nil {
		t := *r.roomSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", t, "multi")
		}
	}
	if r.roomSmokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreference", r.roomSmokingPreference, "")
	}
	if r.roomFloorPreferences != nil {
		t := *r.roomFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", t, "multi")
		}
	}
	if r.housekeepingRoomStatuses != nil {
		t := *r.housekeepingRoomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomRangeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeFrom", r.roomRangeFrom, "")
	}
	if r.roomRangeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeTo", r.roomRangeTo, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedReservationActions != nil {
		t := *r.allowedReservationActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedReservationActions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedReservationActions", t, "multi")
		}
	}
	if r.allowPreRegistration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPreRegistration", r.allowPreRegistration, "")
	}
	if r.excludeNoPost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNoPost", r.excludeNoPost, "")
	}
	if r.excludePMRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePMRooms", r.excludePMRooms, "")
	}
	if r.hasDepositBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasDepositBalance", r.hasDepositBalance, "")
	}
	if r.hasOpenBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenBalance", r.hasOpenBalance, "")
	}
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
	}
	if r.includeScheduledCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScheduledCheckOut", r.includeScheduledCheckOut, "")
	}
	if r.linkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedOnly", r.linkedOnly, "")
	}
	if r.unlinkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unlinkedOnly", r.unlinkedOnly, "")
	}
	if r.actualArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualArrivals", r.actualArrivals, "")
	}
	if r.actualDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualDepartures", r.actualDepartures, "")
	}
	if r.complimentaryReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "complimentaryReservations", r.complimentaryReservations, "")
	}
	if r.dayOfArrivalCancels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayOfArrivalCancels", r.dayOfArrivalCancels, "")
	}
	if r.dayUse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUse", r.dayUse, "")
	}
	if r.earlyDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "earlyDepartures", r.earlyDepartures, "")
	}
	if r.expectedArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivals", r.expectedArrivals, "")
	}
	if r.expectedDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedDepartures", r.expectedDepartures, "")
	}
	if r.extendedStays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extendedStays", r.extendedStays, "")
	}
	if r.houseUseReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseUseReservations", r.houseUseReservations, "")
	}
	if r.stayovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayovers", r.stayovers, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.roomRoutingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRoutingId", r.roomRoutingId, "")
	}
	if r.periodicFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periodicFolio", r.periodicFolio, "")
	}
	if r.folioSettlementTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioSettlementTypes", r.folioSettlementTypes, "")
	}
	if r.defaultDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultDays", r.defaultDays, "")
	}
	if r.excludePseudoRoomReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePseudoRoomReservations", r.excludePseudoRoomReservations, "")
	}
	if r.excludeReservationIds != nil {
		t := *r.excludeReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", t, "multi")
		}
	}
	if r.excludeVIPStatusCodes != nil {
		t := *r.excludeVIPStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", t, "multi")
		}
	}
	if r.excludeSpecials != nil {
		t := *r.excludeSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", t, "multi")
		}
	}
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
	}
	if r.excludeAdvanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAdvanceCheckedIn", r.excludeAdvanceCheckedIn, "")
	}
	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.gamingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceFrom", r.gamingBalanceFrom, "")
	}
	if r.gamingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceTo", r.gamingBalanceTo, "")
	}
	if r.compAccountingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceFrom", r.compAccountingBalanceFrom, "")
	}
	if r.compAccountingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceTo", r.compAccountingBalanceTo, "")
	}
	if r.searchTypes != nil {
		t := *r.searchTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.roomReadyStatuses != nil {
		t := *r.roomReadyStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", t, "multi")
		}
	}
	if r.checkoutMessageReceived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkoutMessageReceived", r.checkoutMessageReceived, "")
	}
	if r.optedForCommunication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optedForCommunication", r.optedForCommunication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateInfoRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyCode *string
	summaryInfo *bool
	criteriaStartDate *string
	criteriaEndDate *string
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	detailDate *string
	blockId *string
	blockIdType *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	ratePlanCode *string
	effectiveRateEnd *[]string
	effectiveRateStart *[]string
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateInfoRequest) Authorization(authorization string) ApiGetRateInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetRateInfoRequest) XAppKey(xAppKey string) ApiGetRateInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateInfoRequest) XHotelid(xHotelid string) ApiGetRateInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The code specifying a monetary unit. Use ISO 4217, three alpha code.
func (r ApiGetRateInfoRequest) CurrencyCode(currencyCode string) ApiGetRateInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// Flag to indicate if summary information is required.
func (r ApiGetRateInfoRequest) SummaryInfo(summaryInfo bool) ApiGetRateInfoRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r ApiGetRateInfoRequest) CriteriaStartDate(criteriaStartDate string) ApiGetRateInfoRequest {
	r.criteriaStartDate = &criteriaStartDate
	return r
}

func (r ApiGetRateInfoRequest) CriteriaEndDate(criteriaEndDate string) ApiGetRateInfoRequest {
	r.criteriaEndDate = &criteriaEndDate
	return r
}

// Defines the number of Adults.
func (r ApiGetRateInfoRequest) Adults(adults int32) ApiGetRateInfoRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r ApiGetRateInfoRequest) Children(children int32) ApiGetRateInfoRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r ApiGetRateInfoRequest) ChildAge(childAge []int32) ApiGetRateInfoRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r ApiGetRateInfoRequest) Bucket1Count(bucket1Count int32) ApiGetRateInfoRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r ApiGetRateInfoRequest) Bucket2Count(bucket2Count int32) ApiGetRateInfoRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r ApiGetRateInfoRequest) Bucket3Count(bucket3Count int32) ApiGetRateInfoRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r ApiGetRateInfoRequest) Bucket4Count(bucket4Count int32) ApiGetRateInfoRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r ApiGetRateInfoRequest) Bucket5Count(bucket5Count int32) ApiGetRateInfoRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// This field is only required when the criteria is meant for a detailed results. The date for the rate detail is needed.
func (r ApiGetRateInfoRequest) DetailDate(detailDate string) ApiGetRateInfoRequest {
	r.detailDate = &detailDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRateInfoRequest) BlockId(blockId string) ApiGetRateInfoRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetRateInfoRequest) BlockIdType(blockIdType string) ApiGetRateInfoRequest {
	r.blockIdType = &blockIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRateInfoRequest) Id(id string) ApiGetRateInfoRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiGetRateInfoRequest) IdExtension(idExtension int32) ApiGetRateInfoRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetRateInfoRequest) IdContext(idContext string) ApiGetRateInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetRateInfoRequest) Type_(type_ string) ApiGetRateInfoRequest {
	r.type_ = &type_
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiGetRateInfoRequest) RatePlanCode(ratePlanCode string) ApiGetRateInfoRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// The ending value of the date range.
func (r ApiGetRateInfoRequest) EffectiveRateEnd(effectiveRateEnd []string) ApiGetRateInfoRequest {
	r.effectiveRateEnd = &effectiveRateEnd
	return r
}

// The starting value of the date range.
func (r ApiGetRateInfoRequest) EffectiveRateStart(effectiveRateStart []string) ApiGetRateInfoRequest {
	r.effectiveRateStart = &effectiveRateStart
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiGetRateInfoRequest) RoomType(roomType string) ApiGetRateInfoRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r ApiGetRateInfoRequest) XExternalsystem(xExternalsystem string) ApiGetRateInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetRateInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateInfoRequest) Execute() (*RateInfo, *http.Response, error) {
	return r.ApiService.GetRateInfoExecute(r)
}

/*
GetRateInfo Get rate information

Use this API to retrieve rate plan information including a breakdown of packages and taxes.<p><strong>OperationId:</strong>getRateInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiGetRateInfoRequest
*/
func (a *ReservationApiService) GetRateInfo(ctx context.Context, hotelId string) ApiGetRateInfoRequest {
	return ApiGetRateInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateInfo
func (a *ReservationApiService) GetRateInfoExecute(r ApiGetRateInfoRequest) (*RateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetRateInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/rateInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.criteriaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaStartDate", r.criteriaStartDate, "")
	}
	if r.criteriaEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaEndDate", r.criteriaEndDate, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.detailDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailDate", r.detailDate, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.effectiveRateEnd != nil {
		t := *r.effectiveRateEnd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateEnd", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateEnd", t, "multi")
		}
	}
	if r.effectiveRateStart != nil {
		t := *r.effectiveRateStart
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateStart", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateStart", t, "multi")
		}
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	allowedActions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationRequest) Authorization(authorization string) ApiGetReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetReservationRequest) XAppKey(xAppKey string) ApiGetReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationRequest) XHotelid(xHotelid string) ApiGetReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ApiGetReservationRequest) FetchInstructions(fetchInstructions []string) ApiGetReservationRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r ApiGetReservationRequest) AllowedActions(allowedActions []string) ApiGetReservationRequest {
	r.allowedActions = &allowedActions
	return r
}

// External system code.
func (r ApiGetReservationRequest) XExternalsystem(xExternalsystem string) ApiGetReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationRequest) Execute() (*Reservation, *http.Response, error) {
	return r.ApiService.GetReservationExecute(r)
}

/*
GetReservation Get reservation by ID

Use this API to retrieve a reservation&apos;s detail such as guest&apos;s stay, arrival and departure dates, transportation, room and rate information, preferences, packages, and more using OPERA&apos;s reservationId.<p><strong>OperationId:</strong>getReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiGetReservationRequest
*/
func (a *ReservationApiService) GetReservation(ctx context.Context, reservationId string, hotelId string) ApiGetReservationRequest {
	return ApiGetReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Reservation
func (a *ReservationApiService) GetReservationExecute(r ApiGetReservationRequest) (*Reservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedActions != nil {
		t := *r.allowedActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedActions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedActions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationActivityLogRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	parameterName *[]string
	parameterValue *[]string
	activityGroup *string
	activityType *string
	searchText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationActivityLogRequest) Authorization(authorization string) ApiGetReservationActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetReservationActivityLogRequest) XAppKey(xAppKey string) ApiGetReservationActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationActivityLogRequest) XHotelid(xHotelid string) ApiGetReservationActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetReservationActivityLogRequest) Limit(limit int32) ApiGetReservationActivityLogRequest {
	r.limit = &limit
	return r
}

// Name of the parameter.
func (r ApiGetReservationActivityLogRequest) ParameterName(parameterName []string) ApiGetReservationActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationActivityLogRequest) ParameterValue(parameterValue []string) ApiGetReservationActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r ApiGetReservationActivityLogRequest) ActivityGroup(activityGroup string) ApiGetReservationActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r ApiGetReservationActivityLogRequest) ActivityType(activityType string) ApiGetReservationActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search text for the user activity log.
func (r ApiGetReservationActivityLogRequest) SearchText(searchText string) ApiGetReservationActivityLogRequest {
	r.searchText = &searchText
	return r
}

// External system code.
func (r ApiGetReservationActivityLogRequest) XExternalsystem(xExternalsystem string) ApiGetReservationActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationActivityLogRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationActivityLogRequest) Execute() (*ActivityLog, *http.Response, error) {
	return r.ApiService.GetReservationActivityLogExecute(r)
}

/*
GetReservationActivityLog Fetch reservation activity log

Use this API to get the activity log data of reservations being created and managed.<p><strong>OperationId:</strong>getReservationActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiGetReservationActivityLogRequest
*/
func (a *ReservationApiService) GetReservationActivityLog(ctx context.Context, hotelId string) ApiGetReservationActivityLogRequest {
	return ApiGetReservationActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityLog
func (a *ReservationApiService) GetReservationActivityLogExecute(r ApiGetReservationActivityLogRequest) (*ActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/activityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationUpsellInfoRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationUpsellInfoRequest) Authorization(authorization string) ApiGetReservationUpsellInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetReservationUpsellInfoRequest) XAppKey(xAppKey string) ApiGetReservationUpsellInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationUpsellInfoRequest) XHotelid(xHotelid string) ApiGetReservationUpsellInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetReservationUpsellInfoRequest) XExternalsystem(xExternalsystem string) ApiGetReservationUpsellInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationUpsellInfoRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationUpsellInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationUpsellInfoRequest) Execute() (*ReservationUpsellInfo, *http.Response, error) {
	return r.ApiService.GetReservationUpsellInfoExecute(r)
}

/*
GetReservationUpsellInfo Get available Upsell offers

Use this API to retrieve the available upsell offers for a specific reservation. If no upsell options are configured for this hotel or available for this reservation, an appropriate error will be returned. <p><strong>OperationId:</strong>getReservationUpsellInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiGetReservationUpsellInfoRequest
*/
func (a *ReservationApiService) GetReservationUpsellInfo(ctx context.Context, reservationId string, hotelId string) ApiGetReservationUpsellInfoRequest {
	return ApiGetReservationUpsellInfoRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationUpsellInfo
func (a *ReservationApiService) GetReservationUpsellInfoExecute(r ApiGetReservationUpsellInfoRequest) (*ReservationUpsellInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationUpsellInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationUpsellInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/upsell"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	recentlyAccessed *bool
	limit *int32
	offset *int32
	searchType *string
	hotelIds *[]string
	text *string
	reservationIdList *[]string
	confirmationNumberList *[]string
	cancellationNumberList *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	arrivalEndDate *string
	arrivalStartDate *string
	departureEndDate *string
	departureStartDate *string
	expectedArrivalStartTime *time.Time
	expectedArrivalEndTime *time.Time
	expectedReturnEndTime *time.Time
	expectedReturnStartTime *time.Time
	companyNames *[]string
	travelAgentIds *[]string
	companyIds *[]string
	sourceIds *[]string
	contactIds *[]string
	groupIds *[]string
	billingContactIds *[]string
	profileIds *[]string
	membershipCardNumber *string
	membershipLevels *[]string
	membershipTypes *[]string
	surname *string
	givenName *string
	anyVIPStatus *bool
	vipCodes *[]string
	guaranteeCode *string
	paymentMethod *string
	discountApplied *bool
	user *[]string
	createdBy *string
	cancelledByList *[]string
	cancelledOn *string
	ratePlanCodes *[]string
	sourceCodes *[]string
	marketCodes *[]string
	excludeBlockReservations *bool
	blockName *string
	blockIds *[]string
	blockCodes *[]string
	customReference *string
	recordLocator *string
	orderBy *[]string
	sortOrder *[]string
	roomAssignedOnly *bool
	roomUnassignedOnly *bool
	roomId *string
	roomType *[]string
	roomFeatures *[]string
	roomSpecials *[]string
	roomSmokingPreference *string
	roomFloorPreferences *[]string
	housekeepingRoomStatuses *[]string
	roomClasses *[]string
	roomRangeFrom *string
	roomRangeTo *string
	communication *string
	fetchInstructions *[]string
	allowPreRegistration *bool
	hasDepositBalance *bool
	hasOpenBalance *bool
	hasOpenFolio *bool
	includeScheduledCheckOut *bool
	linkedOnly *bool
	unlinkedOnly *bool
	actualArrivals *bool
	actualDepartures *bool
	complimentaryReservations *bool
	dayOfArrivalCancels *bool
	dayUse *bool
	earlyDepartures *bool
	expectedArrivals *bool
	expectedDepartures *bool
	extendedStays *bool
	houseUseReservations *bool
	stayovers *bool
	stayDate *string
	roomRoutingId *string
	excludePseudoRoomReservations *bool
	excludeReservationIds *[]string
	excludeVIPStatusCodes *[]string
	excludeSpecials *[]string
	excludeFloorPreferences *[]string
	excludeAdvanceCheckedIn *bool
	playerId *string
	gamingBalanceFrom *float32
	gamingBalanceTo *float32
	compAccountingBalanceFrom *float32
	compAccountingBalanceTo *float32
	searchTypes *[]string
	reservationStatuses *[]string
	transportationCodes *[]string
	roomReadyStatuses *[]string
	checkoutMessageReceived *bool
	optedForCommunication *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationsRequest) Authorization(authorization string) ApiGetReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetReservationsRequest) XAppKey(xAppKey string) ApiGetReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationsRequest) XHotelid(xHotelid string) ApiGetReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this reservation as recently accessed.
func (r ApiGetReservationsRequest) RecentlyAccessed(recentlyAccessed bool) ApiGetReservationsRequest {
	r.recentlyAccessed = &recentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetReservationsRequest) Limit(limit int32) ApiGetReservationsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetReservationsRequest) Offset(offset int32) ApiGetReservationsRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ApiGetReservationsRequest) SearchType(searchType string) ApiGetReservationsRequest {
	r.searchType = &searchType
	return r
}

// List of Hotels to support searches with multiple resorts for which traces are to be fetched.
func (r ApiGetReservationsRequest) HotelIds(hotelIds []string) ApiGetReservationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Free form text field for searching all reservation fields
func (r ApiGetReservationsRequest) Text(text string) ApiGetReservationsRequest {
	r.text = &text
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) ReservationIdList(reservationIdList []string) ApiGetReservationsRequest {
	r.reservationIdList = &reservationIdList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) ConfirmationNumberList(confirmationNumberList []string) ApiGetReservationsRequest {
	r.confirmationNumberList = &confirmationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) CancellationNumberList(cancellationNumberList []string) ApiGetReservationsRequest {
	r.cancellationNumberList = &cancellationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) ExternalReferenceIds(externalReferenceIds []string) ApiGetReservationsRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetReservationsRequest) ExternalSystemCodes(externalSystemCodes []string) ApiGetReservationsRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// The ending value of the date range.
func (r ApiGetReservationsRequest) ArrivalEndDate(arrivalEndDate string) ApiGetReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetReservationsRequest) ArrivalStartDate(arrivalStartDate string) ApiGetReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r ApiGetReservationsRequest) DepartureEndDate(departureEndDate string) ApiGetReservationsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetReservationsRequest) DepartureStartDate(departureStartDate string) ApiGetReservationsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The ending value of the time span.
func (r ApiGetReservationsRequest) ExpectedArrivalStartTime(expectedArrivalStartTime time.Time) ApiGetReservationsRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// The starting value of the time span.
func (r ApiGetReservationsRequest) ExpectedArrivalEndTime(expectedArrivalEndTime time.Time) ApiGetReservationsRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The ending value of the time span.
func (r ApiGetReservationsRequest) ExpectedReturnEndTime(expectedReturnEndTime time.Time) ApiGetReservationsRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r ApiGetReservationsRequest) ExpectedReturnStartTime(expectedReturnStartTime time.Time) ApiGetReservationsRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Attached profile name
func (r ApiGetReservationsRequest) CompanyNames(companyNames []string) ApiGetReservationsRequest {
	r.companyNames = &companyNames
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) TravelAgentIds(travelAgentIds []string) ApiGetReservationsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) CompanyIds(companyIds []string) ApiGetReservationsRequest {
	r.companyIds = &companyIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) SourceIds(sourceIds []string) ApiGetReservationsRequest {
	r.sourceIds = &sourceIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) ContactIds(contactIds []string) ApiGetReservationsRequest {
	r.contactIds = &contactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) GroupIds(groupIds []string) ApiGetReservationsRequest {
	r.groupIds = &groupIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) BillingContactIds(billingContactIds []string) ApiGetReservationsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) ProfileIds(profileIds []string) ApiGetReservationsRequest {
	r.profileIds = &profileIds
	return r
}

// Membership ID criteria.
func (r ApiGetReservationsRequest) MembershipCardNumber(membershipCardNumber string) ApiGetReservationsRequest {
	r.membershipCardNumber = &membershipCardNumber
	return r
}

func (r ApiGetReservationsRequest) MembershipLevels(membershipLevels []string) ApiGetReservationsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

func (r ApiGetReservationsRequest) MembershipTypes(membershipTypes []string) ApiGetReservationsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Family name, last name.
func (r ApiGetReservationsRequest) Surname(surname string) ApiGetReservationsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ApiGetReservationsRequest) GivenName(givenName string) ApiGetReservationsRequest {
	r.givenName = &givenName
	return r
}

// VIP status of the customer.
func (r ApiGetReservationsRequest) AnyVIPStatus(anyVIPStatus bool) ApiGetReservationsRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r ApiGetReservationsRequest) VipCodes(vipCodes []string) ApiGetReservationsRequest {
	r.vipCodes = &vipCodes
	return r
}

// Fetches the reservation having Guarantee Code(Reservation Type) supplied here.
func (r ApiGetReservationsRequest) GuaranteeCode(guaranteeCode string) ApiGetReservationsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Fetches the reservation having method of payment supplied here.
func (r ApiGetReservationsRequest) PaymentMethod(paymentMethod string) ApiGetReservationsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Fetches the reservation for which discount is applied
func (r ApiGetReservationsRequest) DiscountApplied(discountApplied bool) ApiGetReservationsRequest {
	r.discountApplied = &discountApplied
	return r
}

func (r ApiGetReservationsRequest) User(user []string) ApiGetReservationsRequest {
	r.user = &user
	return r
}

// Fetches reservation created by specified user. If both CreatedByUsers and CreatedBy is specified, CreatedByUsers will take precedence.
func (r ApiGetReservationsRequest) CreatedBy(createdBy string) ApiGetReservationsRequest {
	r.createdBy = &createdBy
	return r
}

// Fetches reservations cancelled by list of users.
func (r ApiGetReservationsRequest) CancelledByList(cancelledByList []string) ApiGetReservationsRequest {
	r.cancelledByList = &cancelledByList
	return r
}

// Fetches the reservations which are cancelled on a specific date.
func (r ApiGetReservationsRequest) CancelledOn(cancelledOn string) ApiGetReservationsRequest {
	r.cancelledOn = &cancelledOn
	return r
}

func (r ApiGetReservationsRequest) RatePlanCodes(ratePlanCodes []string) ApiGetReservationsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ApiGetReservationsRequest) SourceCodes(sourceCodes []string) ApiGetReservationsRequest {
	r.sourceCodes = &sourceCodes
	return r
}

func (r ApiGetReservationsRequest) MarketCodes(marketCodes []string) ApiGetReservationsRequest {
	r.marketCodes = &marketCodes
	return r
}

// If true the search result will exclude the blocks reservations.
func (r ApiGetReservationsRequest) ExcludeBlockReservations(excludeBlockReservations bool) ApiGetReservationsRequest {
	r.excludeBlockReservations = &excludeBlockReservations
	return r
}

// The Name of the block that is attached to the reservation.
func (r ApiGetReservationsRequest) BlockName(blockName string) ApiGetReservationsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) BlockIds(blockIds []string) ApiGetReservationsRequest {
	r.blockIds = &blockIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) BlockCodes(blockCodes []string) ApiGetReservationsRequest {
	r.blockCodes = &blockCodes
	return r
}

// Custom reference
func (r ApiGetReservationsRequest) CustomReference(customReference string) ApiGetReservationsRequest {
	r.customReference = &customReference
	return r
}

// GDS Record Locator for reservation.
func (r ApiGetReservationsRequest) RecordLocator(recordLocator string) ApiGetReservationsRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r ApiGetReservationsRequest) OrderBy(orderBy []string) ApiGetReservationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetReservationsRequest) SortOrder(sortOrder []string) ApiGetReservationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Indicator to query reservations which have a room number assigned.
func (r ApiGetReservationsRequest) RoomAssignedOnly(roomAssignedOnly bool) ApiGetReservationsRequest {
	r.roomAssignedOnly = &roomAssignedOnly
	return r
}

// Indicator to query reservations which does not have a room number assigned.
func (r ApiGetReservationsRequest) RoomUnassignedOnly(roomUnassignedOnly bool) ApiGetReservationsRequest {
	r.roomUnassignedOnly = &roomUnassignedOnly
	return r
}

// Room number of the reservation to search by.
func (r ApiGetReservationsRequest) RoomId(roomId string) ApiGetReservationsRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r ApiGetReservationsRequest) RoomType(roomType []string) ApiGetReservationsRequest {
	r.roomType = &roomType
	return r
}

// A code representing a room feature.
func (r ApiGetReservationsRequest) RoomFeatures(roomFeatures []string) ApiGetReservationsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// Preference value for display purposes.
func (r ApiGetReservationsRequest) RoomSpecials(roomSpecials []string) ApiGetReservationsRequest {
	r.roomSpecials = &roomSpecials
	return r
}

// Preference value for display purposes.
func (r ApiGetReservationsRequest) RoomSmokingPreference(roomSmokingPreference string) ApiGetReservationsRequest {
	r.roomSmokingPreference = &roomSmokingPreference
	return r
}

// Preference value for display purposes.
func (r ApiGetReservationsRequest) RoomFloorPreferences(roomFloorPreferences []string) ApiGetReservationsRequest {
	r.roomFloorPreferences = &roomFloorPreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ApiGetReservationsRequest) HousekeepingRoomStatuses(housekeepingRoomStatuses []string) ApiGetReservationsRequest {
	r.housekeepingRoomStatuses = &housekeepingRoomStatuses
	return r
}

func (r ApiGetReservationsRequest) RoomClasses(roomClasses []string) ApiGetReservationsRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r ApiGetReservationsRequest) RoomRangeFrom(roomRangeFrom string) ApiGetReservationsRequest {
	r.roomRangeFrom = &roomRangeFrom
	return r
}

func (r ApiGetReservationsRequest) RoomRangeTo(roomRangeTo string) ApiGetReservationsRequest {
	r.roomRangeTo = &roomRangeTo
	return r
}

// Filter by the last digits of a reservation&#39;s phone number.
func (r ApiGetReservationsRequest) Communication(communication string) ApiGetReservationsRequest {
	r.communication = &communication
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ApiGetReservationsRequest) FetchInstructions(fetchInstructions []string) ApiGetReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag containing true or false value for reservation to be eligible for prior check in by guest using mobile device. Pass the â€˜trueâ€™ or â€˜falseâ€™ values when creating / modifying reservation to indicate whether a reservation is eligible for mobile check in yes / no. Upon fetch, the current state of the flag will show true or false.
func (r ApiGetReservationsRequest) AllowPreRegistration(allowPreRegistration bool) ApiGetReservationsRequest {
	r.allowPreRegistration = &allowPreRegistration
	return r
}

// Indicates that only reservations with deposit balance should be expected from the result.
func (r ApiGetReservationsRequest) HasDepositBalance(hasDepositBalance bool) ApiGetReservationsRequest {
	r.hasDepositBalance = &hasDepositBalance
	return r
}

// Indicates that only reservations with open balance should be expected from the result.
func (r ApiGetReservationsRequest) HasOpenBalance(hasOpenBalance bool) ApiGetReservationsRequest {
	r.hasOpenBalance = &hasOpenBalance
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r ApiGetReservationsRequest) HasOpenFolio(hasOpenFolio bool) ApiGetReservationsRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// Criteria that indicates whether to scheduled checkouts or not.
func (r ApiGetReservationsRequest) IncludeScheduledCheckOut(includeScheduledCheckOut bool) ApiGetReservationsRequest {
	r.includeScheduledCheckOut = &includeScheduledCheckOut
	return r
}

// Indicates that only linked reservations should be expected from the result.
func (r ApiGetReservationsRequest) LinkedOnly(linkedOnly bool) ApiGetReservationsRequest {
	r.linkedOnly = &linkedOnly
	return r
}

// Indicates that only unlinked reservations should be expected from the result.
func (r ApiGetReservationsRequest) UnlinkedOnly(unlinkedOnly bool) ApiGetReservationsRequest {
	r.unlinkedOnly = &unlinkedOnly
	return r
}

// Indicates if reservations which have already arrived on the Search Date is required.
func (r ApiGetReservationsRequest) ActualArrivals(actualArrivals bool) ApiGetReservationsRequest {
	r.actualArrivals = &actualArrivals
	return r
}

// Indicates if reservations which were expected to depart on the Search Date and have already checked, is required.
func (r ApiGetReservationsRequest) ActualDepartures(actualDepartures bool) ApiGetReservationsRequest {
	r.actualDepartures = &actualDepartures
	return r
}

// Indicates if reservations where rate codes are marked as Complimentary Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ApiGetReservationsRequest) ComplimentaryReservations(complimentaryReservations bool) ApiGetReservationsRequest {
	r.complimentaryReservations = &complimentaryReservations
	return r
}

// Indicates if reservations which have cancelled on the Search Date which is also the day of arrival is required.
func (r ApiGetReservationsRequest) DayOfArrivalCancels(dayOfArrivalCancels bool) ApiGetReservationsRequest {
	r.dayOfArrivalCancels = &dayOfArrivalCancels
	return r
}

// Indicates if reservations which are day use reservation on the Search Date, is required.
func (r ApiGetReservationsRequest) DayUse(dayUse bool) ApiGetReservationsRequest {
	r.dayUse = &dayUse
	return r
}

// Indicates if reservations which checked out early on the Search Date, is required.
func (r ApiGetReservationsRequest) EarlyDepartures(earlyDepartures bool) ApiGetReservationsRequest {
	r.earlyDepartures = &earlyDepartures
	return r
}

// Indicates if reservations which are expected arrivals for the Search Date and who have not yet arrived, is required.
func (r ApiGetReservationsRequest) ExpectedArrivals(expectedArrivals bool) ApiGetReservationsRequest {
	r.expectedArrivals = &expectedArrivals
	return r
}

// Indicates if reservations which are expected departures for the Search Date and who have not yet departed, is required.
func (r ApiGetReservationsRequest) ExpectedDepartures(expectedDepartures bool) ApiGetReservationsRequest {
	r.expectedDepartures = &expectedDepartures
	return r
}

// Indicates if reservations which have extended their stays on the Search Date, is required.
func (r ApiGetReservationsRequest) ExtendedStays(extendedStays bool) ApiGetReservationsRequest {
	r.extendedStays = &extendedStays
	return r
}

// Indicates if reservations where rate codes are marked as House Use Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ApiGetReservationsRequest) HouseUseReservations(houseUseReservations bool) ApiGetReservationsRequest {
	r.houseUseReservations = &houseUseReservations
	return r
}

// Indicates if reservations which are StayOvers on the Search Date, is required.
func (r ApiGetReservationsRequest) Stayovers(stayovers bool) ApiGetReservationsRequest {
	r.stayovers = &stayovers
	return r
}

// Date for searching the reservations. This is the date for which the search types are applicable. If date is not available, the business date will be used by default.
func (r ApiGetReservationsRequest) StayDate(stayDate string) ApiGetReservationsRequest {
	r.stayDate = &stayDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) RoomRoutingId(roomRoutingId string) ApiGetReservationsRequest {
	r.roomRoutingId = &roomRoutingId
	return r
}

// Indicates to exclude Pseudo room reservations.
func (r ApiGetReservationsRequest) ExcludePseudoRoomReservations(excludePseudoRoomReservations bool) ApiGetReservationsRequest {
	r.excludePseudoRoomReservations = &excludePseudoRoomReservations
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetReservationsRequest) ExcludeReservationIds(excludeReservationIds []string) ApiGetReservationsRequest {
	r.excludeReservationIds = &excludeReservationIds
	return r
}

// VIP status of the customer.
func (r ApiGetReservationsRequest) ExcludeVIPStatusCodes(excludeVIPStatusCodes []string) ApiGetReservationsRequest {
	r.excludeVIPStatusCodes = &excludeVIPStatusCodes
	return r
}

// Preference value for display purposes.
func (r ApiGetReservationsRequest) ExcludeSpecials(excludeSpecials []string) ApiGetReservationsRequest {
	r.excludeSpecials = &excludeSpecials
	return r
}

// Preference value for display purposes.
func (r ApiGetReservationsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) ApiGetReservationsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r ApiGetReservationsRequest) ExcludeAdvanceCheckedIn(excludeAdvanceCheckedIn bool) ApiGetReservationsRequest {
	r.excludeAdvanceCheckedIn = &excludeAdvanceCheckedIn
	return r
}

// Player ID associated to the reservation.
func (r ApiGetReservationsRequest) PlayerId(playerId string) ApiGetReservationsRequest {
	r.playerId = &playerId
	return r
}

// Balance from.
func (r ApiGetReservationsRequest) GamingBalanceFrom(gamingBalanceFrom float32) ApiGetReservationsRequest {
	r.gamingBalanceFrom = &gamingBalanceFrom
	return r
}

// Balance to.
func (r ApiGetReservationsRequest) GamingBalanceTo(gamingBalanceTo float32) ApiGetReservationsRequest {
	r.gamingBalanceTo = &gamingBalanceTo
	return r
}

// Comp Balance From
func (r ApiGetReservationsRequest) CompAccountingBalanceFrom(compAccountingBalanceFrom float32) ApiGetReservationsRequest {
	r.compAccountingBalanceFrom = &compAccountingBalanceFrom
	return r
}

// Comp Balance To
func (r ApiGetReservationsRequest) CompAccountingBalanceTo(compAccountingBalanceTo float32) ApiGetReservationsRequest {
	r.compAccountingBalanceTo = &compAccountingBalanceTo
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ApiGetReservationsRequest) SearchTypes(searchTypes []string) ApiGetReservationsRequest {
	r.searchTypes = &searchTypes
	return r
}

// Reservation status type for reservations search.
func (r ApiGetReservationsRequest) ReservationStatuses(reservationStatuses []string) ApiGetReservationsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

// Codes to be searched.
func (r ApiGetReservationsRequest) TransportationCodes(transportationCodes []string) ApiGetReservationsRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Enum to denote the Status of Readiness messages sent to Guest Devices.
func (r ApiGetReservationsRequest) RoomReadyStatuses(roomReadyStatuses []string) ApiGetReservationsRequest {
	r.roomReadyStatuses = &roomReadyStatuses
	return r
}

// Fetches the reservations for which Checkout Message is received.
func (r ApiGetReservationsRequest) CheckoutMessageReceived(checkoutMessageReceived bool) ApiGetReservationsRequest {
	r.checkoutMessageReceived = &checkoutMessageReceived
	return r
}

// Fetches the reservations for which reservation communication has been opted.
func (r ApiGetReservationsRequest) OptedForCommunication(optedForCommunication bool) ApiGetReservationsRequest {
	r.optedForCommunication = &optedForCommunication
	return r
}

// External system code.
func (r ApiGetReservationsRequest) XExternalsystem(xExternalsystem string) ApiGetReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationsRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationsRequest) Execute() (*ReservationsDetails, *http.Response, error) {
	return r.ApiService.GetReservationsExecute(r)
}

/*
GetReservations Get Reservations for a hotel

This API will allow a user to retrieve a list of reservations based on the search criteria specified in the request body. For example you can search for reservations using query parameters like first name, last name, arrival/departure date, external confirmation number. <p><strong>OperationId:</strong>getReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReservationsRequest
*/
func (a *ReservationApiService) GetReservations(ctx context.Context) ApiGetReservationsRequest {
	return ApiGetReservationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReservationsDetails
func (a *ReservationApiService) GetReservationsExecute(r ApiGetReservationsRequest) (*ReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.recentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentlyAccessed", r.recentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.reservationIdList != nil {
		t := *r.reservationIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", t, "multi")
		}
	}
	if r.confirmationNumberList != nil {
		t := *r.confirmationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", t, "multi")
		}
	}
	if r.cancellationNumberList != nil {
		t := *r.cancellationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
	}
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.companyNames != nil {
		t := *r.companyNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", t, "multi")
		}
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
	}
	if r.membershipCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNumber", r.membershipCardNumber, "")
	}
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
	}
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.discountApplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountApplied", r.discountApplied, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.cancelledByList != nil {
		t := *r.cancelledByList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", t, "multi")
		}
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.excludeBlockReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeBlockReservations", r.excludeBlockReservations, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockIds != nil {
		t := *r.blockIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", t, "multi")
		}
	}
	if r.blockCodes != nil {
		t := *r.blockCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", t, "multi")
		}
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.roomAssignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignedOnly", r.roomAssignedOnly, "")
	}
	if r.roomUnassignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomUnassignedOnly", r.roomUnassignedOnly, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.roomSpecials != nil {
		t := *r.roomSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", t, "multi")
		}
	}
	if r.roomSmokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreference", r.roomSmokingPreference, "")
	}
	if r.roomFloorPreferences != nil {
		t := *r.roomFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", t, "multi")
		}
	}
	if r.housekeepingRoomStatuses != nil {
		t := *r.housekeepingRoomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomRangeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeFrom", r.roomRangeFrom, "")
	}
	if r.roomRangeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeTo", r.roomRangeTo, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowPreRegistration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPreRegistration", r.allowPreRegistration, "")
	}
	if r.hasDepositBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasDepositBalance", r.hasDepositBalance, "")
	}
	if r.hasOpenBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenBalance", r.hasOpenBalance, "")
	}
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
	}
	if r.includeScheduledCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScheduledCheckOut", r.includeScheduledCheckOut, "")
	}
	if r.linkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedOnly", r.linkedOnly, "")
	}
	if r.unlinkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unlinkedOnly", r.unlinkedOnly, "")
	}
	if r.actualArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualArrivals", r.actualArrivals, "")
	}
	if r.actualDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualDepartures", r.actualDepartures, "")
	}
	if r.complimentaryReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "complimentaryReservations", r.complimentaryReservations, "")
	}
	if r.dayOfArrivalCancels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayOfArrivalCancels", r.dayOfArrivalCancels, "")
	}
	if r.dayUse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUse", r.dayUse, "")
	}
	if r.earlyDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "earlyDepartures", r.earlyDepartures, "")
	}
	if r.expectedArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivals", r.expectedArrivals, "")
	}
	if r.expectedDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedDepartures", r.expectedDepartures, "")
	}
	if r.extendedStays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extendedStays", r.extendedStays, "")
	}
	if r.houseUseReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseUseReservations", r.houseUseReservations, "")
	}
	if r.stayovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayovers", r.stayovers, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.roomRoutingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRoutingId", r.roomRoutingId, "")
	}
	if r.excludePseudoRoomReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePseudoRoomReservations", r.excludePseudoRoomReservations, "")
	}
	if r.excludeReservationIds != nil {
		t := *r.excludeReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", t, "multi")
		}
	}
	if r.excludeVIPStatusCodes != nil {
		t := *r.excludeVIPStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", t, "multi")
		}
	}
	if r.excludeSpecials != nil {
		t := *r.excludeSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", t, "multi")
		}
	}
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
	}
	if r.excludeAdvanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAdvanceCheckedIn", r.excludeAdvanceCheckedIn, "")
	}
	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.gamingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceFrom", r.gamingBalanceFrom, "")
	}
	if r.gamingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceTo", r.gamingBalanceTo, "")
	}
	if r.compAccountingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceFrom", r.compAccountingBalanceFrom, "")
	}
	if r.compAccountingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceTo", r.compAccountingBalanceTo, "")
	}
	if r.searchTypes != nil {
		t := *r.searchTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.roomReadyStatuses != nil {
		t := *r.roomReadyStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", t, "multi")
		}
	}
	if r.checkoutMessageReceived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkoutMessageReceived", r.checkoutMessageReceived, "")
	}
	if r.optedForCommunication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optedForCommunication", r.optedForCommunication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCallRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	registerCall *PostCallRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCallRequest) Authorization(authorization string) ApiPostCallRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostCallRequest) XAppKey(xAppKey string) ApiPostCallRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCallRequest) XHotelid(xHotelid string) ApiPostCallRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to register call. Either creates a new call or updates an existing call.
func (r ApiPostCallRequest) RegisterCall(registerCall PostCallRequest) ApiPostCallRequest {
	r.registerCall = &registerCall
	return r
}

// External system code.
func (r ApiPostCallRequest) XExternalsystem(xExternalsystem string) ApiPostCallRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCallRequest) AcceptLanguage(acceptLanguage string) ApiPostCallRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCallRequest) Execute() (*RegisterCall, *http.Response, error) {
	return r.ApiService.PostCallExecute(r)
}

/*
PostCall Register calls

Use this API to request a new call or make updates to an existing call.<p><strong>OperationId:</strong>postCall</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCallRequest
*/
func (a *ReservationApiService) PostCall(ctx context.Context) ApiPostCallRequest {
	return ApiPostCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterCall
func (a *ReservationApiService) PostCallExecute(r ApiPostCallRequest) (*RegisterCall, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.registerCall == nil {
		return localVarReturnValue, nil, reportError("registerCall is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.registerCall
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCancelReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelReservation *PostCancelReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCancelReservationRequest) Authorization(authorization string) ApiPostCancelReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostCancelReservationRequest) XAppKey(xAppKey string) ApiPostCancelReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCancelReservationRequest) XHotelid(xHotelid string) ApiPostCancelReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for canceling reservations.
func (r ApiPostCancelReservationRequest) CancelReservation(cancelReservation PostCancelReservationRequest) ApiPostCancelReservationRequest {
	r.cancelReservation = &cancelReservation
	return r
}

// External system code.
func (r ApiPostCancelReservationRequest) XExternalsystem(xExternalsystem string) ApiPostCancelReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCancelReservationRequest) AcceptLanguage(acceptLanguage string) ApiPostCancelReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCancelReservationRequest) Execute() (*CancelReservationDetails, *http.Response, error) {
	return r.ApiService.PostCancelReservationExecute(r)
}

/*
PostCancelReservation Cancel Reservation by ID

Use this if a guest would like to cancel their reservation.  You will receive a cancellation number in the response. <p><strong>OperationId:</strong>postCancelReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostCancelReservationRequest
*/
func (a *ReservationApiService) PostCancelReservation(ctx context.Context, reservationId string, hotelId string) ApiPostCancelReservationRequest {
	return ApiPostCancelReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancelReservationDetails
func (a *ReservationApiService) PostCancelReservationExecute(r ApiPostCancelReservationRequest) (*CancelReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCancelReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.cancelReservation == nil {
		return localVarReturnValue, nil, reportError("cancelReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCombineShareReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	combineShareReservations *PostCombineShareReservationsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCombineShareReservationsRequest) Authorization(authorization string) ApiPostCombineShareReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostCombineShareReservationsRequest) XAppKey(xAppKey string) ApiPostCombineShareReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCombineShareReservationsRequest) XHotelid(xHotelid string) ApiPostCombineShareReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to combine sharer reservations. This request requires a Reservation Name Id(Joining to) and a Joining Reservation Id
func (r ApiPostCombineShareReservationsRequest) CombineShareReservations(combineShareReservations PostCombineShareReservationsByExtIdRequest) ApiPostCombineShareReservationsRequest {
	r.combineShareReservations = &combineShareReservations
	return r
}

// External system code.
func (r ApiPostCombineShareReservationsRequest) XExternalsystem(xExternalsystem string) ApiPostCombineShareReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCombineShareReservationsRequest) AcceptLanguage(acceptLanguage string) ApiPostCombineShareReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCombineShareReservationsRequest) Execute() (*CombineShareReservationsDetails, *http.Response, error) {
	return r.ApiService.PostCombineShareReservationsExecute(r)
}

/*
PostCombineShareReservations Combine Share Reservations

Combine share reservation for a given reservation id <p><strong>OperationId:</strong>postCombineShareReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostCombineShareReservationsRequest
*/
func (a *ReservationApiService) PostCombineShareReservations(ctx context.Context, reservationId string, hotelId string) ApiPostCombineShareReservationsRequest {
	return ApiPostCombineShareReservationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CombineShareReservationsDetails
func (a *ReservationApiService) PostCombineShareReservationsExecute(r ApiPostCombineShareReservationsRequest) (*CombineShareReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CombineShareReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCombineShareReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.combineShareReservations == nil {
		return localVarReturnValue, nil, reportError("combineShareReservations is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.combineShareReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCombineShareReservationsByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	combineShareReservations *PostCombineShareReservationsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCombineShareReservationsByExtIdRequest) Authorization(authorization string) ApiPostCombineShareReservationsByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostCombineShareReservationsByExtIdRequest) XAppKey(xAppKey string) ApiPostCombineShareReservationsByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCombineShareReservationsByExtIdRequest) XHotelid(xHotelid string) ApiPostCombineShareReservationsByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to combine sharer reservations. This request requires a Reservation Name Id(Joining to) and a Joining Reservation Id
func (r ApiPostCombineShareReservationsByExtIdRequest) CombineShareReservations(combineShareReservations PostCombineShareReservationsByExtIdRequest) ApiPostCombineShareReservationsByExtIdRequest {
	r.combineShareReservations = &combineShareReservations
	return r
}

// External system code.
func (r ApiPostCombineShareReservationsByExtIdRequest) XExternalsystem(xExternalsystem string) ApiPostCombineShareReservationsByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCombineShareReservationsByExtIdRequest) AcceptLanguage(acceptLanguage string) ApiPostCombineShareReservationsByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCombineShareReservationsByExtIdRequest) Execute() (*CombineShareReservationsDetails, *http.Response, error) {
	return r.ApiService.PostCombineShareReservationsByExtIdExecute(r)
}

/*
PostCombineShareReservationsByExtId Combine Share Reservations

Combine share reservation for a given reservation id <p><strong>OperationId:</strong>postCombineShareReservationsByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostCombineShareReservationsByExtIdRequest
*/
func (a *ReservationApiService) PostCombineShareReservationsByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ApiPostCombineShareReservationsByExtIdRequest {
	return ApiPostCombineShareReservationsByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CombineShareReservationsDetails
func (a *ReservationApiService) PostCombineShareReservationsByExtIdExecute(r ApiPostCombineShareReservationsByExtIdRequest) (*CombineShareReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CombineShareReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCombineShareReservationsByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.combineShareReservations == nil {
		return localVarReturnValue, nil, reportError("combineShareReservations is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.combineShareReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPreCheckInReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preCheckInReservation *PostPreCheckInReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostPreCheckInReservationRequest) Authorization(authorization string) ApiPostPreCheckInReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostPreCheckInReservationRequest) XAppKey(xAppKey string) ApiPostPreCheckInReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostPreCheckInReservationRequest) XHotelid(xHotelid string) ApiPostPreCheckInReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to pre-register a reservation eligible for pre-registration and change arrival details.
func (r ApiPostPreCheckInReservationRequest) PreCheckInReservation(preCheckInReservation PostPreCheckInReservationRequest) ApiPostPreCheckInReservationRequest {
	r.preCheckInReservation = &preCheckInReservation
	return r
}

// External system code.
func (r ApiPostPreCheckInReservationRequest) XExternalsystem(xExternalsystem string) ApiPostPreCheckInReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostPreCheckInReservationRequest) AcceptLanguage(acceptLanguage string) ApiPostPreCheckInReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostPreCheckInReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPreCheckInReservationExecute(r)
}

/*
PostPreCheckInReservation Pre-Checkin a Reservation

This will allow you to set a reservation as a pre-registered guest.  The API request requires the guests confirmation number and you can optionally include arrival time.  The behavior of the API will be dependent upon the Pre-registration rules configured for the hotel in OPERA Cloud administration. <p><strong>OperationId:</strong>postPreCheckInReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostPreCheckInReservationRequest
*/
func (a *ReservationApiService) PostPreCheckInReservation(ctx context.Context, reservationId string, hotelId string) ApiPostPreCheckInReservationRequest {
	return ApiPostPreCheckInReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostPreCheckInReservationExecute(r ApiPostPreCheckInReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostPreCheckInReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preCheckIn"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.preCheckInReservation == nil {
		return localVarReturnValue, nil, reportError("preCheckInReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preCheckInReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createReservation *PostReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostReservationRequest) Authorization(authorization string) ApiPostReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostReservationRequest) XAppKey(xAppKey string) ApiPostReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostReservationRequest) XHotelid(xHotelid string) ApiPostReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create reservations. Includes instructions for information which needs to be returned.
func (r ApiPostReservationRequest) CreateReservation(createReservation PostReservationRequest) ApiPostReservationRequest {
	r.createReservation = &createReservation
	return r
}

// External system code.
func (r ApiPostReservationRequest) XExternalsystem(xExternalsystem string) ApiPostReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostReservationRequest) AcceptLanguage(acceptLanguage string) ApiPostReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationExecute(r)
}

/*
PostReservation Create Reservation

Use this to create a new reservation for a hA12:F24otel.  Generally, you would search for a hotel's availability and rates before proceeding to use postReservation.  There are many fields in postReservation defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postReservation. <p><strong>OperationId:</strong>postReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostReservationRequest
*/
func (a *ReservationApiService) PostReservation(ctx context.Context, hotelId string) ApiPostReservationRequest {
	return ApiPostReservationRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationExecute(r ApiPostReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.createReservation == nil {
		return localVarReturnValue, nil, reportError("createReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReservationByBlockRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createReservation *PostReservationByBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostReservationByBlockRequest) Authorization(authorization string) ApiPostReservationByBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostReservationByBlockRequest) XAppKey(xAppKey string) ApiPostReservationByBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostReservationByBlockRequest) XHotelid(xHotelid string) ApiPostReservationByBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create reservations. Includes instructions for information which needs to be returned.
func (r ApiPostReservationByBlockRequest) CreateReservation(createReservation PostReservationByBlockRequest) ApiPostReservationByBlockRequest {
	r.createReservation = &createReservation
	return r
}

// External system code.
func (r ApiPostReservationByBlockRequest) XExternalsystem(xExternalsystem string) ApiPostReservationByBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostReservationByBlockRequest) AcceptLanguage(acceptLanguage string) ApiPostReservationByBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostReservationByBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationByBlockExecute(r)
}

/*
PostReservationByBlock Create Reservation for a Block

Use this to create a new reservation for a block, you must know the block Code to create this reservation.  In order to post a successful block reservation, please ensure you use the ListOfValues API's to know the hotel's codes; such as Address Type, Country Code,  Titles, preferenceCodes etc. <p><strong>OperationId:</strong>postReservationByBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique OPERA internal ID for the block.
 @param hotelId Unique ID of the hotel where reservation is created.
 @return ApiPostReservationByBlockRequest
*/
func (a *ReservationApiService) PostReservationByBlock(ctx context.Context, blockId string, hotelId string) ApiPostReservationByBlockRequest {
	return ApiPostReservationByBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationByBlockExecute(r ApiPostReservationByBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationByBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.createReservation == nil {
		return localVarReturnValue, nil, reportError("createReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReservationLinksRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationsCriteria *PostReservationLinksRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostReservationLinksRequest) Authorization(authorization string) ApiPostReservationLinksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostReservationLinksRequest) XAppKey(xAppKey string) ApiPostReservationLinksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostReservationLinksRequest) XHotelid(xHotelid string) ApiPostReservationLinksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to link a list of reservations with another existing reservation.
func (r ApiPostReservationLinksRequest) LinkReservationsCriteria(linkReservationsCriteria PostReservationLinksRequest) ApiPostReservationLinksRequest {
	r.linkReservationsCriteria = &linkReservationsCriteria
	return r
}

// External system code.
func (r ApiPostReservationLinksRequest) XExternalsystem(xExternalsystem string) ApiPostReservationLinksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostReservationLinksRequest) AcceptLanguage(acceptLanguage string) ApiPostReservationLinksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostReservationLinksRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationLinksExecute(r)
}

/*
PostReservationLinks Link Reservations

This will allow you to link 1 or more reservations to an existing reservation.  <p><strong>OperationId:</strong>postReservationLinks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostReservationLinksRequest
*/
func (a *ReservationApiService) PostReservationLinks(ctx context.Context, reservationId string, hotelId string) ApiPostReservationLinksRequest {
	return ApiPostReservationLinksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationLinksExecute(r ApiPostReservationLinksRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.linkReservationsCriteria == nil {
		return localVarReturnValue, nil, reportError("linkReservationsCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReservationLinksByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationsCriteria *PostReservationLinksByChainRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostReservationLinksByChainRequest) Authorization(authorization string) ApiPostReservationLinksByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostReservationLinksByChainRequest) XAppKey(xAppKey string) ApiPostReservationLinksByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostReservationLinksByChainRequest) XHotelid(xHotelid string) ApiPostReservationLinksByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to link a list of reservations with another existing reservation.
func (r ApiPostReservationLinksByChainRequest) LinkReservationsCriteria(linkReservationsCriteria PostReservationLinksByChainRequest) ApiPostReservationLinksByChainRequest {
	r.linkReservationsCriteria = &linkReservationsCriteria
	return r
}

// External system code.
func (r ApiPostReservationLinksByChainRequest) XExternalsystem(xExternalsystem string) ApiPostReservationLinksByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostReservationLinksByChainRequest) AcceptLanguage(acceptLanguage string) ApiPostReservationLinksByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostReservationLinksByChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationLinksByChainExecute(r)
}

/*
PostReservationLinksByChain Link Reservations By Chain

This will allow you to link 1 or more reservations to an existing reservation.  <p><strong>OperationId:</strong>postReservationLinksByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @return ApiPostReservationLinksByChainRequest
*/
func (a *ReservationApiService) PostReservationLinksByChain(ctx context.Context, reservationId string) ApiPostReservationLinksByChainRequest {
	return ApiPostReservationLinksByChainRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationLinksByChainExecute(r ApiPostReservationLinksByChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationLinksByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.linkReservationsCriteria == nil {
		return localVarReturnValue, nil, reportError("linkReservationsCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUpsellReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	upsellReservation *PostUpsellReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostUpsellReservationRequest) Authorization(authorization string) ApiPostUpsellReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostUpsellReservationRequest) XAppKey(xAppKey string) ApiPostUpsellReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostUpsellReservationRequest) XHotelid(xHotelid string) ApiPostUpsellReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to upsell a reservation.
func (r ApiPostUpsellReservationRequest) UpsellReservation(upsellReservation PostUpsellReservationRequest) ApiPostUpsellReservationRequest {
	r.upsellReservation = &upsellReservation
	return r
}

// External system code.
func (r ApiPostUpsellReservationRequest) XExternalsystem(xExternalsystem string) ApiPostUpsellReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostUpsellReservationRequest) AcceptLanguage(acceptLanguage string) ApiPostUpsellReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostUpsellReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostUpsellReservationExecute(r)
}

/*
PostUpsellReservation Upsell a Reservation

This API will allow you to upsell a reservation in OPERA.  You would need to already know the upsell rules that are available for this reservation - you can do this by using the getUpsell API. <p><strong>OperationId:</strong>postUpsellReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPostUpsellReservationRequest
*/
func (a *ReservationApiService) PostUpsellReservation(ctx context.Context, reservationId string, hotelId string) ApiPostUpsellReservationRequest {
	return ApiPostUpsellReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostUpsellReservationExecute(r ApiPostUpsellReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostUpsellReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/upsell"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.upsellReservation == nil {
		return localVarReturnValue, nil, reportError("upsellReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.upsellReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutReinstateReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reinstateReservation *PutReinstateReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutReinstateReservationRequest) Authorization(authorization string) ApiPutReinstateReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPutReinstateReservationRequest) XAppKey(xAppKey string) ApiPutReinstateReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutReinstateReservationRequest) XHotelid(xHotelid string) ApiPutReinstateReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Overriding the validation check will log the supposed errors in the warnings log if they would fail.
func (r ApiPutReinstateReservationRequest) ReinstateReservation(reinstateReservation PutReinstateReservationRequest) ApiPutReinstateReservationRequest {
	r.reinstateReservation = &reinstateReservation
	return r
}

// External system code.
func (r ApiPutReinstateReservationRequest) XExternalsystem(xExternalsystem string) ApiPutReinstateReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutReinstateReservationRequest) AcceptLanguage(acceptLanguage string) ApiPutReinstateReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutReinstateReservationRequest) Execute() (*ReinstateReservationDetails, *http.Response, error) {
	return r.ApiService.PutReinstateReservationExecute(r)
}

/*
PutReinstateReservation Reinstate a Reservation

Use this API to reinstate a cancelled reservation. <p><strong>OperationId:</strong>putReinstateReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPutReinstateReservationRequest
*/
func (a *ReservationApiService) PutReinstateReservation(ctx context.Context, reservationId string, hotelId string) ApiPutReinstateReservationRequest {
	return ApiPutReinstateReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReinstateReservationDetails
func (a *ReservationApiService) PutReinstateReservationExecute(r ApiPutReinstateReservationRequest) (*ReinstateReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReinstateReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReinstateReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reinstateReservation == nil {
		return localVarReturnValue, nil, reportError("reinstateReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reinstateReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeReservation *PutReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutReservationRequest) Authorization(authorization string) ApiPutReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPutReservationRequest) XAppKey(xAppKey string) ApiPutReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutReservationRequest) XHotelid(xHotelid string) ApiPutReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request method to change a reservations information.
func (r ApiPutReservationRequest) ChangeReservation(changeReservation PutReservationRequest) ApiPutReservationRequest {
	r.changeReservation = &changeReservation
	return r
}

// External system code.
func (r ApiPutReservationRequest) XExternalsystem(xExternalsystem string) ApiPutReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutReservationRequest) AcceptLanguage(acceptLanguage string) ApiPutReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutReservationRequest) Execute() (*ChangeReservationDetails, *http.Response, error) {
	return r.ApiService.PutReservationExecute(r)
}

/*
PutReservation Update Reservation by ID

Use this to update an existing reservation for a hotel, such as adding comments, changing the number of guests.   There are many fields in putReservation defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use putReservation. <p><strong>OperationId:</strong>putReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPutReservationRequest
*/
func (a *ReservationApiService) PutReservation(ctx context.Context, reservationId string, hotelId string) ApiPutReservationRequest {
	return ApiPutReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeReservationDetails
func (a *ReservationApiService) PutReservationExecute(r ApiPutReservationRequest) (*ChangeReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.changeReservation == nil {
		return localVarReturnValue, nil, reportError("changeReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutValidateReservationChangesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	validateReservationChanges *PutValidateReservationChangesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutValidateReservationChangesRequest) Authorization(authorization string) ApiPutValidateReservationChangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPutValidateReservationChangesRequest) XAppKey(xAppKey string) ApiPutValidateReservationChangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutValidateReservationChangesRequest) XHotelid(xHotelid string) ApiPutValidateReservationChangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate reservation changes.
func (r ApiPutValidateReservationChangesRequest) ValidateReservationChanges(validateReservationChanges PutValidateReservationChangesRequest) ApiPutValidateReservationChangesRequest {
	r.validateReservationChanges = &validateReservationChanges
	return r
}

// External system code.
func (r ApiPutValidateReservationChangesRequest) XExternalsystem(xExternalsystem string) ApiPutValidateReservationChangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutValidateReservationChangesRequest) AcceptLanguage(acceptLanguage string) ApiPutValidateReservationChangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutValidateReservationChangesRequest) Execute() (*ValidateReservationChangesDetails, *http.Response, error) {
	return r.ApiService.PutValidateReservationChangesExecute(r)
}

/*
PutValidateReservationChanges Validate Reservation Change

Use this API to validate either the guarantee type or stay details of a reservation you are about to create. <p><strong>OperationId:</strong>putValidateReservationChanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ApiPutValidateReservationChangesRequest
*/
func (a *ReservationApiService) PutValidateReservationChanges(ctx context.Context, hotelId string) ApiPutValidateReservationChangesRequest {
	return ApiPutValidateReservationChangesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidateReservationChangesDetails
func (a *ReservationApiService) PutValidateReservationChangesExecute(r ApiPutValidateReservationChangesRequest) (*ValidateReservationChangesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateReservationChangesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutValidateReservationChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/validations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.validateReservationChanges == nil {
		return localVarReturnValue, nil, reportError("validateReservationChanges is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.validateReservationChanges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
