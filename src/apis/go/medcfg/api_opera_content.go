/*
OPERA Cloud Content Service

Opera Content Service offers capability to manage large content such as images and files.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// OperaContentApiService OperaContentApi service
type OperaContentApiService service

type ApiEmailFolioReportRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioReportToEmail *EmailFolioReportRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiEmailFolioReportRequest) Authorization(authorization string) ApiEmailFolioReportRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiEmailFolioReportRequest) XAppKey(xAppKey string) ApiEmailFolioReportRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiEmailFolioReportRequest) XHotelid(xHotelid string) ApiEmailFolioReportRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate and email a folio report.
func (r ApiEmailFolioReportRequest) FolioReportToEmail(folioReportToEmail EmailFolioReportRequest) ApiEmailFolioReportRequest {
	r.folioReportToEmail = &folioReportToEmail
	return r
}

// External system code.
func (r ApiEmailFolioReportRequest) XExternalsystem(xExternalsystem string) ApiEmailFolioReportRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiEmailFolioReportRequest) AcceptLanguage(acceptLanguage string) ApiEmailFolioReportRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiEmailFolioReportRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.EmailFolioReportExecute(r)
}

/*
EmailFolioReport Email folio report

Use this APU to email folio report. <p><strong>OperationId:</strong>emailFolioReport</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEmailFolioReportRequest
*/
func (a *OperaContentApiService) EmailFolioReport(ctx context.Context) ApiEmailFolioReportRequest {
	return ApiEmailFolioReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) EmailFolioReportExecute(r ApiEmailFolioReportRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.EmailFolioReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioReports/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.folioReportToEmail == nil {
		return localVarReturnValue, nil, reportError("folioReportToEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioReportToEmail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomizedLetterRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	letterId string
	authorization *string
	xAppKey *string
	xHotelid *string
	letterIdContext *string
	letterIdtype *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCustomizedLetterRequest) Authorization(authorization string) ApiGetCustomizedLetterRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCustomizedLetterRequest) XAppKey(xAppKey string) ApiGetCustomizedLetterRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCustomizedLetterRequest) XHotelid(xHotelid string) ApiGetCustomizedLetterRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCustomizedLetterRequest) LetterIdContext(letterIdContext string) ApiGetCustomizedLetterRequest {
	r.letterIdContext = &letterIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetCustomizedLetterRequest) LetterIdtype(letterIdtype string) ApiGetCustomizedLetterRequest {
	r.letterIdtype = &letterIdtype
	return r
}

// External system code.
func (r ApiGetCustomizedLetterRequest) XExternalsystem(xExternalsystem string) ApiGetCustomizedLetterRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCustomizedLetterRequest) AcceptLanguage(acceptLanguage string) ApiGetCustomizedLetterRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCustomizedLetterRequest) Execute() (*CustomizedLetter, *http.Response, error) {
	return r.ApiService.GetCustomizedLetterExecute(r)
}

/*
GetCustomizedLetter Get customized letter

Use this API to get a customized letter. <p><strong>OperationId:</strong>getCustomizedLetter</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param letterId
 @return ApiGetCustomizedLetterRequest
*/
func (a *OperaContentApiService) GetCustomizedLetter(ctx context.Context, letterId string) ApiGetCustomizedLetterRequest {
	return ApiGetCustomizedLetterRequest{
		ApiService: a,
		ctx: ctx,
		letterId: letterId,
	}
}

// Execute executes the request
//  @return CustomizedLetter
func (a *OperaContentApiService) GetCustomizedLetterExecute(r ApiGetCustomizedLetterRequest) (*CustomizedLetter, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomizedLetter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetCustomizedLetter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customizedLetter/{letterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"letterId"+"}", url.PathEscape(parameterValueToString(r.letterId, "letterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.letterId) < 1 {
		return localVarReturnValue, nil, reportError("letterId must have at least 1 elements")
	}
	if strlen(r.letterId) > 2000 {
		return localVarReturnValue, nil, reportError("letterId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.letterIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "letterIdContext", r.letterIdContext, "")
	}
	if r.letterIdtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "letterIdtype", r.letterIdtype, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmailFileRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	emailId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEmailFileRequest) Authorization(authorization string) ApiGetEmailFileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEmailFileRequest) XAppKey(xAppKey string) ApiGetEmailFileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEmailFileRequest) XHotelid(xHotelid string) ApiGetEmailFileRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetEmailFileRequest) XExternalsystem(xExternalsystem string) ApiGetEmailFileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEmailFileRequest) AcceptLanguage(acceptLanguage string) ApiGetEmailFileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEmailFileRequest) Execute() (*EmailFile, *http.Response, error) {
	return r.ApiService.GetEmailFileExecute(r)
}

/*
GetEmailFile Get Email Blob File

Use this API to retrieve email Blob File Stored in File Storage Schema.Its used in  Profiles to fetch Email and Open in an end user's mail client. <p><strong>OperationId:</strong>getEmailFile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param emailId Unique OPERA Email ID which is used to find an Email BLOB File from OPERA. This ID is a primary identification of an email file in OPERA.
 @return ApiGetEmailFileRequest
*/
func (a *OperaContentApiService) GetEmailFile(ctx context.Context, emailId string) ApiGetEmailFileRequest {
	return ApiGetEmailFileRequest{
		ApiService: a,
		ctx: ctx,
		emailId: emailId,
	}
}

// Execute executes the request
//  @return EmailFile
func (a *OperaContentApiService) GetEmailFileExecute(r ApiGetEmailFileRequest) (*EmailFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetEmailFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/emailFile/{emailId}"
	localVarPath = strings.Replace(localVarPath, "{"+"emailId"+"}", url.PathEscape(parameterValueToString(r.emailId, "emailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.emailId) < 1 {
		return localVarReturnValue, nil, reportError("emailId must have at least 1 elements")
	}
	if strlen(r.emailId) > 2000 {
		return localVarReturnValue, nil, reportError("emailId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileAttachmentRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFileAttachmentRequest) Authorization(authorization string) ApiGetFileAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFileAttachmentRequest) XAppKey(xAppKey string) ApiGetFileAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFileAttachmentRequest) XHotelid(xHotelid string) ApiGetFileAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetFileAttachmentRequest) Id(id string) ApiGetFileAttachmentRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFileAttachmentRequest) IdContext(idContext string) ApiGetFileAttachmentRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetFileAttachmentRequest) IdType(idType string) ApiGetFileAttachmentRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r ApiGetFileAttachmentRequest) XExternalsystem(xExternalsystem string) ApiGetFileAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFileAttachmentRequest) AcceptLanguage(acceptLanguage string) ApiGetFileAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFileAttachmentRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.GetFileAttachmentExecute(r)
}

/*
GetFileAttachment Get file attachment

This APU will fetch file attachments. <p><strong>OperationId:</strong>getFileAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFileAttachmentRequest
*/
func (a *OperaContentApiService) GetFileAttachment(ctx context.Context) ApiGetFileAttachmentRequest {
	return ApiGetFileAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *OperaContentApiService) GetFileAttachmentExecute(r ApiGetFileAttachmentRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetFileAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fileAttachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioReportRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	folioWindowNo *int32
	billNumber *int32
	folioType *string
	folioDate *string
	referenceCurrency *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioReportRequest) Authorization(authorization string) ApiGetFolioReportRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioReportRequest) XAppKey(xAppKey string) ApiGetFolioReportRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioReportRequest) XHotelid(xHotelid string) ApiGetFolioReportRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetFolioReportRequest) ReservationIdContext(reservationIdContext string) ApiGetFolioReportRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetFolioReportRequest) ReservationIdType(reservationIdType string) ApiGetFolioReportRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Folio window number to generate (defaults to view 1).
func (r ApiGetFolioReportRequest) FolioWindowNo(folioWindowNo int32) ApiGetFolioReportRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Optional bill number to generate.
func (r ApiGetFolioReportRequest) BillNumber(billNumber int32) ApiGetFolioReportRequest {
	r.billNumber = &billNumber
	return r
}

// Optional folio type.
func (r ApiGetFolioReportRequest) FolioType(folioType string) ApiGetFolioReportRequest {
	r.folioType = &folioType
	return r
}

// Optional folio generation date - defaults to hotel business date.
func (r ApiGetFolioReportRequest) FolioDate(folioDate string) ApiGetFolioReportRequest {
	r.folioDate = &folioDate
	return r
}

// Folio currency code.
func (r ApiGetFolioReportRequest) ReferenceCurrency(referenceCurrency string) ApiGetFolioReportRequest {
	r.referenceCurrency = &referenceCurrency
	return r
}

// External system code.
func (r ApiGetFolioReportRequest) XExternalsystem(xExternalsystem string) ApiGetFolioReportRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioReportRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioReportRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioReportRequest) Execute() (*FolioReport, *http.Response, error) {
	return r.ApiService.GetFolioReportExecute(r)
}

/*
GetFolioReport Get folio report

This API will get a folio report for a reservation. <p><strong>OperationId:</strong>getFolioReport</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return ApiGetFolioReportRequest
*/
func (a *OperaContentApiService) GetFolioReport(ctx context.Context, reservationId string, hotelId string) ApiGetFolioReportRequest {
	return ApiGetFolioReportRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioReport
func (a *OperaContentApiService) GetFolioReportExecute(r ApiGetFolioReportRequest) (*FolioReport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetFolioReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folioReports"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.billNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "billNumber", r.billNumber, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.referenceCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceCurrency", r.referenceCurrency, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	linkId *string
	linkIdContext *string
	linkIdType *string
	imageCode *string
	imageParameterCode *[]string
	imageParameterValue *[]string
	languageCode *string
	imageStyle *string
	imageId *string
	imageIdContext *string
	imageIdType *string
	base64 *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetImageRequest) Authorization(authorization string) ApiGetImageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetImageRequest) XAppKey(xAppKey string) ApiGetImageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetImageRequest) XHotelid(xHotelid string) ApiGetImageRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetImageRequest) LinkId(linkId string) ApiGetImageRequest {
	r.linkId = &linkId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetImageRequest) LinkIdContext(linkIdContext string) ApiGetImageRequest {
	r.linkIdContext = &linkIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetImageRequest) LinkIdType(linkIdType string) ApiGetImageRequest {
	r.linkIdType = &linkIdType
	return r
}

func (r ApiGetImageRequest) ImageCode(imageCode string) ApiGetImageRequest {
	r.imageCode = &imageCode
	return r
}

func (r ApiGetImageRequest) ImageParameterCode(imageParameterCode []string) ApiGetImageRequest {
	r.imageParameterCode = &imageParameterCode
	return r
}

// Image parameter value.
func (r ApiGetImageRequest) ImageParameterValue(imageParameterValue []string) ApiGetImageRequest {
	r.imageParameterValue = &imageParameterValue
	return r
}

func (r ApiGetImageRequest) LanguageCode(languageCode string) ApiGetImageRequest {
	r.languageCode = &languageCode
	return r
}

// An enumeration of image styles.
func (r ApiGetImageRequest) ImageStyle(imageStyle string) ApiGetImageRequest {
	r.imageStyle = &imageStyle
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetImageRequest) ImageId(imageId string) ApiGetImageRequest {
	r.imageId = &imageId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetImageRequest) ImageIdContext(imageIdContext string) ApiGetImageRequest {
	r.imageIdContext = &imageIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetImageRequest) ImageIdType(imageIdType string) ApiGetImageRequest {
	r.imageIdType = &imageIdType
	return r
}

// True if the image to be returned as a base64String else if the image to be returned as the binary in MTOM attachment then false .
func (r ApiGetImageRequest) Base64(base64 bool) ApiGetImageRequest {
	r.base64 = &base64
	return r
}

// External system code.
func (r ApiGetImageRequest) XExternalsystem(xExternalsystem string) ApiGetImageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetImageRequest) AcceptLanguage(acceptLanguage string) ApiGetImageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetImageRequest) Execute() (*Image, *http.Response, error) {
	return r.ApiService.GetImageExecute(r)
}

/*
GetImage Get image

You can use this API to get an image. <p><strong>OperationId:</strong>getImage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetImageRequest
*/
func (a *OperaContentApiService) GetImage(ctx context.Context) ApiGetImageRequest {
	return ApiGetImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Image
func (a *OperaContentApiService) GetImageExecute(r ApiGetImageRequest) (*Image, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Image
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.linkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkId", r.linkId, "")
	}
	if r.linkIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkIdContext", r.linkIdContext, "")
	}
	if r.linkIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkIdType", r.linkIdType, "")
	}
	if r.imageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageCode", r.imageCode, "")
	}
	if r.imageParameterCode != nil {
		t := *r.imageParameterCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterCode", t, "multi")
		}
	}
	if r.imageParameterValue != nil {
		t := *r.imageParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterValue", t, "multi")
		}
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
	}
	if r.imageStyle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageStyle", r.imageStyle, "")
	}
	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageId", r.imageId, "")
	}
	if r.imageIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdContext", r.imageIdContext, "")
	}
	if r.imageIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdType", r.imageIdType, "")
	}
	if r.base64 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base64", r.base64, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRegistrationCardRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	regenerate *bool
	signedOnly *bool
	language *string
	template *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRegistrationCardRequest) Authorization(authorization string) ApiGetRegistrationCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRegistrationCardRequest) XAppKey(xAppKey string) ApiGetRegistrationCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRegistrationCardRequest) XHotelid(xHotelid string) ApiGetRegistrationCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetRegistrationCardRequest) ReservationIdContext(reservationIdContext string) ApiGetRegistrationCardRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetRegistrationCardRequest) ReservationIdType(reservationIdType string) ApiGetRegistrationCardRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Flag indicating whether a new registration card should be generated even if a signed card already exists.
func (r ApiGetRegistrationCardRequest) Regenerate(regenerate bool) ApiGetRegistrationCardRequest {
	r.regenerate = &regenerate
	return r
}

// Flag indicating whether return only the signed registrationCard if present.
func (r ApiGetRegistrationCardRequest) SignedOnly(signedOnly bool) ApiGetRegistrationCardRequest {
	r.signedOnly = &signedOnly
	return r
}

// Optional language code to use for registration card generation. Default guest language will be applied if not specified.
func (r ApiGetRegistrationCardRequest) Language(language string) ApiGetRegistrationCardRequest {
	r.language = &language
	return r
}

// Optional registration card template code to use for registration card generation. Default template will be applied if not specified.
func (r ApiGetRegistrationCardRequest) Template(template string) ApiGetRegistrationCardRequest {
	r.template = &template
	return r
}

// External system code.
func (r ApiGetRegistrationCardRequest) XExternalsystem(xExternalsystem string) ApiGetRegistrationCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRegistrationCardRequest) AcceptLanguage(acceptLanguage string) ApiGetRegistrationCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRegistrationCardRequest) Execute() (*RegistrationCard, *http.Response, error) {
	return r.ApiService.GetRegistrationCardExecute(r)
}

/*
GetRegistrationCard Get registration card

This API will get a registration card for a reservation. <p><strong>OperationId:</strong>getRegistrationCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return ApiGetRegistrationCardRequest
*/
func (a *OperaContentApiService) GetRegistrationCard(ctx context.Context, reservationId string, hotelId string) ApiGetRegistrationCardRequest {
	return ApiGetRegistrationCardRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RegistrationCard
func (a *OperaContentApiService) GetRegistrationCardExecute(r ApiGetRegistrationCardRequest) (*RegistrationCard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistrationCard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetRegistrationCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/registrationCard"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.regenerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regenerate", r.regenerate, "")
	}
	if r.signedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signedOnly", r.signedOnly, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template", r.template, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveImageRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	imageCode *string
	imageSet *string
	imageId *string
	imageIdContext *string
	imageIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveImageRequest) Authorization(authorization string) ApiRemoveImageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveImageRequest) XAppKey(xAppKey string) ApiRemoveImageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveImageRequest) XHotelid(xHotelid string) ApiRemoveImageRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiRemoveImageRequest) ImageCode(imageCode string) ApiRemoveImageRequest {
	r.imageCode = &imageCode
	return r
}

// Used for Character Strings, length 0 to 800.
func (r ApiRemoveImageRequest) ImageSet(imageSet string) ApiRemoveImageRequest {
	r.imageSet = &imageSet
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiRemoveImageRequest) ImageId(imageId string) ApiRemoveImageRequest {
	r.imageId = &imageId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiRemoveImageRequest) ImageIdContext(imageIdContext string) ApiRemoveImageRequest {
	r.imageIdContext = &imageIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiRemoveImageRequest) ImageIdType(imageIdType string) ApiRemoveImageRequest {
	r.imageIdType = &imageIdType
	return r
}

// External system code.
func (r ApiRemoveImageRequest) XExternalsystem(xExternalsystem string) ApiRemoveImageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveImageRequest) AcceptLanguage(acceptLanguage string) ApiRemoveImageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveImageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveImageExecute(r)
}

/*
RemoveImage Delete image

This API will delete an image. <p><strong>OperationId:</strong>removeImage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveImageRequest
*/
func (a *OperaContentApiService) RemoveImage(ctx context.Context) ApiRemoveImageRequest {
	return ApiRemoveImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) RemoveImageExecute(r ApiRemoveImageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.RemoveImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.imageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageCode", r.imageCode, "")
	}
	if r.imageSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageSet", r.imageSet, "")
	}
	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageId", r.imageId, "")
	}
	if r.imageIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdContext", r.imageIdContext, "")
	}
	if r.imageIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdType", r.imageIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetCustomizedLetterRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customizedLetter *SetCustomizedLetterRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiSetCustomizedLetterRequest) Authorization(authorization string) ApiSetCustomizedLetterRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiSetCustomizedLetterRequest) XAppKey(xAppKey string) ApiSetCustomizedLetterRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiSetCustomizedLetterRequest) XHotelid(xHotelid string) ApiSetCustomizedLetterRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to save customized letter.
func (r ApiSetCustomizedLetterRequest) CustomizedLetter(customizedLetter SetCustomizedLetterRequest) ApiSetCustomizedLetterRequest {
	r.customizedLetter = &customizedLetter
	return r
}

// External system code.
func (r ApiSetCustomizedLetterRequest) XExternalsystem(xExternalsystem string) ApiSetCustomizedLetterRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiSetCustomizedLetterRequest) AcceptLanguage(acceptLanguage string) ApiSetCustomizedLetterRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiSetCustomizedLetterRequest) Execute() (*CustomizedLetterStatus, *http.Response, error) {
	return r.ApiService.SetCustomizedLetterExecute(r)
}

/*
SetCustomizedLetter Set customized letter

You can set a customized letter with this API. <p><strong>OperationId:</strong>setCustomizedLetter</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return ApiSetCustomizedLetterRequest
*/
func (a *OperaContentApiService) SetCustomizedLetter(ctx context.Context, reservationId string, hotelId string) ApiSetCustomizedLetterRequest {
	return ApiSetCustomizedLetterRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomizedLetterStatus
func (a *OperaContentApiService) SetCustomizedLetterExecute(r ApiSetCustomizedLetterRequest) (*CustomizedLetterStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomizedLetterStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.SetCustomizedLetter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/customizedLetter"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.customizedLetter == nil {
		return localVarReturnValue, nil, reportError("customizedLetter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customizedLetter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileAttachmentRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fileToUpload *UploadFileAttachmentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiUploadFileAttachmentRequest) Authorization(authorization string) ApiUploadFileAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiUploadFileAttachmentRequest) XAppKey(xAppKey string) ApiUploadFileAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiUploadFileAttachmentRequest) XHotelid(xHotelid string) ApiUploadFileAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to upload a file attachment.
func (r ApiUploadFileAttachmentRequest) FileToUpload(fileToUpload UploadFileAttachmentRequest) ApiUploadFileAttachmentRequest {
	r.fileToUpload = &fileToUpload
	return r
}

// External system code.
func (r ApiUploadFileAttachmentRequest) XExternalsystem(xExternalsystem string) ApiUploadFileAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiUploadFileAttachmentRequest) AcceptLanguage(acceptLanguage string) ApiUploadFileAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiUploadFileAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UploadFileAttachmentExecute(r)
}

/*
UploadFileAttachment Upload a file attachment

Use this APU to upload a file attachment. <p><strong>OperationId:</strong>uploadFileAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadFileAttachmentRequest
*/
func (a *OperaContentApiService) UploadFileAttachment(ctx context.Context) ApiUploadFileAttachmentRequest {
	return ApiUploadFileAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) UploadFileAttachmentExecute(r ApiUploadFileAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.UploadFileAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fileAttachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.fileToUpload == nil {
		return localVarReturnValue, nil, reportError("fileToUpload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fileToUpload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadImageRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	imageToUpload *UploadImageRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiUploadImageRequest) Authorization(authorization string) ApiUploadImageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiUploadImageRequest) XAppKey(xAppKey string) ApiUploadImageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiUploadImageRequest) XHotelid(xHotelid string) ApiUploadImageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to upload an image.
func (r ApiUploadImageRequest) ImageToUpload(imageToUpload UploadImageRequest) ApiUploadImageRequest {
	r.imageToUpload = &imageToUpload
	return r
}

// External system code.
func (r ApiUploadImageRequest) XExternalsystem(xExternalsystem string) ApiUploadImageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiUploadImageRequest) AcceptLanguage(acceptLanguage string) ApiUploadImageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiUploadImageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UploadImageExecute(r)
}

/*
UploadImage Upload an image

You can use this API to upload an image. <p><strong>OperationId:</strong>uploadImage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadImageRequest
*/
func (a *OperaContentApiService) UploadImage(ctx context.Context) ApiUploadImageRequest {
	return ApiUploadImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) UploadImageExecute(r ApiUploadImageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.UploadImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.imageToUpload == nil {
		return localVarReturnValue, nil, reportError("imageToUpload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.imageToUpload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
