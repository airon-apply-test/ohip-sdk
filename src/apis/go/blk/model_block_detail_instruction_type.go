/*
OPERA Cloud Block API

APIs to cater for Business Block functionality in OPERA Cloud. <br /><br /> A block is a group of rooms held for guests who are attending an event, meeting, or function. You can create blocks for family reunions, business conferences, weddings, and so on. You can also set aside rooms for the event (block).<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// BlockDetailInstructionType Type for block instructions that can be used in requests for partial operations.
type BlockDetailInstructionType string

// List of blockDetailInstructionType
const (
	ACCESS_EXCLUSIONS BlockDetailInstructionType = "AccessExclusions"
	ALIASES BlockDetailInstructionType = "Aliases"
	ALTERNATE_DATES BlockDetailInstructionType = "AlternateDates"
	ATTACHMENTS BlockDetailInstructionType = "Attachments"
	BLOCK BlockDetailInstructionType = "Block"
	BLOCK_NEXT_STATUSES BlockDetailInstructionType = "BlockNextStatuses"
	BLOCK_STATUS_HISTORY BlockDetailInstructionType = "BlockStatusHistory"
	CAT_NEXT_STATUSES BlockDetailInstructionType = "CatNextStatuses"
	CAT_STATUS_HISTORY BlockDetailInstructionType = "CatStatusHistory"
	COMMENTS BlockDetailInstructionType = "Comments"
	DATE_PROTECT BlockDetailInstructionType = "DateProtect"
	EXTERNAL_REFERENCES BlockDetailInstructionType = "ExternalReferences"
	GENERIC_RATE_GRID BlockDetailInstructionType = "GenericRateGrid"
	HEADER BlockDetailInstructionType = "Header"
	INDICATORS BlockDetailInstructionType = "Indicators"
	INVENTORY_ITEMS BlockDetailInstructionType = "InventoryItems"
	OWNERS BlockDetailInstructionType = "Owners"
	PACKAGES BlockDetailInstructionType = "Packages"
	POLICIES BlockDetailInstructionType = "Policies"
	PRIMARY_OWNERS BlockDetailInstructionType = "PrimaryOwners"
	PRIMARY_PROFILES BlockDetailInstructionType = "PrimaryProfiles"
	PRIMARY_RATES BlockDetailInstructionType = "PrimaryRates"
	PROFILES BlockDetailInstructionType = "Profiles"
	RATE_GRID BlockDetailInstructionType = "RateGrid"
	RATE_PROGRAM BlockDetailInstructionType = "RateProgram"
	RATES BlockDetailInstructionType = "Rates"
	RESTRICTIONS BlockDetailInstructionType = "Restrictions"
	SELL_MESSAGES BlockDetailInstructionType = "SellMessages"
	STATISTICS BlockDetailInstructionType = "Statistics"
	SUMMARY_STATISTICS BlockDetailInstructionType = "SummaryStatistics"
	TRACES BlockDetailInstructionType = "Traces"
	WASH_SCHEDULES BlockDetailInstructionType = "WashSchedules"
)

// All allowed values of BlockDetailInstructionType enum
var AllowedBlockDetailInstructionTypeEnumValues = []BlockDetailInstructionType{
	"AccessExclusions",
	"Aliases",
	"AlternateDates",
	"Attachments",
	"Block",
	"BlockNextStatuses",
	"BlockStatusHistory",
	"CatNextStatuses",
	"CatStatusHistory",
	"Comments",
	"DateProtect",
	"ExternalReferences",
	"GenericRateGrid",
	"Header",
	"Indicators",
	"InventoryItems",
	"Owners",
	"Packages",
	"Policies",
	"PrimaryOwners",
	"PrimaryProfiles",
	"PrimaryRates",
	"Profiles",
	"RateGrid",
	"RateProgram",
	"Rates",
	"Restrictions",
	"SellMessages",
	"Statistics",
	"SummaryStatistics",
	"Traces",
	"WashSchedules",
}

func (v *BlockDetailInstructionType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := BlockDetailInstructionType(value)
	for _, existing := range AllowedBlockDetailInstructionTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid BlockDetailInstructionType", value)
}

// NewBlockDetailInstructionTypeFromValue returns a pointer to a valid BlockDetailInstructionType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewBlockDetailInstructionTypeFromValue(v string) (*BlockDetailInstructionType, error) {
	ev := BlockDetailInstructionType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for BlockDetailInstructionType: valid values are %v", v, AllowedBlockDetailInstructionTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v BlockDetailInstructionType) IsValid() bool {
	for _, existing := range AllowedBlockDetailInstructionTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to blockDetailInstructionType value
func (v BlockDetailInstructionType) Ptr() *BlockDetailInstructionType {
	return &v
}

type NullableBlockDetailInstructionType struct {
	value *BlockDetailInstructionType
	isSet bool
}

func (v NullableBlockDetailInstructionType) Get() *BlockDetailInstructionType {
	return v.value
}

func (v *NullableBlockDetailInstructionType) Set(val *BlockDetailInstructionType) {
	v.value = val
	v.isSet = true
}

func (v NullableBlockDetailInstructionType) IsSet() bool {
	return v.isSet
}

func (v *NullableBlockDetailInstructionType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBlockDetailInstructionType(val *BlockDetailInstructionType) *NullableBlockDetailInstructionType {
	return &NullableBlockDetailInstructionType{value: val, isSet: true}
}

func (v NullableBlockDetailInstructionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBlockDetailInstructionType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

