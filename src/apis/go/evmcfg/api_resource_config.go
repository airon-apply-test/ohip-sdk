/*
OPERA Cloud Event Configuration API

This API caters for Event Configuration in OPERA Cloud. <br /><There are operations to post, update, fetch and delete codes such as item inventory, function spaces, menu items and many more.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ResourceConfigApiService ResourceConfigApi service
type ResourceConfigApiService service

type ApiGetCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	codes *[]string
	quickInsertCode *string
	listTypeCodes *[]string
	inactive *bool
	eventTypesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringMenuItemsRequest) Authorization(authorization string) ApiGetCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetCateringMenuItemsRequest) XAppKey(xAppKey string) ApiGetCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringMenuItemsRequest) XHotelid(xHotelid string) ApiGetCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetCateringMenuItemsRequest) Limit(limit int32) ApiGetCateringMenuItemsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetCateringMenuItemsRequest) Offset(offset int32) ApiGetCateringMenuItemsRequest {
	r.offset = &offset
	return r
}

// Menu item name of string lentgth 30
func (r ApiGetCateringMenuItemsRequest) Name(name string) ApiGetCateringMenuItemsRequest {
	r.name = &name
	return r
}

func (r ApiGetCateringMenuItemsRequest) Codes(codes []string) ApiGetCateringMenuItemsRequest {
	r.codes = &codes
	return r
}

// Article number of Menu Item in Caps
func (r ApiGetCateringMenuItemsRequest) QuickInsertCode(quickInsertCode string) ApiGetCateringMenuItemsRequest {
	r.quickInsertCode = &quickInsertCode
	return r
}

func (r ApiGetCateringMenuItemsRequest) ListTypeCodes(listTypeCodes []string) ApiGetCateringMenuItemsRequest {
	r.listTypeCodes = &listTypeCodes
	return r
}

// If true this boolean will set the criteria to only return Menu Items configured as Inactive.
func (r ApiGetCateringMenuItemsRequest) Inactive(inactive bool) ApiGetCateringMenuItemsRequest {
	r.inactive = &inactive
	return r
}

func (r ApiGetCateringMenuItemsRequest) EventTypesCodes(eventTypesCodes []string) ApiGetCateringMenuItemsRequest {
	r.eventTypesCodes = &eventTypesCodes
	return r
}

// External system code.
func (r ApiGetCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ApiGetCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringMenuItemsRequest) Execute() (*CateringMenuItemsInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenuItemsExecute(r)
}

/*
GetCateringMenuItems Get Menu items

Get Menu items for a property. <p><strong>OperationId:</strong>getCateringMenuItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ApiGetCateringMenuItemsRequest
*/
func (a *ResourceConfigApiService) GetCateringMenuItems(ctx context.Context, hotelId string) ApiGetCateringMenuItemsRequest {
	return ApiGetCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenuItemsInfo
func (a *ResourceConfigApiService) GetCateringMenuItemsExecute(r ApiGetCateringMenuItemsRequest) (*CateringMenuItemsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenuItemsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigApiService.GetCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.quickInsertCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quickInsertCode", r.quickInsertCode, "")
	}
	if r.listTypeCodes != nil {
		t := *r.listTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "listTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "listTypeCodes", t, "multi")
		}
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.eventTypesCodes != nil {
		t := *r.eventTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	menuId *string
	iDExtension *int32
	idContext *string
	menuIDType *string
	name *string
	classNameListCodes *[]string
	eventTypesCodes *[]string
	menuTypes *[]string
	dietaryListCodes *[]string
	inactive *bool
	multiChoice *bool
	webBookable *bool
	end *string
	start *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringMenusRequest) Authorization(authorization string) ApiGetCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetCateringMenusRequest) XAppKey(xAppKey string) ApiGetCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringMenusRequest) XHotelid(xHotelid string) ApiGetCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetCateringMenusRequest) Limit(limit int32) ApiGetCateringMenusRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetCateringMenusRequest) Offset(offset int32) ApiGetCateringMenusRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetCateringMenusRequest) MenuId(menuId string) ApiGetCateringMenusRequest {
	r.menuId = &menuId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiGetCateringMenusRequest) IDExtension(iDExtension int32) ApiGetCateringMenusRequest {
	r.iDExtension = &iDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetCateringMenusRequest) IdContext(idContext string) ApiGetCateringMenusRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetCateringMenusRequest) MenuIDType(menuIDType string) ApiGetCateringMenusRequest {
	r.menuIDType = &menuIDType
	return r
}

// This type holds name of Menu Class.
func (r ApiGetCateringMenusRequest) Name(name string) ApiGetCateringMenusRequest {
	r.name = &name
	return r
}

func (r ApiGetCateringMenusRequest) ClassNameListCodes(classNameListCodes []string) ApiGetCateringMenusRequest {
	r.classNameListCodes = &classNameListCodes
	return r
}

func (r ApiGetCateringMenusRequest) EventTypesCodes(eventTypesCodes []string) ApiGetCateringMenusRequest {
	r.eventTypesCodes = &eventTypesCodes
	return r
}

// Defines values for Menu Type
func (r ApiGetCateringMenusRequest) MenuTypes(menuTypes []string) ApiGetCateringMenusRequest {
	r.menuTypes = &menuTypes
	return r
}

func (r ApiGetCateringMenusRequest) DietaryListCodes(dietaryListCodes []string) ApiGetCateringMenusRequest {
	r.dietaryListCodes = &dietaryListCodes
	return r
}

// If true, only Composed Menu&#39;s marked as Inactive in Menu Configuration will be returned.
func (r ApiGetCateringMenusRequest) Inactive(inactive bool) ApiGetCateringMenusRequest {
	r.inactive = &inactive
	return r
}

// When selected Only Composed Menu&#39;s noted as Multi Choice in Menu Configuration will be returned.
func (r ApiGetCateringMenusRequest) MultiChoice(multiChoice bool) ApiGetCateringMenusRequest {
	r.multiChoice = &multiChoice
	return r
}

// Check of Menu if it is web bookable
func (r ApiGetCateringMenusRequest) WebBookable(webBookable bool) ApiGetCateringMenusRequest {
	r.webBookable = &webBookable
	return r
}

// The ending value of the date range.
func (r ApiGetCateringMenusRequest) End(end string) ApiGetCateringMenusRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ApiGetCateringMenusRequest) Start(start string) ApiGetCateringMenusRequest {
	r.start = &start
	return r
}

// Fetch instructions that can be used in Catering Menus maintenance.
func (r ApiGetCateringMenusRequest) FetchInstructions(fetchInstructions []string) ApiGetCateringMenusRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetCateringMenusRequest) XExternalsystem(xExternalsystem string) ApiGetCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringMenusRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringMenusRequest) Execute() (*CateringMenusInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenusExecute(r)
}

/*
GetCateringMenus Get menus

Retrieve a list of menus for a property. <p><strong>OperationId:</strong>getCateringMenus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ApiGetCateringMenusRequest
*/
func (a *ResourceConfigApiService) GetCateringMenus(ctx context.Context, hotelId string) ApiGetCateringMenusRequest {
	return ApiGetCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenusInfo
func (a *ResourceConfigApiService) GetCateringMenusExecute(r ApiGetCateringMenusRequest) (*CateringMenusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigApiService.GetCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.menuId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "menuId", r.menuId, "")
	}
	if r.iDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iDExtension", r.iDExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.menuIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "menuIDType", r.menuIDType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.classNameListCodes != nil {
		t := *r.classNameListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classNameListCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classNameListCodes", t, "multi")
		}
	}
	if r.eventTypesCodes != nil {
		t := *r.eventTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", t, "multi")
		}
	}
	if r.menuTypes != nil {
		t := *r.menuTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", t, "multi")
		}
	}
	if r.dietaryListCodes != nil {
		t := *r.dietaryListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dietaryListCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dietaryListCodes", t, "multi")
		}
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.multiChoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiChoice", r.multiChoice, "")
	}
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
