/*
OPERA Cloud Event Configuration API

This API caters for Event Configuration in OPERA Cloud. <br /><There are operations to post, update, fetch and delete codes such as item inventory, function spaces, menu items and many more.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigApiService HotelConfigApi service
type HotelConfigApiService service

type ApiChangeRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomPoolCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypePoolToBeChanged *ChangeRoomTypePoolRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiChangeRoomTypePoolRequest) Authorization(authorization string) ApiChangeRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiChangeRoomTypePoolRequest) XAppKey(xAppKey string) ApiChangeRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiChangeRoomTypePoolRequest) XHotelid(xHotelid string) ApiChangeRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing room pool.
func (r ApiChangeRoomTypePoolRequest) RoomTypePoolToBeChanged(roomTypePoolToBeChanged ChangeRoomTypePoolRequest) ApiChangeRoomTypePoolRequest {
	r.roomTypePoolToBeChanged = &roomTypePoolToBeChanged
	return r
}

// External system code.
func (r ApiChangeRoomTypePoolRequest) XExternalsystem(xExternalsystem string) ApiChangeRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiChangeRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) ApiChangeRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiChangeRoomTypePoolRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeRoomTypePoolExecute(r)
}

/*
ChangeRoomTypePool Change Room Type Pool 

Use this API to update Room Type Pool and Associated Room Types. <p><strong>OperationId:</strong>changeRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomPoolCode Unique Code of room type pool.
 @param hotelId Unique ID of hotel.
 @return ApiChangeRoomTypePoolRequest
*/
func (a *HotelConfigApiService) ChangeRoomTypePool(ctx context.Context, roomPoolCode string, hotelId string) ApiChangeRoomTypePoolRequest {
	return ApiChangeRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		roomPoolCode: roomPoolCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeRoomTypePoolExecute(r ApiChangeRoomTypePoolRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools/{roomPoolCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomPoolCode"+"}", url.PathEscape(parameterValueToString(r.roomPoolCode, "roomPoolCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomPoolCode) < 1 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have at least 1 elements")
	}
	if strlen(r.roomPoolCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.roomTypePoolToBeChanged == nil {
		return localVarReturnValue, nil, reportError("roomTypePoolToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypePoolToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	limit *int32
	pageNumber *int32
	physical *bool
	pseudo *bool
	summaryInfo *bool
	roomTypeCodes *[]string
	roomClassCodes *[]string
	roomTypePoolCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomTypePoolRequest) Authorization(authorization string) ApiGetRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomTypePoolRequest) XAppKey(xAppKey string) ApiGetRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomTypePoolRequest) XHotelid(xHotelid string) ApiGetRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if inactive room types should be included.
func (r ApiGetRoomTypePoolRequest) IncludeInactive(includeInactive bool) ApiGetRoomTypePoolRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetRoomTypePoolRequest) Limit(limit int32) ApiGetRoomTypePoolRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetRoomTypePoolRequest) PageNumber(pageNumber int32) ApiGetRoomTypePoolRequest {
	r.pageNumber = &pageNumber
	return r
}

// Is it a physical sleep room type.
func (r ApiGetRoomTypePoolRequest) Physical(physical bool) ApiGetRoomTypePoolRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r ApiGetRoomTypePoolRequest) Pseudo(pseudo bool) ApiGetRoomTypePoolRequest {
	r.pseudo = &pseudo
	return r
}

// Flag to indicate if summary or detailed information should be fetched.
func (r ApiGetRoomTypePoolRequest) SummaryInfo(summaryInfo bool) ApiGetRoomTypePoolRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r ApiGetRoomTypePoolRequest) RoomTypeCodes(roomTypeCodes []string) ApiGetRoomTypePoolRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r ApiGetRoomTypePoolRequest) RoomClassCodes(roomClassCodes []string) ApiGetRoomTypePoolRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r ApiGetRoomTypePoolRequest) RoomTypePoolCodes(roomTypePoolCodes []string) ApiGetRoomTypePoolRequest {
	r.roomTypePoolCodes = &roomTypePoolCodes
	return r
}

// External system code.
func (r ApiGetRoomTypePoolRequest) XExternalsystem(xExternalsystem string) ApiGetRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomTypePoolRequest) Execute() (*RoomTypePoolDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypePoolExecute(r)
}

/*
GetRoomTypePool Fetch Room Type Pool

This API allows you to Use this API to get Room Type Pool and the associated Room Types. <p><strong>OperationId:</strong>getRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ApiGetRoomTypePoolRequest
*/
func (a *HotelConfigApiService) GetRoomTypePool(ctx context.Context, hotelId string) ApiGetRoomTypePoolRequest {
	return ApiGetRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomTypePoolDetails
func (a *HotelConfigApiService) GetRoomTypePoolExecute(r ApiGetRoomTypePoolRequest) (*RoomTypePoolDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypePoolDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	if r.roomTypePoolCodes != nil {
		t := *r.roomTypePoolCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypePoolCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypePoolCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypePoolCriteria *PostRoomTypePoolRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostRoomTypePoolRequest) Authorization(authorization string) ApiPostRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostRoomTypePoolRequest) XAppKey(xAppKey string) ApiPostRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostRoomTypePoolRequest) XHotelid(xHotelid string) ApiPostRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new room pool.
func (r ApiPostRoomTypePoolRequest) RoomTypePoolCriteria(roomTypePoolCriteria PostRoomTypePoolRequest) ApiPostRoomTypePoolRequest {
	r.roomTypePoolCriteria = &roomTypePoolCriteria
	return r
}

// External system code.
func (r ApiPostRoomTypePoolRequest) XExternalsystem(xExternalsystem string) ApiPostRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) ApiPostRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostRoomTypePoolRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomTypePoolExecute(r)
}

/*
PostRoomTypePool Create Room Type Pools

This API allows you to Use this API to create Room Type Pools. <p><strong>OperationId:</strong>postRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ApiPostRoomTypePoolRequest
*/
func (a *HotelConfigApiService) PostRoomTypePool(ctx context.Context, hotelId string) ApiPostRoomTypePoolRequest {
	return ApiPostRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostRoomTypePoolExecute(r ApiPostRoomTypePoolRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.roomTypePoolCriteria == nil {
		return localVarReturnValue, nil, reportError("roomTypePoolCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypePoolCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomPoolCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	description *[]string
	defaultText *string
	lang *[]string
	sequence *[]int32
	inactive *[]bool
	numberOfRooms *[]int32
	roomType *[]string
	roomClass *[]string
	shortDescription *[]string
	activeDate *[]string
	pseudo *[]bool
	accessible *[]bool
	sendToInterface *[]bool
	sellSequence *[]float32
	suite *[]bool
	meetingRoom *[]bool
	restricted *[]bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemoveRoomTypePoolRequest) Authorization(authorization string) ApiRemoveRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemoveRoomTypePoolRequest) XAppKey(xAppKey string) ApiRemoveRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemoveRoomTypePoolRequest) XHotelid(xHotelid string) ApiRemoveRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// The description of room pool type.
func (r ApiRemoveRoomTypePoolRequest) Description(description []string) ApiRemoveRoomTypePoolRequest {
	r.description = &description
	return r
}

// Default text with Character length from 0 to 1000.
func (r ApiRemoveRoomTypePoolRequest) DefaultText(defaultText string) ApiRemoveRoomTypePoolRequest {
	r.defaultText = &defaultText
	return r
}

// Language code for the translation.
func (r ApiRemoveRoomTypePoolRequest) Lang(lang []string) ApiRemoveRoomTypePoolRequest {
	r.lang = &lang
	return r
}

// Sequence for representing room type pool record.
func (r ApiRemoveRoomTypePoolRequest) Sequence(sequence []int32) ApiRemoveRoomTypePoolRequest {
	r.sequence = &sequence
	return r
}

// Indicates the room type is inactive or not.
func (r ApiRemoveRoomTypePoolRequest) Inactive(inactive []bool) ApiRemoveRoomTypePoolRequest {
	r.inactive = &inactive
	return r
}

// Number of rooms for this room type.
func (r ApiRemoveRoomTypePoolRequest) NumberOfRooms(numberOfRooms []int32) ApiRemoveRoomTypePoolRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

func (r ApiRemoveRoomTypePoolRequest) RoomType(roomType []string) ApiRemoveRoomTypePoolRequest {
	r.roomType = &roomType
	return r
}

// Room class for the room type code.
func (r ApiRemoveRoomTypePoolRequest) RoomClass(roomClass []string) ApiRemoveRoomTypePoolRequest {
	r.roomClass = &roomClass
	return r
}

// Short Description of room type.
func (r ApiRemoveRoomTypePoolRequest) ShortDescription(shortDescription []string) ApiRemoveRoomTypePoolRequest {
	r.shortDescription = &shortDescription
	return r
}

// Active date of the room type.
func (r ApiRemoveRoomTypePoolRequest) ActiveDate(activeDate []string) ApiRemoveRoomTypePoolRequest {
	r.activeDate = &activeDate
	return r
}

// Indicates if room type is pseudo.
func (r ApiRemoveRoomTypePoolRequest) Pseudo(pseudo []bool) ApiRemoveRoomTypePoolRequest {
	r.pseudo = &pseudo
	return r
}

// Indicates if room type is accessible.
func (r ApiRemoveRoomTypePoolRequest) Accessible(accessible []bool) ApiRemoveRoomTypePoolRequest {
	r.accessible = &accessible
	return r
}

// Indicates if room type is sent to interface.
func (r ApiRemoveRoomTypePoolRequest) SendToInterface(sendToInterface []bool) ApiRemoveRoomTypePoolRequest {
	r.sendToInterface = &sendToInterface
	return r
}

// Indicates room types sell sequence.
func (r ApiRemoveRoomTypePoolRequest) SellSequence(sellSequence []float32) ApiRemoveRoomTypePoolRequest {
	r.sellSequence = &sellSequence
	return r
}

// Indicates room type is a suite.
func (r ApiRemoveRoomTypePoolRequest) Suite(suite []bool) ApiRemoveRoomTypePoolRequest {
	r.suite = &suite
	return r
}

// Indicates room type is meeting room. This Can be Meeting room flag cannot be unmarked at the property level. Can only be marked for non pseudo room types.
func (r ApiRemoveRoomTypePoolRequest) MeetingRoom(meetingRoom []bool) ApiRemoveRoomTypePoolRequest {
	r.meetingRoom = &meetingRoom
	return r
}

// Indicates that the room pool cannot be used to allocate inventory to this room type. Inventory must be allocated directly to the room type itself.
func (r ApiRemoveRoomTypePoolRequest) Restricted(restricted []bool) ApiRemoveRoomTypePoolRequest {
	r.restricted = &restricted
	return r
}

// External system code.
func (r ApiRemoveRoomTypePoolRequest) XExternalsystem(xExternalsystem string) ApiRemoveRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemoveRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) ApiRemoveRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemoveRoomTypePoolRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveRoomTypePoolExecute(r)
}

/*
RemoveRoomTypePool Delete  Room Type Pool and Mappings

Use this API to delete  Room Type Pool and Mappings. <p><strong>OperationId:</strong>removeRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomPoolCode Unique Code of room type pool.
 @param hotelId Unique ID of hotel.
 @return ApiRemoveRoomTypePoolRequest
*/
func (a *HotelConfigApiService) RemoveRoomTypePool(ctx context.Context, roomPoolCode string, hotelId string) ApiRemoveRoomTypePoolRequest {
	return ApiRemoveRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		roomPoolCode: roomPoolCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveRoomTypePoolExecute(r ApiRemoveRoomTypePoolRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools/{roomPoolCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomPoolCode"+"}", url.PathEscape(parameterValueToString(r.roomPoolCode, "roomPoolCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomPoolCode) < 1 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have at least 1 elements")
	}
	if strlen(r.roomPoolCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.defaultText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultText", r.defaultText, "")
	}
	if r.lang != nil {
		t := *r.lang
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lang", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lang", t, "multi")
		}
	}
	if r.sequence != nil {
		t := *r.sequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sequence", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.numberOfRooms != nil {
		t := *r.numberOfRooms
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.shortDescription != nil {
		t := *r.shortDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shortDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shortDescription", t, "multi")
		}
	}
	if r.activeDate != nil {
		t := *r.activeDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activeDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activeDate", t, "multi")
		}
	}
	if r.pseudo != nil {
		t := *r.pseudo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", t, "multi")
		}
	}
	if r.accessible != nil {
		t := *r.accessible
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accessible", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accessible", t, "multi")
		}
	}
	if r.sendToInterface != nil {
		t := *r.sendToInterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sendToInterface", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sendToInterface", t, "multi")
		}
	}
	if r.sellSequence != nil {
		t := *r.sellSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sellSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sellSequence", t, "multi")
		}
	}
	if r.suite != nil {
		t := *r.suite
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "suite", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "suite", t, "multi")
		}
	}
	if r.meetingRoom != nil {
		t := *r.meetingRoom
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "meetingRoom", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "meetingRoom", t, "multi")
		}
	}
	if r.restricted != nil {
		t := *r.restricted
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "restricted", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "restricted", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
