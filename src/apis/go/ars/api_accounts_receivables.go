/*
OPERA Cloud Accounts Receivables API

APIs to cater for Accounts Receivables functionality in OPERA Cloud. <br /><br The OPERA Cloud Accounts Receivable module enables you to manage debtors’ accounts, invoices, and remittance.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// AccountsReceivablesApiService AccountsReceivablesApi service
type AccountsReceivablesApiService service

type ApiCompressARInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arCompressInvoices *CompressARInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCompressARInvoicesRequest) Authorization(authorization string) ApiCompressARInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCompressARInvoicesRequest) XAppKey(xAppKey string) ApiCompressARInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCompressARInvoicesRequest) XHotelid(xHotelid string) ApiCompressARInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to compress two or more invoices for an Account
func (r ApiCompressARInvoicesRequest) ArCompressInvoices(arCompressInvoices CompressARInvoicesRequest) ApiCompressARInvoicesRequest {
	r.arCompressInvoices = &arCompressInvoices
	return r
}

// External system code.
func (r ApiCompressARInvoicesRequest) XExternalsystem(xExternalsystem string) ApiCompressARInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCompressARInvoicesRequest) AcceptLanguage(acceptLanguage string) ApiCompressARInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCompressARInvoicesRequest) Execute() (*CompressedARInvoices, *http.Response, error) {
	return r.ApiService.CompressARInvoicesExecute(r)
}

/*
CompressARInvoices Combines Account receivable invoices

Use this API to combine two or more invoices into one invoice <p><strong>OperationId:</strong>compressARInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiCompressARInvoicesRequest
*/
func (a *AccountsReceivablesApiService) CompressARInvoices(ctx context.Context, accountId string, hotelId string) ApiCompressARInvoicesRequest {
	return ApiCompressARInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompressedARInvoices
func (a *AccountsReceivablesApiService) CompressARInvoicesExecute(r ApiCompressARInvoicesRequest) (*CompressedARInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompressedARInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.CompressARInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/compressInvoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arCompressInvoices == nil {
		return localVarReturnValue, nil, reportError("arCompressInvoices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arCompressInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyARAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arAccountCopy *CopyARAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCopyARAccountRequest) Authorization(authorization string) ApiCopyARAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCopyARAccountRequest) XAppKey(xAppKey string) ApiCopyARAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCopyARAccountRequest) XHotelid(xHotelid string) ApiCopyARAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to copy AR Account
func (r ApiCopyARAccountRequest) ArAccountCopy(arAccountCopy CopyARAccountRequest) ApiCopyARAccountRequest {
	r.arAccountCopy = &arAccountCopy
	return r
}

// External system code.
func (r ApiCopyARAccountRequest) XExternalsystem(xExternalsystem string) ApiCopyARAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCopyARAccountRequest) AcceptLanguage(acceptLanguage string) ApiCopyARAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCopyARAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyARAccountExecute(r)
}

/*
CopyARAccount Copy account receivable account 

Use this API to create account receivable to multiple hotels by copying from source hotel. <p><strong>OperationId:</strong>copyARAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiCopyARAccountRequest
*/
func (a *AccountsReceivablesApiService) CopyARAccount(ctx context.Context, accountId string, hotelId string) ApiCopyARAccountRequest {
	return ApiCopyARAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) CopyARAccountExecute(r ApiCopyARAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.CopyARAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/copyAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arAccountCopy == nil {
		return localVarReturnValue, nil, reportError("arAccountCopy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arAccountCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAccountRequest) Authorization(authorization string) ApiDeleteAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAccountRequest) XAppKey(xAppKey string) ApiDeleteAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAccountRequest) XHotelid(xHotelid string) ApiDeleteAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteAccountRequest) XExternalsystem(xExternalsystem string) ApiDeleteAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAccountRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Delete Account 

Use this API to delete account detail for given unique account id. Use get accounts to find account id. <p><strong>OperationId:</strong>deleteAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiDeleteAccountRequest
*/
func (a *AccountsReceivablesApiService) DeleteAccount(ctx context.Context, accountId string, hotelId string) ApiDeleteAccountRequest {
	return ApiDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) DeleteAccountExecute(r ApiDeleteAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountCommentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	value *string
	hotel *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAccountCommentRequest) Authorization(authorization string) ApiDeleteAccountCommentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAccountCommentRequest) XAppKey(xAppKey string) ApiDeleteAccountCommentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAccountCommentRequest) XHotelid(xHotelid string) ApiDeleteAccountCommentRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteAccountCommentRequest) Id(id string) ApiDeleteAccountCommentRequest {
	r.id = &id
	return r
}

// Property Value
func (r ApiDeleteAccountCommentRequest) Value(value string) ApiDeleteAccountCommentRequest {
	r.value = &value
	return r
}

// If specified comment belongs to the Hotel, otherwise it is a global comment.
func (r ApiDeleteAccountCommentRequest) Hotel(hotel string) ApiDeleteAccountCommentRequest {
	r.hotel = &hotel
	return r
}

// External system code.
func (r ApiDeleteAccountCommentRequest) XExternalsystem(xExternalsystem string) ApiDeleteAccountCommentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAccountCommentRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAccountCommentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAccountCommentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountCommentExecute(r)
}

/*
DeleteAccountComment Delete Account Comment

Use this API to delete notes from a given account id. Use get account with an instruction to get note id. <p><strong>OperationId:</strong>deleteAccountComment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiDeleteAccountCommentRequest
*/
func (a *AccountsReceivablesApiService) DeleteAccountComment(ctx context.Context, accountId string, hotelId string) ApiDeleteAccountCommentRequest {
	return ApiDeleteAccountCommentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) DeleteAccountCommentExecute(r ApiDeleteAccountCommentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.DeleteAccountComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
	}
	if r.hotel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotel", r.hotel, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountFixedChargeRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	fixedChargeId string
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAccountFixedChargeRequest) Authorization(authorization string) ApiDeleteAccountFixedChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAccountFixedChargeRequest) XAppKey(xAppKey string) ApiDeleteAccountFixedChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAccountFixedChargeRequest) XHotelid(xHotelid string) ApiDeleteAccountFixedChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteAccountFixedChargeRequest) XExternalsystem(xExternalsystem string) ApiDeleteAccountFixedChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAccountFixedChargeRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAccountFixedChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAccountFixedChargeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountFixedChargeExecute(r)
}

/*
DeleteAccountFixedCharge Delete fixed charges 

Use this API to delete fixed charges for a given account receivable id. Use getaccounts to find an account id. <p><strong>OperationId:</strong>deleteAccountFixedCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fixedChargeId ID of the fixed charge
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiDeleteAccountFixedChargeRequest
*/
func (a *AccountsReceivablesApiService) DeleteAccountFixedCharge(ctx context.Context, fixedChargeId string, accountId string, hotelId string) ApiDeleteAccountFixedChargeRequest {
	return ApiDeleteAccountFixedChargeRequest{
		ApiService: a,
		ctx: ctx,
		fixedChargeId: fixedChargeId,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) DeleteAccountFixedChargeExecute(r ApiDeleteAccountFixedChargeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.DeleteAccountFixedCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/fixedCharges/{fixedChargeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fixedChargeId"+"}", url.PathEscape(parameterValueToString(r.fixedChargeId, "fixedChargeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fixedChargeId) < 1 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have at least 1 elements")
	}
	if strlen(r.fixedChargeId) > 2000 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountTraceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	traceID *string
	traceOn *time.Time
	traceText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAccountTraceRequest) Authorization(authorization string) ApiDeleteAccountTraceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAccountTraceRequest) XAppKey(xAppKey string) ApiDeleteAccountTraceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAccountTraceRequest) XHotelid(xHotelid string) ApiDeleteAccountTraceRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteAccountTraceRequest) TraceID(traceID string) ApiDeleteAccountTraceRequest {
	r.traceID = &traceID
	return r
}

// Date of the trace.
func (r ApiDeleteAccountTraceRequest) TraceOn(traceOn time.Time) ApiDeleteAccountTraceRequest {
	r.traceOn = &traceOn
	return r
}

// The information this trace contains.
func (r ApiDeleteAccountTraceRequest) TraceText(traceText string) ApiDeleteAccountTraceRequest {
	r.traceText = &traceText
	return r
}

// External system code.
func (r ApiDeleteAccountTraceRequest) XExternalsystem(xExternalsystem string) ApiDeleteAccountTraceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAccountTraceRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAccountTraceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAccountTraceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountTraceExecute(r)
}

/*
DeleteAccountTrace This API facilitates deletion of account traces.

 <p><strong>OperationId:</strong>deleteAccountTrace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiDeleteAccountTraceRequest
*/
func (a *AccountsReceivablesApiService) DeleteAccountTrace(ctx context.Context, accountId string, hotelId string) ApiDeleteAccountTraceRequest {
	return ApiDeleteAccountTraceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) DeleteAccountTraceExecute(r ApiDeleteAccountTraceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.DeleteAccountTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.traceID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "traceID", r.traceID, "")
	}
	if r.traceOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "traceOn", r.traceOn, "")
	}
	if r.traceText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "traceText", r.traceText, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountsReceivableServiceCacheRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAccountsReceivableServiceCacheRequest) Authorization(authorization string) ApiDeleteAccountsReceivableServiceCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAccountsReceivableServiceCacheRequest) XAppKey(xAppKey string) ApiDeleteAccountsReceivableServiceCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAccountsReceivableServiceCacheRequest) XHotelid(xHotelid string) ApiDeleteAccountsReceivableServiceCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteAccountsReceivableServiceCacheRequest) XExternalsystem(xExternalsystem string) ApiDeleteAccountsReceivableServiceCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAccountsReceivableServiceCacheRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAccountsReceivableServiceCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAccountsReceivableServiceCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountsReceivableServiceCacheExecute(r)
}

/*
DeleteAccountsReceivableServiceCache Clears service level cache

This API facilitates clearing of cache in account receivable services. <p><strong>OperationId:</strong>deleteAccountsReceivableServiceCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAccountsReceivableServiceCacheRequest
*/
func (a *AccountsReceivablesApiService) DeleteAccountsReceivableServiceCache(ctx context.Context) ApiDeleteAccountsReceivableServiceCacheRequest {
	return ApiDeleteAccountsReceivableServiceCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) DeleteAccountsReceivableServiceCacheExecute(r ApiDeleteAccountsReceivableServiceCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.DeleteAccountsReceivableServiceCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/accountReceivables/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePaymentsFromInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	transactionId string
	invoiceId string
	hotelId string
	trxNo *[]float32
	accountId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierID *float32
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Unique Transaction Identifier of the Payment.
func (r ApiDeletePaymentsFromInvoiceRequest) TrxNo(trxNo []float32) ApiDeletePaymentsFromInvoiceRequest {
	r.trxNo = &trxNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeletePaymentsFromInvoiceRequest) AccountId(accountId string) ApiDeletePaymentsFromInvoiceRequest {
	r.accountId = &accountId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeletePaymentsFromInvoiceRequest) Authorization(authorization string) ApiDeletePaymentsFromInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeletePaymentsFromInvoiceRequest) XAppKey(xAppKey string) ApiDeletePaymentsFromInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeletePaymentsFromInvoiceRequest) XHotelid(xHotelid string) ApiDeletePaymentsFromInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiDeletePaymentsFromInvoiceRequest) CashierID(cashierID float32) ApiDeletePaymentsFromInvoiceRequest {
	r.cashierID = &cashierID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiDeletePaymentsFromInvoiceRequest) InvoiceNo(invoiceNo float32) ApiDeletePaymentsFromInvoiceRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiDeletePaymentsFromInvoiceRequest) XExternalsystem(xExternalsystem string) ApiDeletePaymentsFromInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeletePaymentsFromInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiDeletePaymentsFromInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeletePaymentsFromInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePaymentsFromInvoiceExecute(r)
}

/*
DeletePaymentsFromInvoice Delete payments from invoice

Delete payments from invoice.<br><p><strong><mark>This API is deprecated. Please use removePaymentsFromInvoice instead</mark></strong></p> <p><strong>OperationId:</strong>deletePaymentsFromInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param invoiceId Unique ID of the invoice
 @param hotelId Unique ID of the hotel
 @return ApiDeletePaymentsFromInvoiceRequest

Deprecated
*/
func (a *AccountsReceivablesApiService) DeletePaymentsFromInvoice(ctx context.Context, transactionId string, invoiceId string, hotelId string) ApiDeletePaymentsFromInvoiceRequest {
	return ApiDeletePaymentsFromInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		invoiceId: invoiceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *AccountsReceivablesApiService) DeletePaymentsFromInvoiceExecute(r ApiDeletePaymentsFromInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.DeletePaymentsFromInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices/{invoiceId}/transactions/{transactionId}/paymentsFromInvoice"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.invoiceId) < 1 {
		return localVarReturnValue, nil, reportError("invoiceId must have at least 1 elements")
	}
	if strlen(r.invoiceId) > 2000 {
		return localVarReturnValue, nil, reportError("invoiceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.trxNo == nil {
		return localVarReturnValue, nil, reportError("trxNo is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.trxNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	if r.cashierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierID", r.cashierID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARAgingCyclesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARAgingCyclesRequest) Authorization(authorization string) ApiGetARAgingCyclesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARAgingCyclesRequest) XAppKey(xAppKey string) ApiGetARAgingCyclesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARAgingCyclesRequest) XHotelid(xHotelid string) ApiGetARAgingCyclesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetARAgingCyclesRequest) XExternalsystem(xExternalsystem string) ApiGetARAgingCyclesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARAgingCyclesRequest) AcceptLanguage(acceptLanguage string) ApiGetARAgingCyclesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARAgingCyclesRequest) Execute() (*ArAgingCycles, *http.Response, error) {
	return r.ApiService.GetARAgingCyclesExecute(r)
}

/*
GetARAgingCycles Get given AR account's aging detail

Use this API to get account receivable profile's aging summary including account name, summary, credit limit, total outstanding balance, etc. per aging bucket. <p><strong>OperationId:</strong>getARAgingCycles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetARAgingCyclesRequest
*/
func (a *AccountsReceivablesApiService) GetARAgingCycles(ctx context.Context, hotelId string) ApiGetARAgingCyclesRequest {
	return ApiGetARAgingCyclesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArAgingCycles
func (a *AccountsReceivablesApiService) GetARAgingCyclesExecute(r ApiGetARAgingCyclesRequest) (*ArAgingCycles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArAgingCycles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetARAgingCycles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/agingCycles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARCreditCardPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	endDate *string
	startDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARCreditCardPaymentsRequest) Authorization(authorization string) ApiGetARCreditCardPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARCreditCardPaymentsRequest) XAppKey(xAppKey string) ApiGetARCreditCardPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARCreditCardPaymentsRequest) XHotelid(xHotelid string) ApiGetARCreditCardPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r ApiGetARCreditCardPaymentsRequest) EndDate(endDate string) ApiGetARCreditCardPaymentsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r ApiGetARCreditCardPaymentsRequest) StartDate(startDate string) ApiGetARCreditCardPaymentsRequest {
	r.startDate = &startDate
	return r
}

// External system code.
func (r ApiGetARCreditCardPaymentsRequest) XExternalsystem(xExternalsystem string) ApiGetARCreditCardPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARCreditCardPaymentsRequest) AcceptLanguage(acceptLanguage string) ApiGetARCreditCardPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARCreditCardPaymentsRequest) Execute() (*ArCreditCardPayments, *http.Response, error) {
	return r.ApiService.GetARCreditCardPaymentsExecute(r)
}

/*
GetARCreditCardPayments Get account receivable folios which are paid using credit cards

Use this API to get lists of folios for guests who checked out using a credit card payment transaction code that has an account receivable associated with it. It also lists payments made prior to check out if the payment was made using a credit card transaction code that has a an account receivable associated with it. <p><strong>OperationId:</strong>getARCreditCardPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiGetARCreditCardPaymentsRequest
*/
func (a *AccountsReceivablesApiService) GetARCreditCardPayments(ctx context.Context, transactionId string, hotelId string) ApiGetARCreditCardPaymentsRequest {
	return ApiGetARCreditCardPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArCreditCardPayments
func (a *AccountsReceivablesApiService) GetARCreditCardPaymentsExecute(r ApiGetARCreditCardPaymentsRequest) (*ArCreditCardPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArCreditCardPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetARCreditCardPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/creditcard/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARFolioPrintersRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	balance *float32
	overrideCreditHoldCheck *bool
	cashierId *float32
	profileId *string
	accountNo *string
	accountName *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	folioWindowNo *[]int32
	chargeCashierId *[]float32
	chargeTransactionCode *[]string
	articleCode *[]string
	amount *float32
	currencyCode *string
	postingQuantity *[]int32
	postingReference *[]string
	postingRemark *[]string
	checkNumber *[]string
	arrangementCode *[]string
	applyRoutingInstructions *[]bool
	usePackageAllowance *[]bool
	autoPosting *[]bool
	financialTransactionId *[]string
	financialTransactionIdContext *[]string
	financialTransactionType *[]string
	reference *string
	remark *string
	folioType *string
	generateFiscalFolio *bool
	queueName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARFolioPrintersRequest) Authorization(authorization string) ApiGetARFolioPrintersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARFolioPrintersRequest) XAppKey(xAppKey string) ApiGetARFolioPrintersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARFolioPrintersRequest) XHotelid(xHotelid string) ApiGetARFolioPrintersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetARFolioPrintersRequest) Balance(balance float32) ApiGetARFolioPrintersRequest {
	r.balance = &balance
	return r
}

func (r ApiGetARFolioPrintersRequest) OverrideCreditHoldCheck(overrideCreditHoldCheck bool) ApiGetARFolioPrintersRequest {
	r.overrideCreditHoldCheck = &overrideCreditHoldCheck
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetARFolioPrintersRequest) CashierId(cashierId float32) ApiGetARFolioPrintersRequest {
	r.cashierId = &cashierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARFolioPrintersRequest) ProfileId(profileId string) ApiGetARFolioPrintersRequest {
	r.profileId = &profileId
	return r
}

// Account Number for the AR Account.
func (r ApiGetARFolioPrintersRequest) AccountNo(accountNo string) ApiGetARFolioPrintersRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetARFolioPrintersRequest) AccountName(accountName string) ApiGetARFolioPrintersRequest {
	r.accountName = &accountName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARFolioPrintersRequest) GuestProfileId(guestProfileId string) ApiGetARFolioPrintersRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARFolioPrintersRequest) GuestProfileIdContext(guestProfileIdContext string) ApiGetARFolioPrintersRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARFolioPrintersRequest) GuestProfileType(guestProfileType string) ApiGetARFolioPrintersRequest {
	r.guestProfileType = &guestProfileType
	return r
}

func (r ApiGetARFolioPrintersRequest) FolioWindowNo(folioWindowNo []int32) ApiGetARFolioPrintersRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetARFolioPrintersRequest) ChargeCashierId(chargeCashierId []float32) ApiGetARFolioPrintersRequest {
	r.chargeCashierId = &chargeCashierId
	return r
}

// Transaction Code to post.
func (r ApiGetARFolioPrintersRequest) ChargeTransactionCode(chargeTransactionCode []string) ApiGetARFolioPrintersRequest {
	r.chargeTransactionCode = &chargeTransactionCode
	return r
}

// Article ID.
func (r ApiGetARFolioPrintersRequest) ArticleCode(articleCode []string) ApiGetARFolioPrintersRequest {
	r.articleCode = &articleCode
	return r
}

// A monetary amount.
func (r ApiGetARFolioPrintersRequest) Amount(amount float32) ApiGetARFolioPrintersRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARFolioPrintersRequest) CurrencyCode(currencyCode string) ApiGetARFolioPrintersRequest {
	r.currencyCode = &currencyCode
	return r
}

// Quantity to post to the folio.
func (r ApiGetARFolioPrintersRequest) PostingQuantity(postingQuantity []int32) ApiGetARFolioPrintersRequest {
	r.postingQuantity = &postingQuantity
	return r
}

// User-defined posting reference.
func (r ApiGetARFolioPrintersRequest) PostingReference(postingReference []string) ApiGetARFolioPrintersRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r ApiGetARFolioPrintersRequest) PostingRemark(postingRemark []string) ApiGetARFolioPrintersRequest {
	r.postingRemark = &postingRemark
	return r
}

// Indicates the Cheque number.
func (r ApiGetARFolioPrintersRequest) CheckNumber(checkNumber []string) ApiGetARFolioPrintersRequest {
	r.checkNumber = &checkNumber
	return r
}

// Corrected arrangement code from the package associated to this transaction.
func (r ApiGetARFolioPrintersRequest) ArrangementCode(arrangementCode []string) ApiGetARFolioPrintersRequest {
	r.arrangementCode = &arrangementCode
	return r
}

// Apply room routing when making this posting.
func (r ApiGetARFolioPrintersRequest) ApplyRoutingInstructions(applyRoutingInstructions []bool) ApiGetARFolioPrintersRequest {
	r.applyRoutingInstructions = &applyRoutingInstructions
	return r
}

// Use the applicable package allowance when making this posting.
func (r ApiGetARFolioPrintersRequest) UsePackageAllowance(usePackageAllowance []bool) ApiGetARFolioPrintersRequest {
	r.usePackageAllowance = &usePackageAllowance
	return r
}

// True indicates the Transaction Code is allowed to be posted automatically.
func (r ApiGetARFolioPrintersRequest) AutoPosting(autoPosting []bool) ApiGetARFolioPrintersRequest {
	r.autoPosting = &autoPosting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARFolioPrintersRequest) FinancialTransactionId(financialTransactionId []string) ApiGetARFolioPrintersRequest {
	r.financialTransactionId = &financialTransactionId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARFolioPrintersRequest) FinancialTransactionIdContext(financialTransactionIdContext []string) ApiGetARFolioPrintersRequest {
	r.financialTransactionIdContext = &financialTransactionIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARFolioPrintersRequest) FinancialTransactionType(financialTransactionType []string) ApiGetARFolioPrintersRequest {
	r.financialTransactionType = &financialTransactionType
	return r
}

// User-defined invoice reference.
func (r ApiGetARFolioPrintersRequest) Reference(reference string) ApiGetARFolioPrintersRequest {
	r.reference = &reference
	return r
}

// User-defined invoice remark.
func (r ApiGetARFolioPrintersRequest) Remark(remark string) ApiGetARFolioPrintersRequest {
	r.remark = &remark
	return r
}

// Folio Type to be assigned to generated folio. This is a country requirement.
func (r ApiGetARFolioPrintersRequest) FolioType(folioType string) ApiGetARFolioPrintersRequest {
	r.folioType = &folioType
	return r
}

// Fiscal folio flag to call fiscal folio web service after folio generation.
func (r ApiGetARFolioPrintersRequest) GenerateFiscalFolio(generateFiscalFolio bool) ApiGetARFolioPrintersRequest {
	r.generateFiscalFolio = &generateFiscalFolio
	return r
}

// Folio Queue name.
func (r ApiGetARFolioPrintersRequest) QueueName(queueName string) ApiGetARFolioPrintersRequest {
	r.queueName = &queueName
	return r
}

// External system code.
func (r ApiGetARFolioPrintersRequest) XExternalsystem(xExternalsystem string) ApiGetARFolioPrintersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARFolioPrintersRequest) AcceptLanguage(acceptLanguage string) ApiGetARFolioPrintersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARFolioPrintersRequest) Execute() (*ArFolioPrinters, *http.Response, error) {
	return r.ApiService.GetARFolioPrintersExecute(r)
}

/*
GetARFolioPrinters Get list of account receivable folio printers

Use this API to find account receivable folio printers <p><strong>OperationId:</strong>getARFolioPrinters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiGetARFolioPrintersRequest
*/
func (a *AccountsReceivablesApiService) GetARFolioPrinters(ctx context.Context, accountId string, hotelId string) ApiGetARFolioPrintersRequest {
	return ApiGetARFolioPrintersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArFolioPrinters
func (a *AccountsReceivablesApiService) GetARFolioPrintersExecute(r ApiGetARFolioPrintersRequest) (*ArFolioPrinters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArFolioPrinters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetARFolioPrinters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/folioPrinters"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
	}
	if r.overrideCreditHoldCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideCreditHoldCheck", r.overrideCreditHoldCheck, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
	}
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
	}
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
	}
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
	}
	if r.chargeCashierId != nil {
		t := *r.chargeCashierId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", t, "multi")
		}
	}
	if r.chargeTransactionCode != nil {
		t := *r.chargeTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chargeTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chargeTransactionCode", t, "multi")
		}
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.postingQuantity != nil {
		t := *r.postingQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", t, "multi")
		}
	}
	if r.postingReference != nil {
		t := *r.postingReference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", t, "multi")
		}
	}
	if r.postingRemark != nil {
		t := *r.postingRemark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", t, "multi")
		}
	}
	if r.checkNumber != nil {
		t := *r.checkNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", t, "multi")
		}
	}
	if r.arrangementCode != nil {
		t := *r.arrangementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", t, "multi")
		}
	}
	if r.applyRoutingInstructions != nil {
		t := *r.applyRoutingInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", t, "multi")
		}
	}
	if r.usePackageAllowance != nil {
		t := *r.usePackageAllowance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", t, "multi")
		}
	}
	if r.autoPosting != nil {
		t := *r.autoPosting
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", t, "multi")
		}
	}
	if r.financialTransactionId != nil {
		t := *r.financialTransactionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionId", t, "multi")
		}
	}
	if r.financialTransactionIdContext != nil {
		t := *r.financialTransactionIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionIdContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionIdContext", t, "multi")
		}
	}
	if r.financialTransactionType != nil {
		t := *r.financialTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionType", t, "multi")
		}
	}
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
	}
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	if r.generateFiscalFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateFiscalFolio", r.generateFiscalFolio, "")
	}
	if r.queueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", r.queueName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARStatementsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	profileId *[]string
	profileIdContext *string
	profileType *string
	accountID *[]string
	accountNo *[]string
	accountName *[]string
	canBeModified *[]bool
	closeDate *[]string
	fiscalBillNo *[]string
	folioDate *[]string
	folioNo *[]float32
	folioStatus *[]string
	folioTypeName *[]string
	internalFolioWindowID *[]string
	invoiceNo *[]float32
	invoiceType *[]string
	postingDate *[]string
	revenueDate *[]string
	statementNo *[]int32
	status *[]string
	transferDate *[]string
	invoiceTransactionCode *[]string
	transactionDate *[]string
	transactionNo *[]float32
	invoiceHotelIds *[]string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	age *[]int32
	guestName *[]string
	originalAmount *float32
	originalAmountCurrencyCode *string
	amount *float32
	currencyCode *string
	paymentsAmount *float32
	paymentsCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	reference *[]string
	remark *[]string
	adjusted *[]bool
	parentInvoiceNo *[]float32
	compressed *[]bool
	compressedDate *[]string
	transferredOut *[]bool
	transferredIn *[]bool
	marketDescription *string
	marketHotelId *string
	marketCode *string
	marketGroup *string
	roomClassDescription *string
	roomClassHotelId *string
	roomClassCode *string
	sourceDescription *string
	sourceHotelId *string
	sourceCode *string
	sourceGroup *string
	cashierId *float32
	cashierName *string
	transactionHotelId *string
	printTrxReceipt *bool
	accountInvoiceTransactionCode *string
	transactionDescription *string
	transactionGroup *string
	transactionSubGroup *string
	universalProductCode *string
	routingInstructionsId *float32
	articleCode *[]string
	articleHotelIds *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	transactionCode *[]string
	articleAmount *float32
	articleCurrencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	invoicePaymentCardId *string
	invoicePaymentCardIdContext *string
	invoicePaymentCardIdType *string
	currentAuthorizedAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmount *float32
	approvalAmountCurrencyCode *string
	type_ *string
	addresseeProfileId *string
	addresseeProfileIdContext *string
	addresseeProfileType *string
	name *string
	city *string
	phone *string
	allowPartialTransferYn *[]bool
	printed *[]bool
	printedDate *[]string
	storedFolioId *string
	storedFolioIdContext *string
	storedFolioType *string
	storedFolioName *[]string
	storedDebitFolioId *string
	storedDebitFolioIdContext *string
	storedDebitFolioType *string
	storedDebitFolioName *[]string
	balanceForwardDate *string
	inclFolios *bool
	inclPrinted *bool
	inclZero *bool
	filterEndDate *string
	filterStartDate *string
	statementText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARStatementsRequest) Authorization(authorization string) ApiGetARStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARStatementsRequest) XAppKey(xAppKey string) ApiGetARStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARStatementsRequest) XHotelid(xHotelid string) ApiGetARStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) HotelId(hotelId []string) ApiGetARStatementsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) ProfileId(profileId []string) ApiGetARStatementsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) ProfileIdContext(profileIdContext string) ApiGetARStatementsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) ProfileType(profileType string) ApiGetARStatementsRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) AccountID(accountID []string) ApiGetARStatementsRequest {
	r.accountID = &accountID
	return r
}

// Account Number for the AR Account.
func (r ApiGetARStatementsRequest) AccountNo(accountNo []string) ApiGetARStatementsRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetARStatementsRequest) AccountName(accountName []string) ApiGetARStatementsRequest {
	r.accountName = &accountName
	return r
}

// Flag to indicate if postings or adjustments can be made to the invoice.
func (r ApiGetARStatementsRequest) CanBeModified(canBeModified []bool) ApiGetARStatementsRequest {
	r.canBeModified = &canBeModified
	return r
}

// Close date of the invoice.
func (r ApiGetARStatementsRequest) CloseDate(closeDate []string) ApiGetARStatementsRequest {
	r.closeDate = &closeDate
	return r
}

// The Fiscal Bill number of this posting
func (r ApiGetARStatementsRequest) FiscalBillNo(fiscalBillNo []string) ApiGetARStatementsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiGetARStatementsRequest) FolioDate(folioDate []string) ApiGetARStatementsRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r ApiGetARStatementsRequest) FolioNo(folioNo []float32) ApiGetARStatementsRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiGetARStatementsRequest) FolioStatus(folioStatus []string) ApiGetARStatementsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiGetARStatementsRequest) FolioTypeName(folioTypeName []string) ApiGetARStatementsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetARStatementsRequest) InternalFolioWindowID(internalFolioWindowID []string) ApiGetARStatementsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetARStatementsRequest) InvoiceNo(invoiceNo []float32) ApiGetARStatementsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

func (r ApiGetARStatementsRequest) InvoiceType(invoiceType []string) ApiGetARStatementsRequest {
	r.invoiceType = &invoiceType
	return r
}

// Posting date of the invoice.
func (r ApiGetARStatementsRequest) PostingDate(postingDate []string) ApiGetARStatementsRequest {
	r.postingDate = &postingDate
	return r
}

// Revenue date ID of the invoice.
func (r ApiGetARStatementsRequest) RevenueDate(revenueDate []string) ApiGetARStatementsRequest {
	r.revenueDate = &revenueDate
	return r
}

// Statementno of the invoice.
func (r ApiGetARStatementsRequest) StatementNo(statementNo []int32) ApiGetARStatementsRequest {
	r.statementNo = &statementNo
	return r
}

// Status of the invoice.
func (r ApiGetARStatementsRequest) Status(status []string) ApiGetARStatementsRequest {
	r.status = &status
	return r
}

// Transfer date of the invoice.
func (r ApiGetARStatementsRequest) TransferDate(transferDate []string) ApiGetARStatementsRequest {
	r.transferDate = &transferDate
	return r
}

// Transaction code of the invoice.
func (r ApiGetARStatementsRequest) InvoiceTransactionCode(invoiceTransactionCode []string) ApiGetARStatementsRequest {
	r.invoiceTransactionCode = &invoiceTransactionCode
	return r
}

// Transaction Date of the invoice.
func (r ApiGetARStatementsRequest) TransactionDate(transactionDate []string) ApiGetARStatementsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Unique Transaction Identifier of the Invoice.
func (r ApiGetARStatementsRequest) TransactionNo(transactionNo []float32) ApiGetARStatementsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) InvoiceHotelIds(invoiceHotelIds []string) ApiGetARStatementsRequest {
	r.invoiceHotelIds = &invoiceHotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) ReservationId(reservationId string) ApiGetARStatementsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) ReservationIdContext(reservationIdContext string) ApiGetARStatementsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) ReservationType(reservationType string) ApiGetARStatementsRequest {
	r.reservationType = &reservationType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) GuestProfileId(guestProfileId string) ApiGetARStatementsRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) GuestProfileIdContext(guestProfileIdContext string) ApiGetARStatementsRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) GuestProfileType(guestProfileType string) ApiGetARStatementsRequest {
	r.guestProfileType = &guestProfileType
	return r
}

// The Aging age of the invoice
func (r ApiGetARStatementsRequest) Age(age []int32) ApiGetARStatementsRequest {
	r.age = &age
	return r
}

// Name of the Guest who consumed these transactions.
func (r ApiGetARStatementsRequest) GuestName(guestName []string) ApiGetARStatementsRequest {
	r.guestName = &guestName
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) OriginalAmount(originalAmount float32) ApiGetARStatementsRequest {
	r.originalAmount = &originalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) OriginalAmountCurrencyCode(originalAmountCurrencyCode string) ApiGetARStatementsRequest {
	r.originalAmountCurrencyCode = &originalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) Amount(amount float32) ApiGetARStatementsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) CurrencyCode(currencyCode string) ApiGetARStatementsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) PaymentsAmount(paymentsAmount float32) ApiGetARStatementsRequest {
	r.paymentsAmount = &paymentsAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) PaymentsCurrencyCode(paymentsCurrencyCode string) ApiGetARStatementsRequest {
	r.paymentsCurrencyCode = &paymentsCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) BalanceAmount(balanceAmount float32) ApiGetARStatementsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetARStatementsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// User-defined posting reference.
func (r ApiGetARStatementsRequest) Reference(reference []string) ApiGetARStatementsRequest {
	r.reference = &reference
	return r
}

// User-defined posting remark.
func (r ApiGetARStatementsRequest) Remark(remark []string) ApiGetARStatementsRequest {
	r.remark = &remark
	return r
}

func (r ApiGetARStatementsRequest) Adjusted(adjusted []bool) ApiGetARStatementsRequest {
	r.adjusted = &adjusted
	return r
}

func (r ApiGetARStatementsRequest) ParentInvoiceNo(parentInvoiceNo []float32) ApiGetARStatementsRequest {
	r.parentInvoiceNo = &parentInvoiceNo
	return r
}

func (r ApiGetARStatementsRequest) Compressed(compressed []bool) ApiGetARStatementsRequest {
	r.compressed = &compressed
	return r
}

func (r ApiGetARStatementsRequest) CompressedDate(compressedDate []string) ApiGetARStatementsRequest {
	r.compressedDate = &compressedDate
	return r
}

func (r ApiGetARStatementsRequest) TransferredOut(transferredOut []bool) ApiGetARStatementsRequest {
	r.transferredOut = &transferredOut
	return r
}

func (r ApiGetARStatementsRequest) TransferredIn(transferredIn []bool) ApiGetARStatementsRequest {
	r.transferredIn = &transferredIn
	return r
}

func (r ApiGetARStatementsRequest) MarketDescription(marketDescription string) ApiGetARStatementsRequest {
	r.marketDescription = &marketDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) MarketHotelId(marketHotelId string) ApiGetARStatementsRequest {
	r.marketHotelId = &marketHotelId
	return r
}

func (r ApiGetARStatementsRequest) MarketCode(marketCode string) ApiGetARStatementsRequest {
	r.marketCode = &marketCode
	return r
}

func (r ApiGetARStatementsRequest) MarketGroup(marketGroup string) ApiGetARStatementsRequest {
	r.marketGroup = &marketGroup
	return r
}

func (r ApiGetARStatementsRequest) RoomClassDescription(roomClassDescription string) ApiGetARStatementsRequest {
	r.roomClassDescription = &roomClassDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) RoomClassHotelId(roomClassHotelId string) ApiGetARStatementsRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r ApiGetARStatementsRequest) RoomClassCode(roomClassCode string) ApiGetARStatementsRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r ApiGetARStatementsRequest) SourceDescription(sourceDescription string) ApiGetARStatementsRequest {
	r.sourceDescription = &sourceDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) SourceHotelId(sourceHotelId string) ApiGetARStatementsRequest {
	r.sourceHotelId = &sourceHotelId
	return r
}

func (r ApiGetARStatementsRequest) SourceCode(sourceCode string) ApiGetARStatementsRequest {
	r.sourceCode = &sourceCode
	return r
}

func (r ApiGetARStatementsRequest) SourceGroup(sourceGroup string) ApiGetARStatementsRequest {
	r.sourceGroup = &sourceGroup
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetARStatementsRequest) CashierId(cashierId float32) ApiGetARStatementsRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier Name.
func (r ApiGetARStatementsRequest) CashierName(cashierName string) ApiGetARStatementsRequest {
	r.cashierName = &cashierName
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) TransactionHotelId(transactionHotelId string) ApiGetARStatementsRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r ApiGetARStatementsRequest) PrintTrxReceipt(printTrxReceipt bool) ApiGetARStatementsRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r ApiGetARStatementsRequest) AccountInvoiceTransactionCode(accountInvoiceTransactionCode string) ApiGetARStatementsRequest {
	r.accountInvoiceTransactionCode = &accountInvoiceTransactionCode
	return r
}

// Transaction codes info.
func (r ApiGetARStatementsRequest) TransactionDescription(transactionDescription string) ApiGetARStatementsRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Category of the transaction code.
func (r ApiGetARStatementsRequest) TransactionGroup(transactionGroup string) ApiGetARStatementsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r ApiGetARStatementsRequest) TransactionSubGroup(transactionSubGroup string) ApiGetARStatementsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r ApiGetARStatementsRequest) UniversalProductCode(universalProductCode string) ApiGetARStatementsRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiGetARStatementsRequest) RoutingInstructionsId(routingInstructionsId float32) ApiGetARStatementsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r ApiGetARStatementsRequest) ArticleCode(articleCode []string) ApiGetARStatementsRequest {
	r.articleCode = &articleCode
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetARStatementsRequest) ArticleHotelIds(articleHotelIds []string) ApiGetARStatementsRequest {
	r.articleHotelIds = &articleHotelIds
	return r
}

// Indicates whether the article is inactive or not.
func (r ApiGetARStatementsRequest) Inactive(inactive []bool) ApiGetARStatementsRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r ApiGetARStatementsRequest) OrderSequence(orderSequence []float32) ApiGetARStatementsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r ApiGetARStatementsRequest) ArticleDescription(articleDescription []string) ApiGetARStatementsRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r ApiGetARStatementsRequest) TransactionCode(transactionCode []string) ApiGetARStatementsRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) ArticleAmount(articleAmount float32) ApiGetARStatementsRequest {
	r.articleAmount = &articleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) ArticleCurrencyCode(articleCurrencyCode string) ApiGetARStatementsRequest {
	r.articleCurrencyCode = &articleCurrencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r ApiGetARStatementsRequest) AvailableForPostIt(availableForPostIt bool) ApiGetARStatementsRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r ApiGetARStatementsRequest) Color(color string) ApiGetARStatementsRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r ApiGetARStatementsRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) ApiGetARStatementsRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Attach the credit card to profile.
func (r ApiGetARStatementsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetARStatementsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetARStatementsRequest) CardHolderName(cardHolderName string) ApiGetARStatementsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetARStatementsRequest) CardNumber(cardNumber string) ApiGetARStatementsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetARStatementsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetARStatementsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetARStatementsRequest) CardNumberMasked(cardNumberMasked string) ApiGetARStatementsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetARStatementsRequest) CardOrToken(cardOrToken string) ApiGetARStatementsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetARStatementsRequest) CardType(cardType string) ApiGetARStatementsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetARStatementsRequest) ExpirationDate(expirationDate string) ApiGetARStatementsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetARStatementsRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetARStatementsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetARStatementsRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetARStatementsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetARStatementsRequest) Processing(processing string) ApiGetARStatementsRequest {
	r.processing = &processing
	return r
}

func (r ApiGetARStatementsRequest) Swiped(swiped bool) ApiGetARStatementsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetARStatementsRequest) UserDefinedCardType(userDefinedCardType string) ApiGetARStatementsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) InvoicePaymentCardId(invoicePaymentCardId string) ApiGetARStatementsRequest {
	r.invoicePaymentCardId = &invoicePaymentCardId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) InvoicePaymentCardIdContext(invoicePaymentCardIdContext string) ApiGetARStatementsRequest {
	r.invoicePaymentCardIdContext = &invoicePaymentCardIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) InvoicePaymentCardIdType(invoicePaymentCardIdType string) ApiGetARStatementsRequest {
	r.invoicePaymentCardIdType = &invoicePaymentCardIdType
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) ApiGetARStatementsRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) ApiGetARStatementsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetARStatementsRequest) ApprovalAmount(approvalAmount float32) ApiGetARStatementsRequest {
	r.approvalAmount = &approvalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARStatementsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetARStatementsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Defines the type of Linked profiles for a block.
func (r ApiGetARStatementsRequest) Type_(type_ string) ApiGetARStatementsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) AddresseeProfileId(addresseeProfileId string) ApiGetARStatementsRequest {
	r.addresseeProfileId = &addresseeProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) AddresseeProfileIdContext(addresseeProfileIdContext string) ApiGetARStatementsRequest {
	r.addresseeProfileIdContext = &addresseeProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) AddresseeProfileType(addresseeProfileType string) ApiGetARStatementsRequest {
	r.addresseeProfileType = &addresseeProfileType
	return r
}

// Name for the profile attached to the block.
func (r ApiGetARStatementsRequest) Name(name string) ApiGetARStatementsRequest {
	r.name = &name
	return r
}

// City for the profile attached to the block.
func (r ApiGetARStatementsRequest) City(city string) ApiGetARStatementsRequest {
	r.city = &city
	return r
}

// Phone for the profile attached to the block.
func (r ApiGetARStatementsRequest) Phone(phone string) ApiGetARStatementsRequest {
	r.phone = &phone
	return r
}

// Flag to check Partail Transfer Allowed.
func (r ApiGetARStatementsRequest) AllowPartialTransferYn(allowPartialTransferYn []bool) ApiGetARStatementsRequest {
	r.allowPartialTransferYn = &allowPartialTransferYn
	return r
}

// Flag to check Invoice Statement is Printed.
func (r ApiGetARStatementsRequest) Printed(printed []bool) ApiGetARStatementsRequest {
	r.printed = &printed
	return r
}

// Invoice Statement Printed Date.
func (r ApiGetARStatementsRequest) PrintedDate(printedDate []string) ApiGetARStatementsRequest {
	r.printedDate = &printedDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) StoredFolioId(storedFolioId string) ApiGetARStatementsRequest {
	r.storedFolioId = &storedFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) StoredFolioIdContext(storedFolioIdContext string) ApiGetARStatementsRequest {
	r.storedFolioIdContext = &storedFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) StoredFolioType(storedFolioType string) ApiGetARStatementsRequest {
	r.storedFolioType = &storedFolioType
	return r
}

// Name of the Stored Folio.
func (r ApiGetARStatementsRequest) StoredFolioName(storedFolioName []string) ApiGetARStatementsRequest {
	r.storedFolioName = &storedFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetARStatementsRequest) StoredDebitFolioId(storedDebitFolioId string) ApiGetARStatementsRequest {
	r.storedDebitFolioId = &storedDebitFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetARStatementsRequest) StoredDebitFolioIdContext(storedDebitFolioIdContext string) ApiGetARStatementsRequest {
	r.storedDebitFolioIdContext = &storedDebitFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetARStatementsRequest) StoredDebitFolioType(storedDebitFolioType string) ApiGetARStatementsRequest {
	r.storedDebitFolioType = &storedDebitFolioType
	return r
}

// Name of the Stored Debit Folio.
func (r ApiGetARStatementsRequest) StoredDebitFolioName(storedDebitFolioName []string) ApiGetARStatementsRequest {
	r.storedDebitFolioName = &storedDebitFolioName
	return r
}

// The date specified in this field determines the balance forward date and balance forward total that is printed on the statement. (A balance forward shows the net amount for all invoices and payments (debits and credits) prior to the balance forward date as a single total, rather than itemizing them individually on the statement.)
func (r ApiGetARStatementsRequest) BalanceForwardDate(balanceForwardDate string) ApiGetARStatementsRequest {
	r.balanceForwardDate = &balanceForwardDate
	return r
}

// Flag to indicate if the associated Folios for the Invoices are to be included along with the the Statement.
func (r ApiGetARStatementsRequest) InclFolios(inclFolios bool) ApiGetARStatementsRequest {
	r.inclFolios = &inclFolios
	return r
}

// Flag to indicate if Previousely Printed Invoices are to be included in the Statement. This is based on the Functionality for AR PRINTED INVOICES.
func (r ApiGetARStatementsRequest) InclPrinted(inclPrinted bool) ApiGetARStatementsRequest {
	r.inclPrinted = &inclPrinted
	return r
}

// Flag to indicate if Zero Balances Invoices are to be included in the Statement.
func (r ApiGetARStatementsRequest) InclZero(inclZero bool) ApiGetARStatementsRequest {
	r.inclZero = &inclZero
	return r
}

// The ending value of the date range.
func (r ApiGetARStatementsRequest) FilterEndDate(filterEndDate string) ApiGetARStatementsRequest {
	r.filterEndDate = &filterEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetARStatementsRequest) FilterStartDate(filterStartDate string) ApiGetARStatementsRequest {
	r.filterStartDate = &filterStartDate
	return r
}

// Text which will be printed on the Invoice.
func (r ApiGetARStatementsRequest) StatementText(statementText string) ApiGetARStatementsRequest {
	r.statementText = &statementText
	return r
}

// External system code.
func (r ApiGetARStatementsRequest) XExternalsystem(xExternalsystem string) ApiGetARStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARStatementsRequest) AcceptLanguage(acceptLanguage string) ApiGetARStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARStatementsRequest) Execute() (*Statements, *http.Response, error) {
	return r.ApiService.GetARStatementsExecute(r)
}

/*
GetARStatements Get given profile's account receivable statements

Use this API to prepare statement for an AR account holders. It is typically prepared for billing purposes. <p><strong>OperationId:</strong>getARStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetARStatementsRequest
*/
func (a *AccountsReceivablesApiService) GetARStatements(ctx context.Context) ApiGetARStatementsRequest {
	return ApiGetARStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Statements
func (a *AccountsReceivablesApiService) GetARStatementsExecute(r ApiGetARStatementsRequest) (*Statements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Statements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetARStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.profileId != nil {
		t := *r.profileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", t, "multi")
		}
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.accountID != nil {
		t := *r.accountID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountID", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountID", t, "multi")
		}
	}
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
	}
	if r.accountName != nil {
		t := *r.accountName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", t, "multi")
		}
	}
	if r.canBeModified != nil {
		t := *r.canBeModified
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", t, "multi")
		}
	}
	if r.closeDate != nil {
		t := *r.closeDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", t, "multi")
		}
	}
	if r.fiscalBillNo != nil {
		t := *r.fiscalBillNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", t, "multi")
		}
	}
	if r.folioDate != nil {
		t := *r.folioDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", t, "multi")
		}
	}
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
	}
	if r.folioStatus != nil {
		t := *r.folioStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", t, "multi")
		}
	}
	if r.folioTypeName != nil {
		t := *r.folioTypeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", t, "multi")
		}
	}
	if r.internalFolioWindowID != nil {
		t := *r.internalFolioWindowID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", t, "multi")
		}
	}
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
	}
	if r.invoiceType != nil {
		t := *r.invoiceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", t, "multi")
		}
	}
	if r.postingDate != nil {
		t := *r.postingDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", t, "multi")
		}
	}
	if r.revenueDate != nil {
		t := *r.revenueDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", t, "multi")
		}
	}
	if r.statementNo != nil {
		t := *r.statementNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.transferDate != nil {
		t := *r.transferDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", t, "multi")
		}
	}
	if r.invoiceTransactionCode != nil {
		t := *r.invoiceTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", t, "multi")
		}
	}
	if r.transactionDate != nil {
		t := *r.transactionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", t, "multi")
		}
	}
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
	}
	if r.invoiceHotelIds != nil {
		t := *r.invoiceHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", t, "multi")
		}
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
	}
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
	}
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
	}
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
	}
	if r.age != nil {
		t := *r.age
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "age", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "age", t, "multi")
		}
	}
	if r.guestName != nil {
		t := *r.guestName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", t, "multi")
		}
	}
	if r.originalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmount", r.originalAmount, "")
	}
	if r.originalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmountCurrencyCode", r.originalAmountCurrencyCode, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.paymentsAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsAmount", r.paymentsAmount, "")
	}
	if r.paymentsCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsCurrencyCode", r.paymentsCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.reference != nil {
		t := *r.reference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reference", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reference", t, "multi")
		}
	}
	if r.remark != nil {
		t := *r.remark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remark", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remark", t, "multi")
		}
	}
	if r.adjusted != nil {
		t := *r.adjusted
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", t, "multi")
		}
	}
	if r.parentInvoiceNo != nil {
		t := *r.parentInvoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", t, "multi")
		}
	}
	if r.compressed != nil {
		t := *r.compressed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", t, "multi")
		}
	}
	if r.compressedDate != nil {
		t := *r.compressedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", t, "multi")
		}
	}
	if r.transferredOut != nil {
		t := *r.transferredOut
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", t, "multi")
		}
	}
	if r.transferredIn != nil {
		t := *r.transferredIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", t, "multi")
		}
	}
	if r.marketDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketDescription", r.marketDescription, "")
	}
	if r.marketHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketHotelId", r.marketHotelId, "")
	}
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
	}
	if r.marketGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroup", r.marketGroup, "")
	}
	if r.roomClassDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassDescription", r.roomClassDescription, "")
	}
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
	}
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
	}
	if r.sourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceDescription", r.sourceDescription, "")
	}
	if r.sourceHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceHotelId", r.sourceHotelId, "")
	}
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
	}
	if r.sourceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceGroup", r.sourceGroup, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.cashierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierName", r.cashierName, "")
	}
	if r.transactionHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", r.transactionHotelId, "")
	}
	if r.printTrxReceipt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", r.printTrxReceipt, "")
	}
	if r.accountInvoiceTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountInvoiceTransactionCode", r.accountInvoiceTransactionCode, "")
	}
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
	}
	if r.transactionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", r.transactionGroup, "")
	}
	if r.transactionSubGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", r.transactionSubGroup, "")
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	if r.routingInstructionsId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", r.routingInstructionsId, "")
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.articleHotelIds != nil {
		t := *r.articleHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.articleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleAmount", r.articleAmount, "")
	}
	if r.articleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleCurrencyCode", r.articleCurrencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.invoicePaymentCardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardId", r.invoicePaymentCardId, "")
	}
	if r.invoicePaymentCardIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdContext", r.invoicePaymentCardIdContext, "")
	}
	if r.invoicePaymentCardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdType", r.invoicePaymentCardIdType, "")
	}
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
	}
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
	}
	if r.approvalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmount", r.approvalAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.addresseeProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileId", r.addresseeProfileId, "")
	}
	if r.addresseeProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileIdContext", r.addresseeProfileIdContext, "")
	}
	if r.addresseeProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileType", r.addresseeProfileType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
	}
	if r.allowPartialTransferYn != nil {
		t := *r.allowPartialTransferYn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", t, "multi")
		}
	}
	if r.printed != nil {
		t := *r.printed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printed", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printed", t, "multi")
		}
	}
	if r.printedDate != nil {
		t := *r.printedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", t, "multi")
		}
	}
	if r.storedFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioId", r.storedFolioId, "")
	}
	if r.storedFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioIdContext", r.storedFolioIdContext, "")
	}
	if r.storedFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioType", r.storedFolioType, "")
	}
	if r.storedFolioName != nil {
		t := *r.storedFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", t, "multi")
		}
	}
	if r.storedDebitFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioId", r.storedDebitFolioId, "")
	}
	if r.storedDebitFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioIdContext", r.storedDebitFolioIdContext, "")
	}
	if r.storedDebitFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioType", r.storedDebitFolioType, "")
	}
	if r.storedDebitFolioName != nil {
		t := *r.storedDebitFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", t, "multi")
		}
	}
	if r.balanceForwardDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceForwardDate", r.balanceForwardDate, "")
	}
	if r.inclFolios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclFolios", r.inclFolios, "")
	}
	if r.inclPrinted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclPrinted", r.inclPrinted, "")
	}
	if r.inclZero != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZero", r.inclZero, "")
	}
	if r.filterEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndDate", r.filterEndDate, "")
	}
	if r.filterStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartDate", r.filterStartDate, "")
	}
	if r.statementText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementText", r.statementText, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	accounts *string
	endDate *string
	startDate *string
	fromAmount *float32
	fromCurrencyCode *string
	toAmount *float32
	toCurrencyCode *string
	guestName *string
	invoices *[]float32
	folios *[]string
	fiscalBillNo *string
	accountName *string
	addresseName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property where the Accounts exist.
func (r ApiGetARTransactionsRequest) HotelIds(hotelIds []string) ApiGetARTransactionsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARTransactionsRequest) Authorization(authorization string) ApiGetARTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARTransactionsRequest) XAppKey(xAppKey string) ApiGetARTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARTransactionsRequest) XHotelid(xHotelid string) ApiGetARTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account number of this transaction.
func (r ApiGetARTransactionsRequest) Accounts(accounts string) ApiGetARTransactionsRequest {
	r.accounts = &accounts
	return r
}

// The ending value of the date range.
func (r ApiGetARTransactionsRequest) EndDate(endDate string) ApiGetARTransactionsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r ApiGetARTransactionsRequest) StartDate(startDate string) ApiGetARTransactionsRequest {
	r.startDate = &startDate
	return r
}

// A monetary amount.
func (r ApiGetARTransactionsRequest) FromAmount(fromAmount float32) ApiGetARTransactionsRequest {
	r.fromAmount = &fromAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARTransactionsRequest) FromCurrencyCode(fromCurrencyCode string) ApiGetARTransactionsRequest {
	r.fromCurrencyCode = &fromCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetARTransactionsRequest) ToAmount(toAmount float32) ApiGetARTransactionsRequest {
	r.toAmount = &toAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetARTransactionsRequest) ToCurrencyCode(toCurrencyCode string) ApiGetARTransactionsRequest {
	r.toCurrencyCode = &toCurrencyCode
	return r
}

// Display Name for the guest.
func (r ApiGetARTransactionsRequest) GuestName(guestName string) ApiGetARTransactionsRequest {
	r.guestName = &guestName
	return r
}

// invoice Number .
func (r ApiGetARTransactionsRequest) Invoices(invoices []float32) ApiGetARTransactionsRequest {
	r.invoices = &invoices
	return r
}

// folio Number .
func (r ApiGetARTransactionsRequest) Folios(folios []string) ApiGetARTransactionsRequest {
	r.folios = &folios
	return r
}

// Fiscal bill number of this transaction.
func (r ApiGetARTransactionsRequest) FiscalBillNo(fiscalBillNo string) ApiGetARTransactionsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Account number of this transaction.
func (r ApiGetARTransactionsRequest) AccountName(accountName string) ApiGetARTransactionsRequest {
	r.accountName = &accountName
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r ApiGetARTransactionsRequest) AddresseName(addresseName string) ApiGetARTransactionsRequest {
	r.addresseName = &addresseName
	return r
}

// External system code.
func (r ApiGetARTransactionsRequest) XExternalsystem(xExternalsystem string) ApiGetARTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARTransactionsRequest) AcceptLanguage(acceptLanguage string) ApiGetARTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARTransactionsRequest) Execute() (*ArTransactions, *http.Response, error) {
	return r.ApiService.GetARTransactionsExecute(r)
}

/*
GetARTransactions Get AR transactions.

Use this API to get list of transaction data for a given account receivable account number and list of hotels <p><strong>OperationId:</strong>getARTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetARTransactionsRequest
*/
func (a *AccountsReceivablesApiService) GetARTransactions(ctx context.Context) ApiGetARTransactionsRequest {
	return ApiGetARTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArTransactions
func (a *AccountsReceivablesApiService) GetARTransactionsExecute(r ApiGetARTransactionsRequest) (*ArTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetARTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/arTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.accounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", r.accounts, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.fromAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAmount", r.fromAmount, "")
	}
	if r.fromCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromCurrencyCode", r.fromCurrencyCode, "")
	}
	if r.toAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toAmount", r.toAmount, "")
	}
	if r.toCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toCurrencyCode", r.toCurrencyCode, "")
	}
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
	}
	if r.invoices != nil {
		t := *r.invoices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", t, "multi")
		}
	}
	if r.folios != nil {
		t := *r.folios
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folios", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folios", t, "multi")
		}
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.addresseName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseName", r.addresseName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountNo *string
	profileId *string
	profileIdContext *string
	profileType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAccountRequest) Authorization(authorization string) ApiGetAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAccountRequest) XAppKey(xAppKey string) ApiGetAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAccountRequest) XHotelid(xHotelid string) ApiGetAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account Number for the Account.
func (r ApiGetAccountRequest) AccountNo(accountNo string) ApiGetAccountRequest {
	r.accountNo = &accountNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetAccountRequest) ProfileId(profileId string) ApiGetAccountRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetAccountRequest) ProfileIdContext(profileIdContext string) ApiGetAccountRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetAccountRequest) ProfileType(profileType string) ApiGetAccountRequest {
	r.profileType = &profileType
	return r
}

// Instructions to fetch AR Account details.
func (r ApiGetAccountRequest) FetchInstructions(fetchInstructions []string) ApiGetAccountRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetAccountRequest) XExternalsystem(xExternalsystem string) ApiGetAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAccountRequest) AcceptLanguage(acceptLanguage string) ApiGetAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAccountRequest) Execute() (*Account, *http.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Get account

Use this API to search for account receivable type account's  detail for given account id. <p><strong>OperationId:</strong>getAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiGetAccountRequest
*/
func (a *AccountsReceivablesApiService) GetAccount(ctx context.Context, accountId string, hotelId string) ApiGetAccountRequest {
	return ApiGetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Account
func (a *AccountsReceivablesApiService) GetAccountExecute(r ApiGetAccountRequest) (*Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	balance *string
	batchStatement *bool
	limit *int32
	offset *int32
	hotelIds *[]string
	profileId *string
	profileIdContext *string
	profileType *string
	type_ *string
	accountNo *[]string
	accountName *string
	accountId *[]string
	accountIdContext *[]string
	accountType *[]string
	includeStatementHistoryIndicator *bool
	includeReminderHistoryIndicator *bool
	superSearch *string
	searchHotelIds *[]string
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAccountsRequest) Authorization(authorization string) ApiGetAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAccountsRequest) XAppKey(xAppKey string) ApiGetAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAccountsRequest) XHotelid(xHotelid string) ApiGetAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Search By Balance. Search will be done for &#39;All&#39;, &#39;Open Balance&#39; or &#39;Zero Balance&#39; Accounts.
func (r ApiGetAccountsRequest) Balance(balance string) ApiGetAccountsRequest {
	r.balance = &balance
	return r
}

// Search criteria for batch processing
func (r ApiGetAccountsRequest) BatchStatement(batchStatement bool) ApiGetAccountsRequest {
	r.batchStatement = &batchStatement
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetAccountsRequest) Limit(limit int32) ApiGetAccountsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetAccountsRequest) Offset(offset int32) ApiGetAccountsRequest {
	r.offset = &offset
	return r
}

// Property where the Accounts exist.
func (r ApiGetAccountsRequest) HotelIds(hotelIds []string) ApiGetAccountsRequest {
	r.hotelIds = &hotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetAccountsRequest) ProfileId(profileId string) ApiGetAccountsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetAccountsRequest) ProfileIdContext(profileIdContext string) ApiGetAccountsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetAccountsRequest) ProfileType(profileType string) ApiGetAccountsRequest {
	r.profileType = &profileType
	return r
}

// Search by Account Type.
func (r ApiGetAccountsRequest) Type_(type_ string) ApiGetAccountsRequest {
	r.type_ = &type_
	return r
}

// Account Number .
func (r ApiGetAccountsRequest) AccountNo(accountNo []string) ApiGetAccountsRequest {
	r.accountNo = &accountNo
	return r
}

// Wild Card Search by Account Name. Search will be done for any Accounts whose name starts with this value.
func (r ApiGetAccountsRequest) AccountName(accountName string) ApiGetAccountsRequest {
	r.accountName = &accountName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetAccountsRequest) AccountId(accountId []string) ApiGetAccountsRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetAccountsRequest) AccountIdContext(accountIdContext []string) ApiGetAccountsRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetAccountsRequest) AccountType(accountType []string) ApiGetAccountsRequest {
	r.accountType = &accountType
	return r
}

// Return statement history indicator in result. This flag included for performance reason to populate history flag only for Statements Mode.
func (r ApiGetAccountsRequest) IncludeStatementHistoryIndicator(includeStatementHistoryIndicator bool) ApiGetAccountsRequest {
	r.includeStatementHistoryIndicator = &includeStatementHistoryIndicator
	return r
}

// Return reminder history indicator in result. This flag included for performance reason to populate history flag only for Statements Mode.
func (r ApiGetAccountsRequest) IncludeReminderHistoryIndicator(includeReminderHistoryIndicator bool) ApiGetAccountsRequest {
	r.includeReminderHistoryIndicator = &includeReminderHistoryIndicator
	return r
}

// Free form text field for searching all reservation fields
func (r ApiGetAccountsRequest) SuperSearch(superSearch string) ApiGetAccountsRequest {
	r.superSearch = &superSearch
	return r
}

// Hotel code.
func (r ApiGetAccountsRequest) SearchHotelIds(searchHotelIds []string) ApiGetAccountsRequest {
	r.searchHotelIds = &searchHotelIds
	return r
}

func (r ApiGetAccountsRequest) AttributeName(attributeName []string) ApiGetAccountsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiGetAccountsRequest) OrderType(orderType []string) ApiGetAccountsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ApiGetAccountsRequest) XExternalsystem(xExternalsystem string) ApiGetAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAccountsRequest) AcceptLanguage(acceptLanguage string) ApiGetAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAccountsRequest) Execute() (*AccountsInfo, *http.Response, error) {
	return r.ApiService.GetAccountsExecute(r)
}

/*
GetAccounts Get given profile's account receivable detail

Use this API to search for AR Accounts for a given OPERA Profile id. API returns contain a list of AR Accounts and their AR information. <p><strong>OperationId:</strong>getAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountsRequest
*/
func (a *AccountsReceivablesApiService) GetAccounts(ctx context.Context) ApiGetAccountsRequest {
	return ApiGetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountsInfo
func (a *AccountsReceivablesApiService) GetAccountsExecute(r ApiGetAccountsRequest) (*AccountsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
	}
	if r.batchStatement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchStatement", r.batchStatement, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.accountId != nil {
		t := *r.accountId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", t, "multi")
		}
	}
	if r.accountIdContext != nil {
		t := *r.accountIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", t, "multi")
		}
	}
	if r.accountType != nil {
		t := *r.accountType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", t, "multi")
		}
	}
	if r.includeStatementHistoryIndicator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStatementHistoryIndicator", r.includeStatementHistoryIndicator, "")
	}
	if r.includeReminderHistoryIndicator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReminderHistoryIndicator", r.includeReminderHistoryIndicator, "")
	}
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
	}
	if r.searchHotelIds != nil {
		t := *r.searchHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchHotelIds", t, "multi")
		}
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppliedInvoicePaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAppliedInvoicePaymentsRequest) Authorization(authorization string) ApiGetAppliedInvoicePaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAppliedInvoicePaymentsRequest) XAppKey(xAppKey string) ApiGetAppliedInvoicePaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAppliedInvoicePaymentsRequest) XHotelid(xHotelid string) ApiGetAppliedInvoicePaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetAppliedInvoicePaymentsRequest) InvoiceNo(invoiceNo float32) ApiGetAppliedInvoicePaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiGetAppliedInvoicePaymentsRequest) XExternalsystem(xExternalsystem string) ApiGetAppliedInvoicePaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAppliedInvoicePaymentsRequest) AcceptLanguage(acceptLanguage string) ApiGetAppliedInvoicePaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAppliedInvoicePaymentsRequest) Execute() (*InvoiceAppliedPayments, *http.Response, error) {
	return r.ApiService.GetAppliedInvoicePaymentsExecute(r)
}

/*
GetAppliedInvoicePayments Get account receivable invoice's payment history

Use this API to get applied payment details for AR invoices. <p><strong>OperationId:</strong>getAppliedInvoicePayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiGetAppliedInvoicePaymentsRequest
*/
func (a *AccountsReceivablesApiService) GetAppliedInvoicePayments(ctx context.Context, accountId string, transactionId string, hotelId string) ApiGetAppliedInvoicePaymentsRequest {
	return ApiGetAppliedInvoicePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoiceAppliedPayments
func (a *AccountsReceivablesApiService) GetAppliedInvoicePaymentsExecute(r ApiGetAppliedInvoicePaymentsRequest) (*InvoiceAppliedPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceAppliedPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetAppliedInvoicePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/accounts/{accountId}/invoiceAppliedPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceAppliedPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	transactionId string
	invoiceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvoiceAppliedPaymentsRequest) Authorization(authorization string) ApiGetInvoiceAppliedPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvoiceAppliedPaymentsRequest) XAppKey(xAppKey string) ApiGetInvoiceAppliedPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvoiceAppliedPaymentsRequest) XHotelid(xHotelid string) ApiGetInvoiceAppliedPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetInvoiceAppliedPaymentsRequest) InvoiceNo(invoiceNo float32) ApiGetInvoiceAppliedPaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiGetInvoiceAppliedPaymentsRequest) XExternalsystem(xExternalsystem string) ApiGetInvoiceAppliedPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvoiceAppliedPaymentsRequest) AcceptLanguage(acceptLanguage string) ApiGetInvoiceAppliedPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvoiceAppliedPaymentsRequest) Execute() (*InvoiceAppliedPayments, *http.Response, error) {
	return r.ApiService.GetInvoiceAppliedPaymentsExecute(r)
}

/*
GetInvoiceAppliedPayments Get account receivable invoice's payment history

Use this API to get applied payment details for AR invoices.<br><p><strong><mark>This API is deprecated. Please use getAppliedInvoicePayments instead</mark></strong></p> <p><strong>OperationId:</strong>getInvoiceAppliedPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param transactionId Unique ID of the transaction
 @param invoiceId Unique ID of the invoice
 @param hotelId Unique ID of the hotel
 @return ApiGetInvoiceAppliedPaymentsRequest

Deprecated
*/
func (a *AccountsReceivablesApiService) GetInvoiceAppliedPayments(ctx context.Context, accountId string, transactionId string, invoiceId string, hotelId string) ApiGetInvoiceAppliedPaymentsRequest {
	return ApiGetInvoiceAppliedPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		transactionId: transactionId,
		invoiceId: invoiceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoiceAppliedPayments
// Deprecated
func (a *AccountsReceivablesApiService) GetInvoiceAppliedPaymentsExecute(r ApiGetInvoiceAppliedPaymentsRequest) (*InvoiceAppliedPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceAppliedPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetInvoiceAppliedPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices/{invoiceId}/transactions/{transactionId}/accounts/{accountId}/invoiceAppliedPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.invoiceId) < 1 {
		return localVarReturnValue, nil, reportError("invoiceId must have at least 1 elements")
	}
	if strlen(r.invoiceId) > 2000 {
		return localVarReturnValue, nil, reportError("invoiceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoicePaymentDetailRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	transactionId string
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileId *string
	profileIdContext *string
	profileType *string
	accountNo *string
	accountName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvoicePaymentDetailRequest) Authorization(authorization string) ApiGetInvoicePaymentDetailRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvoicePaymentDetailRequest) XAppKey(xAppKey string) ApiGetInvoicePaymentDetailRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvoicePaymentDetailRequest) XHotelid(xHotelid string) ApiGetInvoicePaymentDetailRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePaymentDetailRequest) ProfileId(profileId string) ApiGetInvoicePaymentDetailRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePaymentDetailRequest) ProfileIdContext(profileIdContext string) ApiGetInvoicePaymentDetailRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePaymentDetailRequest) ProfileType(profileType string) ApiGetInvoicePaymentDetailRequest {
	r.profileType = &profileType
	return r
}

// Account Number for the AR Account.
func (r ApiGetInvoicePaymentDetailRequest) AccountNo(accountNo string) ApiGetInvoicePaymentDetailRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetInvoicePaymentDetailRequest) AccountName(accountName string) ApiGetInvoicePaymentDetailRequest {
	r.accountName = &accountName
	return r
}

// External system code.
func (r ApiGetInvoicePaymentDetailRequest) XExternalsystem(xExternalsystem string) ApiGetInvoicePaymentDetailRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvoicePaymentDetailRequest) AcceptLanguage(acceptLanguage string) ApiGetInvoicePaymentDetailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvoicePaymentDetailRequest) Execute() (*InvoicePayment, *http.Response, error) {
	return r.ApiService.GetInvoicePaymentDetailExecute(r)
}

/*
GetInvoicePaymentDetail Get account receivable invoice and payment details

Use this API to get AR account's invoice and payment details including credit, debit, amount due date, etc. <p><strong>OperationId:</strong>getInvoicePaymentDetail</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiGetInvoicePaymentDetailRequest
*/
func (a *AccountsReceivablesApiService) GetInvoicePaymentDetail(ctx context.Context, transactionId string, accountId string, hotelId string) ApiGetInvoicePaymentDetailRequest {
	return ApiGetInvoicePaymentDetailRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoicePayment
func (a *AccountsReceivablesApiService) GetInvoicePaymentDetailExecute(r ApiGetInvoicePaymentDetailRequest) (*InvoicePayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicePayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetInvoicePaymentDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/transactions/{transactionId}/invoicePaymentDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoicePostingsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	canBeModified *bool
	closeDate *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	invoiceType *string
	postingDate *string
	revenueDate *string
	statementNo *int32
	status *string
	transferDate *string
	postingTransactionCode *string
	transactionDate *string
	transactionNo *float32
	cashierId *float32
	hotelId *string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	age *int32
	guestName *string
	originalAmount *float32
	originalAmountCurrencyCode *string
	amount *float32
	currencyCode *string
	paymentsAmount *float32
	paymentsCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	reference *string
	remark *string
	adjusted *bool
	parentInvoiceNo *float32
	compressed *bool
	compressedDate *string
	transferredOut *bool
	transferredIn *bool
	marketDescription *string
	marketHotelId *string
	marketCode *string
	marketGroup *string
	roomClassDescription *string
	roomClassHotelId *string
	roomClassCode *string
	sourceDescription *string
	sourceHotelId *string
	sourceCode *string
	sourceGroup *string
	cashierInfoCashierId *float32
	cashierName *string
	transactionHotelId *string
	printTrxReceipt *bool
	invoicePostingsTransactionCode *string
	transactionDescription *string
	transactionGroup *string
	transactionSubGroup *string
	universalProductCode *string
	routingInstructionsId *float32
	articleCode *[]string
	articleHotelIds *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	transactionCode *[]string
	articleAmount *float32
	articleCurrencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	cardId *string
	paymentCardIdContext *string
	paymentCardIdType *string
	currentAuthorizedAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmount *float32
	approvalAmountCurrencyCode *string
	addresseeType *string
	addressProfileId *string
	addressProfileIdContext *string
	addressProfileIdType *string
	name *string
	city *string
	phone *string
	allowPartialTransferYn *bool
	printed *bool
	printedDate *string
	storedFolioId *string
	storedFolioIdContext *string
	storedFolioType *string
	storedFolioName *string
	storedDebitFolioId *string
	storedDebitFolioIdContext *string
	storedDebitFolioType *string
	storedDebitFolioName *string
	accountId *string
	accountIdContext *string
	accountType *string
	accountNo *string
	profileId *string
	profileIdContext *string
	profileIdType *string
	additionalFilterCashierId *float32
	additionalFilterTransactionCode *[]string
	additionalFilterTransactionSubGroupCode *[]string
	end *string
	start *string
	referenceWildCard *string
	supplementWildCard *string
	checkNumberWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvoicePostingsRequest) Authorization(authorization string) ApiGetInvoicePostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvoicePostingsRequest) XAppKey(xAppKey string) ApiGetInvoicePostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvoicePostingsRequest) XHotelid(xHotelid string) ApiGetInvoicePostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if postings or adjustments can be made to the invoice.
func (r ApiGetInvoicePostingsRequest) CanBeModified(canBeModified bool) ApiGetInvoicePostingsRequest {
	r.canBeModified = &canBeModified
	return r
}

// Close date of the invoice.
func (r ApiGetInvoicePostingsRequest) CloseDate(closeDate string) ApiGetInvoicePostingsRequest {
	r.closeDate = &closeDate
	return r
}

// The Fiscal Bill number of this posting
func (r ApiGetInvoicePostingsRequest) FiscalBillNo(fiscalBillNo string) ApiGetInvoicePostingsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiGetInvoicePostingsRequest) FolioDate(folioDate string) ApiGetInvoicePostingsRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r ApiGetInvoicePostingsRequest) FolioNo(folioNo float32) ApiGetInvoicePostingsRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiGetInvoicePostingsRequest) FolioStatus(folioStatus string) ApiGetInvoicePostingsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiGetInvoicePostingsRequest) FolioTypeName(folioTypeName string) ApiGetInvoicePostingsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetInvoicePostingsRequest) InternalFolioWindowID(internalFolioWindowID string) ApiGetInvoicePostingsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetInvoicePostingsRequest) InvoiceNo(invoiceNo float32) ApiGetInvoicePostingsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

func (r ApiGetInvoicePostingsRequest) InvoiceType(invoiceType string) ApiGetInvoicePostingsRequest {
	r.invoiceType = &invoiceType
	return r
}

// Posting date of the invoice.
func (r ApiGetInvoicePostingsRequest) PostingDate(postingDate string) ApiGetInvoicePostingsRequest {
	r.postingDate = &postingDate
	return r
}

// Revenue date ID of the invoice.
func (r ApiGetInvoicePostingsRequest) RevenueDate(revenueDate string) ApiGetInvoicePostingsRequest {
	r.revenueDate = &revenueDate
	return r
}

// Statementno of the invoice.
func (r ApiGetInvoicePostingsRequest) StatementNo(statementNo int32) ApiGetInvoicePostingsRequest {
	r.statementNo = &statementNo
	return r
}

// Status of the invoice.
func (r ApiGetInvoicePostingsRequest) Status(status string) ApiGetInvoicePostingsRequest {
	r.status = &status
	return r
}

// Transfer date of the invoice.
func (r ApiGetInvoicePostingsRequest) TransferDate(transferDate string) ApiGetInvoicePostingsRequest {
	r.transferDate = &transferDate
	return r
}

// Transaction code of the invoice.
func (r ApiGetInvoicePostingsRequest) PostingTransactionCode(postingTransactionCode string) ApiGetInvoicePostingsRequest {
	r.postingTransactionCode = &postingTransactionCode
	return r
}

// Transaction Date of the invoice.
func (r ApiGetInvoicePostingsRequest) TransactionDate(transactionDate string) ApiGetInvoicePostingsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Unique Transaction Identifier of the Invoice.
func (r ApiGetInvoicePostingsRequest) TransactionNo(transactionNo float32) ApiGetInvoicePostingsRequest {
	r.transactionNo = &transactionNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiGetInvoicePostingsRequest) CashierId(cashierId float32) ApiGetInvoicePostingsRequest {
	r.cashierId = &cashierId
	return r
}

// Property where the invoice exists.
func (r ApiGetInvoicePostingsRequest) HotelId(hotelId string) ApiGetInvoicePostingsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) ReservationId(reservationId string) ApiGetInvoicePostingsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) ReservationIdContext(reservationIdContext string) ApiGetInvoicePostingsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) ReservationType(reservationType string) ApiGetInvoicePostingsRequest {
	r.reservationType = &reservationType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) GuestProfileId(guestProfileId string) ApiGetInvoicePostingsRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) GuestProfileIdContext(guestProfileIdContext string) ApiGetInvoicePostingsRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) GuestProfileType(guestProfileType string) ApiGetInvoicePostingsRequest {
	r.guestProfileType = &guestProfileType
	return r
}

// The Aging age of the invoice
func (r ApiGetInvoicePostingsRequest) Age(age int32) ApiGetInvoicePostingsRequest {
	r.age = &age
	return r
}

// Name of the Guest who consumed these transactions.
func (r ApiGetInvoicePostingsRequest) GuestName(guestName string) ApiGetInvoicePostingsRequest {
	r.guestName = &guestName
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) OriginalAmount(originalAmount float32) ApiGetInvoicePostingsRequest {
	r.originalAmount = &originalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) OriginalAmountCurrencyCode(originalAmountCurrencyCode string) ApiGetInvoicePostingsRequest {
	r.originalAmountCurrencyCode = &originalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) Amount(amount float32) ApiGetInvoicePostingsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) CurrencyCode(currencyCode string) ApiGetInvoicePostingsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) PaymentsAmount(paymentsAmount float32) ApiGetInvoicePostingsRequest {
	r.paymentsAmount = &paymentsAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) PaymentsCurrencyCode(paymentsCurrencyCode string) ApiGetInvoicePostingsRequest {
	r.paymentsCurrencyCode = &paymentsCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) BalanceAmount(balanceAmount float32) ApiGetInvoicePostingsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetInvoicePostingsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// User-defined posting reference.
func (r ApiGetInvoicePostingsRequest) Reference(reference string) ApiGetInvoicePostingsRequest {
	r.reference = &reference
	return r
}

// User-defined posting remark.
func (r ApiGetInvoicePostingsRequest) Remark(remark string) ApiGetInvoicePostingsRequest {
	r.remark = &remark
	return r
}

func (r ApiGetInvoicePostingsRequest) Adjusted(adjusted bool) ApiGetInvoicePostingsRequest {
	r.adjusted = &adjusted
	return r
}

func (r ApiGetInvoicePostingsRequest) ParentInvoiceNo(parentInvoiceNo float32) ApiGetInvoicePostingsRequest {
	r.parentInvoiceNo = &parentInvoiceNo
	return r
}

func (r ApiGetInvoicePostingsRequest) Compressed(compressed bool) ApiGetInvoicePostingsRequest {
	r.compressed = &compressed
	return r
}

func (r ApiGetInvoicePostingsRequest) CompressedDate(compressedDate string) ApiGetInvoicePostingsRequest {
	r.compressedDate = &compressedDate
	return r
}

func (r ApiGetInvoicePostingsRequest) TransferredOut(transferredOut bool) ApiGetInvoicePostingsRequest {
	r.transferredOut = &transferredOut
	return r
}

func (r ApiGetInvoicePostingsRequest) TransferredIn(transferredIn bool) ApiGetInvoicePostingsRequest {
	r.transferredIn = &transferredIn
	return r
}

func (r ApiGetInvoicePostingsRequest) MarketDescription(marketDescription string) ApiGetInvoicePostingsRequest {
	r.marketDescription = &marketDescription
	return r
}

func (r ApiGetInvoicePostingsRequest) MarketHotelId(marketHotelId string) ApiGetInvoicePostingsRequest {
	r.marketHotelId = &marketHotelId
	return r
}

func (r ApiGetInvoicePostingsRequest) MarketCode(marketCode string) ApiGetInvoicePostingsRequest {
	r.marketCode = &marketCode
	return r
}

func (r ApiGetInvoicePostingsRequest) MarketGroup(marketGroup string) ApiGetInvoicePostingsRequest {
	r.marketGroup = &marketGroup
	return r
}

func (r ApiGetInvoicePostingsRequest) RoomClassDescription(roomClassDescription string) ApiGetInvoicePostingsRequest {
	r.roomClassDescription = &roomClassDescription
	return r
}

func (r ApiGetInvoicePostingsRequest) RoomClassHotelId(roomClassHotelId string) ApiGetInvoicePostingsRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r ApiGetInvoicePostingsRequest) RoomClassCode(roomClassCode string) ApiGetInvoicePostingsRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r ApiGetInvoicePostingsRequest) SourceDescription(sourceDescription string) ApiGetInvoicePostingsRequest {
	r.sourceDescription = &sourceDescription
	return r
}

func (r ApiGetInvoicePostingsRequest) SourceHotelId(sourceHotelId string) ApiGetInvoicePostingsRequest {
	r.sourceHotelId = &sourceHotelId
	return r
}

func (r ApiGetInvoicePostingsRequest) SourceCode(sourceCode string) ApiGetInvoicePostingsRequest {
	r.sourceCode = &sourceCode
	return r
}

func (r ApiGetInvoicePostingsRequest) SourceGroup(sourceGroup string) ApiGetInvoicePostingsRequest {
	r.sourceGroup = &sourceGroup
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetInvoicePostingsRequest) CashierInfoCashierId(cashierInfoCashierId float32) ApiGetInvoicePostingsRequest {
	r.cashierInfoCashierId = &cashierInfoCashierId
	return r
}

// Cashier Name.
func (r ApiGetInvoicePostingsRequest) CashierName(cashierName string) ApiGetInvoicePostingsRequest {
	r.cashierName = &cashierName
	return r
}

// Hotel context of the Transaction code.
func (r ApiGetInvoicePostingsRequest) TransactionHotelId(transactionHotelId string) ApiGetInvoicePostingsRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r ApiGetInvoicePostingsRequest) PrintTrxReceipt(printTrxReceipt bool) ApiGetInvoicePostingsRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r ApiGetInvoicePostingsRequest) InvoicePostingsTransactionCode(invoicePostingsTransactionCode string) ApiGetInvoicePostingsRequest {
	r.invoicePostingsTransactionCode = &invoicePostingsTransactionCode
	return r
}

// Transaction codes info.
func (r ApiGetInvoicePostingsRequest) TransactionDescription(transactionDescription string) ApiGetInvoicePostingsRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Category of the transaction code.
func (r ApiGetInvoicePostingsRequest) TransactionGroup(transactionGroup string) ApiGetInvoicePostingsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r ApiGetInvoicePostingsRequest) TransactionSubGroup(transactionSubGroup string) ApiGetInvoicePostingsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r ApiGetInvoicePostingsRequest) UniversalProductCode(universalProductCode string) ApiGetInvoicePostingsRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiGetInvoicePostingsRequest) RoutingInstructionsId(routingInstructionsId float32) ApiGetInvoicePostingsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r ApiGetInvoicePostingsRequest) ArticleCode(articleCode []string) ApiGetInvoicePostingsRequest {
	r.articleCode = &articleCode
	return r
}

// Hotel code to which the article belongs.
func (r ApiGetInvoicePostingsRequest) ArticleHotelIds(articleHotelIds []string) ApiGetInvoicePostingsRequest {
	r.articleHotelIds = &articleHotelIds
	return r
}

// Indicates whether the article is inactive or not.
func (r ApiGetInvoicePostingsRequest) Inactive(inactive []bool) ApiGetInvoicePostingsRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r ApiGetInvoicePostingsRequest) OrderSequence(orderSequence []float32) ApiGetInvoicePostingsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r ApiGetInvoicePostingsRequest) ArticleDescription(articleDescription []string) ApiGetInvoicePostingsRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r ApiGetInvoicePostingsRequest) TransactionCode(transactionCode []string) ApiGetInvoicePostingsRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) ArticleAmount(articleAmount float32) ApiGetInvoicePostingsRequest {
	r.articleAmount = &articleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) ArticleCurrencyCode(articleCurrencyCode string) ApiGetInvoicePostingsRequest {
	r.articleCurrencyCode = &articleCurrencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r ApiGetInvoicePostingsRequest) AvailableForPostIt(availableForPostIt bool) ApiGetInvoicePostingsRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r ApiGetInvoicePostingsRequest) Color(color string) ApiGetInvoicePostingsRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r ApiGetInvoicePostingsRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) ApiGetInvoicePostingsRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Attach the credit card to profile.
func (r ApiGetInvoicePostingsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetInvoicePostingsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetInvoicePostingsRequest) CardHolderName(cardHolderName string) ApiGetInvoicePostingsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetInvoicePostingsRequest) CardNumber(cardNumber string) ApiGetInvoicePostingsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetInvoicePostingsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetInvoicePostingsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetInvoicePostingsRequest) CardNumberMasked(cardNumberMasked string) ApiGetInvoicePostingsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetInvoicePostingsRequest) CardOrToken(cardOrToken string) ApiGetInvoicePostingsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetInvoicePostingsRequest) CardType(cardType string) ApiGetInvoicePostingsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetInvoicePostingsRequest) ExpirationDate(expirationDate string) ApiGetInvoicePostingsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetInvoicePostingsRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetInvoicePostingsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetInvoicePostingsRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetInvoicePostingsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetInvoicePostingsRequest) Processing(processing string) ApiGetInvoicePostingsRequest {
	r.processing = &processing
	return r
}

func (r ApiGetInvoicePostingsRequest) Swiped(swiped bool) ApiGetInvoicePostingsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetInvoicePostingsRequest) UserDefinedCardType(userDefinedCardType string) ApiGetInvoicePostingsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) CardId(cardId string) ApiGetInvoicePostingsRequest {
	r.cardId = &cardId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) PaymentCardIdContext(paymentCardIdContext string) ApiGetInvoicePostingsRequest {
	r.paymentCardIdContext = &paymentCardIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) PaymentCardIdType(paymentCardIdType string) ApiGetInvoicePostingsRequest {
	r.paymentCardIdType = &paymentCardIdType
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) ApiGetInvoicePostingsRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) ApiGetInvoicePostingsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetInvoicePostingsRequest) ApprovalAmount(approvalAmount float32) ApiGetInvoicePostingsRequest {
	r.approvalAmount = &approvalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetInvoicePostingsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetInvoicePostingsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Defines the type of Linked profiles for a block.
func (r ApiGetInvoicePostingsRequest) AddresseeType(addresseeType string) ApiGetInvoicePostingsRequest {
	r.addresseeType = &addresseeType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) AddressProfileId(addressProfileId string) ApiGetInvoicePostingsRequest {
	r.addressProfileId = &addressProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) AddressProfileIdContext(addressProfileIdContext string) ApiGetInvoicePostingsRequest {
	r.addressProfileIdContext = &addressProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) AddressProfileIdType(addressProfileIdType string) ApiGetInvoicePostingsRequest {
	r.addressProfileIdType = &addressProfileIdType
	return r
}

// Name for the profile attached to the block.
func (r ApiGetInvoicePostingsRequest) Name(name string) ApiGetInvoicePostingsRequest {
	r.name = &name
	return r
}

// City for the profile attached to the block.
func (r ApiGetInvoicePostingsRequest) City(city string) ApiGetInvoicePostingsRequest {
	r.city = &city
	return r
}

// Phone for the profile attached to the block.
func (r ApiGetInvoicePostingsRequest) Phone(phone string) ApiGetInvoicePostingsRequest {
	r.phone = &phone
	return r
}

// Flag to check Partail Transfer Allowed.
func (r ApiGetInvoicePostingsRequest) AllowPartialTransferYn(allowPartialTransferYn bool) ApiGetInvoicePostingsRequest {
	r.allowPartialTransferYn = &allowPartialTransferYn
	return r
}

// Flag to check Invoice Statement is Printed.
func (r ApiGetInvoicePostingsRequest) Printed(printed bool) ApiGetInvoicePostingsRequest {
	r.printed = &printed
	return r
}

// Invoice Statement Printed Date.
func (r ApiGetInvoicePostingsRequest) PrintedDate(printedDate string) ApiGetInvoicePostingsRequest {
	r.printedDate = &printedDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) StoredFolioId(storedFolioId string) ApiGetInvoicePostingsRequest {
	r.storedFolioId = &storedFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) StoredFolioIdContext(storedFolioIdContext string) ApiGetInvoicePostingsRequest {
	r.storedFolioIdContext = &storedFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) StoredFolioType(storedFolioType string) ApiGetInvoicePostingsRequest {
	r.storedFolioType = &storedFolioType
	return r
}

// Name of the Stored Folio.
func (r ApiGetInvoicePostingsRequest) StoredFolioName(storedFolioName string) ApiGetInvoicePostingsRequest {
	r.storedFolioName = &storedFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) StoredDebitFolioId(storedDebitFolioId string) ApiGetInvoicePostingsRequest {
	r.storedDebitFolioId = &storedDebitFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) StoredDebitFolioIdContext(storedDebitFolioIdContext string) ApiGetInvoicePostingsRequest {
	r.storedDebitFolioIdContext = &storedDebitFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) StoredDebitFolioType(storedDebitFolioType string) ApiGetInvoicePostingsRequest {
	r.storedDebitFolioType = &storedDebitFolioType
	return r
}

// Name of the Stored Debit Folio.
func (r ApiGetInvoicePostingsRequest) StoredDebitFolioName(storedDebitFolioName string) ApiGetInvoicePostingsRequest {
	r.storedDebitFolioName = &storedDebitFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) AccountId(accountId string) ApiGetInvoicePostingsRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) AccountIdContext(accountIdContext string) ApiGetInvoicePostingsRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) AccountType(accountType string) ApiGetInvoicePostingsRequest {
	r.accountType = &accountType
	return r
}

// The Account Number for the Account.
func (r ApiGetInvoicePostingsRequest) AccountNo(accountNo string) ApiGetInvoicePostingsRequest {
	r.accountNo = &accountNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicePostingsRequest) ProfileId(profileId string) ApiGetInvoicePostingsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicePostingsRequest) ProfileIdContext(profileIdContext string) ApiGetInvoicePostingsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicePostingsRequest) ProfileIdType(profileIdType string) ApiGetInvoicePostingsRequest {
	r.profileIdType = &profileIdType
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetInvoicePostingsRequest) AdditionalFilterCashierId(additionalFilterCashierId float32) ApiGetInvoicePostingsRequest {
	r.additionalFilterCashierId = &additionalFilterCashierId
	return r
}

func (r ApiGetInvoicePostingsRequest) AdditionalFilterTransactionCode(additionalFilterTransactionCode []string) ApiGetInvoicePostingsRequest {
	r.additionalFilterTransactionCode = &additionalFilterTransactionCode
	return r
}

func (r ApiGetInvoicePostingsRequest) AdditionalFilterTransactionSubGroupCode(additionalFilterTransactionSubGroupCode []string) ApiGetInvoicePostingsRequest {
	r.additionalFilterTransactionSubGroupCode = &additionalFilterTransactionSubGroupCode
	return r
}

// The ending value of the date range.
func (r ApiGetInvoicePostingsRequest) End(end string) ApiGetInvoicePostingsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ApiGetInvoicePostingsRequest) Start(start string) ApiGetInvoicePostingsRequest {
	r.start = &start
	return r
}

// Filters the results for reference.
func (r ApiGetInvoicePostingsRequest) ReferenceWildCard(referenceWildCard string) ApiGetInvoicePostingsRequest {
	r.referenceWildCard = &referenceWildCard
	return r
}

// Filter the results for supplement.
func (r ApiGetInvoicePostingsRequest) SupplementWildCard(supplementWildCard string) ApiGetInvoicePostingsRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// Lookup string which will try to match an existing Cheque number&#39;s.
func (r ApiGetInvoicePostingsRequest) CheckNumberWildCard(checkNumberWildCard string) ApiGetInvoicePostingsRequest {
	r.checkNumberWildCard = &checkNumberWildCard
	return r
}

// External system code.
func (r ApiGetInvoicePostingsRequest) XExternalsystem(xExternalsystem string) ApiGetInvoicePostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvoicePostingsRequest) AcceptLanguage(acceptLanguage string) ApiGetInvoicePostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvoicePostingsRequest) Execute() (*InvoicePostings, *http.Response, error) {
	return r.ApiService.GetInvoicePostingsExecute(r)
}

/*
GetInvoicePostings Get account receivable invoice postings

Use this API to get account receivable postings. <p><strong>OperationId:</strong>getInvoicePostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInvoicePostingsRequest
*/
func (a *AccountsReceivablesApiService) GetInvoicePostings(ctx context.Context) ApiGetInvoicePostingsRequest {
	return ApiGetInvoicePostingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InvoicePostings
func (a *AccountsReceivablesApiService) GetInvoicePostingsExecute(r ApiGetInvoicePostingsRequest) (*InvoicePostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicePostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetInvoicePostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicePostings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.canBeModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", r.canBeModified, "")
	}
	if r.closeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", r.closeDate, "")
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
	}
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
	}
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
	}
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	if r.invoiceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", r.invoiceType, "")
	}
	if r.postingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", r.postingDate, "")
	}
	if r.revenueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", r.revenueDate, "")
	}
	if r.statementNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", r.statementNo, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.transferDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", r.transferDate, "")
	}
	if r.postingTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingTransactionCode", r.postingTransactionCode, "")
	}
	if r.transactionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", r.transactionDate, "")
	}
	if r.transactionNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", r.transactionNo, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
	}
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
	}
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
	}
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
	}
	if r.age != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age", r.age, "")
	}
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
	}
	if r.originalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmount", r.originalAmount, "")
	}
	if r.originalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmountCurrencyCode", r.originalAmountCurrencyCode, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.paymentsAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsAmount", r.paymentsAmount, "")
	}
	if r.paymentsCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsCurrencyCode", r.paymentsCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
	}
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
	}
	if r.adjusted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", r.adjusted, "")
	}
	if r.parentInvoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", r.parentInvoiceNo, "")
	}
	if r.compressed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", r.compressed, "")
	}
	if r.compressedDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", r.compressedDate, "")
	}
	if r.transferredOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", r.transferredOut, "")
	}
	if r.transferredIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", r.transferredIn, "")
	}
	if r.marketDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketDescription", r.marketDescription, "")
	}
	if r.marketHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketHotelId", r.marketHotelId, "")
	}
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
	}
	if r.marketGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroup", r.marketGroup, "")
	}
	if r.roomClassDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassDescription", r.roomClassDescription, "")
	}
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
	}
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
	}
	if r.sourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceDescription", r.sourceDescription, "")
	}
	if r.sourceHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceHotelId", r.sourceHotelId, "")
	}
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
	}
	if r.sourceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceGroup", r.sourceGroup, "")
	}
	if r.cashierInfoCashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierInfoCashierId", r.cashierInfoCashierId, "")
	}
	if r.cashierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierName", r.cashierName, "")
	}
	if r.transactionHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", r.transactionHotelId, "")
	}
	if r.printTrxReceipt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", r.printTrxReceipt, "")
	}
	if r.invoicePostingsTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePostingsTransactionCode", r.invoicePostingsTransactionCode, "")
	}
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
	}
	if r.transactionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", r.transactionGroup, "")
	}
	if r.transactionSubGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", r.transactionSubGroup, "")
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	if r.routingInstructionsId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", r.routingInstructionsId, "")
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.articleHotelIds != nil {
		t := *r.articleHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.articleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleAmount", r.articleAmount, "")
	}
	if r.articleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleCurrencyCode", r.articleCurrencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.cardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardId", r.cardId, "")
	}
	if r.paymentCardIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PaymentCardIdContext", r.paymentCardIdContext, "")
	}
	if r.paymentCardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentCardIdType", r.paymentCardIdType, "")
	}
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
	}
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
	}
	if r.approvalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmount", r.approvalAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.addresseeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeType", r.addresseeType, "")
	}
	if r.addressProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressProfileId", r.addressProfileId, "")
	}
	if r.addressProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressProfileIdContext", r.addressProfileIdContext, "")
	}
	if r.addressProfileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressProfileIdType", r.addressProfileIdType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
	}
	if r.allowPartialTransferYn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", r.allowPartialTransferYn, "")
	}
	if r.printed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printed", r.printed, "")
	}
	if r.printedDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", r.printedDate, "")
	}
	if r.storedFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioId", r.storedFolioId, "")
	}
	if r.storedFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioIdContext", r.storedFolioIdContext, "")
	}
	if r.storedFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioType", r.storedFolioType, "")
	}
	if r.storedFolioName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", r.storedFolioName, "")
	}
	if r.storedDebitFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioId", r.storedDebitFolioId, "")
	}
	if r.storedDebitFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioIdContext", r.storedDebitFolioIdContext, "")
	}
	if r.storedDebitFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioType", r.storedDebitFolioType, "")
	}
	if r.storedDebitFolioName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", r.storedDebitFolioName, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
	}
	if r.additionalFilterCashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterCashierId", r.additionalFilterCashierId, "")
	}
	if r.additionalFilterTransactionCode != nil {
		t := *r.additionalFilterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionCode", t, "multi")
		}
	}
	if r.additionalFilterTransactionSubGroupCode != nil {
		t := *r.additionalFilterTransactionSubGroupCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionSubGroupCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionSubGroupCode", t, "multi")
		}
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.referenceWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceWildCard", r.referenceWildCard, "")
	}
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
	}
	if r.checkNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumberWildCard", r.checkNumberWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoicesOnHoldRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileId *string
	profileIdContext *string
	profileType *string
	id *string
	accountIdContext *string
	accountType *string
	accountNo *string
	accountName *string
	endDate *string
	startDate *string
	folios *string
	invoices *float32
	fiscalBillNo *string
	guestName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvoicesOnHoldRequest) Authorization(authorization string) ApiGetInvoicesOnHoldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvoicesOnHoldRequest) XAppKey(xAppKey string) ApiGetInvoicesOnHoldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvoicesOnHoldRequest) XHotelid(xHotelid string) ApiGetInvoicesOnHoldRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicesOnHoldRequest) ProfileId(profileId string) ApiGetInvoicesOnHoldRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicesOnHoldRequest) ProfileIdContext(profileIdContext string) ApiGetInvoicesOnHoldRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicesOnHoldRequest) ProfileType(profileType string) ApiGetInvoicesOnHoldRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicesOnHoldRequest) Id(id string) ApiGetInvoicesOnHoldRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicesOnHoldRequest) AccountIdContext(accountIdContext string) ApiGetInvoicesOnHoldRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicesOnHoldRequest) AccountType(accountType string) ApiGetInvoicesOnHoldRequest {
	r.accountType = &accountType
	return r
}

// Account Number for the AR Account.
func (r ApiGetInvoicesOnHoldRequest) AccountNo(accountNo string) ApiGetInvoicesOnHoldRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetInvoicesOnHoldRequest) AccountName(accountName string) ApiGetInvoicesOnHoldRequest {
	r.accountName = &accountName
	return r
}

// The ending value of the date range.
func (r ApiGetInvoicesOnHoldRequest) EndDate(endDate string) ApiGetInvoicesOnHoldRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r ApiGetInvoicesOnHoldRequest) StartDate(startDate string) ApiGetInvoicesOnHoldRequest {
	r.startDate = &startDate
	return r
}

// Folio Number for the invoice.
func (r ApiGetInvoicesOnHoldRequest) Folios(folios string) ApiGetInvoicesOnHoldRequest {
	r.folios = &folios
	return r
}

// Invoice number for the invoice.
func (r ApiGetInvoicesOnHoldRequest) Invoices(invoices float32) ApiGetInvoicesOnHoldRequest {
	r.invoices = &invoices
	return r
}

// Fiscal Bill number for the invoice.
func (r ApiGetInvoicesOnHoldRequest) FiscalBillNo(fiscalBillNo string) ApiGetInvoicesOnHoldRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Guest Name set for the invoice.
func (r ApiGetInvoicesOnHoldRequest) GuestName(guestName string) ApiGetInvoicesOnHoldRequest {
	r.guestName = &guestName
	return r
}

// External system code.
func (r ApiGetInvoicesOnHoldRequest) XExternalsystem(xExternalsystem string) ApiGetInvoicesOnHoldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvoicesOnHoldRequest) AcceptLanguage(acceptLanguage string) ApiGetInvoicesOnHoldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvoicesOnHoldRequest) Execute() (*InvoicesOnHold, *http.Response, error) {
	return r.ApiService.GetInvoicesOnHoldExecute(r)
}

/*
GetInvoicesOnHold Get list of hold invoices for account receivable

Use this API to get list of account receivable invoices which are put on hold. <p><strong>OperationId:</strong>getInvoicesOnHold</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiGetInvoicesOnHoldRequest
*/
func (a *AccountsReceivablesApiService) GetInvoicesOnHold(ctx context.Context, hotelId string) ApiGetInvoicesOnHoldRequest {
	return ApiGetInvoicesOnHoldRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoicesOnHold
func (a *AccountsReceivablesApiService) GetInvoicesOnHoldExecute(r ApiGetInvoicesOnHoldRequest) (*InvoicesOnHold, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicesOnHold
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetInvoicesOnHold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/invoicesOnHold"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.folios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folios", r.folios, "")
	}
	if r.invoices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", r.invoices, "")
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoicesPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inclDetails *bool
	inclZeroBalance *bool
	limit *int32
	offset *int32
	hotelIds *[]string
	end *string
	start *string
	guestDisplayName *string
	remark *string
	reference *string
	invoiceNo *[]float32
	addresseeName *string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	printed *bool
	unBilled *bool
	folioNo *[]string
	fiscalBillNo *string
	statementNo *float32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvoicesPaymentsRequest) Authorization(authorization string) ApiGetInvoicesPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvoicesPaymentsRequest) XAppKey(xAppKey string) ApiGetInvoicesPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvoicesPaymentsRequest) XHotelid(xHotelid string) ApiGetInvoicesPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if Invoice Details are required.
func (r ApiGetInvoicesPaymentsRequest) InclDetails(inclDetails bool) ApiGetInvoicesPaymentsRequest {
	r.inclDetails = &inclDetails
	return r
}

// Flag to indicate if Zero Balance Invoices are to be included.
func (r ApiGetInvoicesPaymentsRequest) InclZeroBalance(inclZeroBalance bool) ApiGetInvoicesPaymentsRequest {
	r.inclZeroBalance = &inclZeroBalance
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetInvoicesPaymentsRequest) Limit(limit int32) ApiGetInvoicesPaymentsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetInvoicesPaymentsRequest) Offset(offset int32) ApiGetInvoicesPaymentsRequest {
	r.offset = &offset
	return r
}

// Property where the Accounts exist.
func (r ApiGetInvoicesPaymentsRequest) HotelIds(hotelIds []string) ApiGetInvoicesPaymentsRequest {
	r.hotelIds = &hotelIds
	return r
}

// The ending value of the date range.
func (r ApiGetInvoicesPaymentsRequest) End(end string) ApiGetInvoicesPaymentsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ApiGetInvoicesPaymentsRequest) Start(start string) ApiGetInvoicesPaymentsRequest {
	r.start = &start
	return r
}

// Display Name for the guest.
func (r ApiGetInvoicesPaymentsRequest) GuestDisplayName(guestDisplayName string) ApiGetInvoicesPaymentsRequest {
	r.guestDisplayName = &guestDisplayName
	return r
}

// Filter for User-defined Invoice Supplement. The search is case-insensitive and supports % as wildcard character with right-side wildcard search by default. Examples: ABC or ABC% finds records that start with ABC, such as ABC, ABCDEF, and ABC123. %ABC or %ABC% finds records that contain ABC, such as ABC, ABC123, MYABC, and MYABC123.
func (r ApiGetInvoicesPaymentsRequest) Remark(remark string) ApiGetInvoicesPaymentsRequest {
	r.remark = &remark
	return r
}

// Filter for User-defined Invoice Reference. The search is case-insensitive and supports % as wildcard character with right-side wildcard search by default. Examples: ABC or ABC% finds records that start with ABC, such as ABC, ABCDEF, and ABC123. %ABC or %ABC% finds records that contain ABC, such as ABC, ABC123, MYABC, and MYABC123.
func (r ApiGetInvoicesPaymentsRequest) Reference(reference string) ApiGetInvoicesPaymentsRequest {
	r.reference = &reference
	return r
}

// invoice Number .
func (r ApiGetInvoicesPaymentsRequest) InvoiceNo(invoiceNo []float32) ApiGetInvoicesPaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r ApiGetInvoicesPaymentsRequest) AddresseeName(addresseeName string) ApiGetInvoicesPaymentsRequest {
	r.addresseeName = &addresseeName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetInvoicesPaymentsRequest) ReservationId(reservationId string) ApiGetInvoicesPaymentsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetInvoicesPaymentsRequest) ReservationIdContext(reservationIdContext string) ApiGetInvoicesPaymentsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetInvoicesPaymentsRequest) ReservationType(reservationType string) ApiGetInvoicesPaymentsRequest {
	r.reservationType = &reservationType
	return r
}

// Flag to check Invoice Statement is Printed.
func (r ApiGetInvoicesPaymentsRequest) Printed(printed bool) ApiGetInvoicesPaymentsRequest {
	r.printed = &printed
	return r
}

// Flag to check Invoice is billed
func (r ApiGetInvoicesPaymentsRequest) UnBilled(unBilled bool) ApiGetInvoicesPaymentsRequest {
	r.unBilled = &unBilled
	return r
}

// folio Number .
func (r ApiGetInvoicesPaymentsRequest) FolioNo(folioNo []string) ApiGetInvoicesPaymentsRequest {
	r.folioNo = &folioNo
	return r
}

// Fiscal bill number of this transaction.
func (r ApiGetInvoicesPaymentsRequest) FiscalBillNo(fiscalBillNo string) ApiGetInvoicesPaymentsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// The Statement number of this invoice.
func (r ApiGetInvoicesPaymentsRequest) StatementNo(statementNo float32) ApiGetInvoicesPaymentsRequest {
	r.statementNo = &statementNo
	return r
}

// Type of AR Invoice information to fetch the invoices or payments data.
func (r ApiGetInvoicesPaymentsRequest) FetchInstructions(fetchInstructions []string) ApiGetInvoicesPaymentsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetInvoicesPaymentsRequest) XExternalsystem(xExternalsystem string) ApiGetInvoicesPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvoicesPaymentsRequest) AcceptLanguage(acceptLanguage string) ApiGetInvoicesPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvoicesPaymentsRequest) Execute() (*InvoicesPayments, *http.Response, error) {
	return r.ApiService.GetInvoicesPaymentsExecute(r)
}

/*
GetInvoicesPayments Get payment detail for account's invoices

Use this API to get payment data for account receivable invoices. <p><strong>OperationId:</strong>getInvoicesPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return ApiGetInvoicesPaymentsRequest
*/
func (a *AccountsReceivablesApiService) GetInvoicesPayments(ctx context.Context, accountId string) ApiGetInvoicesPaymentsRequest {
	return ApiGetInvoicesPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return InvoicesPayments
func (a *AccountsReceivablesApiService) GetInvoicesPaymentsExecute(r ApiGetInvoicesPaymentsRequest) (*InvoicesPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicesPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetInvoicesPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicePayments/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inclDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclDetails", r.inclDetails, "")
	}
	if r.inclZeroBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZeroBalance", r.inclZeroBalance, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.guestDisplayName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestDisplayName", r.guestDisplayName, "")
	}
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
	}
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
	}
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
	}
	if r.addresseeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeName", r.addresseeName, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
	}
	if r.printed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printed", r.printed, "")
	}
	if r.unBilled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unBilled", r.unBilled, "")
	}
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.statementNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", r.statementNo, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileAgingRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	currency *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileAgingRequest) Authorization(authorization string) ApiGetProfileAgingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileAgingRequest) XAppKey(xAppKey string) ApiGetProfileAgingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileAgingRequest) XHotelid(xHotelid string) ApiGetProfileAgingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency of the aging amounts.
func (r ApiGetProfileAgingRequest) Currency(currency string) ApiGetProfileAgingRequest {
	r.currency = &currency
	return r
}

func (r ApiGetProfileAgingRequest) HotelIds(hotelIds []string) ApiGetProfileAgingRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ApiGetProfileAgingRequest) XExternalsystem(xExternalsystem string) ApiGetProfileAgingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileAgingRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileAgingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileAgingRequest) Execute() (*ProfileAging, *http.Response, error) {
	return r.ApiService.GetProfileAgingExecute(r)
}

/*
GetProfileAging Get given profile's aging detail

Use this API to get profile's account receivable summary including fixed charges, account balance, statements, reminder history, etc. <p><strong>OperationId:</strong>getProfileAging</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @return ApiGetProfileAgingRequest
*/
func (a *AccountsReceivablesApiService) GetProfileAging(ctx context.Context, profileId string) ApiGetProfileAgingRequest {
	return ApiGetProfileAgingRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileAging
func (a *AccountsReceivablesApiService) GetProfileAgingExecute(r ApiGetProfileAgingRequest) (*ProfileAging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileAging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetProfileAging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/aging"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileYearViewRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	currency *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileYearViewRequest) Authorization(authorization string) ApiGetProfileYearViewRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileYearViewRequest) XAppKey(xAppKey string) ApiGetProfileYearViewRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileYearViewRequest) XHotelid(xHotelid string) ApiGetProfileYearViewRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency of the Year View amounts.
func (r ApiGetProfileYearViewRequest) Currency(currency string) ApiGetProfileYearViewRequest {
	r.currency = &currency
	return r
}

func (r ApiGetProfileYearViewRequest) HotelIds(hotelIds []string) ApiGetProfileYearViewRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ApiGetProfileYearViewRequest) XExternalsystem(xExternalsystem string) ApiGetProfileYearViewRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileYearViewRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileYearViewRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileYearViewRequest) Execute() (*ProfileYearView, *http.Response, error) {
	return r.ApiService.GetProfileYearViewExecute(r)
}

/*
GetProfileYearView Get given profile's yearly account receivable detail

Use this API to get a month-by-month total of accrued debits, accrued credits, and a net total for the selected account data. <p><strong>OperationId:</strong>getProfileYearView</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @return ApiGetProfileYearViewRequest
*/
func (a *AccountsReceivablesApiService) GetProfileYearView(ctx context.Context, profileId string) ApiGetProfileYearViewRequest {
	return ApiGetProfileYearViewRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileYearView
func (a *AccountsReceivablesApiService) GetProfileYearViewExecute(r ApiGetProfileYearViewRequest) (*ProfileYearView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileYearView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetProfileYearView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/yearViews"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRemindersRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accounts *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	profiles *[]string
	accountNo *[]string
	accountName *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRemindersRequest) Accounts(accounts []string) ApiGetRemindersRequest {
	r.accounts = &accounts
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRemindersRequest) Authorization(authorization string) ApiGetRemindersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRemindersRequest) XAppKey(xAppKey string) ApiGetRemindersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRemindersRequest) XHotelid(xHotelid string) ApiGetRemindersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetRemindersRequest) HotelIds(hotelIds []string) ApiGetRemindersRequest {
	r.hotelIds = &hotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRemindersRequest) Profiles(profiles []string) ApiGetRemindersRequest {
	r.profiles = &profiles
	return r
}

// Account Number for the AR Account.
func (r ApiGetRemindersRequest) AccountNo(accountNo []string) ApiGetRemindersRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetRemindersRequest) AccountName(accountName []string) ApiGetRemindersRequest {
	r.accountName = &accountName
	return r
}

// External system code.
func (r ApiGetRemindersRequest) XExternalsystem(xExternalsystem string) ApiGetRemindersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRemindersRequest) AcceptLanguage(acceptLanguage string) ApiGetRemindersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRemindersRequest) Execute() (*Reminders, *http.Response, error) {
	return r.ApiService.GetRemindersExecute(r)
}

/*
GetReminders Get account receivable's reminder statements

Use this API to get AR account holders' reminder letter that includes detail of payment due, their current account balance, or for other purposes. <p><strong>OperationId:</strong>getReminders</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRemindersRequest
*/
func (a *AccountsReceivablesApiService) GetReminders(ctx context.Context) ApiGetRemindersRequest {
	return ApiGetRemindersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Reminders
func (a *AccountsReceivablesApiService) GetRemindersExecute(r ApiGetRemindersRequest) (*Reminders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reminders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetReminders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountReminders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accounts == nil {
		return localVarReturnValue, nil, reportError("accounts is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.profiles != nil {
		t := *r.profiles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profiles", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profiles", t, "multi")
		}
	}
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
	}
	if r.accountName != nil {
		t := *r.accountName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRemindersHistoryRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	profileId *string
	accountIdContext *string
	accountType *string
	accountNo *string
	accountName *string
	dateSent *string
	reportFileNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRemindersHistoryRequest) Authorization(authorization string) ApiGetRemindersHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRemindersHistoryRequest) XAppKey(xAppKey string) ApiGetRemindersHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRemindersHistoryRequest) XHotelid(xHotelid string) ApiGetRemindersHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetRemindersHistoryRequest) HotelId(hotelId string) ApiGetRemindersHistoryRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetRemindersHistoryRequest) ProfileId(profileId string) ApiGetRemindersHistoryRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetRemindersHistoryRequest) AccountIdContext(accountIdContext string) ApiGetRemindersHistoryRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetRemindersHistoryRequest) AccountType(accountType string) ApiGetRemindersHistoryRequest {
	r.accountType = &accountType
	return r
}

// Account Number for the AR Account.
func (r ApiGetRemindersHistoryRequest) AccountNo(accountNo string) ApiGetRemindersHistoryRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetRemindersHistoryRequest) AccountName(accountName string) ApiGetRemindersHistoryRequest {
	r.accountName = &accountName
	return r
}

// History Date filter.
func (r ApiGetRemindersHistoryRequest) DateSent(dateSent string) ApiGetRemindersHistoryRequest {
	r.dateSent = &dateSent
	return r
}

// Report Name wild card.
func (r ApiGetRemindersHistoryRequest) ReportFileNameWildCard(reportFileNameWildCard string) ApiGetRemindersHistoryRequest {
	r.reportFileNameWildCard = &reportFileNameWildCard
	return r
}

// External system code.
func (r ApiGetRemindersHistoryRequest) XExternalsystem(xExternalsystem string) ApiGetRemindersHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRemindersHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetRemindersHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRemindersHistoryRequest) Execute() (*RemindersHistory, *http.Response, error) {
	return r.ApiService.GetRemindersHistoryExecute(r)
}

/*
GetRemindersHistory Get history of reminder letters for a given account receivable

Use this API to get history of reminder letters prepared for AR account. <p><strong>OperationId:</strong>getRemindersHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return ApiGetRemindersHistoryRequest
*/
func (a *AccountsReceivablesApiService) GetRemindersHistory(ctx context.Context, accountId string) ApiGetRemindersHistoryRequest {
	return ApiGetRemindersHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return RemindersHistory
func (a *AccountsReceivablesApiService) GetRemindersHistoryExecute(r ApiGetRemindersHistoryRequest) (*RemindersHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemindersHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetRemindersHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/remindersHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.dateSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateSent", r.dateSent, "")
	}
	if r.reportFileNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportFileNameWildCard", r.reportFileNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	profileId *string
	profileIdContext *string
	profileType *string
	accountNo *[]string
	accountName *[]string
	canBeModified *[]bool
	closeDate *[]string
	fiscalBillNo *[]string
	folioDate *[]string
	folioNo *[]float32
	folioStatus *[]string
	folioTypeName *[]string
	internalFolioWindowID *[]string
	invoiceNo *[]float32
	invoiceType *[]string
	postingDate *[]string
	revenueDate *[]string
	statementNo *[]int32
	status *[]string
	transferDate *[]string
	invoiceTransactionCode *[]string
	transactionDate *[]string
	transactionNo *[]float32
	invoiceHotelIds *[]string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	age *[]int32
	guestName *[]string
	originalAmount *float32
	originalAmountCurrencyCode *string
	amount *float32
	currencyCode *string
	paymentsAmount *float32
	paymentsCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	reference *[]string
	remark *[]string
	adjusted *[]bool
	parentInvoiceNo *[]float32
	compressed *[]bool
	compressedDate *[]string
	transferredOut *[]bool
	transferredIn *[]bool
	marketDescription *string
	marketHotelId *string
	marketCode *string
	marketGroup *string
	roomClassDescription *string
	roomClassHotelId *string
	roomClassCode *string
	sourceDescription *string
	sourceHotelId *string
	sourceCode *string
	sourceGroup *string
	cashierId *float32
	cashierName *string
	transactionHotelId *string
	printTrxReceipt *bool
	accountInvoiceTransactionCode *string
	transactionDescription *string
	transactionGroup *string
	transactionSubGroup *string
	universalProductCode *string
	routingInstructionsId *float32
	articleCode *[]string
	articleHotelIds *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	transactionCode *[]string
	articleAmount *float32
	articleCurrencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	invoicePaymentCardId *string
	invoicePaymentCardIdContext *string
	invoicePaymentCardIdType *string
	currentAuthorizedAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmount *float32
	approvalAmountCurrencyCode *string
	type_ *string
	addresseeProfileId *string
	addresseeProfileIdContext *string
	addresseeProfileType *string
	name *string
	city *string
	phone *string
	allowPartialTransferYn *[]bool
	printed *[]bool
	printedDate *[]string
	storedFolioId *string
	storedFolioIdContext *string
	storedFolioType *string
	storedFolioName *[]string
	storedDebitFolioId *string
	storedDebitFolioIdContext *string
	storedDebitFolioType *string
	storedDebitFolioName *[]string
	balanceForwardDate *string
	inclFolios *bool
	inclPrinted *bool
	inclZero *bool
	filterEndDate *string
	filterStartDate *string
	statementText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStatementsRequest) Authorization(authorization string) ApiGetStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStatementsRequest) XAppKey(xAppKey string) ApiGetStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStatementsRequest) XHotelid(xHotelid string) ApiGetStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) HotelId(hotelId []string) ApiGetStatementsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) ProfileId(profileId string) ApiGetStatementsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) ProfileIdContext(profileIdContext string) ApiGetStatementsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) ProfileType(profileType string) ApiGetStatementsRequest {
	r.profileType = &profileType
	return r
}

// Account Number for the AR Account.
func (r ApiGetStatementsRequest) AccountNo(accountNo []string) ApiGetStatementsRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetStatementsRequest) AccountName(accountName []string) ApiGetStatementsRequest {
	r.accountName = &accountName
	return r
}

// Flag to indicate if postings or adjustments can be made to the invoice.
func (r ApiGetStatementsRequest) CanBeModified(canBeModified []bool) ApiGetStatementsRequest {
	r.canBeModified = &canBeModified
	return r
}

// Close date of the invoice.
func (r ApiGetStatementsRequest) CloseDate(closeDate []string) ApiGetStatementsRequest {
	r.closeDate = &closeDate
	return r
}

// The Fiscal Bill number of this posting
func (r ApiGetStatementsRequest) FiscalBillNo(fiscalBillNo []string) ApiGetStatementsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r ApiGetStatementsRequest) FolioDate(folioDate []string) ApiGetStatementsRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r ApiGetStatementsRequest) FolioNo(folioNo []float32) ApiGetStatementsRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r ApiGetStatementsRequest) FolioStatus(folioStatus []string) ApiGetStatementsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r ApiGetStatementsRequest) FolioTypeName(folioTypeName []string) ApiGetStatementsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r ApiGetStatementsRequest) InternalFolioWindowID(internalFolioWindowID []string) ApiGetStatementsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiGetStatementsRequest) InvoiceNo(invoiceNo []float32) ApiGetStatementsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

func (r ApiGetStatementsRequest) InvoiceType(invoiceType []string) ApiGetStatementsRequest {
	r.invoiceType = &invoiceType
	return r
}

// Posting date of the invoice.
func (r ApiGetStatementsRequest) PostingDate(postingDate []string) ApiGetStatementsRequest {
	r.postingDate = &postingDate
	return r
}

// Revenue date ID of the invoice.
func (r ApiGetStatementsRequest) RevenueDate(revenueDate []string) ApiGetStatementsRequest {
	r.revenueDate = &revenueDate
	return r
}

// Statementno of the invoice.
func (r ApiGetStatementsRequest) StatementNo(statementNo []int32) ApiGetStatementsRequest {
	r.statementNo = &statementNo
	return r
}

// Status of the invoice.
func (r ApiGetStatementsRequest) Status(status []string) ApiGetStatementsRequest {
	r.status = &status
	return r
}

// Transfer date of the invoice.
func (r ApiGetStatementsRequest) TransferDate(transferDate []string) ApiGetStatementsRequest {
	r.transferDate = &transferDate
	return r
}

// Transaction code of the invoice.
func (r ApiGetStatementsRequest) InvoiceTransactionCode(invoiceTransactionCode []string) ApiGetStatementsRequest {
	r.invoiceTransactionCode = &invoiceTransactionCode
	return r
}

// Transaction Date of the invoice.
func (r ApiGetStatementsRequest) TransactionDate(transactionDate []string) ApiGetStatementsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Unique Transaction Identifier of the Invoice.
func (r ApiGetStatementsRequest) TransactionNo(transactionNo []float32) ApiGetStatementsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) InvoiceHotelIds(invoiceHotelIds []string) ApiGetStatementsRequest {
	r.invoiceHotelIds = &invoiceHotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) ReservationId(reservationId string) ApiGetStatementsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) ReservationIdContext(reservationIdContext string) ApiGetStatementsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) ReservationType(reservationType string) ApiGetStatementsRequest {
	r.reservationType = &reservationType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) GuestProfileId(guestProfileId string) ApiGetStatementsRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) GuestProfileIdContext(guestProfileIdContext string) ApiGetStatementsRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) GuestProfileType(guestProfileType string) ApiGetStatementsRequest {
	r.guestProfileType = &guestProfileType
	return r
}

// The Aging age of the invoice
func (r ApiGetStatementsRequest) Age(age []int32) ApiGetStatementsRequest {
	r.age = &age
	return r
}

// Name of the Guest who consumed these transactions.
func (r ApiGetStatementsRequest) GuestName(guestName []string) ApiGetStatementsRequest {
	r.guestName = &guestName
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) OriginalAmount(originalAmount float32) ApiGetStatementsRequest {
	r.originalAmount = &originalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) OriginalAmountCurrencyCode(originalAmountCurrencyCode string) ApiGetStatementsRequest {
	r.originalAmountCurrencyCode = &originalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) Amount(amount float32) ApiGetStatementsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) CurrencyCode(currencyCode string) ApiGetStatementsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) PaymentsAmount(paymentsAmount float32) ApiGetStatementsRequest {
	r.paymentsAmount = &paymentsAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) PaymentsCurrencyCode(paymentsCurrencyCode string) ApiGetStatementsRequest {
	r.paymentsCurrencyCode = &paymentsCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) BalanceAmount(balanceAmount float32) ApiGetStatementsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) BalanceCurrencyCode(balanceCurrencyCode string) ApiGetStatementsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// User-defined posting reference.
func (r ApiGetStatementsRequest) Reference(reference []string) ApiGetStatementsRequest {
	r.reference = &reference
	return r
}

// User-defined posting remark.
func (r ApiGetStatementsRequest) Remark(remark []string) ApiGetStatementsRequest {
	r.remark = &remark
	return r
}

func (r ApiGetStatementsRequest) Adjusted(adjusted []bool) ApiGetStatementsRequest {
	r.adjusted = &adjusted
	return r
}

func (r ApiGetStatementsRequest) ParentInvoiceNo(parentInvoiceNo []float32) ApiGetStatementsRequest {
	r.parentInvoiceNo = &parentInvoiceNo
	return r
}

func (r ApiGetStatementsRequest) Compressed(compressed []bool) ApiGetStatementsRequest {
	r.compressed = &compressed
	return r
}

func (r ApiGetStatementsRequest) CompressedDate(compressedDate []string) ApiGetStatementsRequest {
	r.compressedDate = &compressedDate
	return r
}

func (r ApiGetStatementsRequest) TransferredOut(transferredOut []bool) ApiGetStatementsRequest {
	r.transferredOut = &transferredOut
	return r
}

func (r ApiGetStatementsRequest) TransferredIn(transferredIn []bool) ApiGetStatementsRequest {
	r.transferredIn = &transferredIn
	return r
}

func (r ApiGetStatementsRequest) MarketDescription(marketDescription string) ApiGetStatementsRequest {
	r.marketDescription = &marketDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) MarketHotelId(marketHotelId string) ApiGetStatementsRequest {
	r.marketHotelId = &marketHotelId
	return r
}

func (r ApiGetStatementsRequest) MarketCode(marketCode string) ApiGetStatementsRequest {
	r.marketCode = &marketCode
	return r
}

func (r ApiGetStatementsRequest) MarketGroup(marketGroup string) ApiGetStatementsRequest {
	r.marketGroup = &marketGroup
	return r
}

func (r ApiGetStatementsRequest) RoomClassDescription(roomClassDescription string) ApiGetStatementsRequest {
	r.roomClassDescription = &roomClassDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) RoomClassHotelId(roomClassHotelId string) ApiGetStatementsRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r ApiGetStatementsRequest) RoomClassCode(roomClassCode string) ApiGetStatementsRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r ApiGetStatementsRequest) SourceDescription(sourceDescription string) ApiGetStatementsRequest {
	r.sourceDescription = &sourceDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) SourceHotelId(sourceHotelId string) ApiGetStatementsRequest {
	r.sourceHotelId = &sourceHotelId
	return r
}

func (r ApiGetStatementsRequest) SourceCode(sourceCode string) ApiGetStatementsRequest {
	r.sourceCode = &sourceCode
	return r
}

func (r ApiGetStatementsRequest) SourceGroup(sourceGroup string) ApiGetStatementsRequest {
	r.sourceGroup = &sourceGroup
	return r
}

// Cashier Id of the Cashier.
func (r ApiGetStatementsRequest) CashierId(cashierId float32) ApiGetStatementsRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier Name.
func (r ApiGetStatementsRequest) CashierName(cashierName string) ApiGetStatementsRequest {
	r.cashierName = &cashierName
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) TransactionHotelId(transactionHotelId string) ApiGetStatementsRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r ApiGetStatementsRequest) PrintTrxReceipt(printTrxReceipt bool) ApiGetStatementsRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r ApiGetStatementsRequest) AccountInvoiceTransactionCode(accountInvoiceTransactionCode string) ApiGetStatementsRequest {
	r.accountInvoiceTransactionCode = &accountInvoiceTransactionCode
	return r
}

// Transaction codes info.
func (r ApiGetStatementsRequest) TransactionDescription(transactionDescription string) ApiGetStatementsRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Category of the transaction code.
func (r ApiGetStatementsRequest) TransactionGroup(transactionGroup string) ApiGetStatementsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r ApiGetStatementsRequest) TransactionSubGroup(transactionSubGroup string) ApiGetStatementsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r ApiGetStatementsRequest) UniversalProductCode(universalProductCode string) ApiGetStatementsRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r ApiGetStatementsRequest) RoutingInstructionsId(routingInstructionsId float32) ApiGetStatementsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r ApiGetStatementsRequest) ArticleCode(articleCode []string) ApiGetStatementsRequest {
	r.articleCode = &articleCode
	return r
}

// Property where the AR Account exists. This is required.
func (r ApiGetStatementsRequest) ArticleHotelIds(articleHotelIds []string) ApiGetStatementsRequest {
	r.articleHotelIds = &articleHotelIds
	return r
}

// Indicates whether the article is inactive or not.
func (r ApiGetStatementsRequest) Inactive(inactive []bool) ApiGetStatementsRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r ApiGetStatementsRequest) OrderSequence(orderSequence []float32) ApiGetStatementsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r ApiGetStatementsRequest) ArticleDescription(articleDescription []string) ApiGetStatementsRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r ApiGetStatementsRequest) TransactionCode(transactionCode []string) ApiGetStatementsRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) ArticleAmount(articleAmount float32) ApiGetStatementsRequest {
	r.articleAmount = &articleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) ArticleCurrencyCode(articleCurrencyCode string) ApiGetStatementsRequest {
	r.articleCurrencyCode = &articleCurrencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r ApiGetStatementsRequest) AvailableForPostIt(availableForPostIt bool) ApiGetStatementsRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r ApiGetStatementsRequest) Color(color string) ApiGetStatementsRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r ApiGetStatementsRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) ApiGetStatementsRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Attach the credit card to profile.
func (r ApiGetStatementsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ApiGetStatementsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ApiGetStatementsRequest) CardHolderName(cardHolderName string) ApiGetStatementsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ApiGetStatementsRequest) CardNumber(cardNumber string) ApiGetStatementsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ApiGetStatementsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ApiGetStatementsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ApiGetStatementsRequest) CardNumberMasked(cardNumberMasked string) ApiGetStatementsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ApiGetStatementsRequest) CardOrToken(cardOrToken string) ApiGetStatementsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ApiGetStatementsRequest) CardType(cardType string) ApiGetStatementsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ApiGetStatementsRequest) ExpirationDate(expirationDate string) ApiGetStatementsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ApiGetStatementsRequest) ExpirationDateExpired(expirationDateExpired bool) ApiGetStatementsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ApiGetStatementsRequest) ExpirationDateMasked(expirationDateMasked string) ApiGetStatementsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ApiGetStatementsRequest) Processing(processing string) ApiGetStatementsRequest {
	r.processing = &processing
	return r
}

func (r ApiGetStatementsRequest) Swiped(swiped bool) ApiGetStatementsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ApiGetStatementsRequest) UserDefinedCardType(userDefinedCardType string) ApiGetStatementsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) InvoicePaymentCardId(invoicePaymentCardId string) ApiGetStatementsRequest {
	r.invoicePaymentCardId = &invoicePaymentCardId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) InvoicePaymentCardIdContext(invoicePaymentCardIdContext string) ApiGetStatementsRequest {
	r.invoicePaymentCardIdContext = &invoicePaymentCardIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) InvoicePaymentCardIdType(invoicePaymentCardIdType string) ApiGetStatementsRequest {
	r.invoicePaymentCardIdType = &invoicePaymentCardIdType
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) ApiGetStatementsRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) ApiGetStatementsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ApiGetStatementsRequest) ApprovalAmount(approvalAmount float32) ApiGetStatementsRequest {
	r.approvalAmount = &approvalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ApiGetStatementsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ApiGetStatementsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Defines the type of Linked profiles for a block.
func (r ApiGetStatementsRequest) Type_(type_ string) ApiGetStatementsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) AddresseeProfileId(addresseeProfileId string) ApiGetStatementsRequest {
	r.addresseeProfileId = &addresseeProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) AddresseeProfileIdContext(addresseeProfileIdContext string) ApiGetStatementsRequest {
	r.addresseeProfileIdContext = &addresseeProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) AddresseeProfileType(addresseeProfileType string) ApiGetStatementsRequest {
	r.addresseeProfileType = &addresseeProfileType
	return r
}

// Name for the profile attached to the block.
func (r ApiGetStatementsRequest) Name(name string) ApiGetStatementsRequest {
	r.name = &name
	return r
}

// City for the profile attached to the block.
func (r ApiGetStatementsRequest) City(city string) ApiGetStatementsRequest {
	r.city = &city
	return r
}

// Phone for the profile attached to the block.
func (r ApiGetStatementsRequest) Phone(phone string) ApiGetStatementsRequest {
	r.phone = &phone
	return r
}

// Flag to check Partail Transfer Allowed.
func (r ApiGetStatementsRequest) AllowPartialTransferYn(allowPartialTransferYn []bool) ApiGetStatementsRequest {
	r.allowPartialTransferYn = &allowPartialTransferYn
	return r
}

// Flag to check Invoice Statement is Printed.
func (r ApiGetStatementsRequest) Printed(printed []bool) ApiGetStatementsRequest {
	r.printed = &printed
	return r
}

// Invoice Statement Printed Date.
func (r ApiGetStatementsRequest) PrintedDate(printedDate []string) ApiGetStatementsRequest {
	r.printedDate = &printedDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) StoredFolioId(storedFolioId string) ApiGetStatementsRequest {
	r.storedFolioId = &storedFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) StoredFolioIdContext(storedFolioIdContext string) ApiGetStatementsRequest {
	r.storedFolioIdContext = &storedFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) StoredFolioType(storedFolioType string) ApiGetStatementsRequest {
	r.storedFolioType = &storedFolioType
	return r
}

// Name of the Stored Folio.
func (r ApiGetStatementsRequest) StoredFolioName(storedFolioName []string) ApiGetStatementsRequest {
	r.storedFolioName = &storedFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementsRequest) StoredDebitFolioId(storedDebitFolioId string) ApiGetStatementsRequest {
	r.storedDebitFolioId = &storedDebitFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetStatementsRequest) StoredDebitFolioIdContext(storedDebitFolioIdContext string) ApiGetStatementsRequest {
	r.storedDebitFolioIdContext = &storedDebitFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementsRequest) StoredDebitFolioType(storedDebitFolioType string) ApiGetStatementsRequest {
	r.storedDebitFolioType = &storedDebitFolioType
	return r
}

// Name of the Stored Debit Folio.
func (r ApiGetStatementsRequest) StoredDebitFolioName(storedDebitFolioName []string) ApiGetStatementsRequest {
	r.storedDebitFolioName = &storedDebitFolioName
	return r
}

// The date specified in this field determines the balance forward date and balance forward total that is printed on the statement. (A balance forward shows the net amount for all invoices and payments (debits and credits) prior to the balance forward date as a single total, rather than itemizing them individually on the statement.)
func (r ApiGetStatementsRequest) BalanceForwardDate(balanceForwardDate string) ApiGetStatementsRequest {
	r.balanceForwardDate = &balanceForwardDate
	return r
}

// Flag to indicate if the associated Folios for the Invoices are to be included along with the the Statement.
func (r ApiGetStatementsRequest) InclFolios(inclFolios bool) ApiGetStatementsRequest {
	r.inclFolios = &inclFolios
	return r
}

// Flag to indicate if Previousely Printed Invoices are to be included in the Statement. This is based on the Functionality for AR PRINTED INVOICES.
func (r ApiGetStatementsRequest) InclPrinted(inclPrinted bool) ApiGetStatementsRequest {
	r.inclPrinted = &inclPrinted
	return r
}

// Flag to indicate if Zero Balances Invoices are to be included in the Statement.
func (r ApiGetStatementsRequest) InclZero(inclZero bool) ApiGetStatementsRequest {
	r.inclZero = &inclZero
	return r
}

// The ending value of the date range.
func (r ApiGetStatementsRequest) FilterEndDate(filterEndDate string) ApiGetStatementsRequest {
	r.filterEndDate = &filterEndDate
	return r
}

// The starting value of the date range.
func (r ApiGetStatementsRequest) FilterStartDate(filterStartDate string) ApiGetStatementsRequest {
	r.filterStartDate = &filterStartDate
	return r
}

// Text which will be printed on the Invoice.
func (r ApiGetStatementsRequest) StatementText(statementText string) ApiGetStatementsRequest {
	r.statementText = &statementText
	return r
}

// External system code.
func (r ApiGetStatementsRequest) XExternalsystem(xExternalsystem string) ApiGetStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStatementsRequest) AcceptLanguage(acceptLanguage string) ApiGetStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStatementsRequest) Execute() (*Statements, *http.Response, error) {
	return r.ApiService.GetStatementsExecute(r)
}

/*
GetStatements Get given profile's account receivable statements

Use this API to prepare statement for an AR account holders. It is typically prepared for billing purposes.<br><p><strong><mark>This API is deprecated. Please use getARStatements instead</mark></strong></p> <p><strong>OperationId:</strong>getStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return ApiGetStatementsRequest

Deprecated
*/
func (a *AccountsReceivablesApiService) GetStatements(ctx context.Context, accountId string) ApiGetStatementsRequest {
	return ApiGetStatementsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return Statements
// Deprecated
func (a *AccountsReceivablesApiService) GetStatementsExecute(r ApiGetStatementsRequest) (*Statements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Statements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
	}
	if r.accountName != nil {
		t := *r.accountName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", t, "multi")
		}
	}
	if r.canBeModified != nil {
		t := *r.canBeModified
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", t, "multi")
		}
	}
	if r.closeDate != nil {
		t := *r.closeDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", t, "multi")
		}
	}
	if r.fiscalBillNo != nil {
		t := *r.fiscalBillNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", t, "multi")
		}
	}
	if r.folioDate != nil {
		t := *r.folioDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", t, "multi")
		}
	}
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
	}
	if r.folioStatus != nil {
		t := *r.folioStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", t, "multi")
		}
	}
	if r.folioTypeName != nil {
		t := *r.folioTypeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", t, "multi")
		}
	}
	if r.internalFolioWindowID != nil {
		t := *r.internalFolioWindowID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", t, "multi")
		}
	}
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
	}
	if r.invoiceType != nil {
		t := *r.invoiceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", t, "multi")
		}
	}
	if r.postingDate != nil {
		t := *r.postingDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", t, "multi")
		}
	}
	if r.revenueDate != nil {
		t := *r.revenueDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", t, "multi")
		}
	}
	if r.statementNo != nil {
		t := *r.statementNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.transferDate != nil {
		t := *r.transferDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", t, "multi")
		}
	}
	if r.invoiceTransactionCode != nil {
		t := *r.invoiceTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", t, "multi")
		}
	}
	if r.transactionDate != nil {
		t := *r.transactionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", t, "multi")
		}
	}
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
	}
	if r.invoiceHotelIds != nil {
		t := *r.invoiceHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", t, "multi")
		}
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
	}
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
	}
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
	}
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
	}
	if r.age != nil {
		t := *r.age
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "age", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "age", t, "multi")
		}
	}
	if r.guestName != nil {
		t := *r.guestName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", t, "multi")
		}
	}
	if r.originalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmount", r.originalAmount, "")
	}
	if r.originalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmountCurrencyCode", r.originalAmountCurrencyCode, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.paymentsAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsAmount", r.paymentsAmount, "")
	}
	if r.paymentsCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsCurrencyCode", r.paymentsCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.reference != nil {
		t := *r.reference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reference", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reference", t, "multi")
		}
	}
	if r.remark != nil {
		t := *r.remark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remark", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remark", t, "multi")
		}
	}
	if r.adjusted != nil {
		t := *r.adjusted
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", t, "multi")
		}
	}
	if r.parentInvoiceNo != nil {
		t := *r.parentInvoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", t, "multi")
		}
	}
	if r.compressed != nil {
		t := *r.compressed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", t, "multi")
		}
	}
	if r.compressedDate != nil {
		t := *r.compressedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", t, "multi")
		}
	}
	if r.transferredOut != nil {
		t := *r.transferredOut
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", t, "multi")
		}
	}
	if r.transferredIn != nil {
		t := *r.transferredIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", t, "multi")
		}
	}
	if r.marketDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketDescription", r.marketDescription, "")
	}
	if r.marketHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketHotelId", r.marketHotelId, "")
	}
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
	}
	if r.marketGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroup", r.marketGroup, "")
	}
	if r.roomClassDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassDescription", r.roomClassDescription, "")
	}
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
	}
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
	}
	if r.sourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceDescription", r.sourceDescription, "")
	}
	if r.sourceHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceHotelId", r.sourceHotelId, "")
	}
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
	}
	if r.sourceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceGroup", r.sourceGroup, "")
	}
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
	}
	if r.cashierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierName", r.cashierName, "")
	}
	if r.transactionHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", r.transactionHotelId, "")
	}
	if r.printTrxReceipt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", r.printTrxReceipt, "")
	}
	if r.accountInvoiceTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountInvoiceTransactionCode", r.accountInvoiceTransactionCode, "")
	}
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
	}
	if r.transactionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", r.transactionGroup, "")
	}
	if r.transactionSubGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", r.transactionSubGroup, "")
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	if r.routingInstructionsId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", r.routingInstructionsId, "")
	}
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
	}
	if r.articleHotelIds != nil {
		t := *r.articleHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.articleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleAmount", r.articleAmount, "")
	}
	if r.articleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleCurrencyCode", r.articleCurrencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.invoicePaymentCardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardId", r.invoicePaymentCardId, "")
	}
	if r.invoicePaymentCardIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdContext", r.invoicePaymentCardIdContext, "")
	}
	if r.invoicePaymentCardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdType", r.invoicePaymentCardIdType, "")
	}
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
	}
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
	}
	if r.approvalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmount", r.approvalAmount, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.addresseeProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileId", r.addresseeProfileId, "")
	}
	if r.addresseeProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileIdContext", r.addresseeProfileIdContext, "")
	}
	if r.addresseeProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileType", r.addresseeProfileType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
	}
	if r.allowPartialTransferYn != nil {
		t := *r.allowPartialTransferYn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", t, "multi")
		}
	}
	if r.printed != nil {
		t := *r.printed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printed", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printed", t, "multi")
		}
	}
	if r.printedDate != nil {
		t := *r.printedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", t, "multi")
		}
	}
	if r.storedFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioId", r.storedFolioId, "")
	}
	if r.storedFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioIdContext", r.storedFolioIdContext, "")
	}
	if r.storedFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioType", r.storedFolioType, "")
	}
	if r.storedFolioName != nil {
		t := *r.storedFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", t, "multi")
		}
	}
	if r.storedDebitFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioId", r.storedDebitFolioId, "")
	}
	if r.storedDebitFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioIdContext", r.storedDebitFolioIdContext, "")
	}
	if r.storedDebitFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioType", r.storedDebitFolioType, "")
	}
	if r.storedDebitFolioName != nil {
		t := *r.storedDebitFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", t, "multi")
		}
	}
	if r.balanceForwardDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceForwardDate", r.balanceForwardDate, "")
	}
	if r.inclFolios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclFolios", r.inclFolios, "")
	}
	if r.inclPrinted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclPrinted", r.inclPrinted, "")
	}
	if r.inclZero != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZero", r.inclZero, "")
	}
	if r.filterEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndDate", r.filterEndDate, "")
	}
	if r.filterStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartDate", r.filterStartDate, "")
	}
	if r.statementText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementText", r.statementText, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementsHistoryRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountNo *string
	accountName *string
	dateSent *string
	reportFileNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStatementsHistoryRequest) Authorization(authorization string) ApiGetStatementsHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStatementsHistoryRequest) XAppKey(xAppKey string) ApiGetStatementsHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStatementsHistoryRequest) XHotelid(xHotelid string) ApiGetStatementsHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account Number for the AR Account.
func (r ApiGetStatementsHistoryRequest) AccountNo(accountNo string) ApiGetStatementsHistoryRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r ApiGetStatementsHistoryRequest) AccountName(accountName string) ApiGetStatementsHistoryRequest {
	r.accountName = &accountName
	return r
}

// History Date filter.
func (r ApiGetStatementsHistoryRequest) DateSent(dateSent string) ApiGetStatementsHistoryRequest {
	r.dateSent = &dateSent
	return r
}

// Report Name wild card.
func (r ApiGetStatementsHistoryRequest) ReportFileNameWildCard(reportFileNameWildCard string) ApiGetStatementsHistoryRequest {
	r.reportFileNameWildCard = &reportFileNameWildCard
	return r
}

// External system code.
func (r ApiGetStatementsHistoryRequest) XExternalsystem(xExternalsystem string) ApiGetStatementsHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStatementsHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetStatementsHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStatementsHistoryRequest) Execute() (*StatementHistory, *http.Response, error) {
	return r.ApiService.GetStatementsHistoryExecute(r)
}

/*
GetStatementsHistory Get given profile's account receivable statements history

Use this API to find the history of statements prepared for AR accounts. <p><strong>OperationId:</strong>getStatementsHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return ApiGetStatementsHistoryRequest
*/
func (a *AccountsReceivablesApiService) GetStatementsHistory(ctx context.Context, accountId string, profileId string, hotelId string) ApiGetStatementsHistoryRequest {
	return ApiGetStatementsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StatementHistory
func (a *AccountsReceivablesApiService) GetStatementsHistoryExecute(r ApiGetStatementsHistoryRequest) (*StatementHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetStatementsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/statementsHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.dateSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateSent", r.dateSent, "")
	}
	if r.reportFileNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportFileNameWildCard", r.reportFileNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingAccountsReceivableServiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPingAccountsReceivableServiceRequest) Authorization(authorization string) ApiPingAccountsReceivableServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPingAccountsReceivableServiceRequest) XAppKey(xAppKey string) ApiPingAccountsReceivableServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPingAccountsReceivableServiceRequest) XHotelid(xHotelid string) ApiPingAccountsReceivableServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiPingAccountsReceivableServiceRequest) XExternalsystem(xExternalsystem string) ApiPingAccountsReceivableServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPingAccountsReceivableServiceRequest) AcceptLanguage(acceptLanguage string) ApiPingAccountsReceivableServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPingAccountsReceivableServiceRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingAccountsReceivableServiceExecute(r)
}

/*
PingAccountsReceivableService Check account receivable service status

Use this API to check account receivable service status. <p><strong>OperationId:</strong>pingAccountsReceivableService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingAccountsReceivableServiceRequest
*/
func (a *AccountsReceivablesApiService) PingAccountsReceivableService(ctx context.Context) ApiPingAccountsReceivableServiceRequest {
	return ApiPingAccountsReceivableServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *AccountsReceivablesApiService) PingAccountsReceivableServiceExecute(r ApiPingAccountsReceivableServiceRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PingAccountsReceivableService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/accountReceivables/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostARChargesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arChargesPostingCriteria *PostChargesToARRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostARChargesRequest) Authorization(authorization string) ApiPostARChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostARChargesRequest) XAppKey(xAppKey string) ApiPostARChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostARChargesRequest) XHotelid(xHotelid string) ApiPostARChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post charges to an existing invoice, when the functionality is available. If the invoice should not be modified or if the folio should not be modified,based on other functionalities, then the charges cannot be posted to the invoice.
func (r ApiPostARChargesRequest) ArChargesPostingCriteria(arChargesPostingCriteria PostChargesToARRequest) ApiPostARChargesRequest {
	r.arChargesPostingCriteria = &arChargesPostingCriteria
	return r
}

// External system code.
func (r ApiPostARChargesRequest) XExternalsystem(xExternalsystem string) ApiPostARChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostARChargesRequest) AcceptLanguage(acceptLanguage string) ApiPostARChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostARChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostARChargesExecute(r)
}

/*
PostARCharges Add charges to account receivable

Use this API to post charges to account receivable account.<br><p><strong><mark>This API is deprecated. Please use postChargesToAR instead</mark></strong></p> <p><strong>OperationId:</strong>postARCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return ApiPostARChargesRequest

Deprecated
*/
func (a *AccountsReceivablesApiService) PostARCharges(ctx context.Context, accountId string, profileId string, hotelId string) ApiPostARChargesRequest {
	return ApiPostARChargesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *AccountsReceivablesApiService) PostARChargesExecute(r ApiPostARChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostARCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arChargesPostingCriteria == nil {
		return localVarReturnValue, nil, reportError("arChargesPostingCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arChargesPostingCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAROldBalancesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	arOldBalances *PostAROldBalancesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAROldBalancesRequest) Authorization(authorization string) ApiPostAROldBalancesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAROldBalancesRequest) XAppKey(xAppKey string) ApiPostAROldBalancesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAROldBalancesRequest) XHotelid(xHotelid string) ApiPostAROldBalancesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Post AR Old Balances
func (r ApiPostAROldBalancesRequest) ArOldBalances(arOldBalances PostAROldBalancesRequest) ApiPostAROldBalancesRequest {
	r.arOldBalances = &arOldBalances
	return r
}

// External system code.
func (r ApiPostAROldBalancesRequest) XExternalsystem(xExternalsystem string) ApiPostAROldBalancesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAROldBalancesRequest) AcceptLanguage(acceptLanguage string) ApiPostAROldBalancesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAROldBalancesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAROldBalancesExecute(r)
}

/*
PostAROldBalances Add old balances from external accounting systems

Use this API to add old balances from external accounting systems into OPERA Accounts Receivable. <p><strong>OperationId:</strong>postAROldBalances</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAROldBalancesRequest
*/
func (a *AccountsReceivablesApiService) PostAROldBalances(ctx context.Context) ApiPostAROldBalancesRequest {
	return ApiPostAROldBalancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostAROldBalancesExecute(r ApiPostAROldBalancesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostAROldBalances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oldBalances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arOldBalances == nil {
		return localVarReturnValue, nil, reportError("arOldBalances is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arOldBalances
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostARPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arPaymentsToBeCreated *PostARPaymentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostARPaymentsRequest) Authorization(authorization string) ApiPostARPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostARPaymentsRequest) XAppKey(xAppKey string) ApiPostARPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostARPaymentsRequest) XHotelid(xHotelid string) ApiPostARPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a payment to an AR Account and apply the payment to Invoices..
func (r ApiPostARPaymentsRequest) ArPaymentsToBeCreated(arPaymentsToBeCreated PostARPaymentsRequest) ApiPostARPaymentsRequest {
	r.arPaymentsToBeCreated = &arPaymentsToBeCreated
	return r
}

// External system code.
func (r ApiPostARPaymentsRequest) XExternalsystem(xExternalsystem string) ApiPostARPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostARPaymentsRequest) AcceptLanguage(acceptLanguage string) ApiPostARPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostARPaymentsRequest) Execute() (*ArPayments, *http.Response, error) {
	return r.ApiService.PostARPaymentsExecute(r)
}

/*
PostARPayments Add payment to an account receivable account for a list of reservations

Use this API to make payment to AR accounts for a list of reservations. <p><strong>OperationId:</strong>postARPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return ApiPostARPaymentsRequest
*/
func (a *AccountsReceivablesApiService) PostARPayments(ctx context.Context, accountId string, profileId string, hotelId string) ApiPostARPaymentsRequest {
	return ApiPostARPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArPayments
func (a *AccountsReceivablesApiService) PostARPaymentsExecute(r ApiPostARPaymentsRequest) (*ArPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostARPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arPaymentsToBeCreated == nil {
		return localVarReturnValue, nil, reportError("arPaymentsToBeCreated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arPaymentsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountCriteria *PostAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAccountRequest) Authorization(authorization string) ApiPostAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAccountRequest) XAppKey(xAppKey string) ApiPostAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAccountRequest) XHotelid(xHotelid string) ApiPostAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new AR Account
func (r ApiPostAccountRequest) AccountCriteria(accountCriteria PostAccountRequest) ApiPostAccountRequest {
	r.accountCriteria = &accountCriteria
	return r
}

// External system code.
func (r ApiPostAccountRequest) XExternalsystem(xExternalsystem string) ApiPostAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAccountRequest) AcceptLanguage(acceptLanguage string) ApiPostAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountExecute(r)
}

/*
PostAccount Create an account receivable account

Use this API to create a new account receivable type account for given OPERA profile id. Prior creating account, need to use getProfile to find OPERA profile's id.  <p><strong>OperationId:</strong>postAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostAccountRequest
*/
func (a *AccountsReceivablesApiService) PostAccount(ctx context.Context, hotelId string) ApiPostAccountRequest {
	return ApiPostAccountRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostAccountExecute(r ApiPostAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountCriteria == nil {
		return localVarReturnValue, nil, reportError("accountCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAccountCommentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountComment *PutAccountCommentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAccountCommentRequest) Authorization(authorization string) ApiPostAccountCommentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAccountCommentRequest) XAppKey(xAppKey string) ApiPostAccountCommentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAccountCommentRequest) XHotelid(xHotelid string) ApiPostAccountCommentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Comment for an Account.
func (r ApiPostAccountCommentRequest) AccountComment(accountComment PutAccountCommentRequest) ApiPostAccountCommentRequest {
	r.accountComment = &accountComment
	return r
}

// External system code.
func (r ApiPostAccountCommentRequest) XExternalsystem(xExternalsystem string) ApiPostAccountCommentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAccountCommentRequest) AcceptLanguage(acceptLanguage string) ApiPostAccountCommentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAccountCommentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountCommentExecute(r)
}

/*
PostAccountComment Create Account Comment

Use this API to add a note for a given account id. Use get accounts to find account id. <p><strong>OperationId:</strong>postAccountComment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostAccountCommentRequest
*/
func (a *AccountsReceivablesApiService) PostAccountComment(ctx context.Context, accountId string, hotelId string) ApiPostAccountCommentRequest {
	return ApiPostAccountCommentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostAccountCommentExecute(r ApiPostAccountCommentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostAccountComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountComment == nil {
		return localVarReturnValue, nil, reportError("accountComment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAccountFixedChargeRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountFixedCharge *PostAccountFixedChargeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAccountFixedChargeRequest) Authorization(authorization string) ApiPostAccountFixedChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAccountFixedChargeRequest) XAppKey(xAppKey string) ApiPostAccountFixedChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAccountFixedChargeRequest) XHotelid(xHotelid string) ApiPostAccountFixedChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Fixed Charge for an Account.
func (r ApiPostAccountFixedChargeRequest) AccountFixedCharge(accountFixedCharge PostAccountFixedChargeRequest) ApiPostAccountFixedChargeRequest {
	r.accountFixedCharge = &accountFixedCharge
	return r
}

// External system code.
func (r ApiPostAccountFixedChargeRequest) XExternalsystem(xExternalsystem string) ApiPostAccountFixedChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAccountFixedChargeRequest) AcceptLanguage(acceptLanguage string) ApiPostAccountFixedChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAccountFixedChargeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountFixedChargeExecute(r)
}

/*
PostAccountFixedCharge Create fixed charges 

Use this API to create fixed charges for a given account id of account receivable. Use get accounts to find an account id. <p><strong>OperationId:</strong>postAccountFixedCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostAccountFixedChargeRequest
*/
func (a *AccountsReceivablesApiService) PostAccountFixedCharge(ctx context.Context, accountId string, hotelId string) ApiPostAccountFixedChargeRequest {
	return ApiPostAccountFixedChargeRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostAccountFixedChargeExecute(r ApiPostAccountFixedChargeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostAccountFixedCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountFixedCharge == nil {
		return localVarReturnValue, nil, reportError("accountFixedCharge is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountFixedCharge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAccountTraceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountTrace *PutAccountTraceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAccountTraceRequest) Authorization(authorization string) ApiPostAccountTraceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAccountTraceRequest) XAppKey(xAppKey string) ApiPostAccountTraceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAccountTraceRequest) XHotelid(xHotelid string) ApiPostAccountTraceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Trace for an Account.
func (r ApiPostAccountTraceRequest) AccountTrace(accountTrace PutAccountTraceRequest) ApiPostAccountTraceRequest {
	r.accountTrace = &accountTrace
	return r
}

// External system code.
func (r ApiPostAccountTraceRequest) XExternalsystem(xExternalsystem string) ApiPostAccountTraceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAccountTraceRequest) AcceptLanguage(acceptLanguage string) ApiPostAccountTraceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAccountTraceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountTraceExecute(r)
}

/*
PostAccountTrace Add a trace to an account receivable account

Use this API to add a trace for a given account id. Use getaccounts to find account id. <p><strong>OperationId:</strong>postAccountTrace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostAccountTraceRequest
*/
func (a *AccountsReceivablesApiService) PostAccountTrace(ctx context.Context, accountId string, hotelId string) ApiPostAccountTraceRequest {
	return ApiPostAccountTraceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostAccountTraceExecute(r ApiPostAccountTraceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostAccountTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountTrace == nil {
		return localVarReturnValue, nil, reportError("accountTrace is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountTrace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBatchChargesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchChargesToPost *PostBatchChargesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostBatchChargesRequest) Authorization(authorization string) ApiPostBatchChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostBatchChargesRequest) XAppKey(xAppKey string) ApiPostBatchChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostBatchChargesRequest) XHotelid(xHotelid string) ApiPostBatchChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for posting a charge in a batch to list of accounts.
func (r ApiPostBatchChargesRequest) BatchChargesToPost(batchChargesToPost PostBatchChargesRequest) ApiPostBatchChargesRequest {
	r.batchChargesToPost = &batchChargesToPost
	return r
}

// External system code.
func (r ApiPostBatchChargesRequest) XExternalsystem(xExternalsystem string) ApiPostBatchChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostBatchChargesRequest) AcceptLanguage(acceptLanguage string) ApiPostBatchChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostBatchChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchChargesExecute(r)
}

/*
PostBatchCharges Create process to charge on multiple account receivables

Use this API to create a batch process for simultaneously post a one-time charge to multiple account receivable accounts. <p><strong>OperationId:</strong>postBatchCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPostBatchChargesRequest
*/
func (a *AccountsReceivablesApiService) PostBatchCharges(ctx context.Context, hotelId string) ApiPostBatchChargesRequest {
	return ApiPostBatchChargesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostBatchChargesExecute(r ApiPostBatchChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostBatchCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/batchCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.batchChargesToPost == nil {
		return localVarReturnValue, nil, reportError("batchChargesToPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchChargesToPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChargesToARRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arChargesPostingCriteria *PostChargesToARRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChargesToARRequest) Authorization(authorization string) ApiPostChargesToARRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChargesToARRequest) XAppKey(xAppKey string) ApiPostChargesToARRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChargesToARRequest) XHotelid(xHotelid string) ApiPostChargesToARRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post charges to an existing invoice, when the functionality is available. If the invoice should not be modified or if the folio should not be modified,based on other functionalities, then the charges cannot be posted to the invoice.
func (r ApiPostChargesToARRequest) ArChargesPostingCriteria(arChargesPostingCriteria PostChargesToARRequest) ApiPostChargesToARRequest {
	r.arChargesPostingCriteria = &arChargesPostingCriteria
	return r
}

// External system code.
func (r ApiPostChargesToARRequest) XExternalsystem(xExternalsystem string) ApiPostChargesToARRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChargesToARRequest) AcceptLanguage(acceptLanguage string) ApiPostChargesToARRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChargesToARRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChargesToARExecute(r)
}

/*
PostChargesToAR Add charges to account receivable

Use this API to post charges to account receivable account. <p><strong>OperationId:</strong>postChargesToAR</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostChargesToARRequest
*/
func (a *AccountsReceivablesApiService) PostChargesToAR(ctx context.Context, accountId string, hotelId string) ApiPostChargesToARRequest {
	return ApiPostChargesToARRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostChargesToARExecute(r ApiPostChargesToARRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostChargesToAR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arChargesPostingCriteria == nil {
		return localVarReturnValue, nil, reportError("arChargesPostingCriteria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arChargesPostingCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreditToInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditToInvoices *PostCreditToInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCreditToInvoicesRequest) Authorization(authorization string) ApiPostCreditToInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCreditToInvoicesRequest) XAppKey(xAppKey string) ApiPostCreditToInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCreditToInvoicesRequest) XHotelid(xHotelid string) ApiPostCreditToInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiPostCreditToInvoicesRequest) CreditToInvoices(creditToInvoices PostCreditToInvoicesRequest) ApiPostCreditToInvoicesRequest {
	r.creditToInvoices = &creditToInvoices
	return r
}

// External system code.
func (r ApiPostCreditToInvoicesRequest) XExternalsystem(xExternalsystem string) ApiPostCreditToInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCreditToInvoicesRequest) AcceptLanguage(acceptLanguage string) ApiPostCreditToInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCreditToInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCreditToInvoicesExecute(r)
}

/*
PostCreditToInvoices Add credits to AR invoices

Use this API to add credits to account receivable invoices. <p><strong>OperationId:</strong>postCreditToInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostCreditToInvoicesRequest
*/
func (a *AccountsReceivablesApiService) PostCreditToInvoices(ctx context.Context, accountId string, hotelId string) ApiPostCreditToInvoicesRequest {
	return ApiPostCreditToInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostCreditToInvoicesExecute(r ApiPostCreditToInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostCreditToInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/applyCreditToInvoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.creditToInvoices == nil {
		return localVarReturnValue, nil, reportError("creditToInvoices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditToInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arInvoice *PostInvoiceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostInvoiceRequest) Authorization(authorization string) ApiPostInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostInvoiceRequest) XAppKey(xAppKey string) ApiPostInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostInvoiceRequest) XHotelid(xHotelid string) ApiPostInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new Invoice for an Account.
func (r ApiPostInvoiceRequest) ArInvoice(arInvoice PostInvoiceRequest) ApiPostInvoiceRequest {
	r.arInvoice = &arInvoice
	return r
}

// External system code.
func (r ApiPostInvoiceRequest) XExternalsystem(xExternalsystem string) ApiPostInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiPostInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostInvoiceRequest) Execute() (*ArInvoiceDetails, *http.Response, error) {
	return r.ApiService.PostInvoiceExecute(r)
}

/*
PostInvoice Create account receivable invoices

Use this API to create a new invoice for an AR account. <p><strong>OperationId:</strong>postInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostInvoiceRequest
*/
func (a *AccountsReceivablesApiService) PostInvoice(ctx context.Context, accountId string, hotelId string) ApiPostInvoiceRequest {
	return ApiPostInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArInvoiceDetails
func (a *AccountsReceivablesApiService) PostInvoiceExecute(r ApiPostInvoiceRequest) (*ArInvoiceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArInvoiceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/invoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arInvoice == nil {
		return localVarReturnValue, nil, reportError("arInvoice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arInvoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRemindersRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	reminders *PostRemindersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostRemindersRequest) Authorization(authorization string) ApiPostRemindersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostRemindersRequest) XAppKey(xAppKey string) ApiPostRemindersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostRemindersRequest) XHotelid(xHotelid string) ApiPostRemindersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update the reminder information on an Account. After the letter has been generated and sent, the account and the invoices will be updated with the Reminder Cycle information. This is done so that the next cycle of Reminder Letters c can be generated correctly.
func (r ApiPostRemindersRequest) Reminders(reminders PostRemindersRequest) ApiPostRemindersRequest {
	r.reminders = &reminders
	return r
}

// External system code.
func (r ApiPostRemindersRequest) XExternalsystem(xExternalsystem string) ApiPostRemindersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostRemindersRequest) AcceptLanguage(acceptLanguage string) ApiPostRemindersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostRemindersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRemindersExecute(r)
}

/*
PostReminders Generate reminders

Use this API to generate a reminder statement which includes payment due,  current account balance, and etc. of account receivable account holder. <p><strong>OperationId:</strong>postReminders</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRemindersRequest
*/
func (a *AccountsReceivablesApiService) PostReminders(ctx context.Context) ApiPostRemindersRequest {
	return ApiPostRemindersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostRemindersExecute(r ApiPostRemindersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostReminders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountReminders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reminders == nil {
		return localVarReturnValue, nil, reportError("reminders is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reminders
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReversePaymentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	transactionId string
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reversePayment *PostReversePaymentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostReversePaymentRequest) Authorization(authorization string) ApiPostReversePaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostReversePaymentRequest) XAppKey(xAppKey string) ApiPostReversePaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostReversePaymentRequest) XHotelid(xHotelid string) ApiPostReversePaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for reverse AR payment
func (r ApiPostReversePaymentRequest) ReversePayment(reversePayment PostReversePaymentRequest) ApiPostReversePaymentRequest {
	r.reversePayment = &reversePayment
	return r
}

// External system code.
func (r ApiPostReversePaymentRequest) XExternalsystem(xExternalsystem string) ApiPostReversePaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostReversePaymentRequest) AcceptLanguage(acceptLanguage string) ApiPostReversePaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostReversePaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReversePaymentExecute(r)
}

/*
PostReversePayment Reverse Payment

Use this API to reverse payment that occurred accidently or via user error. <p><strong>OperationId:</strong>postReversePayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return ApiPostReversePaymentRequest
*/
func (a *AccountsReceivablesApiService) PostReversePayment(ctx context.Context, transactionId string, accountId string, profileId string, hotelId string) ApiPostReversePaymentRequest {
	return ApiPostReversePaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostReversePaymentExecute(r ApiPostReversePaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostReversePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/transactions/{transactionId}/reversePayment"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reversePayment == nil {
		return localVarReturnValue, nil, reportError("reversePayment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reversePayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostStatementsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	statementsToBeGenerated *PostStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostStatementsRequest) Authorization(authorization string) ApiPostStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostStatementsRequest) XAppKey(xAppKey string) ApiPostStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostStatementsRequest) XHotelid(xHotelid string) ApiPostStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to generate AR Statements. This will validate and check if there exists any invoices to be included in the Statement based on the criteria used. If Statement Numbering is used, this will return a statement number to use in report as well as report sequence id to identify statement&#39;s invoices.
func (r ApiPostStatementsRequest) StatementsToBeGenerated(statementsToBeGenerated PostStatementsRequest) ApiPostStatementsRequest {
	r.statementsToBeGenerated = &statementsToBeGenerated
	return r
}

// External system code.
func (r ApiPostStatementsRequest) XExternalsystem(xExternalsystem string) ApiPostStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostStatementsRequest) AcceptLanguage(acceptLanguage string) ApiPostStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostStatementsExecute(r)
}

/*
PostStatements Generate a statement for a given account receivable

Use this API to generate statement for a given account receivable id. It includes the account balance as of the current business date, an aging summary that shows how long outstanding balances have been "on the books" for each aging level set up for given property. <p><strong>OperationId:</strong>postStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPostStatementsRequest
*/
func (a *AccountsReceivablesApiService) PostStatements(ctx context.Context, accountId string, hotelId string) ApiPostStatementsRequest {
	return ApiPostStatementsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostStatementsExecute(r ApiPostStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.statementsToBeGenerated == nil {
		return localVarReturnValue, nil, reportError("statementsToBeGenerated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.statementsToBeGenerated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutARInvoicesAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	arInvoicesAccount *PutARInvoicesAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutARInvoicesAccountRequest) Authorization(authorization string) ApiPutARInvoicesAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutARInvoicesAccountRequest) XAppKey(xAppKey string) ApiPutARInvoicesAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutARInvoicesAccountRequest) XHotelid(xHotelid string) ApiPutARInvoicesAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change AR invoice(s) account in AR.
func (r ApiPutARInvoicesAccountRequest) ArInvoicesAccount(arInvoicesAccount PutARInvoicesAccountRequest) ApiPutARInvoicesAccountRequest {
	r.arInvoicesAccount = &arInvoicesAccount
	return r
}

// External system code.
func (r ApiPutARInvoicesAccountRequest) XExternalsystem(xExternalsystem string) ApiPutARInvoicesAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutARInvoicesAccountRequest) AcceptLanguage(acceptLanguage string) ApiPutARInvoicesAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutARInvoicesAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutARInvoicesAccountExecute(r)
}

/*
PutARInvoicesAccount Change Account receivable invoice for an AR account

Use this API to update existing AR invoice for a given profile and/or a reservation. <p><strong>OperationId:</strong>putARInvoicesAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutARInvoicesAccountRequest
*/
func (a *AccountsReceivablesApiService) PutARInvoicesAccount(ctx context.Context) ApiPutARInvoicesAccountRequest {
	return ApiPutARInvoicesAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutARInvoicesAccountExecute(r ApiPutARInvoicesAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutARInvoicesAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicesAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arInvoicesAccount == nil {
		return localVarReturnValue, nil, reportError("arInvoicesAccount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arInvoicesAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	account *PutAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAccountRequest) Authorization(authorization string) ApiPutAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAccountRequest) XAppKey(xAppKey string) ApiPutAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAccountRequest) XHotelid(xHotelid string) ApiPutAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change and existing AR Account. The Account No, Credit Limit, Address, Email, Telephone information, Permanent Flag, Primary Account Flag, Contact Name are the details that can be changed on an existing account.
func (r ApiPutAccountRequest) Account(account PutAccountRequest) ApiPutAccountRequest {
	r.account = &account
	return r
}

// External system code.
func (r ApiPutAccountRequest) XExternalsystem(xExternalsystem string) ApiPutAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAccountRequest) AcceptLanguage(acceptLanguage string) ApiPutAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountExecute(r)
}

/*
PutAccount Update a account receivable account

Use this API to update existing account using account id and further detail. Use get account to get account detail prior updating. <p><strong>OperationId:</strong>putAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPutAccountRequest
*/
func (a *AccountsReceivablesApiService) PutAccount(ctx context.Context, accountId string, hotelId string) ApiPutAccountRequest {
	return ApiPutAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutAccountExecute(r ApiPutAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.account == nil {
		return localVarReturnValue, nil, reportError("account is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.account
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAccountCommentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountComment *PutAccountCommentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAccountCommentRequest) Authorization(authorization string) ApiPutAccountCommentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAccountCommentRequest) XAppKey(xAppKey string) ApiPutAccountCommentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAccountCommentRequest) XHotelid(xHotelid string) ApiPutAccountCommentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Change the Comment on an Account.
func (r ApiPutAccountCommentRequest) AccountComment(accountComment PutAccountCommentRequest) ApiPutAccountCommentRequest {
	r.accountComment = &accountComment
	return r
}

// External system code.
func (r ApiPutAccountCommentRequest) XExternalsystem(xExternalsystem string) ApiPutAccountCommentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAccountCommentRequest) AcceptLanguage(acceptLanguage string) ApiPutAccountCommentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAccountCommentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountCommentExecute(r)
}

/*
PutAccountComment Change Account Comment

Use this API to update existing account note. Use get account to find noteid <p><strong>OperationId:</strong>putAccountComment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPutAccountCommentRequest
*/
func (a *AccountsReceivablesApiService) PutAccountComment(ctx context.Context, accountId string, hotelId string) ApiPutAccountCommentRequest {
	return ApiPutAccountCommentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutAccountCommentExecute(r ApiPutAccountCommentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutAccountComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountComment == nil {
		return localVarReturnValue, nil, reportError("accountComment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAccountFixedChargeRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	fixedChargeId string
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountFixedCharge *PostAccountFixedChargeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAccountFixedChargeRequest) Authorization(authorization string) ApiPutAccountFixedChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAccountFixedChargeRequest) XAppKey(xAppKey string) ApiPutAccountFixedChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAccountFixedChargeRequest) XHotelid(xHotelid string) ApiPutAccountFixedChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Change the Fixed Charge on an Account.
func (r ApiPutAccountFixedChargeRequest) AccountFixedCharge(accountFixedCharge PostAccountFixedChargeRequest) ApiPutAccountFixedChargeRequest {
	r.accountFixedCharge = &accountFixedCharge
	return r
}

// External system code.
func (r ApiPutAccountFixedChargeRequest) XExternalsystem(xExternalsystem string) ApiPutAccountFixedChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAccountFixedChargeRequest) AcceptLanguage(acceptLanguage string) ApiPutAccountFixedChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAccountFixedChargeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountFixedChargeExecute(r)
}

/*
PutAccountFixedCharge Update fixed charge detail 

Use this API to update existing fixed charges for a given account receivable. <p><strong>OperationId:</strong>putAccountFixedCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fixedChargeId ID of the fixed charge
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPutAccountFixedChargeRequest
*/
func (a *AccountsReceivablesApiService) PutAccountFixedCharge(ctx context.Context, fixedChargeId string, accountId string, hotelId string) ApiPutAccountFixedChargeRequest {
	return ApiPutAccountFixedChargeRequest{
		ApiService: a,
		ctx: ctx,
		fixedChargeId: fixedChargeId,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutAccountFixedChargeExecute(r ApiPutAccountFixedChargeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutAccountFixedCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/fixedCharges/{fixedChargeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fixedChargeId"+"}", url.PathEscape(parameterValueToString(r.fixedChargeId, "fixedChargeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fixedChargeId) < 1 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have at least 1 elements")
	}
	if strlen(r.fixedChargeId) > 2000 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountFixedCharge == nil {
		return localVarReturnValue, nil, reportError("accountFixedCharge is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountFixedCharge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAccountTraceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountTrace *PutAccountTraceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAccountTraceRequest) Authorization(authorization string) ApiPutAccountTraceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAccountTraceRequest) XAppKey(xAppKey string) ApiPutAccountTraceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAccountTraceRequest) XHotelid(xHotelid string) ApiPutAccountTraceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Change the Trace on an Account.
func (r ApiPutAccountTraceRequest) AccountTrace(accountTrace PutAccountTraceRequest) ApiPutAccountTraceRequest {
	r.accountTrace = &accountTrace
	return r
}

// External system code.
func (r ApiPutAccountTraceRequest) XExternalsystem(xExternalsystem string) ApiPutAccountTraceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAccountTraceRequest) AcceptLanguage(acceptLanguage string) ApiPutAccountTraceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAccountTraceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountTraceExecute(r)
}

/*
PutAccountTrace This API facilitates modification of account traces.

 <p><strong>OperationId:</strong>putAccountTrace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiPutAccountTraceRequest
*/
func (a *AccountsReceivablesApiService) PutAccountTrace(ctx context.Context, accountId string, hotelId string) ApiPutAccountTraceRequest {
	return ApiPutAccountTraceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutAccountTraceExecute(r ApiPutAccountTraceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutAccountTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.accountTrace == nil {
		return localVarReturnValue, nil, reportError("accountTrace is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountTrace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	invoiceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoice *UncompressARInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutInvoiceRequest) Authorization(authorization string) ApiPutInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutInvoiceRequest) XAppKey(xAppKey string) ApiPutInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutInvoiceRequest) XHotelid(xHotelid string) ApiPutInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Response to the request to change invoice
func (r ApiPutInvoiceRequest) Invoice(invoice UncompressARInvoicesRequest) ApiPutInvoiceRequest {
	r.invoice = &invoice
	return r
}

// External system code.
func (r ApiPutInvoiceRequest) XExternalsystem(xExternalsystem string) ApiPutInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiPutInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInvoiceExecute(r)
}

/*
PutInvoice Update invoice detail.

Use this API to update or transfer invoice detail such as amount, transaction code, etc.<br><p><strong><mark>This API is deprecated. Please use putInvoiceDetails instead</mark></strong></p> <p><strong>OperationId:</strong>putInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId Unique ID of the invoice
 @param hotelId Unique ID of the hotel
 @return ApiPutInvoiceRequest

Deprecated
*/
func (a *AccountsReceivablesApiService) PutInvoice(ctx context.Context, invoiceId string, hotelId string) ApiPutInvoiceRequest {
	return ApiPutInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *AccountsReceivablesApiService) PutInvoiceExecute(r ApiPutInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.invoiceId) < 1 {
		return localVarReturnValue, nil, reportError("invoiceId must have at least 1 elements")
	}
	if strlen(r.invoiceId) > 2000 {
		return localVarReturnValue, nil, reportError("invoiceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.invoice == nil {
		return localVarReturnValue, nil, reportError("invoice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutInvoiceDetailsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoice *UncompressARInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutInvoiceDetailsRequest) Authorization(authorization string) ApiPutInvoiceDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutInvoiceDetailsRequest) XAppKey(xAppKey string) ApiPutInvoiceDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutInvoiceDetailsRequest) XHotelid(xHotelid string) ApiPutInvoiceDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Response to the request to change invoice
func (r ApiPutInvoiceDetailsRequest) Invoice(invoice UncompressARInvoicesRequest) ApiPutInvoiceDetailsRequest {
	r.invoice = &invoice
	return r
}

// External system code.
func (r ApiPutInvoiceDetailsRequest) XExternalsystem(xExternalsystem string) ApiPutInvoiceDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutInvoiceDetailsRequest) AcceptLanguage(acceptLanguage string) ApiPutInvoiceDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutInvoiceDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInvoiceDetailsExecute(r)
}

/*
PutInvoiceDetails Update invoice detail.

Use this API to update or transfer invoice detail such as amount, transaction code, etc. <p><strong>OperationId:</strong>putInvoiceDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiPutInvoiceDetailsRequest
*/
func (a *AccountsReceivablesApiService) PutInvoiceDetails(ctx context.Context, hotelId string) ApiPutInvoiceDetailsRequest {
	return ApiPutInvoiceDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutInvoiceDetailsExecute(r ApiPutInvoiceDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutInvoiceDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.invoice == nil {
		return localVarReturnValue, nil, reportError("invoice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	invoices *PutInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutInvoicesRequest) Authorization(authorization string) ApiPutInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutInvoicesRequest) XAppKey(xAppKey string) ApiPutInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutInvoicesRequest) XHotelid(xHotelid string) ApiPutInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to close invoice(s)
func (r ApiPutInvoicesRequest) Invoices(invoices PutInvoicesRequest) ApiPutInvoicesRequest {
	r.invoices = &invoices
	return r
}

// External system code.
func (r ApiPutInvoicesRequest) XExternalsystem(xExternalsystem string) ApiPutInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutInvoicesRequest) AcceptLanguage(acceptLanguage string) ApiPutInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInvoicesExecute(r)
}

/*
PutInvoices Close account receivable invoices

Use this API to close ("freeze") one or more selected invoices at any point after they have been created. When an invoice has been closed, no new postings to the invoice can be made, transaction reference or supplemental information can be edited, or adjustments to transaction codes can be made. However, payments can be posted to an invoice after it has been closed. <p><strong>OperationId:</strong>putInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutInvoicesRequest
*/
func (a *AccountsReceivablesApiService) PutInvoices(ctx context.Context) ApiPutInvoicesRequest {
	return ApiPutInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutInvoicesExecute(r ApiPutInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.invoices == nil {
		return localVarReturnValue, nil, reportError("invoices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemovePaymentsFromInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	transactionId string
	hotelId string
	trxNo *[]float32
	accountId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierID *float32
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Unique Transaction Identifier of the Payment.
func (r ApiRemovePaymentsFromInvoiceRequest) TrxNo(trxNo []float32) ApiRemovePaymentsFromInvoiceRequest {
	r.trxNo = &trxNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiRemovePaymentsFromInvoiceRequest) AccountId(accountId string) ApiRemovePaymentsFromInvoiceRequest {
	r.accountId = &accountId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiRemovePaymentsFromInvoiceRequest) Authorization(authorization string) ApiRemovePaymentsFromInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiRemovePaymentsFromInvoiceRequest) XAppKey(xAppKey string) ApiRemovePaymentsFromInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiRemovePaymentsFromInvoiceRequest) XHotelid(xHotelid string) ApiRemovePaymentsFromInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r ApiRemovePaymentsFromInvoiceRequest) CashierID(cashierID float32) ApiRemovePaymentsFromInvoiceRequest {
	r.cashierID = &cashierID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r ApiRemovePaymentsFromInvoiceRequest) InvoiceNo(invoiceNo float32) ApiRemovePaymentsFromInvoiceRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r ApiRemovePaymentsFromInvoiceRequest) XExternalsystem(xExternalsystem string) ApiRemovePaymentsFromInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiRemovePaymentsFromInvoiceRequest) AcceptLanguage(acceptLanguage string) ApiRemovePaymentsFromInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiRemovePaymentsFromInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemovePaymentsFromInvoiceExecute(r)
}

/*
RemovePaymentsFromInvoice Delete payments from invoice

Delete payments from invoice. <p><strong>OperationId:</strong>removePaymentsFromInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return ApiRemovePaymentsFromInvoiceRequest
*/
func (a *AccountsReceivablesApiService) RemovePaymentsFromInvoice(ctx context.Context, transactionId string, hotelId string) ApiRemovePaymentsFromInvoiceRequest {
	return ApiRemovePaymentsFromInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) RemovePaymentsFromInvoiceExecute(r ApiRemovePaymentsFromInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.RemovePaymentsFromInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/paymentsFromInvoice"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.trxNo == nil {
		return localVarReturnValue, nil, reportError("trxNo is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.trxNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	if r.cashierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierID", r.cashierID, "")
	}
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReopenInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	invoices *PutInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiReopenInvoicesRequest) Authorization(authorization string) ApiReopenInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiReopenInvoicesRequest) XAppKey(xAppKey string) ApiReopenInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiReopenInvoicesRequest) XHotelid(xHotelid string) ApiReopenInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to re-open closed invoice(s)
func (r ApiReopenInvoicesRequest) Invoices(invoices PutInvoicesRequest) ApiReopenInvoicesRequest {
	r.invoices = &invoices
	return r
}

// External system code.
func (r ApiReopenInvoicesRequest) XExternalsystem(xExternalsystem string) ApiReopenInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiReopenInvoicesRequest) AcceptLanguage(acceptLanguage string) ApiReopenInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiReopenInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReopenInvoicesExecute(r)
}

/*
ReopenInvoices Reopen account receivable closed invoice

Use this API to unfreeze or reopen invoice for account receivable. <p><strong>OperationId:</strong>reopenInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReopenInvoicesRequest
*/
func (a *AccountsReceivablesApiService) ReopenInvoices(ctx context.Context) ApiReopenInvoicesRequest {
	return ApiReopenInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) ReopenInvoicesExecute(r ApiReopenInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.ReopenInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reopenInvoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.invoices == nil {
		return localVarReturnValue, nil, reportError("invoices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferARCreditCardPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arCreditCardPaymentsToTransfer *TransferARCreditCardPaymentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferARCreditCardPaymentsRequest) Authorization(authorization string) ApiTransferARCreditCardPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferARCreditCardPaymentsRequest) XAppKey(xAppKey string) ApiTransferARCreditCardPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferARCreditCardPaymentsRequest) XHotelid(xHotelid string) ApiTransferARCreditCardPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to transfer AR Credit Card payments.
func (r ApiTransferARCreditCardPaymentsRequest) ArCreditCardPaymentsToTransfer(arCreditCardPaymentsToTransfer TransferARCreditCardPaymentsRequest) ApiTransferARCreditCardPaymentsRequest {
	r.arCreditCardPaymentsToTransfer = &arCreditCardPaymentsToTransfer
	return r
}

// External system code.
func (r ApiTransferARCreditCardPaymentsRequest) XExternalsystem(xExternalsystem string) ApiTransferARCreditCardPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferARCreditCardPaymentsRequest) AcceptLanguage(acceptLanguage string) ApiTransferARCreditCardPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferARCreditCardPaymentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferARCreditCardPaymentsExecute(r)
}

/*
TransferARCreditCardPayments Move credit card payment to account receivable

Use this API to transfer credit card payment transactions to Accounts Receivable. <p><strong>OperationId:</strong>transferARCreditCardPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiTransferARCreditCardPaymentsRequest
*/
func (a *AccountsReceivablesApiService) TransferARCreditCardPayments(ctx context.Context, accountId string, hotelId string) ApiTransferARCreditCardPaymentsRequest {
	return ApiTransferARCreditCardPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) TransferARCreditCardPaymentsExecute(r ApiTransferARCreditCardPaymentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.TransferARCreditCardPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/arCreditCard/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.arCreditCardPaymentsToTransfer == nil {
		return localVarReturnValue, nil, reportError("arCreditCardPaymentsToTransfer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arCreditCardPaymentsToTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferDirectBillsToArRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transferDirectBillsToAr *TransferDirectBillsToArRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferDirectBillsToArRequest) Authorization(authorization string) ApiTransferDirectBillsToArRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferDirectBillsToArRequest) XAppKey(xAppKey string) ApiTransferDirectBillsToArRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferDirectBillsToArRequest) XHotelid(xHotelid string) ApiTransferDirectBillsToArRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for Transfer Directs bill to AR.
func (r ApiTransferDirectBillsToArRequest) TransferDirectBillsToAr(transferDirectBillsToAr TransferDirectBillsToArRequest) ApiTransferDirectBillsToArRequest {
	r.transferDirectBillsToAr = &transferDirectBillsToAr
	return r
}

// External system code.
func (r ApiTransferDirectBillsToArRequest) XExternalsystem(xExternalsystem string) ApiTransferDirectBillsToArRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferDirectBillsToArRequest) AcceptLanguage(acceptLanguage string) ApiTransferDirectBillsToArRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferDirectBillsToArRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferDirectBillsToArExecute(r)
}

/*
TransferDirectBillsToAr Move direct bills to account receivable

Use this API to transfer direct bills to account receivable account <p><strong>OperationId:</strong>transferDirectBillsToAr</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiTransferDirectBillsToArRequest
*/
func (a *AccountsReceivablesApiService) TransferDirectBillsToAr(ctx context.Context, hotelId string) ApiTransferDirectBillsToArRequest {
	return ApiTransferDirectBillsToArRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) TransferDirectBillsToArExecute(r ApiTransferDirectBillsToArRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.TransferDirectBillsToAr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/directBillsToAR"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transferDirectBillsToAr == nil {
		return localVarReturnValue, nil, reportError("transferDirectBillsToAr is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transferDirectBillsToAr
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferInvoicesAndPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	invoicesAndPaymentsToTransfer *TransferInvoicesAndPaymentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferInvoicesAndPaymentsRequest) Authorization(authorization string) ApiTransferInvoicesAndPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferInvoicesAndPaymentsRequest) XAppKey(xAppKey string) ApiTransferInvoicesAndPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferInvoicesAndPaymentsRequest) XHotelid(xHotelid string) ApiTransferInvoicesAndPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transferring invoice(s) in AR.
func (r ApiTransferInvoicesAndPaymentsRequest) InvoicesAndPaymentsToTransfer(invoicesAndPaymentsToTransfer TransferInvoicesAndPaymentsRequest) ApiTransferInvoicesAndPaymentsRequest {
	r.invoicesAndPaymentsToTransfer = &invoicesAndPaymentsToTransfer
	return r
}

// External system code.
func (r ApiTransferInvoicesAndPaymentsRequest) XExternalsystem(xExternalsystem string) ApiTransferInvoicesAndPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferInvoicesAndPaymentsRequest) AcceptLanguage(acceptLanguage string) ApiTransferInvoicesAndPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferInvoicesAndPaymentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferInvoicesAndPaymentsExecute(r)
}

/*
TransferInvoicesAndPayments Move an invoice or a payment to another AR account

Use this API to move all or a portion of an invoice or a payment from one AR account to another AR account <p><strong>OperationId:</strong>transferInvoicesAndPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferInvoicesAndPaymentsRequest
*/
func (a *AccountsReceivablesApiService) TransferInvoicesAndPayments(ctx context.Context) ApiTransferInvoicesAndPaymentsRequest {
	return ApiTransferInvoicesAndPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) TransferInvoicesAndPaymentsExecute(r ApiTransferInvoicesAndPaymentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.TransferInvoicesAndPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferInvoicesAndPayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.invoicesAndPaymentsToTransfer == nil {
		return localVarReturnValue, nil, reportError("invoicesAndPaymentsToTransfer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoicesAndPaymentsToTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferPostingsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transferPostings *TransferPostingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiTransferPostingsRequest) Authorization(authorization string) ApiTransferPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiTransferPostingsRequest) XAppKey(xAppKey string) ApiTransferPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiTransferPostingsRequest) XHotelid(xHotelid string) ApiTransferPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transferring invoice posting(s)in AR.
func (r ApiTransferPostingsRequest) TransferPostings(transferPostings TransferPostingsRequest) ApiTransferPostingsRequest {
	r.transferPostings = &transferPostings
	return r
}

// External system code.
func (r ApiTransferPostingsRequest) XExternalsystem(xExternalsystem string) ApiTransferPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiTransferPostingsRequest) AcceptLanguage(acceptLanguage string) ApiTransferPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiTransferPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferPostingsExecute(r)
}

/*
TransferPostings Transfer postings

Use this API to transfer postings from one account receivable invoice to another account receivable invoice. <p><strong>OperationId:</strong>transferPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferPostingsRequest
*/
func (a *AccountsReceivablesApiService) TransferPostings(ctx context.Context) ApiTransferPostingsRequest {
	return ApiTransferPostingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) TransferPostingsExecute(r ApiTransferPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.TransferPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferPostings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.transferPostings == nil {
		return localVarReturnValue, nil, reportError("transferPostings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transferPostings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUncompressARInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoice *UncompressARInvoicesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiUncompressARInvoicesRequest) Authorization(authorization string) ApiUncompressARInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiUncompressARInvoicesRequest) XAppKey(xAppKey string) ApiUncompressARInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiUncompressARInvoicesRequest) XHotelid(xHotelid string) ApiUncompressARInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to uncompress a compressed(Parent) Invoice
func (r ApiUncompressARInvoicesRequest) Invoice(invoice UncompressARInvoicesRequest) ApiUncompressARInvoicesRequest {
	r.invoice = &invoice
	return r
}

// External system code.
func (r ApiUncompressARInvoicesRequest) XExternalsystem(xExternalsystem string) ApiUncompressARInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiUncompressARInvoicesRequest) AcceptLanguage(acceptLanguage string) ApiUncompressARInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiUncompressARInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UncompressARInvoicesExecute(r)
}

/*
UncompressARInvoices Reverse the compressing invoice process

Use this API to reverse compressing account receivable invoices and break single combined invoice into individual invoices. <p><strong>OperationId:</strong>uncompressARInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return ApiUncompressARInvoicesRequest
*/
func (a *AccountsReceivablesApiService) UncompressARInvoices(ctx context.Context, accountId string, hotelId string) ApiUncompressARInvoicesRequest {
	return ApiUncompressARInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) UncompressARInvoicesExecute(r ApiUncompressARInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.UncompressARInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/uncompressInvoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.invoice == nil {
		return localVarReturnValue, nil, reportError("invoice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlinkInvoiceFromStatementRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	unlinkInvoiceFromStatement *UnlinkInvoiceFromStatementRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiUnlinkInvoiceFromStatementRequest) Authorization(authorization string) ApiUnlinkInvoiceFromStatementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiUnlinkInvoiceFromStatementRequest) XAppKey(xAppKey string) ApiUnlinkInvoiceFromStatementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiUnlinkInvoiceFromStatementRequest) XHotelid(xHotelid string) ApiUnlinkInvoiceFromStatementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to unlink invoice from statement
func (r ApiUnlinkInvoiceFromStatementRequest) UnlinkInvoiceFromStatement(unlinkInvoiceFromStatement UnlinkInvoiceFromStatementRequest) ApiUnlinkInvoiceFromStatementRequest {
	r.unlinkInvoiceFromStatement = &unlinkInvoiceFromStatement
	return r
}

// External system code.
func (r ApiUnlinkInvoiceFromStatementRequest) XExternalsystem(xExternalsystem string) ApiUnlinkInvoiceFromStatementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiUnlinkInvoiceFromStatementRequest) AcceptLanguage(acceptLanguage string) ApiUnlinkInvoiceFromStatementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiUnlinkInvoiceFromStatementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UnlinkInvoiceFromStatementExecute(r)
}

/*
UnlinkInvoiceFromStatement Unlink invoices from a statement

Use this API to remove the invoice from the statement before that invoice can be included in a different statement. <p><strong>OperationId:</strong>unlinkInvoiceFromStatement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return ApiUnlinkInvoiceFromStatementRequest
*/
func (a *AccountsReceivablesApiService) UnlinkInvoiceFromStatement(ctx context.Context, hotelId string) ApiUnlinkInvoiceFromStatementRequest {
	return ApiUnlinkInvoiceFromStatementRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) UnlinkInvoiceFromStatementExecute(r ApiUnlinkInvoiceFromStatementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.UnlinkInvoiceFromStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/unlink/invoiceFromStatement"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.unlinkInvoiceFromStatement == nil {
		return localVarReturnValue, nil, reportError("unlinkInvoiceFromStatement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.unlinkInvoiceFromStatement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
