/*
OPERA Cloud Channel Configuration API

APIs to cater for Channel Management functionality in OPERA Cloud. <br /><br /> Channel Management allows a property to configure and administer channels such as OTAs, and web channels, covering functionality such as channel configuration, availability, inventory and restrictions.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChannelApiService ChannelApi service
type ChannelApiService service

type ApiCopyChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountContractsCopy *CopyChannelAccountContractsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCopyChannelAccountContractsRequest) Authorization(authorization string) ApiCopyChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCopyChannelAccountContractsRequest) XAppKey(xAppKey string) ApiCopyChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCopyChannelAccountContractsRequest) XHotelid(xHotelid string) ApiCopyChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy the channel account contract and create a new contract.
func (r ApiCopyChannelAccountContractsRequest) ChannelAccountContractsCopy(channelAccountContractsCopy CopyChannelAccountContractsRequest) ApiCopyChannelAccountContractsRequest {
	r.channelAccountContractsCopy = &channelAccountContractsCopy
	return r
}

// External system code.
func (r ApiCopyChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ApiCopyChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCopyChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ApiCopyChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCopyChannelAccountContractsRequest) Execute() (*ChannelAccountContractsDetailsCopy, *http.Response, error) {
	return r.ApiService.CopyChannelAccountContractsExecute(r)
}

/*
CopyChannelAccountContracts Creates copy of channel account contracts

This API creates copy of channel account contracts. <p><strong>OperationId:</strong>copyChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCopyChannelAccountContractsRequest
*/
func (a *ChannelApiService) CopyChannelAccountContracts(ctx context.Context) ApiCopyChannelAccountContractsRequest {
	return ApiCopyChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelAccountContractsDetailsCopy
func (a *ChannelApiService) CopyChannelAccountContractsExecute(r ApiCopyChannelAccountContractsRequest) (*ChannelAccountContractsDetailsCopy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccountContractsDetailsCopy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CopyChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/account/contracts/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelAccountContractsCopy == nil {
		return localVarReturnValue, nil, reportError("channelAccountContractsCopy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountContractsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelMarketingTextCopy *CopyChannelMarketingTextRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCopyChannelMarketingTextRequest) Authorization(authorization string) ApiCopyChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCopyChannelMarketingTextRequest) XAppKey(xAppKey string) ApiCopyChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCopyChannelMarketingTextRequest) XHotelid(xHotelid string) ApiCopyChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy channel marketing texts.
func (r ApiCopyChannelMarketingTextRequest) ChannelMarketingTextCopy(channelMarketingTextCopy CopyChannelMarketingTextRequest) ApiCopyChannelMarketingTextRequest {
	r.channelMarketingTextCopy = &channelMarketingTextCopy
	return r
}

// External system code.
func (r ApiCopyChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ApiCopyChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCopyChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ApiCopyChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCopyChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyChannelMarketingTextExecute(r)
}

/*
CopyChannelMarketingText Allows to copy marketing message to another channel and hotel

Use this API to copy one channel's mapping for marketing messages to another channel and hotel mapping. <p><strong>OperationId:</strong>copyChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCopyChannelMarketingTextRequest
*/
func (a *ChannelApiService) CopyChannelMarketingText(ctx context.Context) ApiCopyChannelMarketingTextRequest {
	return ApiCopyChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) CopyChannelMarketingTextExecute(r ApiCopyChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CopyChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelMarketingTextCopy == nil {
		return localVarReturnValue, nil, reportError("channelMarketingTextCopy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelMarketingTextCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	totalPricingElementsCopy *CopyTotalPricingElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCopyTotalPricingElementsRequest) Authorization(authorization string) ApiCopyTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCopyTotalPricingElementsRequest) XAppKey(xAppKey string) ApiCopyTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiCopyTotalPricingElementsRequest) XHotelid(xHotelid string) ApiCopyTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy the total pricing elements into the target properties.
func (r ApiCopyTotalPricingElementsRequest) TotalPricingElementsCopy(totalPricingElementsCopy CopyTotalPricingElementsRequest) ApiCopyTotalPricingElementsRequest {
	r.totalPricingElementsCopy = &totalPricingElementsCopy
	return r
}

// External system code.
func (r ApiCopyTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ApiCopyTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiCopyTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ApiCopyTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCopyTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTotalPricingElementsExecute(r)
}

/*
CopyTotalPricingElements Allows to copy total pricing tax and fees to another hotel id

Use this API to copy global distribution system's fee and tax configurations from one hotel to another hotel within same chain/tenant <p><strong>OperationId:</strong>copyTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCopyTotalPricingElementsRequest
*/
func (a *ChannelApiService) CopyTotalPricingElements(ctx context.Context) ApiCopyTotalPricingElementsRequest {
	return ApiCopyTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) CopyTotalPricingElementsExecute(r ApiCopyTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CopyTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.totalPricingElementsCopy == nil {
		return localVarReturnValue, nil, reportError("totalPricingElementsCopy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.totalPricingElementsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	amenityGroup *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteAmenitiesMappingRequest) Authorization(authorization string) ApiDeleteAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteAmenitiesMappingRequest) XAppKey(xAppKey string) ApiDeleteAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteAmenitiesMappingRequest) XHotelid(xHotelid string) ApiDeleteAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ApiDeleteAmenitiesMappingRequest) Inactive(inactive bool) ApiDeleteAmenitiesMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ApiDeleteAmenitiesMappingRequest) SystemCode(systemCode string) ApiDeleteAmenitiesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ApiDeleteAmenitiesMappingRequest) SystemSubType(systemSubType string) ApiDeleteAmenitiesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ApiDeleteAmenitiesMappingRequest) SystemType(systemType string) ApiDeleteAmenitiesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ApiDeleteAmenitiesMappingRequest) SystemName(systemName string) ApiDeleteAmenitiesMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ApiDeleteAmenitiesMappingRequest) WebsiteURL(websiteURL string) ApiDeleteAmenitiesMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ApiDeleteAmenitiesMappingRequest) IconURL(iconURL string) ApiDeleteAmenitiesMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ApiDeleteAmenitiesMappingRequest) LocalSystemCode(localSystemCode []string) ApiDeleteAmenitiesMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ApiDeleteAmenitiesMappingRequest) ExternalSystemCode(externalSystemCode []string) ApiDeleteAmenitiesMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ApiDeleteAmenitiesMappingRequest) Description(description []string) ApiDeleteAmenitiesMappingRequest {
	r.description = &description
	return r
}

func (r ApiDeleteAmenitiesMappingRequest) StartDate(startDate string) ApiDeleteAmenitiesMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteAmenitiesMappingRequest) EndDate(endDate string) ApiDeleteAmenitiesMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteAmenitiesMappingRequest) Duration(duration string) ApiDeleteAmenitiesMappingRequest {
	r.duration = &duration
	return r
}

// User defined logical group name for the amenities.
func (r ApiDeleteAmenitiesMappingRequest) AmenityGroup(amenityGroup []string) ApiDeleteAmenitiesMappingRequest {
	r.amenityGroup = &amenityGroup
	return r
}

// External system code.
func (r ApiDeleteAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteAmenitiesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAmenitiesMappingExecute(r)
}

/*
DeleteAmenitiesMapping Deletes channel amenities configuration

Use this API to delete channel amenities mapping <p><strong>OperationId:</strong>deleteAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAmenitiesMappingRequest
*/
func (a *ChannelApiService) DeleteAmenitiesMapping(ctx context.Context) ApiDeleteAmenitiesMappingRequest {
	return ApiDeleteAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteAmenitiesMappingExecute(r ApiDeleteAmenitiesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.amenityGroup != nil {
		t := *r.amenityGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amenityGroup", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amenityGroup", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	id1 *[]string
	idExtension1 *[]int32
	idContext1 *[]string
	type1 *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelAccountContractsRequest) Authorization(authorization string) ApiDeleteChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelAccountContractsRequest) XAppKey(xAppKey string) ApiDeleteChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelAccountContractsRequest) XHotelid(xHotelid string) ApiDeleteChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteChannelAccountContractsRequest) Id(id string) ApiDeleteChannelAccountContractsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeleteChannelAccountContractsRequest) IdExtension(idExtension int32) ApiDeleteChannelAccountContractsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeleteChannelAccountContractsRequest) IdContext(idContext string) ApiDeleteChannelAccountContractsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeleteChannelAccountContractsRequest) Type_(type_ string) ApiDeleteChannelAccountContractsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteChannelAccountContractsRequest) Id1(id1 []string) ApiDeleteChannelAccountContractsRequest {
	r.id1 = &id1
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeleteChannelAccountContractsRequest) IdExtension1(idExtension1 []int32) ApiDeleteChannelAccountContractsRequest {
	r.idExtension1 = &idExtension1
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeleteChannelAccountContractsRequest) IdContext1(idContext1 []string) ApiDeleteChannelAccountContractsRequest {
	r.idContext1 = &idContext1
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeleteChannelAccountContractsRequest) Type1(type1 []string) ApiDeleteChannelAccountContractsRequest {
	r.type1 = &type1
	return r
}

// External system code.
func (r ApiDeleteChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelAccountContractsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelAccountContractsExecute(r)
}

/*
DeleteChannelAccountContracts Deletes channel account contracts.

This API deletes channel account contracts. <p><strong>OperationId:</strong>deleteChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelAccountContractsRequest
*/
func (a *ChannelApiService) DeleteChannelAccountContracts(ctx context.Context) ApiDeleteChannelAccountContractsRequest {
	return ApiDeleteChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelAccountContractsExecute(r ApiDeleteChannelAccountContractsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/account/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.id1 != nil {
		t := *r.id1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id1", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id1", t, "multi")
		}
	}
	if r.idExtension1 != nil {
		t := *r.idExtension1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension1", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension1", t, "multi")
		}
	}
	if r.idContext1 != nil {
		t := *r.idContext1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext1", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext1", t, "multi")
		}
	}
	if r.type1 != nil {
		t := *r.type1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type1", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type1", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idExtension *[]int32
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelBillingStatementsRequest) Authorization(authorization string) ApiDeleteChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelBillingStatementsRequest) XAppKey(xAppKey string) ApiDeleteChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelBillingStatementsRequest) XHotelid(xHotelid string) ApiDeleteChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteChannelBillingStatementsRequest) Id(id []string) ApiDeleteChannelBillingStatementsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ApiDeleteChannelBillingStatementsRequest) IdExtension(idExtension []int32) ApiDeleteChannelBillingStatementsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeleteChannelBillingStatementsRequest) IdContext(idContext []string) ApiDeleteChannelBillingStatementsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeleteChannelBillingStatementsRequest) Type_(type_ []string) ApiDeleteChannelBillingStatementsRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ApiDeleteChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelBillingStatementsExecute(r)
}

/*
DeleteChannelBillingStatements Deletes channel billing statements.

This API deletes channel billing statements. <p><strong>OperationId:</strong>deleteChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelBillingStatementsRequest
*/
func (a *ChannelApiService) DeleteChannelBillingStatements(ctx context.Context) ApiDeleteChannelBillingStatementsRequest {
	return ApiDeleteChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelBillingStatementsExecute(r ApiDeleteChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idExtension != nil {
		t := *r.idExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelCardTypeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	cardTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCardType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelCardTypeMappingRequest) Authorization(authorization string) ApiDeleteChannelCardTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelCardTypeMappingRequest) XAppKey(xAppKey string) ApiDeleteChannelCardTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelCardTypeMappingRequest) XHotelid(xHotelid string) ApiDeleteChannelCardTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ApiDeleteChannelCardTypeMappingRequest) ChannelCardType(channelCardType string) ApiDeleteChannelCardTypeMappingRequest {
	r.channelCardType = &channelCardType
	return r
}

// External system code.
func (r ApiDeleteChannelCardTypeMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelCardTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelCardTypeMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelCardTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelCardTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelCardTypeMappingExecute(r)
}

/*
DeleteChannelCardTypeMapping Deletes channel credit card mapping for a hotel

Use this API to delete channel mapping for OPERA credit cards to channel for a given hotel id. <p><strong>OperationId:</strong>deleteChannelCardTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardTypeCode Unique ID that identifies a channel.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiDeleteChannelCardTypeMappingRequest
*/
func (a *ChannelApiService) DeleteChannelCardTypeMapping(ctx context.Context, cardTypeCode string, channelCode string, hotelId string) ApiDeleteChannelCardTypeMappingRequest {
	return ApiDeleteChannelCardTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
		cardTypeCode: cardTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelCardTypeMappingExecute(r ApiDeleteChannelCardTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelCardTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/cardType/{cardTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardTypeCode"+"}", url.PathEscape(parameterValueToString(r.cardTypeCode, "cardTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have at least 1 elements")
	}
	if strlen(r.cardTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.channelCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelCardType", r.channelCardType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelCarriersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	carriers *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of carrier.
func (r ApiDeleteChannelCarriersRequest) BookingChannelCodes(bookingChannelCodes []string) ApiDeleteChannelCarriersRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of carrier.
func (r ApiDeleteChannelCarriersRequest) Carriers(carriers []string) ApiDeleteChannelCarriersRequest {
	r.carriers = &carriers
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelCarriersRequest) Authorization(authorization string) ApiDeleteChannelCarriersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelCarriersRequest) XAppKey(xAppKey string) ApiDeleteChannelCarriersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelCarriersRequest) XHotelid(xHotelid string) ApiDeleteChannelCarriersRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteChannelCarriersRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelCarriersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelCarriersRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelCarriersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelCarriersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelCarriersExecute(r)
}

/*
DeleteChannelCarriers Deletes sub channel configuration

Use this API to delete sub-channel (carrier) configuration for a given channel code. <p><strong>OperationId:</strong>deleteChannelCarriers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelCarriersRequest
*/
func (a *ChannelApiService) DeleteChannelCarriers(ctx context.Context) ApiDeleteChannelCarriersRequest {
	return ApiDeleteChannelCarriersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelCarriersExecute(r ApiDeleteChannelCarriersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/subChannels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bookingChannelCodes == nil {
		return localVarReturnValue, nil, reportError("bookingChannelCodes is required and must be specified")
	}
	if r.carriers == nil {
		return localVarReturnValue, nil, reportError("carriers is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.carriers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "carriers", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "carriers", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelErrorsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	bookingChannelCode *[]string
	error_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelErrorsRequest) Authorization(authorization string) ApiDeleteChannelErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelErrorsRequest) XAppKey(xAppKey string) ApiDeleteChannelErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelErrorsRequest) XHotelid(xHotelid string) ApiDeleteChannelErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Booking channel code of error.
func (r ApiDeleteChannelErrorsRequest) BookingChannelCode(bookingChannelCode []string) ApiDeleteChannelErrorsRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Code of error.
func (r ApiDeleteChannelErrorsRequest) Error_(error_ []string) ApiDeleteChannelErrorsRequest {
	r.error_ = &error_
	return r
}

// External system code.
func (r ApiDeleteChannelErrorsRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelErrorsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelErrorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelErrorsExecute(r)
}

/*
DeleteChannelErrors Deletes channel error codes

Use this API to delete channel error code mapping configurations. <p><strong>OperationId:</strong>deleteChannelErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelErrorsRequest
*/
func (a *ChannelApiService) DeleteChannelErrors(ctx context.Context) ApiDeleteChannelErrorsRequest {
	return ApiDeleteChannelErrorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelErrorsExecute(r ApiDeleteChannelErrorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/errorCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.error_ != nil {
		t := *r.error_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "error", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "error", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelGuaranteeCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	guaranteeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelGuaranteeCodeMappingRequest) Authorization(authorization string) ApiDeleteChannelGuaranteeCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelGuaranteeCodeMappingRequest) XAppKey(xAppKey string) ApiDeleteChannelGuaranteeCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelGuaranteeCodeMappingRequest) XHotelid(xHotelid string) ApiDeleteChannelGuaranteeCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteChannelGuaranteeCodeMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelGuaranteeCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelGuaranteeCodeMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelGuaranteeCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelGuaranteeCodeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelGuaranteeCodeMappingExecute(r)
}

/*
DeleteChannelGuaranteeCodeMapping Deletes channel guarantee code mapping for a hotel

Use this API to delete channel guarantee code mapping to OPERA guarantee code for a given property. <p><strong>OperationId:</strong>deleteChannelGuaranteeCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guaranteeCode Guarantee Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiDeleteChannelGuaranteeCodeMappingRequest
*/
func (a *ChannelApiService) DeleteChannelGuaranteeCodeMapping(ctx context.Context, guaranteeCode string, channelCode string, hotelId string) ApiDeleteChannelGuaranteeCodeMappingRequest {
	return ApiDeleteChannelGuaranteeCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		guaranteeCode: guaranteeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelGuaranteeCodeMappingExecute(r ApiDeleteChannelGuaranteeCodeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelGuaranteeCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/guarantees/{guaranteeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guaranteeCode"+"}", url.PathEscape(parameterValueToString(r.guaranteeCode, "guaranteeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guaranteeCode) < 1 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have at least 1 elements")
	}
	if strlen(r.guaranteeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	code *string
	description *string
	hotelId *[]string
	code1 *string
	description1 *string
	letterType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelHotelLettersRequest) Authorization(authorization string) ApiDeleteChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelHotelLettersRequest) XAppKey(xAppKey string) ApiDeleteChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelHotelLettersRequest) XHotelid(xHotelid string) ApiDeleteChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code.
func (r ApiDeleteChannelHotelLettersRequest) Code(code string) ApiDeleteChannelHotelLettersRequest {
	r.code = &code
	return r
}

// description.
func (r ApiDeleteChannelHotelLettersRequest) Description(description string) ApiDeleteChannelHotelLettersRequest {
	r.description = &description
	return r
}

// Hotel code which the hotel letters belong to.
func (r ApiDeleteChannelHotelLettersRequest) HotelId(hotelId []string) ApiDeleteChannelHotelLettersRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ApiDeleteChannelHotelLettersRequest) Code1(code1 string) ApiDeleteChannelHotelLettersRequest {
	r.code1 = &code1
	return r
}

// description.
func (r ApiDeleteChannelHotelLettersRequest) Description1(description1 string) ApiDeleteChannelHotelLettersRequest {
	r.description1 = &description1
	return r
}

// Represents Inquiry Letter Type.
func (r ApiDeleteChannelHotelLettersRequest) LetterType(letterType []string) ApiDeleteChannelHotelLettersRequest {
	r.letterType = &letterType
	return r
}

// External system code.
func (r ApiDeleteChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelHotelLettersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelHotelLettersExecute(r)
}

/*
DeleteChannelHotelLetters Deletes channel property confirmation letter mapping

Use this API to delete channel property confirmation letter configuration. <p><strong>OperationId:</strong>deleteChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelHotelLettersRequest
*/
func (a *ChannelApiService) DeleteChannelHotelLetters(ctx context.Context) ApiDeleteChannelHotelLettersRequest {
	return ApiDeleteChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelHotelLettersExecute(r ApiDeleteChannelHotelLettersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code1", r.code1, "")
	}
	if r.description1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description1", r.description1, "")
	}
	if r.letterType != nil {
		t := *r.letterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "letterType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "letterType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	beginDate *[]string
	bookingChannelCode *[]string
	endDate *[]string
	globalTextYN *[]bool
	hotelId *[]string
	marketingText *[]string
	policyDetail *[]string
	policyType *[]string
	transactionType *[]string
	newHotelId *[]string
	newTransactionType *[]string
	newPolicyType *[]string
	newPolicyDetail *[]string
	newBeginDate *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelMarketingTextRequest) Authorization(authorization string) ApiDeleteChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelMarketingTextRequest) XAppKey(xAppKey string) ApiDeleteChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelMarketingTextRequest) XHotelid(xHotelid string) ApiDeleteChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) BeginDate(beginDate []string) ApiDeleteChannelMarketingTextRequest {
	r.beginDate = &beginDate
	return r
}

// The code that identifies a Booking Channel.
func (r ApiDeleteChannelMarketingTextRequest) BookingChannelCode(bookingChannelCode []string) ApiDeleteChannelMarketingTextRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) EndDate(endDate []string) ApiDeleteChannelMarketingTextRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) GlobalTextYN(globalTextYN []bool) ApiDeleteChannelMarketingTextRequest {
	r.globalTextYN = &globalTextYN
	return r
}

// The code that identifies a Hotel.
func (r ApiDeleteChannelMarketingTextRequest) HotelId(hotelId []string) ApiDeleteChannelMarketingTextRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) MarketingText(marketingText []string) ApiDeleteChannelMarketingTextRequest {
	r.marketingText = &marketingText
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) PolicyDetail(policyDetail []string) ApiDeleteChannelMarketingTextRequest {
	r.policyDetail = &policyDetail
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) PolicyType(policyType []string) ApiDeleteChannelMarketingTextRequest {
	r.policyType = &policyType
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) TransactionType(transactionType []string) ApiDeleteChannelMarketingTextRequest {
	r.transactionType = &transactionType
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) NewHotelId(newHotelId []string) ApiDeleteChannelMarketingTextRequest {
	r.newHotelId = &newHotelId
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) NewTransactionType(newTransactionType []string) ApiDeleteChannelMarketingTextRequest {
	r.newTransactionType = &newTransactionType
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) NewPolicyType(newPolicyType []string) ApiDeleteChannelMarketingTextRequest {
	r.newPolicyType = &newPolicyType
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) NewPolicyDetail(newPolicyDetail []string) ApiDeleteChannelMarketingTextRequest {
	r.newPolicyDetail = &newPolicyDetail
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) NewBeginDate(newBeginDate []string) ApiDeleteChannelMarketingTextRequest {
	r.newBeginDate = &newBeginDate
	return r
}

// External system code.
func (r ApiDeleteChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelMarketingTextExecute(r)
}

/*
DeleteChannelMarketingText Deletes channel marketing messages

Use this API to delete channel mapping for marketing messages. <p><strong>OperationId:</strong>deleteChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelMarketingTextRequest
*/
func (a *ChannelApiService) DeleteChannelMarketingText(ctx context.Context) ApiDeleteChannelMarketingTextRequest {
	return ApiDeleteChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelMarketingTextExecute(r ApiDeleteChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.beginDate != nil {
		t := *r.beginDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", t, "multi")
		}
	}
	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.endDate != nil {
		t := *r.endDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", t, "multi")
		}
	}
	if r.globalTextYN != nil {
		t := *r.globalTextYN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "globalTextYN", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "globalTextYN", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.marketingText != nil {
		t := *r.marketingText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketingText", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketingText", t, "multi")
		}
	}
	if r.policyDetail != nil {
		t := *r.policyDetail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetail", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetail", t, "multi")
		}
	}
	if r.policyType != nil {
		t := *r.policyType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyType", t, "multi")
		}
	}
	if r.transactionType != nil {
		t := *r.transactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", t, "multi")
		}
	}
	if r.newHotelId != nil {
		t := *r.newHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newHotelId", t, "multi")
		}
	}
	if r.newTransactionType != nil {
		t := *r.newTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newTransactionType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newTransactionType", t, "multi")
		}
	}
	if r.newPolicyType != nil {
		t := *r.newPolicyType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyType", t, "multi")
		}
	}
	if r.newPolicyDetail != nil {
		t := *r.newPolicyDetail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyDetail", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyDetail", t, "multi")
		}
	}
	if r.newBeginDate != nil {
		t := *r.newBeginDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newBeginDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newBeginDate", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	bookingChannelCode *string
	channelRatePlanCode *string
	hotelId *string
	id *[]string
	idContext *[]string
	type_ *[]string
	externalSystem *string
	language *string
	nameType *string
	namePrefix *string
	givenName *string
	middleName *string
	surname *string
	nameSuffix *string
	nameTitle *string
	nameTitleSuffix *int32
	envelopeGreeting *string
	salutation *string
	accessCode *[]string
	end *[]string
	start *[]string
	newAccessCode *string
	channelRatePlanCodeOrder *int32
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelNegotiatedRateRequest) Authorization(authorization string) ApiDeleteChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelNegotiatedRateRequest) XAppKey(xAppKey string) ApiDeleteChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelNegotiatedRateRequest) XHotelid(xHotelid string) ApiDeleteChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Booking Channel Code.
func (r ApiDeleteChannelNegotiatedRateRequest) BookingChannelCode(bookingChannelCode string) ApiDeleteChannelNegotiatedRateRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Channel Room Type.
func (r ApiDeleteChannelNegotiatedRateRequest) ChannelRatePlanCode(channelRatePlanCode string) ApiDeleteChannelNegotiatedRateRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

// Hotel Code.
func (r ApiDeleteChannelNegotiatedRateRequest) HotelId(hotelId string) ApiDeleteChannelNegotiatedRateRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiDeleteChannelNegotiatedRateRequest) Id(id []string) ApiDeleteChannelNegotiatedRateRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiDeleteChannelNegotiatedRateRequest) IdContext(idContext []string) ApiDeleteChannelNegotiatedRateRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiDeleteChannelNegotiatedRateRequest) Type_(type_ []string) ApiDeleteChannelNegotiatedRateRequest {
	r.type_ = &type_
	return r
}

// When name type is external, indicates the external system the name belongs to.
func (r ApiDeleteChannelNegotiatedRateRequest) ExternalSystem(externalSystem string) ApiDeleteChannelNegotiatedRateRequest {
	r.externalSystem = &externalSystem
	return r
}

// Language code associated with an alternate name.
func (r ApiDeleteChannelNegotiatedRateRequest) Language(language string) ApiDeleteChannelNegotiatedRateRequest {
	r.language = &language
	return r
}

// Person&#39;s name in an external system.
func (r ApiDeleteChannelNegotiatedRateRequest) NameType(nameType string) ApiDeleteChannelNegotiatedRateRequest {
	r.nameType = &nameType
	return r
}

// Salutation of honorific (e.g. Mr., Mrs., Ms., Miss, Dr.)
func (r ApiDeleteChannelNegotiatedRateRequest) NamePrefix(namePrefix string) ApiDeleteChannelNegotiatedRateRequest {
	r.namePrefix = &namePrefix
	return r
}

// Given name, first name or names.
func (r ApiDeleteChannelNegotiatedRateRequest) GivenName(givenName string) ApiDeleteChannelNegotiatedRateRequest {
	r.givenName = &givenName
	return r
}

// The middle name of the person name.
func (r ApiDeleteChannelNegotiatedRateRequest) MiddleName(middleName string) ApiDeleteChannelNegotiatedRateRequest {
	r.middleName = &middleName
	return r
}

// Family name, last name. May also be used for full name if the sending system does not have the ability to separate a full name into its parts, e.g. the surname element may be used to pass the full name.
func (r ApiDeleteChannelNegotiatedRateRequest) Surname(surname string) ApiDeleteChannelNegotiatedRateRequest {
	r.surname = &surname
	return r
}

// Hold various name suffixes and letters (e.g. Jr., Sr., III, Ret., Esq.)
func (r ApiDeleteChannelNegotiatedRateRequest) NameSuffix(nameSuffix string) ApiDeleteChannelNegotiatedRateRequest {
	r.nameSuffix = &nameSuffix
	return r
}

// Degree or honors (e.g., Ph.D., M.D.)
func (r ApiDeleteChannelNegotiatedRateRequest) NameTitle(nameTitle string) ApiDeleteChannelNegotiatedRateRequest {
	r.nameTitle = &nameTitle
	return r
}

// Title Suffix. Must be populated if ADVANCED_TITLE is on.
func (r ApiDeleteChannelNegotiatedRateRequest) NameTitleSuffix(nameTitleSuffix int32) ApiDeleteChannelNegotiatedRateRequest {
	r.nameTitleSuffix = &nameTitleSuffix
	return r
}

// Envelope Greeting of the profile
func (r ApiDeleteChannelNegotiatedRateRequest) EnvelopeGreeting(envelopeGreeting string) ApiDeleteChannelNegotiatedRateRequest {
	r.envelopeGreeting = &envelopeGreeting
	return r
}

// Salutation of the profile
func (r ApiDeleteChannelNegotiatedRateRequest) Salutation(salutation string) ApiDeleteChannelNegotiatedRateRequest {
	r.salutation = &salutation
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) AccessCode(accessCode []string) ApiDeleteChannelNegotiatedRateRequest {
	r.accessCode = &accessCode
	return r
}

// The ending value of the date range.
func (r ApiDeleteChannelNegotiatedRateRequest) End(end []string) ApiDeleteChannelNegotiatedRateRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ApiDeleteChannelNegotiatedRateRequest) Start(start []string) ApiDeleteChannelNegotiatedRateRequest {
	r.start = &start
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) NewAccessCode(newAccessCode string) ApiDeleteChannelNegotiatedRateRequest {
	r.newAccessCode = &newAccessCode
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) ChannelRatePlanCodeOrder(channelRatePlanCodeOrder int32) ApiDeleteChannelNegotiatedRateRequest {
	r.channelRatePlanCodeOrder = &channelRatePlanCodeOrder
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) StartDate(startDate string) ApiDeleteChannelNegotiatedRateRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) EndDate(endDate string) ApiDeleteChannelNegotiatedRateRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) Duration(duration string) ApiDeleteChannelNegotiatedRateRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r ApiDeleteChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelNegotiatedRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelNegotiatedRateExecute(r)
}

/*
DeleteChannelNegotiatedRate Deletes channel negotiate rate

Use this API to update channel's negotiated rate code mapping including negotiated profile, negotiate rate access code, start date, end date, and sequence. <p><strong>OperationId:</strong>deleteChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) DeleteChannelNegotiatedRate(ctx context.Context) ApiDeleteChannelNegotiatedRateRequest {
	return ApiDeleteChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelNegotiatedRateExecute(r ApiDeleteChannelNegotiatedRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.channelRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", r.channelRatePlanCode, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.externalSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystem", r.externalSystem, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.nameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameType", r.nameType, "")
	}
	if r.namePrefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namePrefix", r.namePrefix, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.middleName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "middleName", r.middleName, "")
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.nameSuffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameSuffix", r.nameSuffix, "")
	}
	if r.nameTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTitle", r.nameTitle, "")
	}
	if r.nameTitleSuffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTitleSuffix", r.nameTitleSuffix, "")
	}
	if r.envelopeGreeting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "envelopeGreeting", r.envelopeGreeting, "")
	}
	if r.salutation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salutation", r.salutation, "")
	}
	if r.accessCode != nil {
		t := *r.accessCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accessCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accessCode", t, "multi")
		}
	}
	if r.end != nil {
		t := *r.end
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end", t, "multi")
		}
	}
	if r.start != nil {
		t := *r.start
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start", t, "multi")
		}
	}
	if r.newAccessCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newAccessCode", r.newAccessCode, "")
	}
	if r.channelRatePlanCodeOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCodeOrder", r.channelRatePlanCodeOrder, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	tenantCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelOrgMappingRequest) Authorization(authorization string) ApiDeleteChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelOrgMappingRequest) XAppKey(xAppKey string) ApiDeleteChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelOrgMappingRequest) XHotelid(xHotelid string) ApiDeleteChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Chain code for which channel code and org code are mapped.
func (r ApiDeleteChannelOrgMappingRequest) ChainCode(chainCode string) ApiDeleteChannelOrgMappingRequest {
	r.chainCode = &chainCode
	return r
}

// External system code.
func (r ApiDeleteChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelOrgMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelOrgMappingExecute(r)
}

/*
DeleteChannelOrgMapping Deletes channel tenants mapping.

This API deletes channel tenants mapping. <p><strong>OperationId:</strong>deleteChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantCode Tenant Code.
 @param channelCode Unique ID that identifies a channel.
 @return ApiDeleteChannelOrgMappingRequest
*/
func (a *ChannelApiService) DeleteChannelOrgMapping(ctx context.Context, tenantCode string, channelCode string) ApiDeleteChannelOrgMappingRequest {
	return ApiDeleteChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		tenantCode: tenantCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelOrgMappingExecute(r ApiDeleteChannelOrgMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants/{tenantCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantCode"+"}", url.PathEscape(parameterValueToString(r.tenantCode, "tenantCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tenantCode) < 1 {
		return localVarReturnValue, nil, reportError("tenantCode must have at least 1 elements")
	}
	if strlen(r.tenantCode) > 2000 {
		return localVarReturnValue, nil, reportError("tenantCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.chainCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", r.chainCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRateCategoriesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	rateCategories *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of rate category.
func (r ApiDeleteChannelRateCategoriesRequest) BookingChannelCodes(bookingChannelCodes []string) ApiDeleteChannelRateCategoriesRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of rate category.
func (r ApiDeleteChannelRateCategoriesRequest) RateCategories(rateCategories []string) ApiDeleteChannelRateCategoriesRequest {
	r.rateCategories = &rateCategories
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRateCategoriesRequest) Authorization(authorization string) ApiDeleteChannelRateCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRateCategoriesRequest) XAppKey(xAppKey string) ApiDeleteChannelRateCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRateCategoriesRequest) XHotelid(xHotelid string) ApiDeleteChannelRateCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteChannelRateCategoriesRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRateCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRateCategoriesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRateCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRateCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRateCategoriesExecute(r)
}

/*
DeleteChannelRateCategories Deletes given channel's rate categories

Use this API to delete channel rate categories for a given channel. <p><strong>OperationId:</strong>deleteChannelRateCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelRateCategoriesRequest
*/
func (a *ChannelApiService) DeleteChannelRateCategories(ctx context.Context) ApiDeleteChannelRateCategoriesRequest {
	return ApiDeleteChannelRateCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRateCategoriesExecute(r ApiDeleteChannelRateCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRateCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rateCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bookingChannelCodes == nil {
		return localVarReturnValue, nil, reportError("bookingChannelCodes is required and must be specified")
	}
	if r.rateCategories == nil {
		return localVarReturnValue, nil, reportError("rateCategories is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.rateCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategories", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategories", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRateLevelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	rateLevels *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of rate level.
func (r ApiDeleteChannelRateLevelsRequest) BookingChannelCodes(bookingChannelCodes []string) ApiDeleteChannelRateLevelsRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of rate level.
func (r ApiDeleteChannelRateLevelsRequest) RateLevels(rateLevels []string) ApiDeleteChannelRateLevelsRequest {
	r.rateLevels = &rateLevels
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRateLevelsRequest) Authorization(authorization string) ApiDeleteChannelRateLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRateLevelsRequest) XAppKey(xAppKey string) ApiDeleteChannelRateLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRateLevelsRequest) XHotelid(xHotelid string) ApiDeleteChannelRateLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteChannelRateLevelsRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRateLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRateLevelsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRateLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRateLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRateLevelsExecute(r)
}

/*
DeleteChannelRateLevels Deletes channel rate level

Use this API to delete channel rate level code's description. <p><strong>OperationId:</strong>deleteChannelRateLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelRateLevelsRequest
*/
func (a *ChannelApiService) DeleteChannelRateLevels(ctx context.Context) ApiDeleteChannelRateLevelsRequest {
	return ApiDeleteChannelRateLevelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRateLevelsExecute(r ApiDeleteChannelRateLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRateLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rateLevels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bookingChannelCodes == nil {
		return localVarReturnValue, nil, reportError("bookingChannelCodes is required and must be specified")
	}
	if r.rateLevels == nil {
		return localVarReturnValue, nil, reportError("rateLevels is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.rateLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateLevels", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateLevels", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	bookingChannelCode *[]string
	channelRatePlanCode *[]string
	hasChannelNegotiatedRates *[]bool
	hasNegotiatedRates *[]bool
	hotelId *[]string
	ratePlanCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRateMappingRequest) Authorization(authorization string) ApiDeleteChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRateMappingRequest) XAppKey(xAppKey string) ApiDeleteChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRateMappingRequest) XHotelid(xHotelid string) ApiDeleteChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Booking Channel Code.
func (r ApiDeleteChannelRateMappingRequest) BookingChannelCode(bookingChannelCode []string) ApiDeleteChannelRateMappingRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Channel Room Type.
func (r ApiDeleteChannelRateMappingRequest) ChannelRatePlanCode(channelRatePlanCode []string) ApiDeleteChannelRateMappingRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

// True if the mapping has channel negotiated rates, otherwise false.
func (r ApiDeleteChannelRateMappingRequest) HasChannelNegotiatedRates(hasChannelNegotiatedRates []bool) ApiDeleteChannelRateMappingRequest {
	r.hasChannelNegotiatedRates = &hasChannelNegotiatedRates
	return r
}

// True if this channel rate plan code has negotiated rates, otherwise false
func (r ApiDeleteChannelRateMappingRequest) HasNegotiatedRates(hasNegotiatedRates []bool) ApiDeleteChannelRateMappingRequest {
	r.hasNegotiatedRates = &hasNegotiatedRates
	return r
}

// Hotel Code.
func (r ApiDeleteChannelRateMappingRequest) HotelId(hotelId []string) ApiDeleteChannelRateMappingRequest {
	r.hotelId = &hotelId
	return r
}

// Room Type.
func (r ApiDeleteChannelRateMappingRequest) RatePlanCode(ratePlanCode []string) ApiDeleteChannelRateMappingRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// External system code.
func (r ApiDeleteChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRateMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRateMappingExecute(r)
}

/*
DeleteChannelRateMapping Deletes channel property rate mapping

Use this API to delete channel property rate mapping including channel rate code, start date, end date, rate level, channel rate description. <p><strong>OperationId:</strong>deleteChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelRateMappingRequest
*/
func (a *ChannelApiService) DeleteChannelRateMapping(ctx context.Context) ApiDeleteChannelRateMappingRequest {
	return ApiDeleteChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRateMappingExecute(r ApiDeleteChannelRateMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.channelRatePlanCode != nil {
		t := *r.channelRatePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", t, "multi")
		}
	}
	if r.hasChannelNegotiatedRates != nil {
		t := *r.hasChannelNegotiatedRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hasChannelNegotiatedRates", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hasChannelNegotiatedRates", t, "multi")
		}
	}
	if r.hasNegotiatedRates != nil {
		t := *r.hasNegotiatedRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hasNegotiatedRates", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hasNegotiatedRates", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *string
	description *string
	code1 *string
	description1 *string
	globalDescType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property mapping with Rate plan code or Room type
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) HotelId(hotelId []string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) Code(code string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.code = &code
	return r
}

// description.
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) Description(description string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.description = &description
	return r
}

// Code.
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) Code1(code1 string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.code1 = &code1
	return r
}

// description.
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) Description1(description1 string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.description1 = &description1
	return r
}

// Either Room Type or Rate Plan Code
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) GlobalDescType(globalDescType []string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.globalDescType = &globalDescType
	return r
}

// External system code.
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRatesGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRatesGlobalDescriptionsExecute(r)
}

/*
DeleteChannelRatesGlobalDescriptions Deletes global rate descriptions

Use this API to delete global rate description for given hotel id and rate code. <p><strong>OperationId:</strong>deleteChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) DeleteChannelRatesGlobalDescriptions(ctx context.Context) ApiDeleteChannelRatesGlobalDescriptionsRequest {
	return ApiDeleteChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRatesGlobalDescriptionsExecute(r ApiDeleteChannelRatesGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.code1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code1", r.code1, "")
	}
	if r.description1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description1", r.description1, "")
	}
	if r.globalDescType != nil {
		t := *r.globalDescType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	beginDate *string
	channelRoomType *string
	endDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRoomMappingRequest) Authorization(authorization string) ApiDeleteChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRoomMappingRequest) XAppKey(xAppKey string) ApiDeleteChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRoomMappingRequest) XHotelid(xHotelid string) ApiDeleteChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Begin Date.
func (r ApiDeleteChannelRoomMappingRequest) BeginDate(beginDate string) ApiDeleteChannelRoomMappingRequest {
	r.beginDate = &beginDate
	return r
}

// Channel Room Type.
func (r ApiDeleteChannelRoomMappingRequest) ChannelRoomType(channelRoomType string) ApiDeleteChannelRoomMappingRequest {
	r.channelRoomType = &channelRoomType
	return r
}

// End date of the hotel-channel room type mapping.
func (r ApiDeleteChannelRoomMappingRequest) EndDate(endDate string) ApiDeleteChannelRoomMappingRequest {
	r.endDate = &endDate
	return r
}

// External system code.
func (r ApiDeleteChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRoomMappingExecute(r)
}

/*
DeleteChannelRoomMapping Deletes channel property room mapping

Use this API to delete channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>deleteChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Room Type Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiDeleteChannelRoomMappingRequest
*/
func (a *ChannelApiService) DeleteChannelRoomMapping(ctx context.Context, roomTypeCode string, channelCode string, hotelId string) ApiDeleteChannelRoomMappingRequest {
	return ApiDeleteChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRoomMappingExecute(r ApiDeleteChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.channelRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomType", r.channelRoomType, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRoomTypesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	roomTypes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of room type.
func (r ApiDeleteChannelRoomTypesRequest) BookingChannelCodes(bookingChannelCodes []string) ApiDeleteChannelRoomTypesRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of room type.
func (r ApiDeleteChannelRoomTypesRequest) RoomTypes(roomTypes []string) ApiDeleteChannelRoomTypesRequest {
	r.roomTypes = &roomTypes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRoomTypesRequest) Authorization(authorization string) ApiDeleteChannelRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRoomTypesRequest) XAppKey(xAppKey string) ApiDeleteChannelRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRoomTypesRequest) XHotelid(xHotelid string) ApiDeleteChannelRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteChannelRoomTypesRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRoomTypesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRoomTypesExecute(r)
}

/*
DeleteChannelRoomTypes Delete channel configuration

Use this API to delete channel configuration. <p><strong>OperationId:</strong>deleteChannelRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelRoomTypesRequest
*/
func (a *ChannelApiService) DeleteChannelRoomTypes(ctx context.Context) ApiDeleteChannelRoomTypesRequest {
	return ApiDeleteChannelRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRoomTypesExecute(r ApiDeleteChannelRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/roomTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bookingChannelCodes == nil {
		return localVarReturnValue, nil, reportError("bookingChannelCodes is required and must be specified")
	}
	if r.roomTypes == nil {
		return localVarReturnValue, nil, reportError("roomTypes is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *string
	description *string
	code1 *string
	description1 *string
	globalDescType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property mapping with Rate plan code or Room type
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) HotelId(hotelId []string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) Code(code string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.code = &code
	return r
}

// description.
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) Description(description string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.description = &description
	return r
}

// Code.
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) Code1(code1 string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.code1 = &code1
	return r
}

// description.
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) Description1(description1 string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.description1 = &description1
	return r
}

// Either Room Type or Rate Plan Code
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) GlobalDescType(globalDescType []string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.globalDescType = &globalDescType
	return r
}

// External system code.
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelRoomsGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRoomsGlobalDescriptionsExecute(r)
}

/*
DeleteChannelRoomsGlobalDescriptions Deletes global room descriptions

Use this API to delete global room description for given hotel id and room type code. <p><strong>OperationId:</strong>deleteChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) DeleteChannelRoomsGlobalDescriptions(ctx context.Context) ApiDeleteChannelRoomsGlobalDescriptionsRequest {
	return ApiDeleteChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRoomsGlobalDescriptionsExecute(r ApiDeleteChannelRoomsGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.code1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code1", r.code1, "")
	}
	if r.description1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description1", r.description1, "")
	}
	if r.globalDescType != nil {
		t := *r.globalDescType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChannelServiceCacheRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteChannelServiceCacheRequest) Authorization(authorization string) ApiDeleteChannelServiceCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteChannelServiceCacheRequest) XAppKey(xAppKey string) ApiDeleteChannelServiceCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteChannelServiceCacheRequest) XHotelid(xHotelid string) ApiDeleteChannelServiceCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiDeleteChannelServiceCacheRequest) XExternalsystem(xExternalsystem string) ApiDeleteChannelServiceCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteChannelServiceCacheRequest) AcceptLanguage(acceptLanguage string) ApiDeleteChannelServiceCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteChannelServiceCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelServiceCacheExecute(r)
}

/*
DeleteChannelServiceCache Deletes the cache for Channel Service.

This API deletes the cache for Channel Service. <p><strong>OperationId:</strong>deleteChannelServiceCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChannelServiceCacheRequest
*/
func (a *ChannelApiService) DeleteChannelServiceCache(ctx context.Context) ApiDeleteChannelServiceCacheRequest {
	return ApiDeleteChannelServiceCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelServiceCacheExecute(r ApiDeleteChannelServiceCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelServiceCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/channels/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteCreditCardsMappingRequest) Authorization(authorization string) ApiDeleteCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteCreditCardsMappingRequest) XAppKey(xAppKey string) ApiDeleteCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteCreditCardsMappingRequest) XHotelid(xHotelid string) ApiDeleteCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ApiDeleteCreditCardsMappingRequest) Inactive(inactive bool) ApiDeleteCreditCardsMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ApiDeleteCreditCardsMappingRequest) SystemCode(systemCode string) ApiDeleteCreditCardsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ApiDeleteCreditCardsMappingRequest) SystemSubType(systemSubType string) ApiDeleteCreditCardsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ApiDeleteCreditCardsMappingRequest) SystemType(systemType string) ApiDeleteCreditCardsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ApiDeleteCreditCardsMappingRequest) SystemName(systemName string) ApiDeleteCreditCardsMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ApiDeleteCreditCardsMappingRequest) WebsiteURL(websiteURL string) ApiDeleteCreditCardsMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ApiDeleteCreditCardsMappingRequest) IconURL(iconURL string) ApiDeleteCreditCardsMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ApiDeleteCreditCardsMappingRequest) LocalSystemCode(localSystemCode []string) ApiDeleteCreditCardsMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ApiDeleteCreditCardsMappingRequest) ExternalSystemCode(externalSystemCode []string) ApiDeleteCreditCardsMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ApiDeleteCreditCardsMappingRequest) Description(description []string) ApiDeleteCreditCardsMappingRequest {
	r.description = &description
	return r
}

func (r ApiDeleteCreditCardsMappingRequest) StartDate(startDate string) ApiDeleteCreditCardsMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteCreditCardsMappingRequest) EndDate(endDate string) ApiDeleteCreditCardsMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteCreditCardsMappingRequest) Duration(duration string) ApiDeleteCreditCardsMappingRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r ApiDeleteCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteCreditCardsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCreditCardsMappingExecute(r)
}

/*
DeleteCreditCardsMapping Deletes channel credit card mapping

Use this API to delete channel credit card code mapping to OPERA credit card code. <p><strong>OperationId:</strong>deleteCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCreditCardsMappingRequest
*/
func (a *ChannelApiService) DeleteCreditCardsMapping(ctx context.Context) ApiDeleteCreditCardsMappingRequest {
	return ApiDeleteCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteCreditCardsMappingExecute(r ApiDeleteCreditCardsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	lanyonDecimalPosition *[]int32
	channelDecimalPosition *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteCurrenciesMappingRequest) Authorization(authorization string) ApiDeleteCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteCurrenciesMappingRequest) XAppKey(xAppKey string) ApiDeleteCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteCurrenciesMappingRequest) XHotelid(xHotelid string) ApiDeleteCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ApiDeleteCurrenciesMappingRequest) Inactive(inactive bool) ApiDeleteCurrenciesMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ApiDeleteCurrenciesMappingRequest) SystemCode(systemCode string) ApiDeleteCurrenciesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ApiDeleteCurrenciesMappingRequest) SystemSubType(systemSubType string) ApiDeleteCurrenciesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ApiDeleteCurrenciesMappingRequest) SystemType(systemType string) ApiDeleteCurrenciesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ApiDeleteCurrenciesMappingRequest) SystemName(systemName string) ApiDeleteCurrenciesMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ApiDeleteCurrenciesMappingRequest) WebsiteURL(websiteURL string) ApiDeleteCurrenciesMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ApiDeleteCurrenciesMappingRequest) IconURL(iconURL string) ApiDeleteCurrenciesMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ApiDeleteCurrenciesMappingRequest) LocalSystemCode(localSystemCode []string) ApiDeleteCurrenciesMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ApiDeleteCurrenciesMappingRequest) ExternalSystemCode(externalSystemCode []string) ApiDeleteCurrenciesMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ApiDeleteCurrenciesMappingRequest) Description(description []string) ApiDeleteCurrenciesMappingRequest {
	r.description = &description
	return r
}

func (r ApiDeleteCurrenciesMappingRequest) StartDate(startDate string) ApiDeleteCurrenciesMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteCurrenciesMappingRequest) EndDate(endDate string) ApiDeleteCurrenciesMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteCurrenciesMappingRequest) Duration(duration string) ApiDeleteCurrenciesMappingRequest {
	r.duration = &duration
	return r
}

// Number of decimal positions used by the currency.
func (r ApiDeleteCurrenciesMappingRequest) LanyonDecimalPosition(lanyonDecimalPosition []int32) ApiDeleteCurrenciesMappingRequest {
	r.lanyonDecimalPosition = &lanyonDecimalPosition
	return r
}

// Number of decimal positions used by the currency as per the channel.
func (r ApiDeleteCurrenciesMappingRequest) ChannelDecimalPosition(channelDecimalPosition []int32) ApiDeleteCurrenciesMappingRequest {
	r.channelDecimalPosition = &channelDecimalPosition
	return r
}

// External system code.
func (r ApiDeleteCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteCurrenciesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCurrenciesMappingExecute(r)
}

/*
DeleteCurrenciesMapping Deletes channel currency code mapping

Use this API to delete channel mapping to OPERA currency codes. <p><strong>OperationId:</strong>deleteCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCurrenciesMappingRequest
*/
func (a *ChannelApiService) DeleteCurrenciesMapping(ctx context.Context) ApiDeleteCurrenciesMappingRequest {
	return ApiDeleteCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteCurrenciesMappingExecute(r ApiDeleteCurrenciesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.lanyonDecimalPosition != nil {
		t := *r.lanyonDecimalPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lanyonDecimalPosition", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lanyonDecimalPosition", t, "multi")
		}
	}
	if r.channelDecimalPosition != nil {
		t := *r.channelDecimalPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelDecimalPosition", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelDecimalPosition", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	code *[]string
	hotelId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteDistributionTemplatesRequest) Authorization(authorization string) ApiDeleteDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteDistributionTemplatesRequest) XAppKey(xAppKey string) ApiDeleteDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteDistributionTemplatesRequest) XHotelid(xHotelid string) ApiDeleteDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiDeleteDistributionTemplatesRequest) Codes(codes []string) ApiDeleteDistributionTemplatesRequest {
	r.codes = &codes
	return r
}

// Configuration code.
func (r ApiDeleteDistributionTemplatesRequest) Code(code []string) ApiDeleteDistributionTemplatesRequest {
	r.code = &code
	return r
}

// Hotel where the code is configured.
func (r ApiDeleteDistributionTemplatesRequest) HotelId(hotelId []string) ApiDeleteDistributionTemplatesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ApiDeleteDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ApiDeleteDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ApiDeleteDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteDistributionTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDistributionTemplatesExecute(r)
}

/*
DeleteDistributionTemplates Deletes rate templates configurations

Use this API to delete existing distribution rate template. <p><strong>OperationId:</strong>deleteDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteDistributionTemplatesRequest
*/
func (a *ChannelApiService) DeleteDistributionTemplates(ctx context.Context) ApiDeleteDistributionTemplatesRequest {
	return ApiDeleteDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteDistributionTemplatesExecute(r ApiDeleteDistributionTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	requirementCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteGuaranteesMappingRequest) Authorization(authorization string) ApiDeleteGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteGuaranteesMappingRequest) XAppKey(xAppKey string) ApiDeleteGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteGuaranteesMappingRequest) XHotelid(xHotelid string) ApiDeleteGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ApiDeleteGuaranteesMappingRequest) Inactive(inactive bool) ApiDeleteGuaranteesMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ApiDeleteGuaranteesMappingRequest) SystemCode(systemCode string) ApiDeleteGuaranteesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ApiDeleteGuaranteesMappingRequest) SystemSubType(systemSubType string) ApiDeleteGuaranteesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ApiDeleteGuaranteesMappingRequest) SystemType(systemType string) ApiDeleteGuaranteesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ApiDeleteGuaranteesMappingRequest) SystemName(systemName string) ApiDeleteGuaranteesMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ApiDeleteGuaranteesMappingRequest) WebsiteURL(websiteURL string) ApiDeleteGuaranteesMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ApiDeleteGuaranteesMappingRequest) IconURL(iconURL string) ApiDeleteGuaranteesMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ApiDeleteGuaranteesMappingRequest) LocalSystemCode(localSystemCode []string) ApiDeleteGuaranteesMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ApiDeleteGuaranteesMappingRequest) ExternalSystemCode(externalSystemCode []string) ApiDeleteGuaranteesMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ApiDeleteGuaranteesMappingRequest) Description(description []string) ApiDeleteGuaranteesMappingRequest {
	r.description = &description
	return r
}

func (r ApiDeleteGuaranteesMappingRequest) StartDate(startDate string) ApiDeleteGuaranteesMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteGuaranteesMappingRequest) EndDate(endDate string) ApiDeleteGuaranteesMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteGuaranteesMappingRequest) Duration(duration string) ApiDeleteGuaranteesMappingRequest {
	r.duration = &duration
	return r
}

// Requirement code of guarantee.
func (r ApiDeleteGuaranteesMappingRequest) RequirementCode(requirementCode []string) ApiDeleteGuaranteesMappingRequest {
	r.requirementCode = &requirementCode
	return r
}

// External system code.
func (r ApiDeleteGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteGuaranteesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGuaranteesMappingExecute(r)
}

/*
DeleteGuaranteesMapping Deletes channel guarantee code mapping

Use this API to delete channel's guarantee codes mapping to OPERA guarantee codes. <p><strong>OperationId:</strong>deleteGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGuaranteesMappingRequest
*/
func (a *ChannelApiService) DeleteGuaranteesMapping(ctx context.Context) ApiDeleteGuaranteesMappingRequest {
	return ApiDeleteGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteGuaranteesMappingExecute(r ApiDeleteGuaranteesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.requirementCode != nil {
		t := *r.requirementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "requirementCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "requirementCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	city *[]string
	roomLimit *[]int32
	bookingLimit *[]int32
	hotelChainId *[]string
	chainCode *[]string
	prevailingRates *[]bool
	aRIEnabled *[]bool
	addOnLicense *[]string
	available *bool
	defaultRateCode *string
	defaultRateCode1 *[]string
	lowRevenueThreshold *[]int32
	highRevenueThreshold *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteHotelsMappingRequest) Authorization(authorization string) ApiDeleteHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteHotelsMappingRequest) XAppKey(xAppKey string) ApiDeleteHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteHotelsMappingRequest) XHotelid(xHotelid string) ApiDeleteHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ApiDeleteHotelsMappingRequest) Inactive(inactive bool) ApiDeleteHotelsMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ApiDeleteHotelsMappingRequest) SystemCode(systemCode string) ApiDeleteHotelsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ApiDeleteHotelsMappingRequest) SystemSubType(systemSubType string) ApiDeleteHotelsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ApiDeleteHotelsMappingRequest) SystemType(systemType string) ApiDeleteHotelsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ApiDeleteHotelsMappingRequest) SystemName(systemName string) ApiDeleteHotelsMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ApiDeleteHotelsMappingRequest) WebsiteURL(websiteURL string) ApiDeleteHotelsMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ApiDeleteHotelsMappingRequest) IconURL(iconURL string) ApiDeleteHotelsMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ApiDeleteHotelsMappingRequest) LocalSystemCode(localSystemCode []string) ApiDeleteHotelsMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ApiDeleteHotelsMappingRequest) ExternalSystemCode(externalSystemCode []string) ApiDeleteHotelsMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ApiDeleteHotelsMappingRequest) Description(description []string) ApiDeleteHotelsMappingRequest {
	r.description = &description
	return r
}

func (r ApiDeleteHotelsMappingRequest) StartDate(startDate string) ApiDeleteHotelsMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDeleteHotelsMappingRequest) EndDate(endDate string) ApiDeleteHotelsMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDeleteHotelsMappingRequest) Duration(duration string) ApiDeleteHotelsMappingRequest {
	r.duration = &duration
	return r
}

// City code of the channel hotel.
func (r ApiDeleteHotelsMappingRequest) City(city []string) ApiDeleteHotelsMappingRequest {
	r.city = &city
	return r
}

// Maximum room limit for the channel hotel reservation.
func (r ApiDeleteHotelsMappingRequest) RoomLimit(roomLimit []int32) ApiDeleteHotelsMappingRequest {
	r.roomLimit = &roomLimit
	return r
}

// Booking limit used by ADS interface for booking limit upload. Available if channel type is ADS and ADS ARI is enabled.
func (r ApiDeleteHotelsMappingRequest) BookingLimit(bookingLimit []int32) ApiDeleteHotelsMappingRequest {
	r.bookingLimit = &bookingLimit
	return r
}

// Hotel chain ID of channel-hotel mapping. Only available for UA channel. It may not be modified if in myfidelio environment, and user is for a specific hotel.
func (r ApiDeleteHotelsMappingRequest) HotelChainId(hotelChainId []string) ApiDeleteHotelsMappingRequest {
	r.hotelChainId = &hotelChainId
	return r
}

// Chain code for the channel-hotel mapping.
func (r ApiDeleteHotelsMappingRequest) ChainCode(chainCode []string) ApiDeleteHotelsMappingRequest {
	r.chainCode = &chainCode
	return r
}

// Prevailing rates flag of channel-hotel mapping. Available if PREVAILING_RATE_BY_LOS parameter is on.
func (r ApiDeleteHotelsMappingRequest) PrevailingRates(prevailingRates []bool) ApiDeleteHotelsMappingRequest {
	r.prevailingRates = &prevailingRates
	return r
}

// ADS ARI enabled flag of channel-hotel mapping. Available only if channel type is ADS.
func (r ApiDeleteHotelsMappingRequest) ARIEnabled(aRIEnabled []bool) ApiDeleteHotelsMappingRequest {
	r.aRIEnabled = &aRIEnabled
	return r
}

// External system Add-on license. This is mandatory when Channel Type is ADS.
func (r ApiDeleteHotelsMappingRequest) AddOnLicense(addOnLicense []string) ApiDeleteHotelsMappingRequest {
	r.addOnLicense = &addOnLicense
	return r
}

// Flag indicating if channel resort mapping is available.
func (r ApiDeleteHotelsMappingRequest) Available(available bool) ApiDeleteHotelsMappingRequest {
	r.available = &available
	return r
}

// Default rate code to be used to calculate the total revenue.
func (r ApiDeleteHotelsMappingRequest) DefaultRateCode(defaultRateCode string) ApiDeleteHotelsMappingRequest {
	r.defaultRateCode = &defaultRateCode
	return r
}

// Default rate code of channel hotel.
func (r ApiDeleteHotelsMappingRequest) DefaultRateCode1(defaultRateCode1 []string) ApiDeleteHotelsMappingRequest {
	r.defaultRateCode1 = &defaultRateCode1
	return r
}

// Low revenue threshold.
func (r ApiDeleteHotelsMappingRequest) LowRevenueThreshold(lowRevenueThreshold []int32) ApiDeleteHotelsMappingRequest {
	r.lowRevenueThreshold = &lowRevenueThreshold
	return r
}

// High revenue threshold.
func (r ApiDeleteHotelsMappingRequest) HighRevenueThreshold(highRevenueThreshold []int32) ApiDeleteHotelsMappingRequest {
	r.highRevenueThreshold = &highRevenueThreshold
	return r
}

// External system code.
func (r ApiDeleteHotelsMappingRequest) XExternalsystem(xExternalsystem string) ApiDeleteHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ApiDeleteHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteHotelsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelsMappingExecute(r)
}

/*
DeleteHotelsMapping Deletes channel hotel mapping

Use this API to delete channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date. <p><strong>OperationId:</strong>deleteHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteHotelsMappingRequest
*/
func (a *ChannelApiService) DeleteHotelsMapping(ctx context.Context) ApiDeleteHotelsMappingRequest {
	return ApiDeleteHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteHotelsMappingExecute(r ApiDeleteHotelsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.city != nil {
		t := *r.city
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "city", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "city", t, "multi")
		}
	}
	if r.roomLimit != nil {
		t := *r.roomLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomLimit", t, "multi")
		}
	}
	if r.bookingLimit != nil {
		t := *r.bookingLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingLimit", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingLimit", t, "multi")
		}
	}
	if r.hotelChainId != nil {
		t := *r.hotelChainId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelChainId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelChainId", t, "multi")
		}
	}
	if r.chainCode != nil {
		t := *r.chainCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", t, "multi")
		}
	}
	if r.prevailingRates != nil {
		t := *r.prevailingRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRates", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRates", t, "multi")
		}
	}
	if r.aRIEnabled != nil {
		t := *r.aRIEnabled
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "aRIEnabled", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "aRIEnabled", t, "multi")
		}
	}
	if r.addOnLicense != nil {
		t := *r.addOnLicense
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addOnLicense", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addOnLicense", t, "multi")
		}
	}
	if r.available != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available", r.available, "")
	}
	if r.defaultRateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultRateCode", r.defaultRateCode, "")
	}
	if r.defaultRateCode1 != nil {
		t := *r.defaultRateCode1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "defaultRateCode1", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "defaultRateCode1", t, "multi")
		}
	}
	if r.lowRevenueThreshold != nil {
		t := *r.lowRevenueThreshold
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lowRevenueThreshold", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lowRevenueThreshold", t, "multi")
		}
	}
	if r.highRevenueThreshold != nil {
		t := *r.highRevenueThreshold
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "highRevenueThreshold", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "highRevenueThreshold", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDeleteTotalPricingElementsRequest) Authorization(authorization string) ApiDeleteTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDeleteTotalPricingElementsRequest) XAppKey(xAppKey string) ApiDeleteTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDeleteTotalPricingElementsRequest) XHotelid(xHotelid string) ApiDeleteTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code that associated with Transaction Code and Total Pricing Element
func (r ApiDeleteTotalPricingElementsRequest) HotelId(hotelId []string) ApiDeleteTotalPricingElementsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ApiDeleteTotalPricingElementsRequest) Code(code string) ApiDeleteTotalPricingElementsRequest {
	r.code = &code
	return r
}

// description.
func (r ApiDeleteTotalPricingElementsRequest) Description(description string) ApiDeleteTotalPricingElementsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ApiDeleteTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ApiDeleteTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDeleteTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDeleteTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTotalPricingElementsExecute(r)
}

/*
DeleteTotalPricingElements Deletes total pricing tax and fee types

Use this API to delete global distribution channels tax and fee configurations. <p><strong>OperationId:</strong>deleteTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTotalPricingElementsRequest
*/
func (a *ChannelApiService) DeleteTotalPricingElements(ctx context.Context) ApiDeleteTotalPricingElementsRequest {
	return ApiDeleteTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteTotalPricingElementsExecute(r ApiDeleteTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelBillingStatements *PutChannelBillingStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGenerateChannelBillingStatementsRequest) Authorization(authorization string) ApiGenerateChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGenerateChannelBillingStatementsRequest) XAppKey(xAppKey string) ApiGenerateChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGenerateChannelBillingStatementsRequest) XHotelid(xHotelid string) ApiGenerateChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Generate channel billing statements.
func (r ApiGenerateChannelBillingStatementsRequest) ChannelBillingStatements(channelBillingStatements PutChannelBillingStatementsRequest) ApiGenerateChannelBillingStatementsRequest {
	r.channelBillingStatements = &channelBillingStatements
	return r
}

// External system code.
func (r ApiGenerateChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ApiGenerateChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGenerateChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ApiGenerateChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGenerateChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.GenerateChannelBillingStatementsExecute(r)
}

/*
GenerateChannelBillingStatements This API generates channel billing statements.

This API generates channel billing statements. <p><strong>OperationId:</strong>generateChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateChannelBillingStatementsRequest
*/
func (a *ChannelApiService) GenerateChannelBillingStatements(ctx context.Context) ApiGenerateChannelBillingStatementsRequest {
	return ApiGenerateChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) GenerateChannelBillingStatementsExecute(r ApiGenerateChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GenerateChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelBillingStatements == nil {
		return localVarReturnValue, nil, reportError("channelBillingStatements is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelBillingStatements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAmenitiesMappingRequest) Authorization(authorization string) ApiGetAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAmenitiesMappingRequest) XAppKey(xAppKey string) ApiGetAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAmenitiesMappingRequest) XHotelid(xHotelid string) ApiGetAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ApiGetAmenitiesMappingRequest) Inactive(inactive bool) ApiGetAmenitiesMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetAmenitiesMappingRequest) Limit(limit int32) ApiGetAmenitiesMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetAmenitiesMappingRequest) Offset(offset int32) ApiGetAmenitiesMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ApiGetAmenitiesMappingRequest) SystemCode(systemCode string) ApiGetAmenitiesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ApiGetAmenitiesMappingRequest) SystemType(systemType string) ApiGetAmenitiesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ApiGetAmenitiesMappingRequest) SystemSubType(systemSubType string) ApiGetAmenitiesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ApiGetAmenitiesMappingRequest) SystemRateType(systemRateType string) ApiGetAmenitiesMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ApiGetAmenitiesMappingRequest) LocalSystemCodes(localSystemCodes []string) ApiGetAmenitiesMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// External system code.
func (r ApiGetAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ApiGetAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAmenitiesMappingRequest) Execute() (*AmenitiesMapping, *http.Response, error) {
	return r.ApiService.GetAmenitiesMappingExecute(r)
}

/*
GetAmenitiesMapping Gets channel amenities configuration

Use this API to get channel amenities mapping. <p><strong>OperationId:</strong>getAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmenitiesMappingRequest
*/
func (a *ChannelApiService) GetAmenitiesMapping(ctx context.Context) ApiGetAmenitiesMappingRequest {
	return ApiGetAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AmenitiesMapping
func (a *ChannelApiService) GetAmenitiesMappingExecute(r ApiGetAmenitiesMappingRequest) (*AmenitiesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AmenitiesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *[]bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRequest) Authorization(authorization string) ApiGetChannelRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRequest) XAppKey(xAppKey string) ApiGetChannelRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRequest) XHotelid(xHotelid string) ApiGetChannelRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether fetch should include inactive codes or not.
func (r ApiGetChannelRequest) IncludeInactive(includeInactive []bool) ApiGetChannelRequest {
	r.includeInactive = &includeInactive
	return r
}

// Simple type for external system instructions that can be used in requests for partial operations.
func (r ApiGetChannelRequest) FetchInstructions(fetchInstructions []string) ApiGetChannelRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetChannelRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRequest) Execute() (*Channel, *http.Response, error) {
	return r.ApiService.GetChannelExecute(r)
}

/*
GetChannel Gets channel detail

This API retrieves channel information for the given channel code. <p><strong>OperationId:</strong>getChannel</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiGetChannelRequest
*/
func (a *ChannelApiService) GetChannel(ctx context.Context, channelCode string) ApiGetChannelRequest {
	return ApiGetChannelRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Channel
func (a *ChannelApiService) GetChannelExecute(r ApiGetChannelRequest) (*Channel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactive != nil {
		t := *r.includeInactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelAccountRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelAccountRequest) Authorization(authorization string) ApiGetChannelAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelAccountRequest) XAppKey(xAppKey string) ApiGetChannelAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelAccountRequest) XHotelid(xHotelid string) ApiGetChannelAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Providing this flag marks the billing account as recently accessed.
func (r ApiGetChannelAccountRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ApiGetChannelAccountRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Channel account indicators information.
func (r ApiGetChannelAccountRequest) FetchInstructions(fetchInstructions []string) ApiGetChannelAccountRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetChannelAccountRequest) XExternalsystem(xExternalsystem string) ApiGetChannelAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelAccountRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelAccountRequest) Execute() (*ChannelAccount, *http.Response, error) {
	return r.ApiService.GetChannelAccountExecute(r)
}

/*
GetChannelAccount Gets channel accounts

Use this API to get existing channel account for a given OPERA profile id. <p><strong>OperationId:</strong>getChannelAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountProfileId Unique ID that identifies an account profile.
 @return ApiGetChannelAccountRequest
*/
func (a *ChannelApiService) GetChannelAccount(ctx context.Context, accountProfileId string) ApiGetChannelAccountRequest {
	return ApiGetChannelAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return ChannelAccount
func (a *ChannelApiService) GetChannelAccountExecute(r ApiGetChannelAccountRequest) (*ChannelAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelAccountContractElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	contractId string
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelAccountContractElementsRequest) Authorization(authorization string) ApiGetChannelAccountContractElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelAccountContractElementsRequest) XAppKey(xAppKey string) ApiGetChannelAccountContractElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelAccountContractElementsRequest) XHotelid(xHotelid string) ApiGetChannelAccountContractElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelAccountContractElementsRequest) Limit(limit int32) ApiGetChannelAccountContractElementsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelAccountContractElementsRequest) Offset(offset int32) ApiGetChannelAccountContractElementsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChannelAccountContractElementsRequest) AttributeName(attributeName []string) ApiGetChannelAccountContractElementsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiGetChannelAccountContractElementsRequest) OrderType(orderType []string) ApiGetChannelAccountContractElementsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ApiGetChannelAccountContractElementsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelAccountContractElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelAccountContractElementsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelAccountContractElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelAccountContractElementsRequest) Execute() (*ChannelAccountContractElements, *http.Response, error) {
	return r.ApiService.GetChannelAccountContractElementsExecute(r)
}

/*
GetChannelAccountContractElements Gets channel account contracts for given profile Id.

Use this API to get existing cannel account contract for a given OPERA profile id. <p><strong>OperationId:</strong>getChannelAccountContractElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId Contract Id.
 @param accountProfileId Unique ID that identifies an account profile.
 @return ApiGetChannelAccountContractElementsRequest
*/
func (a *ChannelApiService) GetChannelAccountContractElements(ctx context.Context, contractId string, accountProfileId string) ApiGetChannelAccountContractElementsRequest {
	return ApiGetChannelAccountContractElementsRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return ChannelAccountContractElements
func (a *ChannelApiService) GetChannelAccountContractElementsExecute(r ApiGetChannelAccountContractElementsRequest) (*ChannelAccountContractElements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccountContractElements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelAccountContractElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}/contracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contractId) < 1 {
		return localVarReturnValue, nil, reportError("contractId must have at least 1 elements")
	}
	if strlen(r.contractId) > 2000 {
		return localVarReturnValue, nil, reportError("contractId must have less than 2000 elements")
	}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeInactive *bool
	limit *int32
	offset *int32
	hotelId *[]string
	accountType *string
	accountName *string
	accountCode *string
	contractExpInDays *int32
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelAccountsRequest) Authorization(authorization string) ApiGetChannelAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelAccountsRequest) XAppKey(xAppKey string) ApiGetChannelAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelAccountsRequest) XHotelid(xHotelid string) ApiGetChannelAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator that tells whether to include inactive channel accounts or not.
func (r ApiGetChannelAccountsRequest) ExcludeInactive(excludeInactive bool) ApiGetChannelAccountsRequest {
	r.excludeInactive = &excludeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelAccountsRequest) Limit(limit int32) ApiGetChannelAccountsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelAccountsRequest) Offset(offset int32) ApiGetChannelAccountsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChannelAccountsRequest) HotelId(hotelId []string) ApiGetChannelAccountsRequest {
	r.hotelId = &hotelId
	return r
}

// Represents channel account TEMPLATE type.
func (r ApiGetChannelAccountsRequest) AccountType(accountType string) ApiGetChannelAccountsRequest {
	r.accountType = &accountType
	return r
}

// Account Name for which details need to be fetched.
func (r ApiGetChannelAccountsRequest) AccountName(accountName string) ApiGetChannelAccountsRequest {
	r.accountName = &accountName
	return r
}

// Account Code/No for which details need to be fetched.
func (r ApiGetChannelAccountsRequest) AccountCode(accountCode string) ApiGetChannelAccountsRequest {
	r.accountCode = &accountCode
	return r
}

// To fetch channel accounts which expires in no., of days.
func (r ApiGetChannelAccountsRequest) ContractExpInDays(contractExpInDays int32) ApiGetChannelAccountsRequest {
	r.contractExpInDays = &contractExpInDays
	return r
}

func (r ApiGetChannelAccountsRequest) AttributeName(attributeName []string) ApiGetChannelAccountsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiGetChannelAccountsRequest) OrderType(orderType []string) ApiGetChannelAccountsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ApiGetChannelAccountsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelAccountsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelAccountsRequest) Execute() (*ChannelAccountsSummary, *http.Response, error) {
	return r.ApiService.GetChannelAccountsExecute(r)
}

/*
GetChannelAccounts This API retrieves channel accounts.

This API retrieves channel accounts. <p><strong>OperationId:</strong>getChannelAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelAccountsRequest
*/
func (a *ChannelApiService) GetChannelAccounts(ctx context.Context) ApiGetChannelAccountsRequest {
	return ApiGetChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelAccountsSummary
func (a *ChannelApiService) GetChannelAccountsExecute(r ApiGetChannelAccountsRequest) (*ChannelAccountsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccountsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.excludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInactive", r.excludeInactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.accountCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountCode", r.accountCode, "")
	}
	if r.contractExpInDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractExpInDays", r.contractExpInDays, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelBillingStatementRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	statementId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelBillingStatementRequest) Authorization(authorization string) ApiGetChannelBillingStatementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelBillingStatementRequest) XAppKey(xAppKey string) ApiGetChannelBillingStatementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelBillingStatementRequest) XHotelid(xHotelid string) ApiGetChannelBillingStatementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetChannelBillingStatementRequest) IdContext(idContext string) ApiGetChannelBillingStatementRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetChannelBillingStatementRequest) IdType(idType string) ApiGetChannelBillingStatementRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r ApiGetChannelBillingStatementRequest) XExternalsystem(xExternalsystem string) ApiGetChannelBillingStatementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelBillingStatementRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelBillingStatementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelBillingStatementRequest) Execute() (*ChannelBillingStatement, *http.Response, error) {
	return r.ApiService.GetChannelBillingStatementExecute(r)
}

/*
GetChannelBillingStatement Retrieves channel billing statement for a given statement Id

This API retrieves channel billing statement for a given statement Id. <p><strong>OperationId:</strong>getChannelBillingStatement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId Statement Id.
 @return ApiGetChannelBillingStatementRequest
*/
func (a *ChannelApiService) GetChannelBillingStatement(ctx context.Context, statementId string) ApiGetChannelBillingStatementRequest {
	return ApiGetChannelBillingStatementRequest{
		ApiService: a,
		ctx: ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return ChannelBillingStatement
func (a *ChannelApiService) GetChannelBillingStatementExecute(r ApiGetChannelBillingStatementRequest) (*ChannelBillingStatement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelBillingStatement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBillingStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/{statementId}"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.statementId) < 1 {
		return localVarReturnValue, nil, reportError("statementId must have at least 1 elements")
	}
	if strlen(r.statementId) > 2000 {
		return localVarReturnValue, nil, reportError("statementId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelBillingStatementDetailsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	statementId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	contractId *string
	contractIdType *string
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelBillingStatementDetailsRequest) Authorization(authorization string) ApiGetChannelBillingStatementDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelBillingStatementDetailsRequest) XAppKey(xAppKey string) ApiGetChannelBillingStatementDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelBillingStatementDetailsRequest) XHotelid(xHotelid string) ApiGetChannelBillingStatementDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelBillingStatementDetailsRequest) Limit(limit int32) ApiGetChannelBillingStatementDetailsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelBillingStatementDetailsRequest) Offset(offset int32) ApiGetChannelBillingStatementDetailsRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetChannelBillingStatementDetailsRequest) ContractId(contractId string) ApiGetChannelBillingStatementDetailsRequest {
	r.contractId = &contractId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetChannelBillingStatementDetailsRequest) ContractIdType(contractIdType string) ApiGetChannelBillingStatementDetailsRequest {
	r.contractIdType = &contractIdType
	return r
}

func (r ApiGetChannelBillingStatementDetailsRequest) AttributeName(attributeName []string) ApiGetChannelBillingStatementDetailsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiGetChannelBillingStatementDetailsRequest) OrderType(orderType []string) ApiGetChannelBillingStatementDetailsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ApiGetChannelBillingStatementDetailsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelBillingStatementDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelBillingStatementDetailsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelBillingStatementDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelBillingStatementDetailsRequest) Execute() (*ChannelBillingStatementDetails, *http.Response, error) {
	return r.ApiService.GetChannelBillingStatementDetailsExecute(r)
}

/*
GetChannelBillingStatementDetails Retrieves channel billing statement details for a given statement Id

This API retrieves channel billing statement details for a given statement Id. <p><strong>OperationId:</strong>getChannelBillingStatementDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId Statement Id.
 @return ApiGetChannelBillingStatementDetailsRequest
*/
func (a *ChannelApiService) GetChannelBillingStatementDetails(ctx context.Context, statementId string) ApiGetChannelBillingStatementDetailsRequest {
	return ApiGetChannelBillingStatementDetailsRequest{
		ApiService: a,
		ctx: ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return ChannelBillingStatementDetails
func (a *ChannelApiService) GetChannelBillingStatementDetailsExecute(r ApiGetChannelBillingStatementDetailsRequest) (*ChannelBillingStatementDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelBillingStatementDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBillingStatementDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/{statementId}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.statementId) < 1 {
		return localVarReturnValue, nil, reportError("statementId must have at least 1 elements")
	}
	if strlen(r.statementId) > 2000 {
		return localVarReturnValue, nil, reportError("statementId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", r.contractId, "")
	}
	if r.contractIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractIdType", r.contractIdType, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	includeLocked *bool
	limit *int32
	offset *int32
	statementId *string
	statementIdType *string
	beginDate *string
	endDate *string
	profileId *[]string
	profileIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelBillingStatementsRequest) Authorization(authorization string) ApiGetChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelBillingStatementsRequest) XAppKey(xAppKey string) ApiGetChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelBillingStatementsRequest) XHotelid(xHotelid string) ApiGetChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether search results should include locked statements or not. By default, locked statements will be included.
func (r ApiGetChannelBillingStatementsRequest) IncludeLocked(includeLocked bool) ApiGetChannelBillingStatementsRequest {
	r.includeLocked = &includeLocked
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelBillingStatementsRequest) Limit(limit int32) ApiGetChannelBillingStatementsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelBillingStatementsRequest) Offset(offset int32) ApiGetChannelBillingStatementsRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetChannelBillingStatementsRequest) StatementId(statementId string) ApiGetChannelBillingStatementsRequest {
	r.statementId = &statementId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetChannelBillingStatementsRequest) StatementIdType(statementIdType string) ApiGetChannelBillingStatementsRequest {
	r.statementIdType = &statementIdType
	return r
}

// Begin date of the statement.
func (r ApiGetChannelBillingStatementsRequest) BeginDate(beginDate string) ApiGetChannelBillingStatementsRequest {
	r.beginDate = &beginDate
	return r
}

// End date of the statement.
func (r ApiGetChannelBillingStatementsRequest) EndDate(endDate string) ApiGetChannelBillingStatementsRequest {
	r.endDate = &endDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetChannelBillingStatementsRequest) ProfileId(profileId []string) ApiGetChannelBillingStatementsRequest {
	r.profileId = &profileId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetChannelBillingStatementsRequest) ProfileIdType(profileIdType []string) ApiGetChannelBillingStatementsRequest {
	r.profileIdType = &profileIdType
	return r
}

// External system code.
func (r ApiGetChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelBillingStatementsRequest) Execute() (*ChannelBillingStatementSummaries, *http.Response, error) {
	return r.ApiService.GetChannelBillingStatementsExecute(r)
}

/*
GetChannelBillingStatements Retrieves channel billing statements.

This API retrieves channel billing statements. <p><strong>OperationId:</strong>getChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelBillingStatementsRequest
*/
func (a *ChannelApiService) GetChannelBillingStatements(ctx context.Context) ApiGetChannelBillingStatementsRequest {
	return ApiGetChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelBillingStatementSummaries
func (a *ChannelApiService) GetChannelBillingStatementsExecute(r ApiGetChannelBillingStatementsRequest) (*ChannelBillingStatementSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelBillingStatementSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLocked", r.includeLocked, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.statementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementId", r.statementId, "")
	}
	if r.statementIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementIdType", r.statementIdType, "")
	}
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.profileId != nil {
		t := *r.profileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", t, "multi")
		}
	}
	if r.profileIdType != nil {
		t := *r.profileIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelCardTypeMappingsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	cardTypes *[]string
	channelCardTypes *[]string
	includeInactive *bool
	fetchUnmapped *bool
	fetchMapped *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r ApiGetChannelCardTypeMappingsRequest) HotelIds(hotelIds []string) ApiGetChannelCardTypeMappingsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelCardTypeMappingsRequest) Authorization(authorization string) ApiGetChannelCardTypeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelCardTypeMappingsRequest) XAppKey(xAppKey string) ApiGetChannelCardTypeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelCardTypeMappingsRequest) XHotelid(xHotelid string) ApiGetChannelCardTypeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelCardTypeMappingsRequest) Limit(limit int32) ApiGetChannelCardTypeMappingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelCardTypeMappingsRequest) Offset(offset int32) ApiGetChannelCardTypeMappingsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChannelCardTypeMappingsRequest) BookingChannelCodes(bookingChannelCodes []string) ApiGetChannelCardTypeMappingsRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ApiGetChannelCardTypeMappingsRequest) CardTypes(cardTypes []string) ApiGetChannelCardTypeMappingsRequest {
	r.cardTypes = &cardTypes
	return r
}

func (r ApiGetChannelCardTypeMappingsRequest) ChannelCardTypes(channelCardTypes []string) ApiGetChannelCardTypeMappingsRequest {
	r.channelCardTypes = &channelCardTypes
	return r
}

// Indicates whether search includes inactive mapping.
func (r ApiGetChannelCardTypeMappingsRequest) IncludeInactive(includeInactive bool) ApiGetChannelCardTypeMappingsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether unmapped channel-hotel card types should be fetched.
func (r ApiGetChannelCardTypeMappingsRequest) FetchUnmapped(fetchUnmapped bool) ApiGetChannelCardTypeMappingsRequest {
	r.fetchUnmapped = &fetchUnmapped
	return r
}

// Indicates whether mapped channel-hotel card types should be fetched.
func (r ApiGetChannelCardTypeMappingsRequest) FetchMapped(fetchMapped bool) ApiGetChannelCardTypeMappingsRequest {
	r.fetchMapped = &fetchMapped
	return r
}

// External system code.
func (r ApiGetChannelCardTypeMappingsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelCardTypeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelCardTypeMappingsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelCardTypeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelCardTypeMappingsRequest) Execute() (*ChannelCardTypeMappingDetails, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingsExecute(r)
}

/*
GetChannelCardTypeMappings Gets channel credit card mapping for a hotel

Use this API to get channel mapping for OPERA credit cards to channel for a given hotel id. <p><strong>OperationId:</strong>getChannelCardTypeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelCardTypeMappingsRequest
*/
func (a *ChannelApiService) GetChannelCardTypeMappings(ctx context.Context) ApiGetChannelCardTypeMappingsRequest {
	return ApiGetChannelCardTypeMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelCardTypeMappingDetails
func (a *ChannelApiService) GetChannelCardTypeMappingsExecute(r ApiGetChannelCardTypeMappingsRequest) (*ChannelCardTypeMappingDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelCardTypeMappingDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelCardTypeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardType/mappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hotelIds == nil {
		return localVarReturnValue, nil, reportError("hotelIds is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.cardTypes != nil {
		t := *r.cardTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cardTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cardTypes", t, "multi")
		}
	}
	if r.channelCardTypes != nil {
		t := *r.channelCardTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCardTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCardTypes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.fetchUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchUnmapped", r.fetchUnmapped, "")
	}
	if r.fetchMapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchMapped", r.fetchMapped, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelGuaranteeCodeMappingsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	guaranteeCode *[]string
	channelGuaranteeCode *[]string
	includeInactive *bool
	fetchUnmapped *bool
	fetchMapped *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelGuaranteeCodeMappingsRequest) Authorization(authorization string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelGuaranteeCodeMappingsRequest) XAppKey(xAppKey string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelGuaranteeCodeMappingsRequest) XHotelid(xHotelid string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelGuaranteeCodeMappingsRequest) Limit(limit int32) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelGuaranteeCodeMappingsRequest) Offset(offset int32) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChannelGuaranteeCodeMappingsRequest) BookingChannelCodes(bookingChannelCodes []string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ApiGetChannelGuaranteeCodeMappingsRequest) GuaranteeCode(guaranteeCode []string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

func (r ApiGetChannelGuaranteeCodeMappingsRequest) ChannelGuaranteeCode(channelGuaranteeCode []string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.channelGuaranteeCode = &channelGuaranteeCode
	return r
}

// Indicates whether search includes inactive mapping.
func (r ApiGetChannelGuaranteeCodeMappingsRequest) IncludeInactive(includeInactive bool) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether unmapped channel-hotel guarantee code should be fetched.
func (r ApiGetChannelGuaranteeCodeMappingsRequest) FetchUnmapped(fetchUnmapped bool) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.fetchUnmapped = &fetchUnmapped
	return r
}

// Indicates whether mapped channel-hotel guarantee code should be fetched.
func (r ApiGetChannelGuaranteeCodeMappingsRequest) FetchMapped(fetchMapped bool) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.fetchMapped = &fetchMapped
	return r
}

// External system code.
func (r ApiGetChannelGuaranteeCodeMappingsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelGuaranteeCodeMappingsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelGuaranteeCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelGuaranteeCodeMappingsRequest) Execute() (*ChannelGuaranteeCodeMappingDetails, *http.Response, error) {
	return r.ApiService.GetChannelGuaranteeCodeMappingsExecute(r)
}

/*
GetChannelGuaranteeCodeMappings Gets channel guarantee code mappings

Use this API  to get the list of the channel guarantee code mappings to the OPERA guarantee codes. <p><strong>OperationId:</strong>getChannelGuaranteeCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelGuaranteeCodeMappingsRequest
*/
func (a *ChannelApiService) GetChannelGuaranteeCodeMappings(ctx context.Context, hotelId string) ApiGetChannelGuaranteeCodeMappingsRequest {
	return ApiGetChannelGuaranteeCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelGuaranteeCodeMappingDetails
func (a *ChannelApiService) GetChannelGuaranteeCodeMappingsExecute(r ApiGetChannelGuaranteeCodeMappingsRequest) (*ChannelGuaranteeCodeMappingDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelGuaranteeCodeMappingDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelGuaranteeCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/guarantees"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		t := *r.guaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", t, "multi")
		}
	}
	if r.channelGuaranteeCode != nil {
		t := *r.channelGuaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelGuaranteeCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelGuaranteeCode", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.fetchUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchUnmapped", r.fetchUnmapped, "")
	}
	if r.fetchMapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchMapped", r.fetchMapped, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelHotelCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	channelHotelCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelHotelCodeMappingRequest) Authorization(authorization string) ApiGetChannelHotelCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelHotelCodeMappingRequest) XAppKey(xAppKey string) ApiGetChannelHotelCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelHotelCodeMappingRequest) XHotelid(xHotelid string) ApiGetChannelHotelCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// OPERA hotel code for which mapped channel hotel code should be fetched.
func (r ApiGetChannelHotelCodeMappingRequest) HotelId(hotelId string) ApiGetChannelHotelCodeMappingRequest {
	r.hotelId = &hotelId
	return r
}

// Channel hotel code for which mapped OPERA hotel code should be fetched.
func (r ApiGetChannelHotelCodeMappingRequest) ChannelHotelCode(channelHotelCode string) ApiGetChannelHotelCodeMappingRequest {
	r.channelHotelCode = &channelHotelCode
	return r
}

// External system code.
func (r ApiGetChannelHotelCodeMappingRequest) XExternalsystem(xExternalsystem string) ApiGetChannelHotelCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelHotelCodeMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelHotelCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelHotelCodeMappingRequest) Execute() (*ChannelHotelCodeMapping, *http.Response, error) {
	return r.ApiService.GetChannelHotelCodeMappingExecute(r)
}

/*
GetChannelHotelCodeMapping Get channel hotel mappings

Use this API to get the channel mappings to the OPERA hotel id, including hotel details for channel hotel code, room sell limit per reservation, city code and end date. <p><strong>OperationId:</strong>getChannelHotelCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiGetChannelHotelCodeMappingRequest
*/
func (a *ChannelApiService) GetChannelHotelCodeMapping(ctx context.Context, channelCode string) ApiGetChannelHotelCodeMappingRequest {
	return ApiGetChannelHotelCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return ChannelHotelCodeMapping
func (a *ChannelApiService) GetChannelHotelCodeMappingExecute(r ApiGetChannelHotelCodeMappingRequest) (*ChannelHotelCodeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelHotelCodeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelHotelCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/hotels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.channelHotelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelHotelCode", r.channelHotelCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCode *[]string
	hotelIds *[]string
	language *string
	letterType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelHotelLettersRequest) Authorization(authorization string) ApiGetChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelHotelLettersRequest) XAppKey(xAppKey string) ApiGetChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelHotelLettersRequest) XHotelid(xHotelid string) ApiGetChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetChannelHotelLettersRequest) ChannelCode(channelCode []string) ApiGetChannelHotelLettersRequest {
	r.channelCode = &channelCode
	return r
}

func (r ApiGetChannelHotelLettersRequest) HotelIds(hotelIds []string) ApiGetChannelHotelLettersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Language code associated with the hotel letters.
func (r ApiGetChannelHotelLettersRequest) Language(language string) ApiGetChannelHotelLettersRequest {
	r.language = &language
	return r
}

// Represents Inquiry Letter Type.
func (r ApiGetChannelHotelLettersRequest) LetterType(letterType string) ApiGetChannelHotelLettersRequest {
	r.letterType = &letterType
	return r
}

// External system code.
func (r ApiGetChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ApiGetChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelHotelLettersRequest) Execute() (*FetchedChannelHotelLetters, *http.Response, error) {
	return r.ApiService.GetChannelHotelLettersExecute(r)
}

/*
GetChannelHotelLetters Gets channel property confirmation letter mapping

Use this API to get channel property confirmation letter configuration <p><strong>OperationId:</strong>getChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelHotelLettersRequest
*/
func (a *ChannelApiService) GetChannelHotelLetters(ctx context.Context) ApiGetChannelHotelLettersRequest {
	return ApiGetChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedChannelHotelLetters
func (a *ChannelApiService) GetChannelHotelLettersExecute(r ApiGetChannelHotelLettersRequest) (*FetchedChannelHotelLetters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedChannelHotelLetters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.channelCode != nil {
		t := *r.channelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.letterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "letterType", r.letterType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionType *string
	policyType *string
	policyDetail *string
	beginDate *string
	filterHotelIds *[]string
	bookingChannelCode *[]string
	transactionTypes *[]string
	policyTypesPolicyType *[]string
	policyDetailPolicyDetail *[]string
	showGlobal *bool
	includeInactive *bool
	fetchInstructions *[]string
	hotelIds *[]string
	channelCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelMarketingTextRequest) Authorization(authorization string) ApiGetChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelMarketingTextRequest) XAppKey(xAppKey string) ApiGetChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelMarketingTextRequest) XHotelid(xHotelid string) ApiGetChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetChannelMarketingTextRequest) TransactionType(transactionType string) ApiGetChannelMarketingTextRequest {
	r.transactionType = &transactionType
	return r
}

func (r ApiGetChannelMarketingTextRequest) PolicyType(policyType string) ApiGetChannelMarketingTextRequest {
	r.policyType = &policyType
	return r
}

func (r ApiGetChannelMarketingTextRequest) PolicyDetail(policyDetail string) ApiGetChannelMarketingTextRequest {
	r.policyDetail = &policyDetail
	return r
}

func (r ApiGetChannelMarketingTextRequest) BeginDate(beginDate string) ApiGetChannelMarketingTextRequest {
	r.beginDate = &beginDate
	return r
}

func (r ApiGetChannelMarketingTextRequest) FilterHotelIds(filterHotelIds []string) ApiGetChannelMarketingTextRequest {
	r.filterHotelIds = &filterHotelIds
	return r
}

func (r ApiGetChannelMarketingTextRequest) BookingChannelCode(bookingChannelCode []string) ApiGetChannelMarketingTextRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r ApiGetChannelMarketingTextRequest) TransactionTypes(transactionTypes []string) ApiGetChannelMarketingTextRequest {
	r.transactionTypes = &transactionTypes
	return r
}

func (r ApiGetChannelMarketingTextRequest) PolicyTypesPolicyType(policyTypesPolicyType []string) ApiGetChannelMarketingTextRequest {
	r.policyTypesPolicyType = &policyTypesPolicyType
	return r
}

func (r ApiGetChannelMarketingTextRequest) PolicyDetailPolicyDetail(policyDetailPolicyDetail []string) ApiGetChannelMarketingTextRequest {
	r.policyDetailPolicyDetail = &policyDetailPolicyDetail
	return r
}

func (r ApiGetChannelMarketingTextRequest) ShowGlobal(showGlobal bool) ApiGetChannelMarketingTextRequest {
	r.showGlobal = &showGlobal
	return r
}

// Include or not include inactive channel marketing text.
func (r ApiGetChannelMarketingTextRequest) IncludeInactive(includeInactive bool) ApiGetChannelMarketingTextRequest {
	r.includeInactive = &includeInactive
	return r
}

// Simple type for channel fetch instruction.
func (r ApiGetChannelMarketingTextRequest) FetchInstructions(fetchInstructions []string) ApiGetChannelMarketingTextRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Hotel code.
func (r ApiGetChannelMarketingTextRequest) HotelIds(hotelIds []string) ApiGetChannelMarketingTextRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ApiGetChannelMarketingTextRequest) ChannelCode(channelCode []string) ApiGetChannelMarketingTextRequest {
	r.channelCode = &channelCode
	return r
}

// External system code.
func (r ApiGetChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ApiGetChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelMarketingTextRequest) Execute() (*ChannelMarketingTextsInfo, *http.Response, error) {
	return r.ApiService.GetChannelMarketingTextExecute(r)
}

/*
GetChannelMarketingText Gets channel marketing messages

Use this API to get channel mapping for marketing messages. <p><strong>OperationId:</strong>getChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelMarketingTextRequest
*/
func (a *ChannelApiService) GetChannelMarketingText(ctx context.Context) ApiGetChannelMarketingTextRequest {
	return ApiGetChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelMarketingTextsInfo
func (a *ChannelApiService) GetChannelMarketingTextExecute(r ApiGetChannelMarketingTextRequest) (*ChannelMarketingTextsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelMarketingTextsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.transactionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", r.transactionType, "")
	}
	if r.policyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyType", r.policyType, "")
	}
	if r.policyDetail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetail", r.policyDetail, "")
	}
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.filterHotelIds != nil {
		t := *r.filterHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterHotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterHotelIds", t, "multi")
		}
	}
	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.transactionTypes != nil {
		t := *r.transactionTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionTypes", t, "multi")
		}
	}
	if r.policyTypesPolicyType != nil {
		t := *r.policyTypesPolicyType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyTypesPolicyType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyTypesPolicyType", t, "multi")
		}
	}
	if r.policyDetailPolicyDetail != nil {
		t := *r.policyDetailPolicyDetail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetailPolicyDetail", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetailPolicyDetail", t, "multi")
		}
	}
	if r.showGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showGlobal", r.showGlobal, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.channelCode != nil {
		t := *r.channelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	hotelId *string
	bookingChannelCode *string
	channelRatePlanCode *string
	accessCode *string
	uniqueId *[]string
	uniqueIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelNegotiatedRateRequest) Authorization(authorization string) ApiGetChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelNegotiatedRateRequest) XAppKey(xAppKey string) ApiGetChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelNegotiatedRateRequest) XHotelid(xHotelid string) ApiGetChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelNegotiatedRateRequest) Limit(limit int32) ApiGetChannelNegotiatedRateRequest {
	r.limit = &limit
	return r
}

func (r ApiGetChannelNegotiatedRateRequest) HotelId(hotelId string) ApiGetChannelNegotiatedRateRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiGetChannelNegotiatedRateRequest) BookingChannelCode(bookingChannelCode string) ApiGetChannelNegotiatedRateRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r ApiGetChannelNegotiatedRateRequest) ChannelRatePlanCode(channelRatePlanCode string) ApiGetChannelNegotiatedRateRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

func (r ApiGetChannelNegotiatedRateRequest) AccessCode(accessCode string) ApiGetChannelNegotiatedRateRequest {
	r.accessCode = &accessCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetChannelNegotiatedRateRequest) UniqueId(uniqueId []string) ApiGetChannelNegotiatedRateRequest {
	r.uniqueId = &uniqueId
	return r
}

func (r ApiGetChannelNegotiatedRateRequest) UniqueIdType(uniqueIdType []string) ApiGetChannelNegotiatedRateRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// External system code.
func (r ApiGetChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ApiGetChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelNegotiatedRateRequest) Execute() (*ChannelNegotiatedRateDetails, *http.Response, error) {
	return r.ApiService.GetChannelNegotiatedRateExecute(r)
}

/*
GetChannelNegotiatedRate Gets channel negotiate rate

Use this API to update channel's negotiated rate code mapping including negotiated profile, negotiate rate access code, start date, end date, and sequence. <p><strong>OperationId:</strong>getChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) GetChannelNegotiatedRate(ctx context.Context) ApiGetChannelNegotiatedRateRequest {
	return ApiGetChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelNegotiatedRateDetails
func (a *ChannelApiService) GetChannelNegotiatedRateExecute(r ApiGetChannelNegotiatedRateRequest) (*ChannelNegotiatedRateDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelNegotiatedRateDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.channelRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", r.channelRatePlanCode, "")
	}
	if r.accessCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessCode", r.accessCode, "")
	}
	if r.uniqueId != nil {
		t := *r.uniqueId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueId", t, "multi")
		}
	}
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	tenantCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelOrgMappingRequest) Authorization(authorization string) ApiGetChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelOrgMappingRequest) XAppKey(xAppKey string) ApiGetChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelOrgMappingRequest) XHotelid(xHotelid string) ApiGetChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Chain code for which channel code and org code are mapped.
func (r ApiGetChannelOrgMappingRequest) ChainCode(chainCode string) ApiGetChannelOrgMappingRequest {
	r.chainCode = &chainCode
	return r
}

// External system code.
func (r ApiGetChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ApiGetChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelOrgMappingRequest) Execute() (*ChannelOrgMappingsDetails, *http.Response, error) {
	return r.ApiService.GetChannelOrgMappingExecute(r)
}

/*
GetChannelOrgMapping Retrieves channel tenants mapping.

This API retrieves channel tenants mapping. <p><strong>OperationId:</strong>getChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantCode Tenant Code.
 @param channelCode Unique ID that identifies a channel.
 @return ApiGetChannelOrgMappingRequest
*/
func (a *ChannelApiService) GetChannelOrgMapping(ctx context.Context, tenantCode string, channelCode string) ApiGetChannelOrgMappingRequest {
	return ApiGetChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		tenantCode: tenantCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return ChannelOrgMappingsDetails
func (a *ChannelApiService) GetChannelOrgMappingExecute(r ApiGetChannelOrgMappingRequest) (*ChannelOrgMappingsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelOrgMappingsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants/{tenantCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantCode"+"}", url.PathEscape(parameterValueToString(r.tenantCode, "tenantCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tenantCode) < 1 {
		return localVarReturnValue, nil, reportError("tenantCode must have at least 1 elements")
	}
	if strlen(r.tenantCode) > 2000 {
		return localVarReturnValue, nil, reportError("tenantCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.chainCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", r.chainCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelParametersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	parameterNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelParametersRequest) Authorization(authorization string) ApiGetChannelParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelParametersRequest) XAppKey(xAppKey string) ApiGetChannelParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelParametersRequest) XHotelid(xHotelid string) ApiGetChannelParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Parameter for wild card search on channel parameters.
func (r ApiGetChannelParametersRequest) ParameterNameWildCard(parameterNameWildCard string) ApiGetChannelParametersRequest {
	r.parameterNameWildCard = &parameterNameWildCard
	return r
}

// External system code.
func (r ApiGetChannelParametersRequest) XExternalsystem(xExternalsystem string) ApiGetChannelParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelParametersRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelParametersRequest) Execute() (*ChannelParameterMapping, *http.Response, error) {
	return r.ApiService.GetChannelParametersExecute(r)
}

/*
GetChannelParameters Retrieves channel parameters.

Use this API to get list of channel parameters and their settings. <p><strong>OperationId:</strong>getChannelParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelParametersRequest
*/
func (a *ChannelApiService) GetChannelParameters(ctx context.Context, channelCode string, hotelId string) ApiGetChannelParametersRequest {
	return ApiGetChannelParametersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelParameterMapping
func (a *ChannelApiService) GetChannelParametersExecute(r ApiGetChannelParametersRequest) (*ChannelParameterMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelParameterMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.parameterNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNameWildCard", r.parameterNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelPoliciesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	requestType *string
	startDate *string
	endDate *string
	duration *string
	channelRatePlanCode *[]string
	channelRoomTypeCode *[]string
	ratePlanCode *[]string
	roomTypeCode *[]string
	corporateId *string
	corporateIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelPoliciesRequest) Authorization(authorization string) ApiGetChannelPoliciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelPoliciesRequest) XAppKey(xAppKey string) ApiGetChannelPoliciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelPoliciesRequest) XHotelid(xHotelid string) ApiGetChannelPoliciesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetChannelPoliciesRequest) RequestType(requestType string) ApiGetChannelPoliciesRequest {
	r.requestType = &requestType
	return r
}

func (r ApiGetChannelPoliciesRequest) StartDate(startDate string) ApiGetChannelPoliciesRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetChannelPoliciesRequest) EndDate(endDate string) ApiGetChannelPoliciesRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetChannelPoliciesRequest) Duration(duration string) ApiGetChannelPoliciesRequest {
	r.duration = &duration
	return r
}

func (r ApiGetChannelPoliciesRequest) ChannelRatePlanCode(channelRatePlanCode []string) ApiGetChannelPoliciesRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

func (r ApiGetChannelPoliciesRequest) ChannelRoomTypeCode(channelRoomTypeCode []string) ApiGetChannelPoliciesRequest {
	r.channelRoomTypeCode = &channelRoomTypeCode
	return r
}

func (r ApiGetChannelPoliciesRequest) RatePlanCode(ratePlanCode []string) ApiGetChannelPoliciesRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

func (r ApiGetChannelPoliciesRequest) RoomTypeCode(roomTypeCode []string) ApiGetChannelPoliciesRequest {
	r.roomTypeCode = &roomTypeCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetChannelPoliciesRequest) CorporateId(corporateId string) ApiGetChannelPoliciesRequest {
	r.corporateId = &corporateId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetChannelPoliciesRequest) CorporateIdType(corporateIdType string) ApiGetChannelPoliciesRequest {
	r.corporateIdType = &corporateIdType
	return r
}

// External system code.
func (r ApiGetChannelPoliciesRequest) XExternalsystem(xExternalsystem string) ApiGetChannelPoliciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelPoliciesRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelPoliciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelPoliciesRequest) Execute() (*ChannelPolicies, *http.Response, error) {
	return r.ApiService.GetChannelPoliciesExecute(r)
}

/*
GetChannelPolicies Retrieves the channel policies

Use this API to retrieve channel policies mapping. <p><strong>OperationId:</strong>getChannelPolicies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelPoliciesRequest
*/
func (a *ChannelApiService) GetChannelPolicies(ctx context.Context, channelCode string, hotelId string) ApiGetChannelPoliciesRequest {
	return ApiGetChannelPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelPolicies
func (a *ChannelApiService) GetChannelPoliciesExecute(r ApiGetChannelPoliciesRequest) (*ChannelPolicies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.requestType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestType", r.requestType, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.channelRatePlanCode != nil {
		t := *r.channelRatePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", t, "multi")
		}
	}
	if r.channelRoomTypeCode != nil {
		t := *r.channelRoomTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypeCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypeCode", t, "multi")
		}
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.roomTypeCode != nil {
		t := *r.roomTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCode", t, "multi")
		}
	}
	if r.corporateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateId", r.corporateId, "")
	}
	if r.corporateIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIdType", r.corporateIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRateCodeGlobalDescRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRateCodeGlobalDescRequest) Authorization(authorization string) ApiGetChannelRateCodeGlobalDescRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRateCodeGlobalDescRequest) XAppKey(xAppKey string) ApiGetChannelRateCodeGlobalDescRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRateCodeGlobalDescRequest) XHotelid(xHotelid string) ApiGetChannelRateCodeGlobalDescRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetChannelRateCodeGlobalDescRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRateCodeGlobalDescRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRateCodeGlobalDescRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRateCodeGlobalDescRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRateCodeGlobalDescRequest) Execute() (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	return r.ApiService.GetChannelRateCodeGlobalDescExecute(r)
}

/*
GetChannelRateCodeGlobalDesc Gets global rate descriptions

Use this API to get global rate description for given hotel id and rate code. <p><strong>OperationId:</strong>getChannelRateCodeGlobalDesc</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelRateCodeGlobalDescRequest
*/
func (a *ChannelApiService) GetChannelRateCodeGlobalDesc(ctx context.Context, ratePlanCode string, hotelId string) ApiGetChannelRateCodeGlobalDescRequest {
	return ApiGetChannelRateCodeGlobalDescRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelEnhancedGlobalDescription
func (a *ChannelApiService) GetChannelRateCodeGlobalDescExecute(r ApiGetChannelRateCodeGlobalDescRequest) (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelEnhancedGlobalDescription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRateCodeGlobalDesc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rates/{ratePlanCode}/globalDescription"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *[]string
	channelCode *[]string
	ratePlanCodes *[]string
	channelRatePlanCodes *[]string
	ratePlanCategories *[]string
	channelRatePlanCategories *[]string
	includeUnmappedRatePlans *bool
	onlyUnmappedRatePlans *bool
	includeInactiveMappings *bool
	onlyNegotiatedRates *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRateMappingRequest) Authorization(authorization string) ApiGetChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRateMappingRequest) XAppKey(xAppKey string) ApiGetChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRateMappingRequest) XHotelid(xHotelid string) ApiGetChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelRateMappingRequest) Limit(limit int32) ApiGetChannelRateMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelRateMappingRequest) Offset(offset int32) ApiGetChannelRateMappingRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChannelRateMappingRequest) HotelId(hotelId []string) ApiGetChannelRateMappingRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiGetChannelRateMappingRequest) ChannelCode(channelCode []string) ApiGetChannelRateMappingRequest {
	r.channelCode = &channelCode
	return r
}

func (r ApiGetChannelRateMappingRequest) RatePlanCodes(ratePlanCodes []string) ApiGetChannelRateMappingRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ApiGetChannelRateMappingRequest) ChannelRatePlanCodes(channelRatePlanCodes []string) ApiGetChannelRateMappingRequest {
	r.channelRatePlanCodes = &channelRatePlanCodes
	return r
}

func (r ApiGetChannelRateMappingRequest) RatePlanCategories(ratePlanCategories []string) ApiGetChannelRateMappingRequest {
	r.ratePlanCategories = &ratePlanCategories
	return r
}

func (r ApiGetChannelRateMappingRequest) ChannelRatePlanCategories(channelRatePlanCategories []string) ApiGetChannelRateMappingRequest {
	r.channelRatePlanCategories = &channelRatePlanCategories
	return r
}

// Flag whether to include unmapped rate codes.
func (r ApiGetChannelRateMappingRequest) IncludeUnmappedRatePlans(includeUnmappedRatePlans bool) ApiGetChannelRateMappingRequest {
	r.includeUnmappedRatePlans = &includeUnmappedRatePlans
	return r
}

// Flag whether to include unmapped rate codes only.
func (r ApiGetChannelRateMappingRequest) OnlyUnmappedRatePlans(onlyUnmappedRatePlans bool) ApiGetChannelRateMappingRequest {
	r.onlyUnmappedRatePlans = &onlyUnmappedRatePlans
	return r
}

// Flag whether to include inactive mappings.
func (r ApiGetChannelRateMappingRequest) IncludeInactiveMappings(includeInactiveMappings bool) ApiGetChannelRateMappingRequest {
	r.includeInactiveMappings = &includeInactiveMappings
	return r
}

// Flag whether to include negotiated rate mappings only.
func (r ApiGetChannelRateMappingRequest) OnlyNegotiatedRates(onlyNegotiatedRates bool) ApiGetChannelRateMappingRequest {
	r.onlyNegotiatedRates = &onlyNegotiatedRates
	return r
}

// External system code.
func (r ApiGetChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRateMappingRequest) Execute() (*ChannelRateMappings, *http.Response, error) {
	return r.ApiService.GetChannelRateMappingExecute(r)
}

/*
GetChannelRateMapping Gets channel property rate mapping

Use this API to get channel property rate mapping including channel rate code, start date, end date, rate level, channel rate description. <p><strong>OperationId:</strong>getChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelRateMappingRequest
*/
func (a *ChannelApiService) GetChannelRateMapping(ctx context.Context) ApiGetChannelRateMappingRequest {
	return ApiGetChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelRateMappings
func (a *ChannelApiService) GetChannelRateMappingExecute(r ApiGetChannelRateMappingRequest) (*ChannelRateMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRateMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.channelCode != nil {
		t := *r.channelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", t, "multi")
		}
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.channelRatePlanCodes != nil {
		t := *r.channelRatePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCodes", t, "multi")
		}
	}
	if r.ratePlanCategories != nil {
		t := *r.ratePlanCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategories", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategories", t, "multi")
		}
	}
	if r.channelRatePlanCategories != nil {
		t := *r.channelRatePlanCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCategories", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCategories", t, "multi")
		}
	}
	if r.includeUnmappedRatePlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUnmappedRatePlans", r.includeUnmappedRatePlans, "")
	}
	if r.onlyUnmappedRatePlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyUnmappedRatePlans", r.onlyUnmappedRatePlans, "")
	}
	if r.includeInactiveMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveMappings", r.includeInactiveMappings, "")
	}
	if r.onlyNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyNegotiatedRates", r.onlyNegotiatedRates, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRateRoomSeqRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	ratePlanCode *string
	roomType *string
	channelRatePlanCode *string
	channelRoomType *string
	channelRateRoomParameterName *[]string
	channelRateRoomParameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRateRoomSeqRequest) Authorization(authorization string) ApiGetChannelRateRoomSeqRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRateRoomSeqRequest) XAppKey(xAppKey string) ApiGetChannelRateRoomSeqRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRateRoomSeqRequest) XHotelid(xHotelid string) ApiGetChannelRateRoomSeqRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelRateRoomSeqRequest) Limit(limit int32) ApiGetChannelRateRoomSeqRequest {
	r.limit = &limit
	return r
}

// Hotel Rate Plan Code.
func (r ApiGetChannelRateRoomSeqRequest) RatePlanCode(ratePlanCode string) ApiGetChannelRateRoomSeqRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Hotel Room Type.
func (r ApiGetChannelRateRoomSeqRequest) RoomType(roomType string) ApiGetChannelRateRoomSeqRequest {
	r.roomType = &roomType
	return r
}

// Channel Rate Plan Code.
func (r ApiGetChannelRateRoomSeqRequest) ChannelRatePlanCode(channelRatePlanCode string) ApiGetChannelRateRoomSeqRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

// Channel Room Type.
func (r ApiGetChannelRateRoomSeqRequest) ChannelRoomType(channelRoomType string) ApiGetChannelRateRoomSeqRequest {
	r.channelRoomType = &channelRoomType
	return r
}

// Enumaration of the different parameters Channel Rate Room accepts.
func (r ApiGetChannelRateRoomSeqRequest) ChannelRateRoomParameterName(channelRateRoomParameterName []string) ApiGetChannelRateRoomSeqRequest {
	r.channelRateRoomParameterName = &channelRateRoomParameterName
	return r
}

func (r ApiGetChannelRateRoomSeqRequest) ChannelRateRoomParameterValue(channelRateRoomParameterValue []string) ApiGetChannelRateRoomSeqRequest {
	r.channelRateRoomParameterValue = &channelRateRoomParameterValue
	return r
}

// External system code.
func (r ApiGetChannelRateRoomSeqRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRateRoomSeqRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRateRoomSeqRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRateRoomSeqRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRateRoomSeqRequest) Execute() (*ChannelRateRoomSequenceDetails, *http.Response, error) {
	return r.ApiService.GetChannelRateRoomSeqExecute(r)
}

/*
GetChannelRateRoomSeq Gets channel property rateroom sequence

Use this API to get sequence for given channel property rate room mapping. <p><strong>OperationId:</strong>getChannelRateRoomSeq</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiGetChannelRateRoomSeqRequest
*/
func (a *ChannelApiService) GetChannelRateRoomSeq(ctx context.Context, channelCode string) ApiGetChannelRateRoomSeqRequest {
	return ApiGetChannelRateRoomSeqRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return ChannelRateRoomSequenceDetails
func (a *ChannelApiService) GetChannelRateRoomSeqExecute(r ApiGetChannelRateRoomSeqRequest) (*ChannelRateRoomSequenceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRateRoomSequenceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRateRoomSeq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateRoomSequences"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.channelRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", r.channelRatePlanCode, "")
	}
	if r.channelRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomType", r.channelRoomType, "")
	}
	if r.channelRateRoomParameterName != nil {
		t := *r.channelRateRoomParameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterName", t, "multi")
		}
	}
	if r.channelRateRoomParameterValue != nil {
		t := *r.channelRateRoomParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	ratePlanCodes *[]string
	roomTypes *[]string
	globalDescriptionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetChannelRatesGlobalDescriptionsRequest) HotelIds(hotelIds []string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ApiGetChannelRatesGlobalDescriptionsRequest) RatePlanCodes(ratePlanCodes []string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ApiGetChannelRatesGlobalDescriptionsRequest) RoomTypes(roomTypes []string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.roomTypes = &roomTypes
	return r
}

// Either Room Type or Rate Plan Code
func (r ApiGetChannelRatesGlobalDescriptionsRequest) GlobalDescriptionType(globalDescriptionType string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.globalDescriptionType = &globalDescriptionType
	return r
}

// External system code.
func (r ApiGetChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRatesGlobalDescriptionsRequest) Execute() (*ChannelGlobalDescriptions, *http.Response, error) {
	return r.ApiService.GetChannelRatesGlobalDescriptionsExecute(r)
}

/*
GetChannelRatesGlobalDescriptions Gets global rate descriptions

Use this API to get global rate description for given hotel id. <p><strong>OperationId:</strong>getChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) GetChannelRatesGlobalDescriptions(ctx context.Context) ApiGetChannelRatesGlobalDescriptionsRequest {
	return ApiGetChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelGlobalDescriptions
func (a *ChannelApiService) GetChannelRatesGlobalDescriptionsExecute(r ApiGetChannelRatesGlobalDescriptionsRequest) (*ChannelGlobalDescriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelGlobalDescriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.globalDescriptionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescriptionType", r.globalDescriptionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	roomTypes *[]string
	channelRoomTypes *[]string
	includeInactiveMappings *bool
	includeUnmappedRoomTypes *bool
	onlyUnmappedRoomTypes *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRoomMappingRequest) Authorization(authorization string) ApiGetChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRoomMappingRequest) XAppKey(xAppKey string) ApiGetChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRoomMappingRequest) XHotelid(xHotelid string) ApiGetChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelRoomMappingRequest) Limit(limit int32) ApiGetChannelRoomMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelRoomMappingRequest) Offset(offset int32) ApiGetChannelRoomMappingRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChannelRoomMappingRequest) BookingChannelCodes(bookingChannelCodes []string) ApiGetChannelRoomMappingRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ApiGetChannelRoomMappingRequest) RoomTypes(roomTypes []string) ApiGetChannelRoomMappingRequest {
	r.roomTypes = &roomTypes
	return r
}

func (r ApiGetChannelRoomMappingRequest) ChannelRoomTypes(channelRoomTypes []string) ApiGetChannelRoomMappingRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// Flag whether to include inactive mappings or not.
func (r ApiGetChannelRoomMappingRequest) IncludeInactiveMappings(includeInactiveMappings bool) ApiGetChannelRoomMappingRequest {
	r.includeInactiveMappings = &includeInactiveMappings
	return r
}

// Flag whether to include unmapped room types or not.
func (r ApiGetChannelRoomMappingRequest) IncludeUnmappedRoomTypes(includeUnmappedRoomTypes bool) ApiGetChannelRoomMappingRequest {
	r.includeUnmappedRoomTypes = &includeUnmappedRoomTypes
	return r
}

// Flag whether to include mapped room types only.
func (r ApiGetChannelRoomMappingRequest) OnlyUnmappedRoomTypes(onlyUnmappedRoomTypes bool) ApiGetChannelRoomMappingRequest {
	r.onlyUnmappedRoomTypes = &onlyUnmappedRoomTypes
	return r
}

// External system code.
func (r ApiGetChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRoomMappingRequest) Execute() (*ChannelRoomMappingsSummary, *http.Response, error) {
	return r.ApiService.GetChannelRoomMappingExecute(r)
}

/*
GetChannelRoomMapping Gets channel property room mapping

Use this API to get channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>getChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelRoomMappingRequest
*/
func (a *ChannelApiService) GetChannelRoomMapping(ctx context.Context, hotelId string) ApiGetChannelRoomMappingRequest {
	return ApiGetChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelRoomMappingsSummary
func (a *ChannelApiService) GetChannelRoomMappingExecute(r ApiGetChannelRoomMappingRequest) (*ChannelRoomMappingsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRoomMappingsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.channelRoomTypes != nil {
		t := *r.channelRoomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypes", t, "multi")
		}
	}
	if r.includeInactiveMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveMappings", r.includeInactiveMappings, "")
	}
	if r.includeUnmappedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUnmappedRoomTypes", r.includeUnmappedRoomTypes, "")
	}
	if r.onlyUnmappedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyUnmappedRoomTypes", r.onlyUnmappedRoomTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRoomMappingByIdRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	beginDate *string
	channelRoomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRoomMappingByIdRequest) Authorization(authorization string) ApiGetChannelRoomMappingByIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRoomMappingByIdRequest) XAppKey(xAppKey string) ApiGetChannelRoomMappingByIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRoomMappingByIdRequest) XHotelid(xHotelid string) ApiGetChannelRoomMappingByIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Begin Date.
func (r ApiGetChannelRoomMappingByIdRequest) BeginDate(beginDate string) ApiGetChannelRoomMappingByIdRequest {
	r.beginDate = &beginDate
	return r
}

// Channel Room Type.
func (r ApiGetChannelRoomMappingByIdRequest) ChannelRoomType(channelRoomType string) ApiGetChannelRoomMappingByIdRequest {
	r.channelRoomType = &channelRoomType
	return r
}

// External system code.
func (r ApiGetChannelRoomMappingByIdRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRoomMappingByIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRoomMappingByIdRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRoomMappingByIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRoomMappingByIdRequest) Execute() (*ChannelRoomMapping, *http.Response, error) {
	return r.ApiService.GetChannelRoomMappingByIdExecute(r)
}

/*
GetChannelRoomMappingById Gets channel room mapping by room type

This API retrieves channel room mapping by room type. <p><strong>OperationId:</strong>getChannelRoomMappingById</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Room Type Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelRoomMappingByIdRequest
*/
func (a *ChannelApiService) GetChannelRoomMappingById(ctx context.Context, roomTypeCode string, channelCode string, hotelId string) ApiGetChannelRoomMappingByIdRequest {
	return ApiGetChannelRoomMappingByIdRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelRoomMapping
func (a *ChannelApiService) GetChannelRoomMappingByIdExecute(r ApiGetChannelRoomMappingByIdRequest) (*ChannelRoomMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRoomMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomMappingById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.channelRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomType", r.channelRoomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRoomTypeGlobalDescRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRoomTypeGlobalDescRequest) Authorization(authorization string) ApiGetChannelRoomTypeGlobalDescRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRoomTypeGlobalDescRequest) XAppKey(xAppKey string) ApiGetChannelRoomTypeGlobalDescRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRoomTypeGlobalDescRequest) XHotelid(xHotelid string) ApiGetChannelRoomTypeGlobalDescRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetChannelRoomTypeGlobalDescRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRoomTypeGlobalDescRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRoomTypeGlobalDescRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRoomTypeGlobalDescRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRoomTypeGlobalDescRequest) Execute() (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	return r.ApiService.GetChannelRoomTypeGlobalDescExecute(r)
}

/*
GetChannelRoomTypeGlobalDesc Gets global room descriptions

Use this API to get global room description for given hotel id and room type code. <p><strong>OperationId:</strong>getChannelRoomTypeGlobalDesc</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Room type.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetChannelRoomTypeGlobalDescRequest
*/
func (a *ChannelApiService) GetChannelRoomTypeGlobalDesc(ctx context.Context, roomType string, hotelId string) ApiGetChannelRoomTypeGlobalDescRequest {
	return ApiGetChannelRoomTypeGlobalDescRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelEnhancedGlobalDescription
func (a *ChannelApiService) GetChannelRoomTypeGlobalDescExecute(r ApiGetChannelRoomTypeGlobalDescRequest) (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelEnhancedGlobalDescription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomTypeGlobalDesc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomType}/globalDescription"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	ratePlanCodes *[]string
	roomTypes *[]string
	globalDescriptionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiGetChannelRoomsGlobalDescriptionsRequest) HotelIds(hotelIds []string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ApiGetChannelRoomsGlobalDescriptionsRequest) RatePlanCodes(ratePlanCodes []string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ApiGetChannelRoomsGlobalDescriptionsRequest) RoomTypes(roomTypes []string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.roomTypes = &roomTypes
	return r
}

// Either Room Type or Rate Plan Code
func (r ApiGetChannelRoomsGlobalDescriptionsRequest) GlobalDescriptionType(globalDescriptionType string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.globalDescriptionType = &globalDescriptionType
	return r
}

// External system code.
func (r ApiGetChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelRoomsGlobalDescriptionsRequest) Execute() (*ChannelGlobalDescriptions, *http.Response, error) {
	return r.ApiService.GetChannelRoomsGlobalDescriptionsExecute(r)
}

/*
GetChannelRoomsGlobalDescriptions Gets global room descriptions

Use this API to get global room description for given hotel id and room type code. <p><strong>OperationId:</strong>getChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) GetChannelRoomsGlobalDescriptions(ctx context.Context) ApiGetChannelRoomsGlobalDescriptionsRequest {
	return ApiGetChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelGlobalDescriptions
func (a *ChannelApiService) GetChannelRoomsGlobalDescriptionsExecute(r ApiGetChannelRoomsGlobalDescriptionsRequest) (*ChannelGlobalDescriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelGlobalDescriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.globalDescriptionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescriptionType", r.globalDescriptionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	channelCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelsRequest) Authorization(authorization string) ApiGetChannelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelsRequest) XAppKey(xAppKey string) ApiGetChannelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelsRequest) XHotelid(xHotelid string) ApiGetChannelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ApiGetChannelsRequest) Inactive(inactive bool) ApiGetChannelsRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetChannelsRequest) Limit(limit int32) ApiGetChannelsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetChannelsRequest) Offset(offset int32) ApiGetChannelsRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ApiGetChannelsRequest) ChannelCode(channelCode string) ApiGetChannelsRequest {
	r.channelCode = &channelCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ApiGetChannelsRequest) SystemType(systemType string) ApiGetChannelsRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ApiGetChannelsRequest) SystemSubType(systemSubType string) ApiGetChannelsRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ApiGetChannelsRequest) SystemRateType(systemRateType string) ApiGetChannelsRequest {
	r.systemRateType = &systemRateType
	return r
}

// Flag whether to include inactive channel or not.
func (r ApiGetChannelsRequest) IncludeInactive(includeInactive bool) ApiGetChannelsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetChannelsRequest) XExternalsystem(xExternalsystem string) ApiGetChannelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelsRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelsRequest) Execute() (*Channels, *http.Response, error) {
	return r.ApiService.GetChannelsExecute(r)
}

/*
GetChannels Gets list of channels

Use this API to get list of channels from OPERA. <p><strong>OperationId:</strong>getChannels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelsRequest
*/
func (a *ChannelApiService) GetChannels(ctx context.Context) ApiGetChannelsRequest {
	return ApiGetChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Channels
func (a *ChannelApiService) GetChannelsExecute(r ApiGetChannelsRequest) (*Channels, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Channels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.channelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", r.channelCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCreditCardsMappingRequest) Authorization(authorization string) ApiGetCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCreditCardsMappingRequest) XAppKey(xAppKey string) ApiGetCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCreditCardsMappingRequest) XHotelid(xHotelid string) ApiGetCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ApiGetCreditCardsMappingRequest) Inactive(inactive bool) ApiGetCreditCardsMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetCreditCardsMappingRequest) Limit(limit int32) ApiGetCreditCardsMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetCreditCardsMappingRequest) Offset(offset int32) ApiGetCreditCardsMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ApiGetCreditCardsMappingRequest) SystemCode(systemCode string) ApiGetCreditCardsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ApiGetCreditCardsMappingRequest) SystemType(systemType string) ApiGetCreditCardsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ApiGetCreditCardsMappingRequest) SystemSubType(systemSubType string) ApiGetCreditCardsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ApiGetCreditCardsMappingRequest) SystemRateType(systemRateType string) ApiGetCreditCardsMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ApiGetCreditCardsMappingRequest) LocalSystemCodes(localSystemCodes []string) ApiGetCreditCardsMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ApiGetCreditCardsMappingRequest) IncludeInactive(includeInactive bool) ApiGetCreditCardsMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ApiGetCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCreditCardsMappingRequest) Execute() (*CreditCardsMapping, *http.Response, error) {
	return r.ApiService.GetCreditCardsMappingExecute(r)
}

/*
GetCreditCardsMapping Gets channel credit card mapping

Use this API to get channel credit card code mapping to OPERA credit card code. <p><strong>OperationId:</strong>getCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreditCardsMappingRequest
*/
func (a *ChannelApiService) GetCreditCardsMapping(ctx context.Context) ApiGetCreditCardsMappingRequest {
	return ApiGetCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreditCardsMapping
func (a *ChannelApiService) GetCreditCardsMappingExecute(r ApiGetCreditCardsMappingRequest) (*CreditCardsMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditCardsMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCurrenciesMappingRequest) Authorization(authorization string) ApiGetCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCurrenciesMappingRequest) XAppKey(xAppKey string) ApiGetCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCurrenciesMappingRequest) XHotelid(xHotelid string) ApiGetCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ApiGetCurrenciesMappingRequest) Inactive(inactive bool) ApiGetCurrenciesMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetCurrenciesMappingRequest) Limit(limit int32) ApiGetCurrenciesMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetCurrenciesMappingRequest) Offset(offset int32) ApiGetCurrenciesMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ApiGetCurrenciesMappingRequest) SystemCode(systemCode string) ApiGetCurrenciesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ApiGetCurrenciesMappingRequest) SystemType(systemType string) ApiGetCurrenciesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ApiGetCurrenciesMappingRequest) SystemSubType(systemSubType string) ApiGetCurrenciesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ApiGetCurrenciesMappingRequest) SystemRateType(systemRateType string) ApiGetCurrenciesMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ApiGetCurrenciesMappingRequest) LocalSystemCodes(localSystemCodes []string) ApiGetCurrenciesMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ApiGetCurrenciesMappingRequest) IncludeInactive(includeInactive bool) ApiGetCurrenciesMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ApiGetCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCurrenciesMappingRequest) Execute() (*CurrenciesMapping, *http.Response, error) {
	return r.ApiService.GetCurrenciesMappingExecute(r)
}

/*
GetCurrenciesMapping Gets channel currency code mapping

Use this API to update channel mapping to OPERA currency codes. <p><strong>OperationId:</strong>getCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrenciesMappingRequest
*/
func (a *ChannelApiService) GetCurrenciesMapping(ctx context.Context) ApiGetCurrenciesMappingRequest {
	return ApiGetCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrenciesMapping
func (a *ChannelApiService) GetCurrenciesMappingExecute(r ApiGetCurrenciesMappingRequest) (*CurrenciesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrenciesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	isChain *bool
	hotelIds *[]string
	codes *[]string
	types *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDistributionTemplatesRequest) Authorization(authorization string) ApiGetDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDistributionTemplatesRequest) XAppKey(xAppKey string) ApiGetDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDistributionTemplatesRequest) XHotelid(xHotelid string) ApiGetDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Filter chain level distribution templates by chain.
func (r ApiGetDistributionTemplatesRequest) IsChain(isChain bool) ApiGetDistributionTemplatesRequest {
	r.isChain = &isChain
	return r
}

func (r ApiGetDistributionTemplatesRequest) HotelIds(hotelIds []string) ApiGetDistributionTemplatesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ApiGetDistributionTemplatesRequest) Codes(codes []string) ApiGetDistributionTemplatesRequest {
	r.codes = &codes
	return r
}

func (r ApiGetDistributionTemplatesRequest) Types(types []string) ApiGetDistributionTemplatesRequest {
	r.types = &types
	return r
}

// Indicates whether search includes inactive distribution templates.
func (r ApiGetDistributionTemplatesRequest) IncludeInactive(includeInactive bool) ApiGetDistributionTemplatesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ApiGetDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ApiGetDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDistributionTemplatesRequest) Execute() (*DistributionTemplates, *http.Response, error) {
	return r.ApiService.GetDistributionTemplatesExecute(r)
}

/*
GetDistributionTemplates Retrieves distribution templates

This API retrieves distribution templates. <p><strong>OperationId:</strong>getDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDistributionTemplatesRequest
*/
func (a *ChannelApiService) GetDistributionTemplates(ctx context.Context) ApiGetDistributionTemplatesRequest {
	return ApiGetDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DistributionTemplates
func (a *ChannelApiService) GetDistributionTemplatesExecute(r ApiGetDistributionTemplatesRequest) (*DistributionTemplates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DistributionTemplates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.isChain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isChain", r.isChain, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGuaranteesMappingRequest) Authorization(authorization string) ApiGetGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGuaranteesMappingRequest) XAppKey(xAppKey string) ApiGetGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGuaranteesMappingRequest) XHotelid(xHotelid string) ApiGetGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ApiGetGuaranteesMappingRequest) Inactive(inactive bool) ApiGetGuaranteesMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetGuaranteesMappingRequest) Limit(limit int32) ApiGetGuaranteesMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetGuaranteesMappingRequest) Offset(offset int32) ApiGetGuaranteesMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ApiGetGuaranteesMappingRequest) SystemCode(systemCode string) ApiGetGuaranteesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ApiGetGuaranteesMappingRequest) SystemType(systemType string) ApiGetGuaranteesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ApiGetGuaranteesMappingRequest) SystemSubType(systemSubType string) ApiGetGuaranteesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ApiGetGuaranteesMappingRequest) SystemRateType(systemRateType string) ApiGetGuaranteesMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ApiGetGuaranteesMappingRequest) LocalSystemCodes(localSystemCodes []string) ApiGetGuaranteesMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ApiGetGuaranteesMappingRequest) IncludeInactive(includeInactive bool) ApiGetGuaranteesMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ApiGetGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGuaranteesMappingRequest) Execute() (*GuaranteesMapping, *http.Response, error) {
	return r.ApiService.GetGuaranteesMappingExecute(r)
}

/*
GetGuaranteesMapping Gets channel guarantee code mapping for a hotel

Use this API to get channel guarantee code mapping to OPERA guarantee code for a given hotel. <p><strong>OperationId:</strong>getGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGuaranteesMappingRequest
*/
func (a *ChannelApiService) GetGuaranteesMapping(ctx context.Context) ApiGetGuaranteesMappingRequest {
	return ApiGetGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GuaranteesMapping
func (a *ChannelApiService) GetGuaranteesMappingExecute(r ApiGetGuaranteesMappingRequest) (*GuaranteesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuaranteesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelsMappingRequest) Authorization(authorization string) ApiGetHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelsMappingRequest) XAppKey(xAppKey string) ApiGetHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelsMappingRequest) XHotelid(xHotelid string) ApiGetHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ApiGetHotelsMappingRequest) Inactive(inactive bool) ApiGetHotelsMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetHotelsMappingRequest) Limit(limit int32) ApiGetHotelsMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetHotelsMappingRequest) Offset(offset int32) ApiGetHotelsMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ApiGetHotelsMappingRequest) SystemCode(systemCode string) ApiGetHotelsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ApiGetHotelsMappingRequest) SystemType(systemType string) ApiGetHotelsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ApiGetHotelsMappingRequest) SystemSubType(systemSubType string) ApiGetHotelsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ApiGetHotelsMappingRequest) SystemRateType(systemRateType string) ApiGetHotelsMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ApiGetHotelsMappingRequest) LocalSystemCodes(localSystemCodes []string) ApiGetHotelsMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ApiGetHotelsMappingRequest) IncludeInactive(includeInactive bool) ApiGetHotelsMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ApiGetHotelsMappingRequest) XExternalsystem(xExternalsystem string) ApiGetHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelsMappingRequest) Execute() (*PropertiesMapping, *http.Response, error) {
	return r.ApiService.GetHotelsMappingExecute(r)
}

/*
GetHotelsMapping Gets channel hotel mapping

Use this API to get channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date. <p><strong>OperationId:</strong>getHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHotelsMappingRequest
*/
func (a *ChannelApiService) GetHotelsMapping(ctx context.Context) ApiGetHotelsMappingRequest {
	return ApiGetHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PropertiesMapping
func (a *ChannelApiService) GetHotelsMappingExecute(r ApiGetHotelsMappingRequest) (*PropertiesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PropertiesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementDetailsStatisticsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	statementId string
	authorization *string
	xAppKey *string
	xHotelid *string
	contractId *string
	contractIdType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStatementDetailsStatisticsRequest) Authorization(authorization string) ApiGetStatementDetailsStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStatementDetailsStatisticsRequest) XAppKey(xAppKey string) ApiGetStatementDetailsStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStatementDetailsStatisticsRequest) XHotelid(xHotelid string) ApiGetStatementDetailsStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetStatementDetailsStatisticsRequest) ContractId(contractId string) ApiGetStatementDetailsStatisticsRequest {
	r.contractId = &contractId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetStatementDetailsStatisticsRequest) ContractIdType(contractIdType string) ApiGetStatementDetailsStatisticsRequest {
	r.contractIdType = &contractIdType
	return r
}

// Type for statement details statistics instructions that can be used in requests for partial operations.
func (r ApiGetStatementDetailsStatisticsRequest) FetchInstructions(fetchInstructions []string) ApiGetStatementDetailsStatisticsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetStatementDetailsStatisticsRequest) XExternalsystem(xExternalsystem string) ApiGetStatementDetailsStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStatementDetailsStatisticsRequest) AcceptLanguage(acceptLanguage string) ApiGetStatementDetailsStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStatementDetailsStatisticsRequest) Execute() (*StatementDetailsStatistics, *http.Response, error) {
	return r.ApiService.GetStatementDetailsStatisticsExecute(r)
}

/*
GetStatementDetailsStatistics Retrieves billing statement details statistics.

This API retrieves billing statement details statistics. <p><strong>OperationId:</strong>getStatementDetailsStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId Statement Id.
 @return ApiGetStatementDetailsStatisticsRequest
*/
func (a *ChannelApiService) GetStatementDetailsStatistics(ctx context.Context, statementId string) ApiGetStatementDetailsStatisticsRequest {
	return ApiGetStatementDetailsStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return StatementDetailsStatistics
func (a *ChannelApiService) GetStatementDetailsStatisticsExecute(r ApiGetStatementDetailsStatisticsRequest) (*StatementDetailsStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementDetailsStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetStatementDetailsStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/{statementId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.statementId) < 1 {
		return localVarReturnValue, nil, reportError("statementId must have at least 1 elements")
	}
	if strlen(r.statementId) > 2000 {
		return localVarReturnValue, nil, reportError("statementId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", r.contractId, "")
	}
	if r.contractIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractIdType", r.contractIdType, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	elementCodes *[]string
	transactionCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTotalPricingElementsRequest) Authorization(authorization string) ApiGetTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTotalPricingElementsRequest) XAppKey(xAppKey string) ApiGetTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTotalPricingElementsRequest) XHotelid(xHotelid string) ApiGetTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetTotalPricingElementsRequest) Limit(limit int32) ApiGetTotalPricingElementsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetTotalPricingElementsRequest) Offset(offset int32) ApiGetTotalPricingElementsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetTotalPricingElementsRequest) ElementCodes(elementCodes []string) ApiGetTotalPricingElementsRequest {
	r.elementCodes = &elementCodes
	return r
}

func (r ApiGetTotalPricingElementsRequest) TransactionCodes(transactionCodes []string) ApiGetTotalPricingElementsRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// External system code.
func (r ApiGetTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ApiGetTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ApiGetTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTotalPricingElementsRequest) Execute() (*TotalPricingElements, *http.Response, error) {
	return r.ApiService.GetTotalPricingElementsExecute(r)
}

/*
GetTotalPricingElements Gets total pricing tax and fee types

Use this API to get global distribution channels tax and fee configurations. <p><strong>OperationId:</strong>getTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiGetTotalPricingElementsRequest
*/
func (a *ChannelApiService) GetTotalPricingElements(ctx context.Context, hotelId string) ApiGetTotalPricingElementsRequest {
	return ApiGetTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TotalPricingElements
func (a *ChannelApiService) GetTotalPricingElementsExecute(r ApiGetTotalPricingElementsRequest) (*TotalPricingElements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TotalPricingElements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/totalPricing"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.elementCodes != nil {
		t := *r.elementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "elementCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "elementCodes", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiManageChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomMappings *ManageChannelRoomMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiManageChannelRoomMappingRequest) Authorization(authorization string) ApiManageChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiManageChannelRoomMappingRequest) XAppKey(xAppKey string) ApiManageChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiManageChannelRoomMappingRequest) XHotelid(xHotelid string) ApiManageChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create, edit or delete channel room type mapping.
func (r ApiManageChannelRoomMappingRequest) ChannelRoomMappings(channelRoomMappings ManageChannelRoomMappingRequest) ApiManageChannelRoomMappingRequest {
	r.channelRoomMappings = &channelRoomMappings
	return r
}

// External system code.
func (r ApiManageChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ApiManageChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiManageChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ApiManageChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiManageChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ManageChannelRoomMappingExecute(r)
}

/*
ManageChannelRoomMapping Updates channel room configuration

Use this API to update channel room description <p><strong>OperationId:</strong>manageChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiManageChannelRoomMappingRequest
*/
func (a *ChannelApiService) ManageChannelRoomMapping(ctx context.Context) ApiManageChannelRoomMappingRequest {
	return ApiManageChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) ManageChannelRoomMappingExecute(r ApiManageChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.ManageChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRoomMappings == nil {
		return localVarReturnValue, nil, reportError("channelRoomMappings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingChannelServiceRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPingChannelServiceRequest) Authorization(authorization string) ApiPingChannelServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPingChannelServiceRequest) XAppKey(xAppKey string) ApiPingChannelServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPingChannelServiceRequest) XHotelid(xHotelid string) ApiPingChannelServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiPingChannelServiceRequest) XExternalsystem(xExternalsystem string) ApiPingChannelServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPingChannelServiceRequest) AcceptLanguage(acceptLanguage string) ApiPingChannelServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPingChannelServiceRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingChannelServiceExecute(r)
}

/*
PingChannelService Retrieves channel service version

This API retrieves channel service version. <p><strong>OperationId:</strong>pingChannelService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingChannelServiceRequest
*/
func (a *ChannelApiService) PingChannelService(ctx context.Context) ApiPingChannelServiceRequest {
	return ApiPingChannelServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *ChannelApiService) PingChannelServiceExecute(r ApiPingChannelServiceRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PingChannelService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/channels/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	amenities *PutAmenitiesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostAmenitiesMappingRequest) Authorization(authorization string) ApiPostAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostAmenitiesMappingRequest) XAppKey(xAppKey string) ApiPostAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostAmenitiesMappingRequest) XHotelid(xHotelid string) ApiPostAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new external system amenities.
func (r ApiPostAmenitiesMappingRequest) Amenities(amenities PutAmenitiesMappingRequest) ApiPostAmenitiesMappingRequest {
	r.amenities = &amenities
	return r
}

// External system code.
func (r ApiPostAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ApiPostAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostAmenitiesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAmenitiesMappingExecute(r)
}

/*
PostAmenitiesMapping Adds channel amenities configuration

Use this API to add channel amenities mapping <p><strong>OperationId:</strong>postAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAmenitiesMappingRequest
*/
func (a *ChannelApiService) PostAmenitiesMapping(ctx context.Context) ApiPostAmenitiesMappingRequest {
	return ApiPostAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostAmenitiesMappingExecute(r ApiPostAmenitiesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.amenities == nil {
		return localVarReturnValue, nil, reportError("amenities is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.amenities
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountContracts *PutChannelAccountContractsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelAccountContractsRequest) Authorization(authorization string) ApiPostChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelAccountContractsRequest) XAppKey(xAppKey string) ApiPostChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelAccountContractsRequest) XHotelid(xHotelid string) ApiPostChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create the channel account contracts.
func (r ApiPostChannelAccountContractsRequest) ChannelAccountContracts(channelAccountContracts PutChannelAccountContractsRequest) ApiPostChannelAccountContractsRequest {
	r.channelAccountContracts = &channelAccountContracts
	return r
}

// External system code.
func (r ApiPostChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelAccountContractsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelAccountContractsExecute(r)
}

/*
PostChannelAccountContracts Adds channel account contracts for given profile Id.

This API adds channel account contracts for given profile Id. <p><strong>OperationId:</strong>postChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountProfileId Unique ID that identifies an account profile.
 @return ApiPostChannelAccountContractsRequest
*/
func (a *ChannelApiService) PostChannelAccountContracts(ctx context.Context, accountProfileId string) ApiPostChannelAccountContractsRequest {
	return ApiPostChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelAccountContractsExecute(r ApiPostChannelAccountContractsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelAccountContracts == nil {
		return localVarReturnValue, nil, reportError("channelAccountContracts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountContracts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccounts *PostChannelAccountsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelAccountsRequest) Authorization(authorization string) ApiPostChannelAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelAccountsRequest) XAppKey(xAppKey string) ApiPostChannelAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelAccountsRequest) XHotelid(xHotelid string) ApiPostChannelAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create the channel accounts.
func (r ApiPostChannelAccountsRequest) ChannelAccounts(channelAccounts PostChannelAccountsRequest) ApiPostChannelAccountsRequest {
	r.channelAccounts = &channelAccounts
	return r
}

// External system code.
func (r ApiPostChannelAccountsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelAccountsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelAccountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelAccountsExecute(r)
}

/*
PostChannelAccounts Adds channel accounts.

This API adds channel accounts. <p><strong>OperationId:</strong>postChannelAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelAccountsRequest
*/
func (a *ChannelApiService) PostChannelAccounts(ctx context.Context) ApiPostChannelAccountsRequest {
	return ApiPostChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelAccountsExecute(r ApiPostChannelAccountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelAccounts == nil {
		return localVarReturnValue, nil, reportError("channelAccounts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccounts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelBillingStatements *PutChannelBillingStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelBillingStatementsRequest) Authorization(authorization string) ApiPostChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelBillingStatementsRequest) XAppKey(xAppKey string) ApiPostChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelBillingStatementsRequest) XHotelid(xHotelid string) ApiPostChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create channel billing statements.
func (r ApiPostChannelBillingStatementsRequest) ChannelBillingStatements(channelBillingStatements PutChannelBillingStatementsRequest) ApiPostChannelBillingStatementsRequest {
	r.channelBillingStatements = &channelBillingStatements
	return r
}

// External system code.
func (r ApiPostChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelBillingStatementsExecute(r)
}

/*
PostChannelBillingStatements Adds channel billing statements.

This API adds channel billing statements. <p><strong>OperationId:</strong>postChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelBillingStatementsRequest
*/
func (a *ChannelApiService) PostChannelBillingStatements(ctx context.Context) ApiPostChannelBillingStatementsRequest {
	return ApiPostChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelBillingStatementsExecute(r ApiPostChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelBillingStatements == nil {
		return localVarReturnValue, nil, reportError("channelBillingStatements is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelBillingStatements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelCardTypeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	cardTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCardTypeMappings *PutChannelCardTypeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelCardTypeMappingRequest) Authorization(authorization string) ApiPostChannelCardTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelCardTypeMappingRequest) XAppKey(xAppKey string) ApiPostChannelCardTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelCardTypeMappingRequest) XHotelid(xHotelid string) ApiPostChannelCardTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new channel-hotel card type mapping.
func (r ApiPostChannelCardTypeMappingRequest) ChannelCardTypeMappings(channelCardTypeMappings PutChannelCardTypeMappingRequest) ApiPostChannelCardTypeMappingRequest {
	r.channelCardTypeMappings = &channelCardTypeMappings
	return r
}

// External system code.
func (r ApiPostChannelCardTypeMappingRequest) XExternalsystem(xExternalsystem string) ApiPostChannelCardTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelCardTypeMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelCardTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelCardTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelCardTypeMappingExecute(r)
}

/*
PostChannelCardTypeMapping Adds channel credit card mapping for a hotel

Use this API to add channel mapping for OPERA credit cards to channel for a given hotel id <p><strong>OperationId:</strong>postChannelCardTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardTypeCode Unique ID that identifies a channel.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPostChannelCardTypeMappingRequest
*/
func (a *ChannelApiService) PostChannelCardTypeMapping(ctx context.Context, cardTypeCode string, channelCode string, hotelId string) ApiPostChannelCardTypeMappingRequest {
	return ApiPostChannelCardTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
		cardTypeCode: cardTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelCardTypeMappingExecute(r ApiPostChannelCardTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelCardTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/cardType/{cardTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardTypeCode"+"}", url.PathEscape(parameterValueToString(r.cardTypeCode, "cardTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have at least 1 elements")
	}
	if strlen(r.cardTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelCardTypeMappings == nil {
		return localVarReturnValue, nil, reportError("channelCardTypeMappings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCardTypeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelCarriersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCarriers *PutChannelCarriersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelCarriersRequest) Authorization(authorization string) ApiPostChannelCarriersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelCarriersRequest) XAppKey(xAppKey string) ApiPostChannelCarriersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelCarriersRequest) XHotelid(xHotelid string) ApiPostChannelCarriersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel carriers.
func (r ApiPostChannelCarriersRequest) ChannelCarriers(channelCarriers PutChannelCarriersRequest) ApiPostChannelCarriersRequest {
	r.channelCarriers = &channelCarriers
	return r
}

// External system code.
func (r ApiPostChannelCarriersRequest) XExternalsystem(xExternalsystem string) ApiPostChannelCarriersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelCarriersRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelCarriersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelCarriersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelCarriersExecute(r)
}

/*
PostChannelCarriers Adds sub channel configuration

Use this API to add sub-channel (carrier) configuration for a given channel code <p><strong>OperationId:</strong>postChannelCarriers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPostChannelCarriersRequest
*/
func (a *ChannelApiService) PostChannelCarriers(ctx context.Context, channelCode string) ApiPostChannelCarriersRequest {
	return ApiPostChannelCarriersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelCarriersExecute(r ApiPostChannelCarriersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/subChannels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelCarriers == nil {
		return localVarReturnValue, nil, reportError("channelCarriers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCarriers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelErrorsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelErrors *PutChannelErrorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelErrorsRequest) Authorization(authorization string) ApiPostChannelErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelErrorsRequest) XAppKey(xAppKey string) ApiPostChannelErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelErrorsRequest) XHotelid(xHotelid string) ApiPostChannelErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel errors.
func (r ApiPostChannelErrorsRequest) ChannelErrors(channelErrors PutChannelErrorsRequest) ApiPostChannelErrorsRequest {
	r.channelErrors = &channelErrors
	return r
}

// External system code.
func (r ApiPostChannelErrorsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelErrorsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelErrorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelErrorsExecute(r)
}

/*
PostChannelErrors Adds channel error codes

Use this API to add channel error code mapping configurations <p><strong>OperationId:</strong>postChannelErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPostChannelErrorsRequest
*/
func (a *ChannelApiService) PostChannelErrors(ctx context.Context, channelCode string) ApiPostChannelErrorsRequest {
	return ApiPostChannelErrorsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelErrorsExecute(r ApiPostChannelErrorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/errorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelErrors == nil {
		return localVarReturnValue, nil, reportError("channelErrors is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelErrors
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelGuaranteeCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	guaranteeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGuaranteeCodeMappings *PutChannelGuaranteeCodeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelGuaranteeCodeMappingRequest) Authorization(authorization string) ApiPostChannelGuaranteeCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelGuaranteeCodeMappingRequest) XAppKey(xAppKey string) ApiPostChannelGuaranteeCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelGuaranteeCodeMappingRequest) XHotelid(xHotelid string) ApiPostChannelGuaranteeCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new channel-hotel guarantee code mapping.
func (r ApiPostChannelGuaranteeCodeMappingRequest) ChannelGuaranteeCodeMappings(channelGuaranteeCodeMappings PutChannelGuaranteeCodeMappingRequest) ApiPostChannelGuaranteeCodeMappingRequest {
	r.channelGuaranteeCodeMappings = &channelGuaranteeCodeMappings
	return r
}

// External system code.
func (r ApiPostChannelGuaranteeCodeMappingRequest) XExternalsystem(xExternalsystem string) ApiPostChannelGuaranteeCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelGuaranteeCodeMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelGuaranteeCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelGuaranteeCodeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelGuaranteeCodeMappingExecute(r)
}

/*
PostChannelGuaranteeCodeMapping Adds channel guarantee code mapping for a hotel

Use this API to add channel guarantee code mapping to OPERA guarantee code for a given hotel <p><strong>OperationId:</strong>postChannelGuaranteeCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guaranteeCode Guarantee Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPostChannelGuaranteeCodeMappingRequest
*/
func (a *ChannelApiService) PostChannelGuaranteeCodeMapping(ctx context.Context, guaranteeCode string, channelCode string, hotelId string) ApiPostChannelGuaranteeCodeMappingRequest {
	return ApiPostChannelGuaranteeCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		guaranteeCode: guaranteeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelGuaranteeCodeMappingExecute(r ApiPostChannelGuaranteeCodeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelGuaranteeCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/guarantees/{guaranteeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guaranteeCode"+"}", url.PathEscape(parameterValueToString(r.guaranteeCode, "guaranteeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guaranteeCode) < 1 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have at least 1 elements")
	}
	if strlen(r.guaranteeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGuaranteeCodeMappings == nil {
		return localVarReturnValue, nil, reportError("channelGuaranteeCodeMappings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGuaranteeCodeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelHotelLettersToBeCreated *PostChannelHotelLettersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelHotelLettersRequest) Authorization(authorization string) ApiPostChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelHotelLettersRequest) XAppKey(xAppKey string) ApiPostChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelHotelLettersRequest) XHotelid(xHotelid string) ApiPostChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new Hotel Letters associated with the Channels
func (r ApiPostChannelHotelLettersRequest) ChannelHotelLettersToBeCreated(channelHotelLettersToBeCreated PostChannelHotelLettersRequest) ApiPostChannelHotelLettersRequest {
	r.channelHotelLettersToBeCreated = &channelHotelLettersToBeCreated
	return r
}

// External system code.
func (r ApiPostChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ApiPostChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelHotelLettersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelHotelLettersExecute(r)
}

/*
PostChannelHotelLetters Adds channel property confirmation letter mapping

Use this API to add channel property confirmation letter configuration <p><strong>OperationId:</strong>postChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelHotelLettersRequest
*/
func (a *ChannelApiService) PostChannelHotelLetters(ctx context.Context) ApiPostChannelHotelLettersRequest {
	return ApiPostChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelHotelLettersExecute(r ApiPostChannelHotelLettersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelHotelLettersToBeCreated == nil {
		return localVarReturnValue, nil, reportError("channelHotelLettersToBeCreated is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelHotelLettersToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelMarketingText *PostChannelMarketingTextRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelMarketingTextRequest) Authorization(authorization string) ApiPostChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelMarketingTextRequest) XAppKey(xAppKey string) ApiPostChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelMarketingTextRequest) XHotelid(xHotelid string) ApiPostChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel marketing texts.
func (r ApiPostChannelMarketingTextRequest) ChannelMarketingText(channelMarketingText PostChannelMarketingTextRequest) ApiPostChannelMarketingTextRequest {
	r.channelMarketingText = &channelMarketingText
	return r
}

// External system code.
func (r ApiPostChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ApiPostChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelMarketingTextExecute(r)
}

/*
PostChannelMarketingText Adds channel marketing messages

Use this API to add channel mapping for marketing messages <p><strong>OperationId:</strong>postChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelMarketingTextRequest
*/
func (a *ChannelApiService) PostChannelMarketingText(ctx context.Context) ApiPostChannelMarketingTextRequest {
	return ApiPostChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelMarketingTextExecute(r ApiPostChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelMarketingText == nil {
		return localVarReturnValue, nil, reportError("channelMarketingText is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelMarketingText
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelNegotiatedRates *PutChannelNegotiatedRateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelNegotiatedRateRequest) Authorization(authorization string) ApiPostChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelNegotiatedRateRequest) XAppKey(xAppKey string) ApiPostChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelNegotiatedRateRequest) XHotelid(xHotelid string) ApiPostChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Negotiated channel rates.
func (r ApiPostChannelNegotiatedRateRequest) ChannelNegotiatedRates(channelNegotiatedRates PutChannelNegotiatedRateRequest) ApiPostChannelNegotiatedRateRequest {
	r.channelNegotiatedRates = &channelNegotiatedRates
	return r
}

// External system code.
func (r ApiPostChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ApiPostChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelNegotiatedRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelNegotiatedRateExecute(r)
}

/*
PostChannelNegotiatedRate Adds channel negotiate rate

Use this API to add channel's negotiated rate code mapping with an OPERA profile for a given hotel id <p><strong>OperationId:</strong>postChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) PostChannelNegotiatedRate(ctx context.Context) ApiPostChannelNegotiatedRateRequest {
	return ApiPostChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelNegotiatedRateExecute(r ApiPostChannelNegotiatedRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelNegotiatedRates == nil {
		return localVarReturnValue, nil, reportError("channelNegotiatedRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelNegotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelOrgMapping *PostChannelOrgMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelOrgMappingRequest) Authorization(authorization string) ApiPostChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelOrgMappingRequest) XAppKey(xAppKey string) ApiPostChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelOrgMappingRequest) XHotelid(xHotelid string) ApiPostChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Create Channel to ORG and CRO Mapping.
func (r ApiPostChannelOrgMappingRequest) ChannelOrgMapping(channelOrgMapping PostChannelOrgMappingRequest) ApiPostChannelOrgMappingRequest {
	r.channelOrgMapping = &channelOrgMapping
	return r
}

// External system code.
func (r ApiPostChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ApiPostChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelOrgMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelOrgMappingExecute(r)
}

/*
PostChannelOrgMapping Adds channel tenants.

This API adds channel tenants. <p><strong>OperationId:</strong>postChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPostChannelOrgMappingRequest
*/
func (a *ChannelApiService) PostChannelOrgMapping(ctx context.Context, channelCode string) ApiPostChannelOrgMappingRequest {
	return ApiPostChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelOrgMappingExecute(r ApiPostChannelOrgMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelOrgMapping == nil {
		return localVarReturnValue, nil, reportError("channelOrgMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelOrgMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRateCategoriesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateCategories *PutChannelRateCategoriesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRateCategoriesRequest) Authorization(authorization string) ApiPostChannelRateCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRateCategoriesRequest) XAppKey(xAppKey string) ApiPostChannelRateCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRateCategoriesRequest) XHotelid(xHotelid string) ApiPostChannelRateCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel rate categories.
func (r ApiPostChannelRateCategoriesRequest) ChannelRateCategories(channelRateCategories PutChannelRateCategoriesRequest) ApiPostChannelRateCategoriesRequest {
	r.channelRateCategories = &channelRateCategories
	return r
}

// External system code.
func (r ApiPostChannelRateCategoriesRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRateCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRateCategoriesRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRateCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRateCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRateCategoriesExecute(r)
}

/*
PostChannelRateCategories Adds given channel's rate categories

Use this API to add channel rate categories for a given channel. <p><strong>OperationId:</strong>postChannelRateCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPostChannelRateCategoriesRequest
*/
func (a *ChannelApiService) PostChannelRateCategories(ctx context.Context, channelCode string) ApiPostChannelRateCategoriesRequest {
	return ApiPostChannelRateCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRateCategoriesExecute(r ApiPostChannelRateCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRateCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateCategories == nil {
		return localVarReturnValue, nil, reportError("channelRateCategories is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateCategories
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRateLevelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateLevels *PutChannelRateLevelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRateLevelsRequest) Authorization(authorization string) ApiPostChannelRateLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRateLevelsRequest) XAppKey(xAppKey string) ApiPostChannelRateLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRateLevelsRequest) XHotelid(xHotelid string) ApiPostChannelRateLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel rate levels.
func (r ApiPostChannelRateLevelsRequest) ChannelRateLevels(channelRateLevels PutChannelRateLevelsRequest) ApiPostChannelRateLevelsRequest {
	r.channelRateLevels = &channelRateLevels
	return r
}

// External system code.
func (r ApiPostChannelRateLevelsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRateLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRateLevelsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRateLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRateLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRateLevelsExecute(r)
}

/*
PostChannelRateLevels Adds channel rate level

Use this API to add channel rate level configurations <p><strong>OperationId:</strong>postChannelRateLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPostChannelRateLevelsRequest
*/
func (a *ChannelApiService) PostChannelRateLevels(ctx context.Context, channelCode string) ApiPostChannelRateLevelsRequest {
	return ApiPostChannelRateLevelsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRateLevelsExecute(r ApiPostChannelRateLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRateLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateLevels == nil {
		return localVarReturnValue, nil, reportError("channelRateLevels is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateLevels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateMapping *PutChannelRateMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRateMappingRequest) Authorization(authorization string) ApiPostChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRateMappingRequest) XAppKey(xAppKey string) ApiPostChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRateMappingRequest) XHotelid(xHotelid string) ApiPostChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel rate mappings.
func (r ApiPostChannelRateMappingRequest) ChannelRateMapping(channelRateMapping PutChannelRateMappingRequest) ApiPostChannelRateMappingRequest {
	r.channelRateMapping = &channelRateMapping
	return r
}

// External system code.
func (r ApiPostChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRateMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRateMappingExecute(r)
}

/*
PostChannelRateMapping Adds channel property rate mapping

Use this API to add channel property rate mapping with OPERA hotel rate <p><strong>OperationId:</strong>postChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelRateMappingRequest
*/
func (a *ChannelApiService) PostChannelRateMapping(ctx context.Context) ApiPostChannelRateMappingRequest {
	return ApiPostChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRateMappingExecute(r ApiPostChannelRateMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateMapping == nil {
		return localVarReturnValue, nil, reportError("channelRateMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRates *PostChannelRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRatesRequest) Authorization(authorization string) ApiPostChannelRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRatesRequest) XAppKey(xAppKey string) ApiPostChannelRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRatesRequest) XHotelid(xHotelid string) ApiPostChannelRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for distributing channel rates.
func (r ApiPostChannelRatesRequest) ChannelRates(channelRates PostChannelRatesRequest) ApiPostChannelRatesRequest {
	r.channelRates = &channelRates
	return r
}

// External system code.
func (r ApiPostChannelRatesRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRatesRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRatesExecute(r)
}

/*
PostChannelRates Distributes channel rate mappings to channel room types

Use this API to link (distribute) channel a rate code to channel room types. <p><strong>OperationId:</strong>postChannelRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPostChannelRatesRequest
*/
func (a *ChannelApiService) PostChannelRates(ctx context.Context, hotelId string) ApiPostChannelRatesRequest {
	return ApiPostChannelRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRatesExecute(r ApiPostChannelRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRates == nil {
		return localVarReturnValue, nil, reportError("channelRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ApiPostChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiPostChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiPostChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new Global Descriptions of the GDS Channels
func (r ApiPostChannelRatesGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ApiPostChannelRatesGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ApiPostChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRatesGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRatesGlobalDescriptionsExecute(r)
}

/*
PostChannelRatesGlobalDescriptions Adds global room descriptions

Use this API to adds global room description for given hotel id and room type code <p><strong>OperationId:</strong>postChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PostChannelRatesGlobalDescriptions(ctx context.Context) ApiPostChannelRatesGlobalDescriptionsRequest {
	return ApiPostChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRatesGlobalDescriptionsExecute(r ApiPostChannelRatesGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGlobalDescriptions == nil {
		return localVarReturnValue, nil, reportError("channelGlobalDescriptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomMappings *ManageChannelRoomMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRoomMappingRequest) Authorization(authorization string) ApiPostChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRoomMappingRequest) XAppKey(xAppKey string) ApiPostChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRoomMappingRequest) XHotelid(xHotelid string) ApiPostChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Channel Room Mapping creation.
func (r ApiPostChannelRoomMappingRequest) ChannelRoomMappings(channelRoomMappings ManageChannelRoomMappingRequest) ApiPostChannelRoomMappingRequest {
	r.channelRoomMappings = &channelRoomMappings
	return r
}

// External system code.
func (r ApiPostChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomMappingExecute(r)
}

/*
PostChannelRoomMapping Adds channel property room mapping

Use this API to add channel room mapping to OPERA hotel's room. <p><strong>OperationId:</strong>postChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelRoomMappingRequest
*/
func (a *ChannelApiService) PostChannelRoomMapping(ctx context.Context) ApiPostChannelRoomMappingRequest {
	return ApiPostChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomMappingExecute(r ApiPostChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRoomMappings == nil {
		return localVarReturnValue, nil, reportError("channelRoomMappings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRoomTypeRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelRoomType string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRates *PostChannelRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRoomTypeRateRequest) Authorization(authorization string) ApiPostChannelRoomTypeRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRoomTypeRateRequest) XAppKey(xAppKey string) ApiPostChannelRoomTypeRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRoomTypeRateRequest) XHotelid(xHotelid string) ApiPostChannelRoomTypeRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for distributing channel rates.
func (r ApiPostChannelRoomTypeRateRequest) ChannelRates(channelRates PostChannelRatesRequest) ApiPostChannelRoomTypeRateRequest {
	r.channelRates = &channelRates
	return r
}

// External system code.
func (r ApiPostChannelRoomTypeRateRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRoomTypeRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRoomTypeRateRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRoomTypeRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRoomTypeRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomTypeRateExecute(r)
}

/*
PostChannelRoomTypeRate Distributes channel room rate mappings.

Use this API to link (distribute) channel a room type to channel rate codes. <p><strong>OperationId:</strong>postChannelRoomTypeRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelRoomType Channel Room Type.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPostChannelRoomTypeRateRequest
*/
func (a *ChannelApiService) PostChannelRoomTypeRate(ctx context.Context, channelRoomType string, channelCode string, hotelId string) ApiPostChannelRoomTypeRateRequest {
	return ApiPostChannelRoomTypeRateRequest{
		ApiService: a,
		ctx: ctx,
		channelRoomType: channelRoomType,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomTypeRateExecute(r ApiPostChannelRoomTypeRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomTypeRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{channelRoomType}/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"channelRoomType"+"}", url.PathEscape(parameterValueToString(r.channelRoomType, "channelRoomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelRoomType) < 1 {
		return localVarReturnValue, nil, reportError("channelRoomType must have at least 1 elements")
	}
	if strlen(r.channelRoomType) > 2000 {
		return localVarReturnValue, nil, reportError("channelRoomType must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRates == nil {
		return localVarReturnValue, nil, reportError("channelRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRoomTypesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomTypes *PutChannelRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRoomTypesRequest) Authorization(authorization string) ApiPostChannelRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRoomTypesRequest) XAppKey(xAppKey string) ApiPostChannelRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRoomTypesRequest) XHotelid(xHotelid string) ApiPostChannelRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel room types.
func (r ApiPostChannelRoomTypesRequest) ChannelRoomTypes(channelRoomTypes PutChannelRoomTypesRequest) ApiPostChannelRoomTypesRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// External system code.
func (r ApiPostChannelRoomTypesRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRoomTypesRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomTypesExecute(r)
}

/*
PostChannelRoomTypes Adds channel room

Use this API to add channel room configuration <p><strong>OperationId:</strong>postChannelRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPostChannelRoomTypesRequest
*/
func (a *ChannelApiService) PostChannelRoomTypes(ctx context.Context, channelCode string) ApiPostChannelRoomTypesRequest {
	return ApiPostChannelRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomTypesExecute(r ApiPostChannelRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRoomTypes == nil {
		return localVarReturnValue, nil, reportError("channelRoomTypes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ApiPostChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiPostChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiPostChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new Global Descriptions of the GDS Channels
func (r ApiPostChannelRoomsGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ApiPostChannelRoomsGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ApiPostChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelRoomsGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomsGlobalDescriptionsExecute(r)
}

/*
PostChannelRoomsGlobalDescriptions Adds global rate descriptions

Use this API to add global rate description for given hotel id and rate code <p><strong>OperationId:</strong>postChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PostChannelRoomsGlobalDescriptions(ctx context.Context) ApiPostChannelRoomsGlobalDescriptionsRequest {
	return ApiPostChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomsGlobalDescriptionsExecute(r ApiPostChannelRoomsGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGlobalDescriptions == nil {
		return localVarReturnValue, nil, reportError("channelGlobalDescriptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostChannelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channels *PutChannelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostChannelsRequest) Authorization(authorization string) ApiPostChannelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostChannelsRequest) XAppKey(xAppKey string) ApiPostChannelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostChannelsRequest) XHotelid(xHotelid string) ApiPostChannelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channels.
func (r ApiPostChannelsRequest) Channels(channels PutChannelsRequest) ApiPostChannelsRequest {
	r.channels = &channels
	return r
}

// External system code.
func (r ApiPostChannelsRequest) XExternalsystem(xExternalsystem string) ApiPostChannelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostChannelsRequest) AcceptLanguage(acceptLanguage string) ApiPostChannelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostChannelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelsExecute(r)
}

/*
PostChannels Adds new channel

Use this API to add new channel code in OPERA <p><strong>OperationId:</strong>postChannels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostChannelsRequest
*/
func (a *ChannelApiService) PostChannels(ctx context.Context) ApiPostChannelsRequest {
	return ApiPostChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelsExecute(r ApiPostChannelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channels == nil {
		return localVarReturnValue, nil, reportError("channels is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCards *PutCreditCardsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCreditCardsMappingRequest) Authorization(authorization string) ApiPostCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCreditCardsMappingRequest) XAppKey(xAppKey string) ApiPostCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCreditCardsMappingRequest) XHotelid(xHotelid string) ApiPostCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating external system credit cards.
func (r ApiPostCreditCardsMappingRequest) CreditCards(creditCards PutCreditCardsMappingRequest) ApiPostCreditCardsMappingRequest {
	r.creditCards = &creditCards
	return r
}

// External system code.
func (r ApiPostCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ApiPostCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCreditCardsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCreditCardsMappingExecute(r)
}

/*
PostCreditCardsMapping Adds channel credit card mapping

Use this API to add channel mapping for OPERA Credit cards <p><strong>OperationId:</strong>postCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreditCardsMappingRequest
*/
func (a *ChannelApiService) PostCreditCardsMapping(ctx context.Context) ApiPostCreditCardsMappingRequest {
	return ApiPostCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostCreditCardsMappingExecute(r ApiPostCreditCardsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.creditCards == nil {
		return localVarReturnValue, nil, reportError("creditCards is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditCards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencies *PutCurrenciesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCurrenciesMappingRequest) Authorization(authorization string) ApiPostCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostCurrenciesMappingRequest) XAppKey(xAppKey string) ApiPostCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCurrenciesMappingRequest) XHotelid(xHotelid string) ApiPostCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating external system currencies.
func (r ApiPostCurrenciesMappingRequest) Currencies(currencies PutCurrenciesMappingRequest) ApiPostCurrenciesMappingRequest {
	r.currencies = &currencies
	return r
}

// External system code.
func (r ApiPostCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ApiPostCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCurrenciesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCurrenciesMappingExecute(r)
}

/*
PostCurrenciesMapping Adds channel currency code mapping

Use this API to add channel currency code mapping to OPERA currency codes. <p><strong>OperationId:</strong>postCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCurrenciesMappingRequest
*/
func (a *ChannelApiService) PostCurrenciesMapping(ctx context.Context) ApiPostCurrenciesMappingRequest {
	return ApiPostCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostCurrenciesMappingExecute(r ApiPostCurrenciesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.currencies == nil {
		return localVarReturnValue, nil, reportError("currencies is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	distributionTemplates *PutDistributionTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostDistributionTemplatesRequest) Authorization(authorization string) ApiPostDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostDistributionTemplatesRequest) XAppKey(xAppKey string) ApiPostDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostDistributionTemplatesRequest) XHotelid(xHotelid string) ApiPostDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating chain or property level distribution templates.
func (r ApiPostDistributionTemplatesRequest) DistributionTemplates(distributionTemplates PutDistributionTemplatesRequest) ApiPostDistributionTemplatesRequest {
	r.distributionTemplates = &distributionTemplates
	return r
}

// External system code.
func (r ApiPostDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ApiPostDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ApiPostDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostDistributionTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDistributionTemplatesExecute(r)
}

/*
PostDistributionTemplates Adds rate templates configurations

Use this API to add a distribution rate template. <p><strong>OperationId:</strong>postDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDistributionTemplatesRequest
*/
func (a *ChannelApiService) PostDistributionTemplates(ctx context.Context) ApiPostDistributionTemplatesRequest {
	return ApiPostDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostDistributionTemplatesExecute(r ApiPostDistributionTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.distributionTemplates == nil {
		return localVarReturnValue, nil, reportError("distributionTemplates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.distributionTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guarantees *PutGuaranteesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostGuaranteesMappingRequest) Authorization(authorization string) ApiPostGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostGuaranteesMappingRequest) XAppKey(xAppKey string) ApiPostGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostGuaranteesMappingRequest) XHotelid(xHotelid string) ApiPostGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new external system guarantees.
func (r ApiPostGuaranteesMappingRequest) Guarantees(guarantees PutGuaranteesMappingRequest) ApiPostGuaranteesMappingRequest {
	r.guarantees = &guarantees
	return r
}

// External system code.
func (r ApiPostGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ApiPostGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostGuaranteesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuaranteesMappingExecute(r)
}

/*
PostGuaranteesMapping Adds channel guarantee code mapping

Use this API to add channel's guarantee codes mapping to OPERA guarantee codes. <p><strong>OperationId:</strong>postGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGuaranteesMappingRequest
*/
func (a *ChannelApiService) PostGuaranteesMapping(ctx context.Context) ApiPostGuaranteesMappingRequest {
	return ApiPostGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostGuaranteesMappingExecute(r ApiPostGuaranteesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.guarantees == nil {
		return localVarReturnValue, nil, reportError("guarantees is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guarantees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	properties *PutHotelsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostHotelsMappingRequest) Authorization(authorization string) ApiPostHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostHotelsMappingRequest) XAppKey(xAppKey string) ApiPostHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostHotelsMappingRequest) XHotelid(xHotelid string) ApiPostHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating external system properties.
func (r ApiPostHotelsMappingRequest) Properties(properties PutHotelsMappingRequest) ApiPostHotelsMappingRequest {
	r.properties = &properties
	return r
}

// External system code.
func (r ApiPostHotelsMappingRequest) XExternalsystem(xExternalsystem string) ApiPostHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ApiPostHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostHotelsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelsMappingExecute(r)
}

/*
PostHotelsMapping Adds channel hotel mapping

Use this API to add channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date. <p><strong>OperationId:</strong>postHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostHotelsMappingRequest
*/
func (a *ChannelApiService) PostHotelsMapping(ctx context.Context) ApiPostHotelsMappingRequest {
	return ApiPostHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostHotelsMappingExecute(r ApiPostHotelsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.properties == nil {
		return localVarReturnValue, nil, reportError("properties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.properties
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	totalPricingElements *PutTotalPricingElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostTotalPricingElementsRequest) Authorization(authorization string) ApiPostTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPostTotalPricingElementsRequest) XAppKey(xAppKey string) ApiPostTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostTotalPricingElementsRequest) XHotelid(xHotelid string) ApiPostTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create the total pricing elements of GDS channel.
func (r ApiPostTotalPricingElementsRequest) TotalPricingElements(totalPricingElements PutTotalPricingElementsRequest) ApiPostTotalPricingElementsRequest {
	r.totalPricingElements = &totalPricingElements
	return r
}

// External system code.
func (r ApiPostTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ApiPostTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ApiPostTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTotalPricingElementsExecute(r)
}

/*
PostTotalPricingElements Adds total pricing tax and fee types

Use this API to add global distribution channels tax and fee configurations. <p><strong>OperationId:</strong>postTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTotalPricingElementsRequest
*/
func (a *ChannelApiService) PostTotalPricingElements(ctx context.Context) ApiPostTotalPricingElementsRequest {
	return ApiPostTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostTotalPricingElementsExecute(r ApiPostTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.totalPricingElements == nil {
		return localVarReturnValue, nil, reportError("totalPricingElements is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.totalPricingElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishChannelAvailabilityRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAvailability *PublishChannelAvailabilityRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPublishChannelAvailabilityRequest) Authorization(authorization string) ApiPublishChannelAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPublishChannelAvailabilityRequest) XAppKey(xAppKey string) ApiPublishChannelAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPublishChannelAvailabilityRequest) XHotelid(xHotelid string) ApiPublishChannelAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate availability to channels.
func (r ApiPublishChannelAvailabilityRequest) ChannelAvailability(channelAvailability PublishChannelAvailabilityRequest) ApiPublishChannelAvailabilityRequest {
	r.channelAvailability = &channelAvailability
	return r
}

// External system code.
func (r ApiPublishChannelAvailabilityRequest) XExternalsystem(xExternalsystem string) ApiPublishChannelAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPublishChannelAvailabilityRequest) AcceptLanguage(acceptLanguage string) ApiPublishChannelAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPublishChannelAvailabilityRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishChannelAvailabilityExecute(r)
}

/*
PublishChannelAvailability Publishes channel availability.

This API changes publishes channel availability. <p><strong>OperationId:</strong>publishChannelAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishChannelAvailabilityRequest
*/
func (a *ChannelApiService) PublishChannelAvailability(ctx context.Context) ApiPublishChannelAvailabilityRequest {
	return ApiPublishChannelAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishChannelAvailabilityExecute(r ApiPublishChannelAvailabilityRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishChannelAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/availability/publish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelAvailability == nil {
		return localVarReturnValue, nil, reportError("channelAvailability is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAvailability
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishChannelRatePlansRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRatePlans *PublishChannelRatePlansRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPublishChannelRatePlansRequest) Authorization(authorization string) ApiPublishChannelRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPublishChannelRatePlansRequest) XAppKey(xAppKey string) ApiPublishChannelRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPublishChannelRatePlansRequest) XHotelid(xHotelid string) ApiPublishChannelRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate codes to GDS.
func (r ApiPublishChannelRatePlansRequest) ChannelRatePlans(channelRatePlans PublishChannelRatePlansRequest) ApiPublishChannelRatePlansRequest {
	r.channelRatePlans = &channelRatePlans
	return r
}

// External system code.
func (r ApiPublishChannelRatePlansRequest) XExternalsystem(xExternalsystem string) ApiPublishChannelRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPublishChannelRatePlansRequest) AcceptLanguage(acceptLanguage string) ApiPublishChannelRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPublishChannelRatePlansRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishChannelRatePlansExecute(r)
}

/*
PublishChannelRatePlans Publishes channel rate plan codes

This API changes the channel rate plans for given channel code. <p><strong>OperationId:</strong>publishChannelRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPublishChannelRatePlansRequest
*/
func (a *ChannelApiService) PublishChannelRatePlans(ctx context.Context, channelCode string) ApiPublishChannelRatePlansRequest {
	return ApiPublishChannelRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishChannelRatePlansExecute(r ApiPublishChannelRatePlansRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishChannelRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRatePlans == nil {
		return localVarReturnValue, nil, reportError("channelRatePlans is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRatePlans
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishChannelRestrictionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRestrictions *PublishChannelRestrictionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPublishChannelRestrictionsRequest) Authorization(authorization string) ApiPublishChannelRestrictionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPublishChannelRestrictionsRequest) XAppKey(xAppKey string) ApiPublishChannelRestrictionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPublishChannelRestrictionsRequest) XHotelid(xHotelid string) ApiPublishChannelRestrictionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate restrictions to channels.
func (r ApiPublishChannelRestrictionsRequest) ChannelRestrictions(channelRestrictions PublishChannelRestrictionsRequest) ApiPublishChannelRestrictionsRequest {
	r.channelRestrictions = &channelRestrictions
	return r
}

// External system code.
func (r ApiPublishChannelRestrictionsRequest) XExternalsystem(xExternalsystem string) ApiPublishChannelRestrictionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPublishChannelRestrictionsRequest) AcceptLanguage(acceptLanguage string) ApiPublishChannelRestrictionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPublishChannelRestrictionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishChannelRestrictionsExecute(r)
}

/*
PublishChannelRestrictions Publishes channel restrictions

This API changes the channel restrictions. <p><strong>OperationId:</strong>publishChannelRestrictions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishChannelRestrictionsRequest
*/
func (a *ChannelApiService) PublishChannelRestrictions(ctx context.Context) ApiPublishChannelRestrictionsRequest {
	return ApiPublishChannelRestrictionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishChannelRestrictionsExecute(r ApiPublishChannelRestrictionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishChannelRestrictions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/restrictions/publish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRestrictions == nil {
		return localVarReturnValue, nil, reportError("channelRestrictions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRestrictions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishHotelChannelRatePlansRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRatePlans *PublishChannelRatePlansRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPublishHotelChannelRatePlansRequest) Authorization(authorization string) ApiPublishHotelChannelRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPublishHotelChannelRatePlansRequest) XAppKey(xAppKey string) ApiPublishHotelChannelRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPublishHotelChannelRatePlansRequest) XHotelid(xHotelid string) ApiPublishHotelChannelRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate codes to GDS.
func (r ApiPublishHotelChannelRatePlansRequest) ChannelRatePlans(channelRatePlans PublishChannelRatePlansRequest) ApiPublishHotelChannelRatePlansRequest {
	r.channelRatePlans = &channelRatePlans
	return r
}

// External system code.
func (r ApiPublishHotelChannelRatePlansRequest) XExternalsystem(xExternalsystem string) ApiPublishHotelChannelRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPublishHotelChannelRatePlansRequest) AcceptLanguage(acceptLanguage string) ApiPublishHotelChannelRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPublishHotelChannelRatePlansRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishHotelChannelRatePlansExecute(r)
}

/*
PublishHotelChannelRatePlans Publishes channel hotel rate plan codes

This API changes the channel rate plans for given Hotel Id. <p><strong>OperationId:</strong>publishHotelChannelRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPublishHotelChannelRatePlansRequest
*/
func (a *ChannelApiService) PublishHotelChannelRatePlans(ctx context.Context, hotelId string) ApiPublishHotelChannelRatePlansRequest {
	return ApiPublishHotelChannelRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishHotelChannelRatePlansExecute(r ApiPublishHotelChannelRatePlansRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishHotelChannelRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRatePlans == nil {
		return localVarReturnValue, nil, reportError("channelRatePlans is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRatePlans
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	amenities *PutAmenitiesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutAmenitiesMappingRequest) Authorization(authorization string) ApiPutAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutAmenitiesMappingRequest) XAppKey(xAppKey string) ApiPutAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutAmenitiesMappingRequest) XHotelid(xHotelid string) ApiPutAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing external system amenities.
func (r ApiPutAmenitiesMappingRequest) Amenities(amenities PutAmenitiesMappingRequest) ApiPutAmenitiesMappingRequest {
	r.amenities = &amenities
	return r
}

// External system code.
func (r ApiPutAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ApiPutAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutAmenitiesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAmenitiesMappingExecute(r)
}

/*
PutAmenitiesMapping Updates channel amenities configuration

Use this API to update channel amenities mapping <p><strong>OperationId:</strong>putAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutAmenitiesMappingRequest
*/
func (a *ChannelApiService) PutAmenitiesMapping(ctx context.Context) ApiPutAmenitiesMappingRequest {
	return ApiPutAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutAmenitiesMappingExecute(r ApiPutAmenitiesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.amenities == nil {
		return localVarReturnValue, nil, reportError("amenities is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.amenities
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountContracts *PutChannelAccountContractsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelAccountContractsRequest) Authorization(authorization string) ApiPutChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelAccountContractsRequest) XAppKey(xAppKey string) ApiPutChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelAccountContractsRequest) XHotelid(xHotelid string) ApiPutChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change the channel account contracts.
func (r ApiPutChannelAccountContractsRequest) ChannelAccountContracts(channelAccountContracts PutChannelAccountContractsRequest) ApiPutChannelAccountContractsRequest {
	r.channelAccountContracts = &channelAccountContracts
	return r
}

// External system code.
func (r ApiPutChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelAccountContractsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelAccountContractsExecute(r)
}

/*
PutChannelAccountContracts Updates channel account contracts for given profile Id.

Use this API to update existing cannel account contract for a given OPERA profile id <p><strong>OperationId:</strong>putChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountProfileId Unique ID that identifies an account profile.
 @return ApiPutChannelAccountContractsRequest
*/
func (a *ChannelApiService) PutChannelAccountContracts(ctx context.Context, accountProfileId string) ApiPutChannelAccountContractsRequest {
	return ApiPutChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelAccountContractsExecute(r ApiPutChannelAccountContractsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelAccountContracts == nil {
		return localVarReturnValue, nil, reportError("channelAccountContracts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountContracts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountsToChange *UNKNOWN_BASE_TYPE
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelAccountsRequest) Authorization(authorization string) ApiPutChannelAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelAccountsRequest) XAppKey(xAppKey string) ApiPutChannelAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelAccountsRequest) XHotelid(xHotelid string) ApiPutChannelAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Channel account information to create a new channel account.
func (r ApiPutChannelAccountsRequest) ChannelAccountsToChange(channelAccountsToChange UNKNOWN_BASE_TYPE) ApiPutChannelAccountsRequest {
	r.channelAccountsToChange = &channelAccountsToChange
	return r
}

// External system code.
func (r ApiPutChannelAccountsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelAccountsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelAccountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelAccountsExecute(r)
}

/*
PutChannelAccounts Updates channel accounts

Use this API to update existing channel account for a given OPERA profile id <p><strong>OperationId:</strong>putChannelAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelAccountsRequest
*/
func (a *ChannelApiService) PutChannelAccounts(ctx context.Context) ApiPutChannelAccountsRequest {
	return ApiPutChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelAccountsExecute(r ApiPutChannelAccountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelAccountsToChange == nil {
		return localVarReturnValue, nil, reportError("channelAccountsToChange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelBillingStatements *PutChannelBillingStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelBillingStatementsRequest) Authorization(authorization string) ApiPutChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelBillingStatementsRequest) XAppKey(xAppKey string) ApiPutChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelBillingStatementsRequest) XHotelid(xHotelid string) ApiPutChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Change channel billing statements.
func (r ApiPutChannelBillingStatementsRequest) ChannelBillingStatements(channelBillingStatements PutChannelBillingStatementsRequest) ApiPutChannelBillingStatementsRequest {
	r.channelBillingStatements = &channelBillingStatements
	return r
}

// External system code.
func (r ApiPutChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelBillingStatementsExecute(r)
}

/*
PutChannelBillingStatements Updates channel billing statement details

Use this API to update channels billing statements for a given OPERA statement id <p><strong>OperationId:</strong>putChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelBillingStatementsRequest
*/
func (a *ChannelApiService) PutChannelBillingStatements(ctx context.Context) ApiPutChannelBillingStatementsRequest {
	return ApiPutChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelBillingStatementsExecute(r ApiPutChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelBillingStatements == nil {
		return localVarReturnValue, nil, reportError("channelBillingStatements is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelBillingStatements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelCardTypeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	cardTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCardTypeMappings *PutChannelCardTypeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelCardTypeMappingRequest) Authorization(authorization string) ApiPutChannelCardTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelCardTypeMappingRequest) XAppKey(xAppKey string) ApiPutChannelCardTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelCardTypeMappingRequest) XHotelid(xHotelid string) ApiPutChannelCardTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing information of an existing channel-hotel card type mapping.
func (r ApiPutChannelCardTypeMappingRequest) ChannelCardTypeMappings(channelCardTypeMappings PutChannelCardTypeMappingRequest) ApiPutChannelCardTypeMappingRequest {
	r.channelCardTypeMappings = &channelCardTypeMappings
	return r
}

// External system code.
func (r ApiPutChannelCardTypeMappingRequest) XExternalsystem(xExternalsystem string) ApiPutChannelCardTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelCardTypeMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelCardTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelCardTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelCardTypeMappingExecute(r)
}

/*
PutChannelCardTypeMapping Updates channel credit card mapping for a hotel

Use this API to update channel mapping for OPERA credit cards to channel for a given hotel id <p><strong>OperationId:</strong>putChannelCardTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardTypeCode Unique ID that identifies a channel.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPutChannelCardTypeMappingRequest
*/
func (a *ChannelApiService) PutChannelCardTypeMapping(ctx context.Context, cardTypeCode string, channelCode string, hotelId string) ApiPutChannelCardTypeMappingRequest {
	return ApiPutChannelCardTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
		cardTypeCode: cardTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelCardTypeMappingExecute(r ApiPutChannelCardTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelCardTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/cardType/{cardTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardTypeCode"+"}", url.PathEscape(parameterValueToString(r.cardTypeCode, "cardTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have at least 1 elements")
	}
	if strlen(r.cardTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelCardTypeMappings == nil {
		return localVarReturnValue, nil, reportError("channelCardTypeMappings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCardTypeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelCarriersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCarriers *PutChannelCarriersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelCarriersRequest) Authorization(authorization string) ApiPutChannelCarriersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelCarriersRequest) XAppKey(xAppKey string) ApiPutChannelCarriersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelCarriersRequest) XHotelid(xHotelid string) ApiPutChannelCarriersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel carriers.
func (r ApiPutChannelCarriersRequest) ChannelCarriers(channelCarriers PutChannelCarriersRequest) ApiPutChannelCarriersRequest {
	r.channelCarriers = &channelCarriers
	return r
}

// External system code.
func (r ApiPutChannelCarriersRequest) XExternalsystem(xExternalsystem string) ApiPutChannelCarriersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelCarriersRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelCarriersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelCarriersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelCarriersExecute(r)
}

/*
PutChannelCarriers Updates sub channel configuration

Use this API to update sub-channel (carrier) configuration for a given channel code <p><strong>OperationId:</strong>putChannelCarriers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelCarriersRequest
*/
func (a *ChannelApiService) PutChannelCarriers(ctx context.Context, channelCode string) ApiPutChannelCarriersRequest {
	return ApiPutChannelCarriersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelCarriersExecute(r ApiPutChannelCarriersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/subChannels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelCarriers == nil {
		return localVarReturnValue, nil, reportError("channelCarriers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCarriers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelErrorsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelErrors *PutChannelErrorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelErrorsRequest) Authorization(authorization string) ApiPutChannelErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelErrorsRequest) XAppKey(xAppKey string) ApiPutChannelErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelErrorsRequest) XHotelid(xHotelid string) ApiPutChannelErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel errors.
func (r ApiPutChannelErrorsRequest) ChannelErrors(channelErrors PutChannelErrorsRequest) ApiPutChannelErrorsRequest {
	r.channelErrors = &channelErrors
	return r
}

// External system code.
func (r ApiPutChannelErrorsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelErrorsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelErrorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelErrorsExecute(r)
}

/*
PutChannelErrors Updates channel error codes

Use this API to update channel error code mapping configurations <p><strong>OperationId:</strong>putChannelErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelErrorsRequest
*/
func (a *ChannelApiService) PutChannelErrors(ctx context.Context, channelCode string) ApiPutChannelErrorsRequest {
	return ApiPutChannelErrorsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelErrorsExecute(r ApiPutChannelErrorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/errorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelErrors == nil {
		return localVarReturnValue, nil, reportError("channelErrors is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelErrors
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelGuaranteeCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	guaranteeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGuaranteeCodeMappings *PutChannelGuaranteeCodeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelGuaranteeCodeMappingRequest) Authorization(authorization string) ApiPutChannelGuaranteeCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelGuaranteeCodeMappingRequest) XAppKey(xAppKey string) ApiPutChannelGuaranteeCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelGuaranteeCodeMappingRequest) XHotelid(xHotelid string) ApiPutChannelGuaranteeCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing information of an existing channel-hotel guarantee code mapping.
func (r ApiPutChannelGuaranteeCodeMappingRequest) ChannelGuaranteeCodeMappings(channelGuaranteeCodeMappings PutChannelGuaranteeCodeMappingRequest) ApiPutChannelGuaranteeCodeMappingRequest {
	r.channelGuaranteeCodeMappings = &channelGuaranteeCodeMappings
	return r
}

// External system code.
func (r ApiPutChannelGuaranteeCodeMappingRequest) XExternalsystem(xExternalsystem string) ApiPutChannelGuaranteeCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelGuaranteeCodeMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelGuaranteeCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelGuaranteeCodeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelGuaranteeCodeMappingExecute(r)
}

/*
PutChannelGuaranteeCodeMapping Updates channel guarantee code mapping for a hotel

Use this API to update channel guarantee code mapping to OPERA guarantee code for a given hotel <p><strong>OperationId:</strong>putChannelGuaranteeCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guaranteeCode Guarantee Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPutChannelGuaranteeCodeMappingRequest
*/
func (a *ChannelApiService) PutChannelGuaranteeCodeMapping(ctx context.Context, guaranteeCode string, channelCode string, hotelId string) ApiPutChannelGuaranteeCodeMappingRequest {
	return ApiPutChannelGuaranteeCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		guaranteeCode: guaranteeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelGuaranteeCodeMappingExecute(r ApiPutChannelGuaranteeCodeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelGuaranteeCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/guarantees/{guaranteeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guaranteeCode"+"}", url.PathEscape(parameterValueToString(r.guaranteeCode, "guaranteeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guaranteeCode) < 1 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have at least 1 elements")
	}
	if strlen(r.guaranteeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGuaranteeCodeMappings == nil {
		return localVarReturnValue, nil, reportError("channelGuaranteeCodeMappings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGuaranteeCodeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelHotelLettersToBeChanged *PutChannelHotelLettersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelHotelLettersRequest) Authorization(authorization string) ApiPutChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelHotelLettersRequest) XAppKey(xAppKey string) ApiPutChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelHotelLettersRequest) XHotelid(xHotelid string) ApiPutChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update existing Hotel Letters associated with the Booking Channels
func (r ApiPutChannelHotelLettersRequest) ChannelHotelLettersToBeChanged(channelHotelLettersToBeChanged PutChannelHotelLettersRequest) ApiPutChannelHotelLettersRequest {
	r.channelHotelLettersToBeChanged = &channelHotelLettersToBeChanged
	return r
}

// External system code.
func (r ApiPutChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ApiPutChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelHotelLettersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelHotelLettersExecute(r)
}

/*
PutChannelHotelLetters Updates channel property confirmation letter mapping

Use this API to update channel property confirmation letter configuration <p><strong>OperationId:</strong>putChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelHotelLettersRequest
*/
func (a *ChannelApiService) PutChannelHotelLetters(ctx context.Context) ApiPutChannelHotelLettersRequest {
	return ApiPutChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelHotelLettersExecute(r ApiPutChannelHotelLettersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelHotelLettersToBeChanged == nil {
		return localVarReturnValue, nil, reportError("channelHotelLettersToBeChanged is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelHotelLettersToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelMarketingTextToChange *PutChannelMarketingTextRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelMarketingTextRequest) Authorization(authorization string) ApiPutChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelMarketingTextRequest) XAppKey(xAppKey string) ApiPutChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelMarketingTextRequest) XHotelid(xHotelid string) ApiPutChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing channel marketing texts.
func (r ApiPutChannelMarketingTextRequest) ChannelMarketingTextToChange(channelMarketingTextToChange PutChannelMarketingTextRequest) ApiPutChannelMarketingTextRequest {
	r.channelMarketingTextToChange = &channelMarketingTextToChange
	return r
}

// External system code.
func (r ApiPutChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ApiPutChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelMarketingTextExecute(r)
}

/*
PutChannelMarketingText Updates channel marketing messages

Use this API to update channel mapping for marketing messages <p><strong>OperationId:</strong>putChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelMarketingTextRequest
*/
func (a *ChannelApiService) PutChannelMarketingText(ctx context.Context) ApiPutChannelMarketingTextRequest {
	return ApiPutChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelMarketingTextExecute(r ApiPutChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelMarketingTextToChange == nil {
		return localVarReturnValue, nil, reportError("channelMarketingTextToChange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelMarketingTextToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelNegotiatedRates *PutChannelNegotiatedRateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelNegotiatedRateRequest) Authorization(authorization string) ApiPutChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelNegotiatedRateRequest) XAppKey(xAppKey string) ApiPutChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelNegotiatedRateRequest) XHotelid(xHotelid string) ApiPutChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Negotiated channel rates.
func (r ApiPutChannelNegotiatedRateRequest) ChannelNegotiatedRates(channelNegotiatedRates PutChannelNegotiatedRateRequest) ApiPutChannelNegotiatedRateRequest {
	r.channelNegotiatedRates = &channelNegotiatedRates
	return r
}

// External system code.
func (r ApiPutChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ApiPutChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelNegotiatedRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelNegotiatedRateExecute(r)
}

/*
PutChannelNegotiatedRate Updates channel negotiate rate

Use this API to update channel's negotiated rate code mapping including negotiated profile, negotiate rate access code, start date, end date, and sequence. <p><strong>OperationId:</strong>putChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) PutChannelNegotiatedRate(ctx context.Context) ApiPutChannelNegotiatedRateRequest {
	return ApiPutChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelNegotiatedRateExecute(r ApiPutChannelNegotiatedRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelNegotiatedRates == nil {
		return localVarReturnValue, nil, reportError("channelNegotiatedRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelNegotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	tenantCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelOrgMapping *PostChannelOrgMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelOrgMappingRequest) Authorization(authorization string) ApiPutChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelOrgMappingRequest) XAppKey(xAppKey string) ApiPutChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelOrgMappingRequest) XHotelid(xHotelid string) ApiPutChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Change Channel to ORG and CRO Mapping.
func (r ApiPutChannelOrgMappingRequest) ChannelOrgMapping(channelOrgMapping PostChannelOrgMappingRequest) ApiPutChannelOrgMappingRequest {
	r.channelOrgMapping = &channelOrgMapping
	return r
}

// External system code.
func (r ApiPutChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ApiPutChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelOrgMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelOrgMappingExecute(r)
}

/*
PutChannelOrgMapping Updates channel tenants mapping.

This API changes channel tenants mapping. <p><strong>OperationId:</strong>putChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantCode Tenant Code.
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelOrgMappingRequest
*/
func (a *ChannelApiService) PutChannelOrgMapping(ctx context.Context, tenantCode string, channelCode string) ApiPutChannelOrgMappingRequest {
	return ApiPutChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		tenantCode: tenantCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelOrgMappingExecute(r ApiPutChannelOrgMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants/{tenantCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantCode"+"}", url.PathEscape(parameterValueToString(r.tenantCode, "tenantCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tenantCode) < 1 {
		return localVarReturnValue, nil, reportError("tenantCode must have at least 1 elements")
	}
	if strlen(r.tenantCode) > 2000 {
		return localVarReturnValue, nil, reportError("tenantCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelOrgMapping == nil {
		return localVarReturnValue, nil, reportError("channelOrgMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelOrgMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelParametersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeChannelParameters *PutChannelParametersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelParametersRequest) Authorization(authorization string) ApiPutChannelParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelParametersRequest) XAppKey(xAppKey string) ApiPutChannelParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelParametersRequest) XHotelid(xHotelid string) ApiPutChannelParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying channel parameter(s).
func (r ApiPutChannelParametersRequest) ChangeChannelParameters(changeChannelParameters PutChannelParametersRequest) ApiPutChannelParametersRequest {
	r.changeChannelParameters = &changeChannelParameters
	return r
}

// External system code.
func (r ApiPutChannelParametersRequest) XExternalsystem(xExternalsystem string) ApiPutChannelParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelParametersRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelParametersExecute(r)
}

/*
PutChannelParameters Updates channel control settings

Use this API to active/inactive channel controls. It also allows to update channel control settings. <p><strong>OperationId:</strong>putChannelParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelParametersRequest
*/
func (a *ChannelApiService) PutChannelParameters(ctx context.Context, channelCode string) ApiPutChannelParametersRequest {
	return ApiPutChannelParametersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelParametersExecute(r ApiPutChannelParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.changeChannelParameters == nil {
		return localVarReturnValue, nil, reportError("changeChannelParameters is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeChannelParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRateCategoriesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateCategories *PutChannelRateCategoriesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRateCategoriesRequest) Authorization(authorization string) ApiPutChannelRateCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRateCategoriesRequest) XAppKey(xAppKey string) ApiPutChannelRateCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRateCategoriesRequest) XHotelid(xHotelid string) ApiPutChannelRateCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel rate categories.
func (r ApiPutChannelRateCategoriesRequest) ChannelRateCategories(channelRateCategories PutChannelRateCategoriesRequest) ApiPutChannelRateCategoriesRequest {
	r.channelRateCategories = &channelRateCategories
	return r
}

// External system code.
func (r ApiPutChannelRateCategoriesRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRateCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRateCategoriesRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRateCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRateCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateCategoriesExecute(r)
}

/*
PutChannelRateCategories Updates given channel's rate categories

Use this API to update channel rate categories for a given channel. <p><strong>OperationId:</strong>putChannelRateCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelRateCategoriesRequest
*/
func (a *ChannelApiService) PutChannelRateCategories(ctx context.Context, channelCode string) ApiPutChannelRateCategoriesRequest {
	return ApiPutChannelRateCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateCategoriesExecute(r ApiPutChannelRateCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateCategories == nil {
		return localVarReturnValue, nil, reportError("channelRateCategories is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateCategories
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRateLevelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateLevels *PutChannelRateLevelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRateLevelsRequest) Authorization(authorization string) ApiPutChannelRateLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRateLevelsRequest) XAppKey(xAppKey string) ApiPutChannelRateLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRateLevelsRequest) XHotelid(xHotelid string) ApiPutChannelRateLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel rate levels.
func (r ApiPutChannelRateLevelsRequest) ChannelRateLevels(channelRateLevels PutChannelRateLevelsRequest) ApiPutChannelRateLevelsRequest {
	r.channelRateLevels = &channelRateLevels
	return r
}

// External system code.
func (r ApiPutChannelRateLevelsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRateLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRateLevelsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRateLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRateLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateLevelsExecute(r)
}

/*
PutChannelRateLevels Updates channel rate level

Use this API to update channel rate level code's description <p><strong>OperationId:</strong>putChannelRateLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelRateLevelsRequest
*/
func (a *ChannelApiService) PutChannelRateLevels(ctx context.Context, channelCode string) ApiPutChannelRateLevelsRequest {
	return ApiPutChannelRateLevelsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateLevelsExecute(r ApiPutChannelRateLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateLevels == nil {
		return localVarReturnValue, nil, reportError("channelRateLevels is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateLevels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateMapping *PutChannelRateMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRateMappingRequest) Authorization(authorization string) ApiPutChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRateMappingRequest) XAppKey(xAppKey string) ApiPutChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRateMappingRequest) XHotelid(xHotelid string) ApiPutChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing channel rate mappings.
func (r ApiPutChannelRateMappingRequest) ChannelRateMapping(channelRateMapping PutChannelRateMappingRequest) ApiPutChannelRateMappingRequest {
	r.channelRateMapping = &channelRateMapping
	return r
}

// External system code.
func (r ApiPutChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRateMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateMappingExecute(r)
}

/*
PutChannelRateMapping Updates channel property rate mapping

Use this API to update channel property rate mapping including channel rate code, start date, end date, rate level, channel rate description. <p><strong>OperationId:</strong>putChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelRateMappingRequest
*/
func (a *ChannelApiService) PutChannelRateMapping(ctx context.Context) ApiPutChannelRateMappingRequest {
	return ApiPutChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateMappingExecute(r ApiPutChannelRateMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateMapping == nil {
		return localVarReturnValue, nil, reportError("channelRateMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRateRoomSeqRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateRoomSequence *PutChannelRateRoomSeqRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRateRoomSeqRequest) Authorization(authorization string) ApiPutChannelRateRoomSeqRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRateRoomSeqRequest) XAppKey(xAppKey string) ApiPutChannelRateRoomSeqRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRateRoomSeqRequest) XHotelid(xHotelid string) ApiPutChannelRateRoomSeqRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing sequence for channel rate rooms.
func (r ApiPutChannelRateRoomSeqRequest) ChannelRateRoomSequence(channelRateRoomSequence PutChannelRateRoomSeqRequest) ApiPutChannelRateRoomSeqRequest {
	r.channelRateRoomSequence = &channelRateRoomSequence
	return r
}

// External system code.
func (r ApiPutChannelRateRoomSeqRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRateRoomSeqRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRateRoomSeqRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRateRoomSeqRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRateRoomSeqRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateRoomSeqExecute(r)
}

/*
PutChannelRateRoomSeq Updates channel property rateroom sequence

Use this API to update sequence for given channel property rate room mapping  <p><strong>OperationId:</strong>putChannelRateRoomSeq</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelRateRoomSeqRequest
*/
func (a *ChannelApiService) PutChannelRateRoomSeq(ctx context.Context) ApiPutChannelRateRoomSeqRequest {
	return ApiPutChannelRateRoomSeqRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateRoomSeqExecute(r ApiPutChannelRateRoomSeqRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateRoomSeq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/roomSequence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRateRoomSequence == nil {
		return localVarReturnValue, nil, reportError("channelRateRoomSequence is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateRoomSequence
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ApiPutChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiPutChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiPutChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update existing Global Descriptions of the GDS Channels
func (r ApiPutChannelRatesGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ApiPutChannelRatesGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ApiPutChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRatesGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRatesGlobalDescriptionsExecute(r)
}

/*
PutChannelRatesGlobalDescriptions Updates global rate descriptions

Use this API to update global rate description for given hotel id and rate code <p><strong>OperationId:</strong>putChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PutChannelRatesGlobalDescriptions(ctx context.Context) ApiPutChannelRatesGlobalDescriptionsRequest {
	return ApiPutChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRatesGlobalDescriptionsExecute(r ApiPutChannelRatesGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGlobalDescriptions == nil {
		return localVarReturnValue, nil, reportError("channelGlobalDescriptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomMapping *PutChannelRoomMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRoomMappingRequest) Authorization(authorization string) ApiPutChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRoomMappingRequest) XAppKey(xAppKey string) ApiPutChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRoomMappingRequest) XHotelid(xHotelid string) ApiPutChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Channel Room Mapping.
func (r ApiPutChannelRoomMappingRequest) ChannelRoomMapping(channelRoomMapping PutChannelRoomMappingRequest) ApiPutChannelRoomMappingRequest {
	r.channelRoomMapping = &channelRoomMapping
	return r
}

// External system code.
func (r ApiPutChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRoomMappingExecute(r)
}

/*
PutChannelRoomMapping Updates channel property room mapping

Use this API to update channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>putChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Room Type Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ApiPutChannelRoomMappingRequest
*/
func (a *ChannelApiService) PutChannelRoomMapping(ctx context.Context, roomTypeCode string, channelCode string, hotelId string) ApiPutChannelRoomMappingRequest {
	return ApiPutChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRoomMappingExecute(r ApiPutChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRoomMapping == nil {
		return localVarReturnValue, nil, reportError("channelRoomMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRoomTypesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomTypes *PutChannelRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRoomTypesRequest) Authorization(authorization string) ApiPutChannelRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRoomTypesRequest) XAppKey(xAppKey string) ApiPutChannelRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRoomTypesRequest) XHotelid(xHotelid string) ApiPutChannelRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel room types.
func (r ApiPutChannelRoomTypesRequest) ChannelRoomTypes(channelRoomTypes PutChannelRoomTypesRequest) ApiPutChannelRoomTypesRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// External system code.
func (r ApiPutChannelRoomTypesRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRoomTypesRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRoomTypesExecute(r)
}

/*
PutChannelRoomTypes Updates channel room

Use this API to update channel room description <p><strong>OperationId:</strong>putChannelRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutChannelRoomTypesRequest
*/
func (a *ChannelApiService) PutChannelRoomTypes(ctx context.Context, channelCode string) ApiPutChannelRoomTypesRequest {
	return ApiPutChannelRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRoomTypesExecute(r ApiPutChannelRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelRoomTypes == nil {
		return localVarReturnValue, nil, reportError("channelRoomTypes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ApiPutChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ApiPutChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ApiPutChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update existing Global Descriptions of the GDS Channels
func (r ApiPutChannelRoomsGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ApiPutChannelRoomsGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ApiPutChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelRoomsGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRoomsGlobalDescriptionsExecute(r)
}

/*
PutChannelRoomsGlobalDescriptions Updates global room descriptions

Use this API to update global room description for given hotel id and room type code <p><strong>OperationId:</strong>putChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PutChannelRoomsGlobalDescriptions(ctx context.Context) ApiPutChannelRoomsGlobalDescriptionsRequest {
	return ApiPutChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRoomsGlobalDescriptionsExecute(r ApiPutChannelRoomsGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGlobalDescriptions == nil {
		return localVarReturnValue, nil, reportError("channelGlobalDescriptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutChannelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channels *PutChannelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutChannelsRequest) Authorization(authorization string) ApiPutChannelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutChannelsRequest) XAppKey(xAppKey string) ApiPutChannelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutChannelsRequest) XHotelid(xHotelid string) ApiPutChannelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channels.
func (r ApiPutChannelsRequest) Channels(channels PutChannelsRequest) ApiPutChannelsRequest {
	r.channels = &channels
	return r
}

// External system code.
func (r ApiPutChannelsRequest) XExternalsystem(xExternalsystem string) ApiPutChannelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutChannelsRequest) AcceptLanguage(acceptLanguage string) ApiPutChannelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutChannelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelsExecute(r)
}

/*
PutChannels Update channel configuration

Use this API to update channel configuration <p><strong>OperationId:</strong>putChannels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutChannelsRequest
*/
func (a *ChannelApiService) PutChannels(ctx context.Context) ApiPutChannelsRequest {
	return ApiPutChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelsExecute(r ApiPutChannelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channels == nil {
		return localVarReturnValue, nil, reportError("channels is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCards *PutCreditCardsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCreditCardsMappingRequest) Authorization(authorization string) ApiPutCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCreditCardsMappingRequest) XAppKey(xAppKey string) ApiPutCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCreditCardsMappingRequest) XHotelid(xHotelid string) ApiPutCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing external system credit cards.
func (r ApiPutCreditCardsMappingRequest) CreditCards(creditCards PutCreditCardsMappingRequest) ApiPutCreditCardsMappingRequest {
	r.creditCards = &creditCards
	return r
}

// External system code.
func (r ApiPutCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ApiPutCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCreditCardsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCreditCardsMappingExecute(r)
}

/*
PutCreditCardsMapping Updates channel credit card mapping

Use this API to update channel credit card code mapping to OPERA credit card code <p><strong>OperationId:</strong>putCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCreditCardsMappingRequest
*/
func (a *ChannelApiService) PutCreditCardsMapping(ctx context.Context) ApiPutCreditCardsMappingRequest {
	return ApiPutCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutCreditCardsMappingExecute(r ApiPutCreditCardsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.creditCards == nil {
		return localVarReturnValue, nil, reportError("creditCards is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditCards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencies *PutCurrenciesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutCurrenciesMappingRequest) Authorization(authorization string) ApiPutCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutCurrenciesMappingRequest) XAppKey(xAppKey string) ApiPutCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutCurrenciesMappingRequest) XHotelid(xHotelid string) ApiPutCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing external system currencies.
func (r ApiPutCurrenciesMappingRequest) Currencies(currencies PutCurrenciesMappingRequest) ApiPutCurrenciesMappingRequest {
	r.currencies = &currencies
	return r
}

// External system code.
func (r ApiPutCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ApiPutCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutCurrenciesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCurrenciesMappingExecute(r)
}

/*
PutCurrenciesMapping Updates channel currency code mapping

Use this API to update channel mapping to OPERA currency codes <p><strong>OperationId:</strong>putCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCurrenciesMappingRequest
*/
func (a *ChannelApiService) PutCurrenciesMapping(ctx context.Context) ApiPutCurrenciesMappingRequest {
	return ApiPutCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutCurrenciesMappingExecute(r ApiPutCurrenciesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.currencies == nil {
		return localVarReturnValue, nil, reportError("currencies is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	distributionTemplates *PutDistributionTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutDistributionTemplatesRequest) Authorization(authorization string) ApiPutDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutDistributionTemplatesRequest) XAppKey(xAppKey string) ApiPutDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutDistributionTemplatesRequest) XHotelid(xHotelid string) ApiPutDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying chain or property level distribution templates.
func (r ApiPutDistributionTemplatesRequest) DistributionTemplates(distributionTemplates PutDistributionTemplatesRequest) ApiPutDistributionTemplatesRequest {
	r.distributionTemplates = &distributionTemplates
	return r
}

// External system code.
func (r ApiPutDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ApiPutDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ApiPutDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutDistributionTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDistributionTemplatesExecute(r)
}

/*
PutDistributionTemplates Updates rate templates configurations

Use this API to update existing distribution rate template <p><strong>OperationId:</strong>putDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutDistributionTemplatesRequest
*/
func (a *ChannelApiService) PutDistributionTemplates(ctx context.Context) ApiPutDistributionTemplatesRequest {
	return ApiPutDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutDistributionTemplatesExecute(r ApiPutDistributionTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.distributionTemplates == nil {
		return localVarReturnValue, nil, reportError("distributionTemplates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.distributionTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guarantees *PutGuaranteesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutGuaranteesMappingRequest) Authorization(authorization string) ApiPutGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutGuaranteesMappingRequest) XAppKey(xAppKey string) ApiPutGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutGuaranteesMappingRequest) XHotelid(xHotelid string) ApiPutGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing external system guarantees.
func (r ApiPutGuaranteesMappingRequest) Guarantees(guarantees PutGuaranteesMappingRequest) ApiPutGuaranteesMappingRequest {
	r.guarantees = &guarantees
	return r
}

// External system code.
func (r ApiPutGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ApiPutGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutGuaranteesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGuaranteesMappingExecute(r)
}

/*
PutGuaranteesMapping Updates channel guarantee code mapping

Use this API to update channel's guarantee codes mapping to OPERA guarantee codes <p><strong>OperationId:</strong>putGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutGuaranteesMappingRequest
*/
func (a *ChannelApiService) PutGuaranteesMapping(ctx context.Context) ApiPutGuaranteesMappingRequest {
	return ApiPutGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutGuaranteesMappingExecute(r ApiPutGuaranteesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.guarantees == nil {
		return localVarReturnValue, nil, reportError("guarantees is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guarantees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	properties *PutHotelsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutHotelsMappingRequest) Authorization(authorization string) ApiPutHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutHotelsMappingRequest) XAppKey(xAppKey string) ApiPutHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutHotelsMappingRequest) XHotelid(xHotelid string) ApiPutHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing external system properties.
func (r ApiPutHotelsMappingRequest) Properties(properties PutHotelsMappingRequest) ApiPutHotelsMappingRequest {
	r.properties = &properties
	return r
}

// External system code.
func (r ApiPutHotelsMappingRequest) XExternalsystem(xExternalsystem string) ApiPutHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ApiPutHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutHotelsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutHotelsMappingExecute(r)
}

/*
PutHotelsMapping Updates channel hotel mapping

Use this API to update channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date <p><strong>OperationId:</strong>putHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutHotelsMappingRequest
*/
func (a *ChannelApiService) PutHotelsMapping(ctx context.Context) ApiPutHotelsMappingRequest {
	return ApiPutHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutHotelsMappingExecute(r ApiPutHotelsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.properties == nil {
		return localVarReturnValue, nil, reportError("properties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.properties
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRateGlobalDescriptionRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelRateCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescription *PutRoomDescriptionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutRateGlobalDescriptionRequest) Authorization(authorization string) ApiPutRateGlobalDescriptionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutRateGlobalDescriptionRequest) XAppKey(xAppKey string) ApiPutRateGlobalDescriptionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutRateGlobalDescriptionRequest) XHotelid(xHotelid string) ApiPutRateGlobalDescriptionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing channel rate codes global description.
func (r ApiPutRateGlobalDescriptionRequest) ChannelGlobalDescription(channelGlobalDescription PutRoomDescriptionRequest) ApiPutRateGlobalDescriptionRequest {
	r.channelGlobalDescription = &channelGlobalDescription
	return r
}

// External system code.
func (r ApiPutRateGlobalDescriptionRequest) XExternalsystem(xExternalsystem string) ApiPutRateGlobalDescriptionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutRateGlobalDescriptionRequest) AcceptLanguage(acceptLanguage string) ApiPutRateGlobalDescriptionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutRateGlobalDescriptionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRateGlobalDescriptionExecute(r)
}

/*
PutRateGlobalDescription Updates global descriptions for a rate

Use this API to update OPERA rate's global description for global distribution type channels <p><strong>OperationId:</strong>putRateGlobalDescription</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelRateCode Channel Rate Code.
 @param channelCode Unique ID that identifies a channel.
 @return ApiPutRateGlobalDescriptionRequest
*/
func (a *ChannelApiService) PutRateGlobalDescription(ctx context.Context, channelRateCode string, channelCode string) ApiPutRateGlobalDescriptionRequest {
	return ApiPutRateGlobalDescriptionRequest{
		ApiService: a,
		ctx: ctx,
		channelRateCode: channelRateCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutRateGlobalDescriptionExecute(r ApiPutRateGlobalDescriptionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutRateGlobalDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rates/{channelRateCode}/globalDescription"
	localVarPath = strings.Replace(localVarPath, "{"+"channelRateCode"+"}", url.PathEscape(parameterValueToString(r.channelRateCode, "channelRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelRateCode) < 1 {
		return localVarReturnValue, nil, reportError("channelRateCode must have at least 1 elements")
	}
	if strlen(r.channelRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelRateCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGlobalDescription == nil {
		return localVarReturnValue, nil, reportError("channelGlobalDescription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRoomDescriptionRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescription *PutRoomDescriptionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutRoomDescriptionRequest) Authorization(authorization string) ApiPutRoomDescriptionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutRoomDescriptionRequest) XAppKey(xAppKey string) ApiPutRoomDescriptionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutRoomDescriptionRequest) XHotelid(xHotelid string) ApiPutRoomDescriptionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Room Mapping description.
func (r ApiPutRoomDescriptionRequest) ChannelGlobalDescription(channelGlobalDescription PutRoomDescriptionRequest) ApiPutRoomDescriptionRequest {
	r.channelGlobalDescription = &channelGlobalDescription
	return r
}

// External system code.
func (r ApiPutRoomDescriptionRequest) XExternalsystem(xExternalsystem string) ApiPutRoomDescriptionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutRoomDescriptionRequest) AcceptLanguage(acceptLanguage string) ApiPutRoomDescriptionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutRoomDescriptionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomDescriptionExecute(r)
}

/*
PutRoomDescription Update global descriptions for a room

Use this API to update OPERA room's global description for global distribution type channels <p><strong>OperationId:</strong>putRoomDescription</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutRoomDescriptionRequest
*/
func (a *ChannelApiService) PutRoomDescription(ctx context.Context) ApiPutRoomDescriptionRequest {
	return ApiPutRoomDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutRoomDescriptionExecute(r ApiPutRoomDescriptionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutRoomDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.channelGlobalDescription == nil {
		return localVarReturnValue, nil, reportError("channelGlobalDescription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	totalPricingElements *PutTotalPricingElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPutTotalPricingElementsRequest) Authorization(authorization string) ApiPutTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPutTotalPricingElementsRequest) XAppKey(xAppKey string) ApiPutTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPutTotalPricingElementsRequest) XHotelid(xHotelid string) ApiPutTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change the total pricing elements of GDS channel.
func (r ApiPutTotalPricingElementsRequest) TotalPricingElements(totalPricingElements PutTotalPricingElementsRequest) ApiPutTotalPricingElementsRequest {
	r.totalPricingElements = &totalPricingElements
	return r
}

// External system code.
func (r ApiPutTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ApiPutTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPutTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ApiPutTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPutTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTotalPricingElementsExecute(r)
}

/*
PutTotalPricingElements Updates total pricing tax and fee types

Use this API to update global distribution channels tax and fee configurations <p><strong>OperationId:</strong>putTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutTotalPricingElementsRequest
*/
func (a *ChannelApiService) PutTotalPricingElements(ctx context.Context) ApiPutTotalPricingElementsRequest {
	return ApiPutTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutTotalPricingElementsExecute(r ApiPutTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.totalPricingElements == nil {
		return localVarReturnValue, nil, reportError("totalPricingElements is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.totalPricingElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
