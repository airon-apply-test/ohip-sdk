/*
OPERA Cloud Front Desk Operations Service

APIs to cater for Front Desk Operations and Front Desk Statistic functionality in OPERA Cloud. <br /><br /> Front Desk features some of the most commonly used operations in OPERA Cloud, such as managing guest arrivals, managing in-house guests, and managing guest departures. Some additional tasks you can complete from the Front Desk menu are room searches, room assignments, and quick check outs as well as opening folios, creating registration cards, setting wake up calls, and sending messages to guests.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// FrontDeskOperationsApiService FrontDeskOperationsApi service
type FrontDeskOperationsApiService service

type ApiGetHotelRoomsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	roomNumberWildcard *string
	hotelRoomStatus *[]string
	hotelFORoomStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	hotelRoomStartDate *string
	hotelRoomEndDate *string
	duration *string
	roomType *[]string
	roomClass *string
	floor *string
	includeDueOut *bool
	departureTime *time.Time
	roomFeatureCode *[]string
	description *[]string
	orderSequence *[]float32
	quantity *[]int32
	smokingPreference *string
	includeAllRoomConditions *bool
	includeComponentRooms *bool
	includePseudoRooms *bool
	includeOORoomCheck *bool
	connectingRoomsOnly *bool
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	pseudoRoomsOnly *bool
	includeAttendentInRoom *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelRoomsRequest) Authorization(authorization string) ApiGetHotelRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetHotelRoomsRequest) XAppKey(xAppKey string) ApiGetHotelRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelRoomsRequest) XHotelid(xHotelid string) ApiGetHotelRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetHotelRoomsRequest) Limit(limit int32) ApiGetHotelRoomsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetHotelRoomsRequest) Offset(offset int32) ApiGetHotelRoomsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetHotelRoomsRequest) RoomNumberWildcard(roomNumberWildcard string) ApiGetHotelRoomsRequest {
	r.roomNumberWildcard = &roomNumberWildcard
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ApiGetHotelRoomsRequest) HotelRoomStatus(hotelRoomStatus []string) ApiGetHotelRoomsRequest {
	r.hotelRoomStatus = &hotelRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r ApiGetHotelRoomsRequest) HotelFORoomStatus(hotelFORoomStatus []string) ApiGetHotelRoomsRequest {
	r.hotelFORoomStatus = &hotelFORoomStatus
	return r
}

func (r ApiGetHotelRoomsRequest) FromRoomNumber(fromRoomNumber string) ApiGetHotelRoomsRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r ApiGetHotelRoomsRequest) ToRoomNumber(toRoomNumber string) ApiGetHotelRoomsRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

func (r ApiGetHotelRoomsRequest) HotelRoomStartDate(hotelRoomStartDate string) ApiGetHotelRoomsRequest {
	r.hotelRoomStartDate = &hotelRoomStartDate
	return r
}

func (r ApiGetHotelRoomsRequest) HotelRoomEndDate(hotelRoomEndDate string) ApiGetHotelRoomsRequest {
	r.hotelRoomEndDate = &hotelRoomEndDate
	return r
}

func (r ApiGetHotelRoomsRequest) Duration(duration string) ApiGetHotelRoomsRequest {
	r.duration = &duration
	return r
}

// The room types of hotel rooms to be fetched.
func (r ApiGetHotelRoomsRequest) RoomType(roomType []string) ApiGetHotelRoomsRequest {
	r.roomType = &roomType
	return r
}

// The room class of hotel rooms to be fetched.
func (r ApiGetHotelRoomsRequest) RoomClass(roomClass string) ApiGetHotelRoomsRequest {
	r.roomClass = &roomClass
	return r
}

// The floor of room to be fetched.
func (r ApiGetHotelRoomsRequest) Floor(floor string) ApiGetHotelRoomsRequest {
	r.floor = &floor
	return r
}

// This flag when set to true will include rooms assigned to due out reservations.
func (r ApiGetHotelRoomsRequest) IncludeDueOut(includeDueOut bool) ApiGetHotelRoomsRequest {
	r.includeDueOut = &includeDueOut
	return r
}

// When IncludeDueOut is enable,it is the departure time before which to search.
func (r ApiGetHotelRoomsRequest) DepartureTime(departureTime time.Time) ApiGetHotelRoomsRequest {
	r.departureTime = &departureTime
	return r
}

// A code representing a room feature.
func (r ApiGetHotelRoomsRequest) RoomFeatureCode(roomFeatureCode []string) ApiGetHotelRoomsRequest {
	r.roomFeatureCode = &roomFeatureCode
	return r
}

// A code representing a room feature.
func (r ApiGetHotelRoomsRequest) Description(description []string) ApiGetHotelRoomsRequest {
	r.description = &description
	return r
}

// Display Order sequence.
func (r ApiGetHotelRoomsRequest) OrderSequence(orderSequence []float32) ApiGetHotelRoomsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Indicates quantity.
func (r ApiGetHotelRoomsRequest) Quantity(quantity []int32) ApiGetHotelRoomsRequest {
	r.quantity = &quantity
	return r
}

// The smoking preference of room to be fetched.
func (r ApiGetHotelRoomsRequest) SmokingPreference(smokingPreference string) ApiGetHotelRoomsRequest {
	r.smokingPreference = &smokingPreference
	return r
}

// This flag when set to true will include all room conditions, when set to false then room with \&quot;General Assignment\&quot; condition type will be excluded from the result.
func (r ApiGetHotelRoomsRequest) IncludeAllRoomConditions(includeAllRoomConditions bool) ApiGetHotelRoomsRequest {
	r.includeAllRoomConditions = &includeAllRoomConditions
	return r
}

// This flag when set to true will include all component rooms
func (r ApiGetHotelRoomsRequest) IncludeComponentRooms(includeComponentRooms bool) ApiGetHotelRoomsRequest {
	r.includeComponentRooms = &includeComponentRooms
	return r
}

// This flag when set to true will include all pseudo rooms
func (r ApiGetHotelRoomsRequest) IncludePseudoRooms(includePseudoRooms bool) ApiGetHotelRoomsRequest {
	r.includePseudoRooms = &includePseudoRooms
	return r
}

// This flag when set to true will work for Available Rooms functionality
func (r ApiGetHotelRoomsRequest) IncludeOORoomCheck(includeOORoomCheck bool) ApiGetHotelRoomsRequest {
	r.includeOORoomCheck = &includeOORoomCheck
	return r
}

// This flag when set to true will include only connecting rooms.
func (r ApiGetHotelRoomsRequest) ConnectingRoomsOnly(connectingRoomsOnly bool) ApiGetHotelRoomsRequest {
	r.connectingRoomsOnly = &connectingRoomsOnly
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetHotelRoomsRequest) ReservationId(reservationId string) ApiGetHotelRoomsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetHotelRoomsRequest) ReservationIdContext(reservationIdContext string) ApiGetHotelRoomsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r ApiGetHotelRoomsRequest) ReservationIdType(reservationIdType string) ApiGetHotelRoomsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// This flag when set to true will include only pseudo rooms
func (r ApiGetHotelRoomsRequest) PseudoRoomsOnly(pseudoRoomsOnly bool) ApiGetHotelRoomsRequest {
	r.pseudoRoomsOnly = &pseudoRoomsOnly
	return r
}

// This flag when set to true will includes attendent in Rooms
func (r ApiGetHotelRoomsRequest) IncludeAttendentInRoom(includeAttendentInRoom bool) ApiGetHotelRoomsRequest {
	r.includeAttendentInRoom = &includeAttendentInRoom
	return r
}

// External system code.
func (r ApiGetHotelRoomsRequest) XExternalsystem(xExternalsystem string) ApiGetHotelRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelRoomsRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelRoomsRequest) Execute() (*HotelRooms, *http.Response, error) {
	return r.ApiService.GetHotelRoomsExecute(r)
}

/*
GetHotelRooms Get hotel available rooms

Use this API to return available rooms based on search criteria such as hotelId, hotelRoomStatus, roomType, roomFeatureCode,etc.<p><strong>OperationId:</strong>getHotelRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return ApiGetHotelRoomsRequest
*/
func (a *FrontDeskOperationsApiService) GetHotelRooms(ctx context.Context, hotelId string) ApiGetHotelRoomsRequest {
	return ApiGetHotelRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelRooms
func (a *FrontDeskOperationsApiService) GetHotelRoomsExecute(r ApiGetHotelRoomsRequest) (*HotelRooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelRooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.GetHotelRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.roomNumberWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildcard", r.roomNumberWildcard, "")
	}
	if r.hotelRoomStatus != nil {
		t := *r.hotelRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", t, "multi")
		}
	}
	if r.hotelFORoomStatus != nil {
		t := *r.hotelFORoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.hotelRoomStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStartDate", r.hotelRoomStartDate, "")
	}
	if r.hotelRoomEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomEndDate", r.hotelRoomEndDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
	}
	if r.floor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "floor", r.floor, "")
	}
	if r.includeDueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDueOut", r.includeDueOut, "")
	}
	if r.departureTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureTime", r.departureTime, "")
	}
	if r.roomFeatureCode != nil {
		t := *r.roomFeatureCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.quantity != nil {
		t := *r.quantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", t, "multi")
		}
	}
	if r.smokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", r.smokingPreference, "")
	}
	if r.includeAllRoomConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllRoomConditions", r.includeAllRoomConditions, "")
	}
	if r.includeComponentRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComponentRooms", r.includeComponentRooms, "")
	}
	if r.includePseudoRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePseudoRooms", r.includePseudoRooms, "")
	}
	if r.includeOORoomCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOORoomCheck", r.includeOORoomCheck, "")
	}
	if r.connectingRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectingRoomsOnly", r.connectingRoomsOnly, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.pseudoRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudoRoomsOnly", r.pseudoRoomsOnly, "")
	}
	if r.includeAttendentInRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAttendentInRoom", r.includeAttendentInRoom, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomKeysRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomKeysRequest) Authorization(authorization string) ApiGetRoomKeysRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiGetRoomKeysRequest) XAppKey(xAppKey string) ApiGetRoomKeysRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomKeysRequest) XHotelid(xHotelid string) ApiGetRoomKeysRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetRoomKeysRequest) XExternalsystem(xExternalsystem string) ApiGetRoomKeysRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomKeysRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomKeysRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomKeysRequest) Execute() (*RoomKeyInfo, *http.Response, error) {
	return r.ApiService.GetRoomKeysExecute(r)
}

/*
GetRoomKeys Fetch the room keys

You can use this API to retrieve any existing room key information for a reservation. <p><strong>OperationId:</strong>getRoomKeys</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return ApiGetRoomKeysRequest
*/
func (a *FrontDeskOperationsApiService) GetRoomKeys(ctx context.Context, reservationId string, hotelId string) ApiGetRoomKeysRequest {
	return ApiGetRoomKeysRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyInfo
func (a *FrontDeskOperationsApiService) GetRoomKeysExecute(r ApiGetRoomKeysRequest) (*RoomKeyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.GetRoomKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservation *PostCheckInRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostCheckInRequest) Authorization(authorization string) ApiPostCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostCheckInRequest) XAppKey(xAppKey string) ApiPostCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostCheckInRequest) XHotelid(xHotelid string) ApiPostCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// Validation checks includes the following: - Reservation is not valid to be checked in. - Split is still required before the reservation can be checked in. - Room information is missing. - Payment information is missing. - The status of the room needs to be reviewed. - Sharers was impacted. The check-in process affected the reservation details of shared guests on the reservation. - Sharers was not impacted. The check-in process has not affected the reservation details of shared guests on the reservation.
func (r ApiPostCheckInRequest) Reservation(reservation PostCheckInRequest) ApiPostCheckInRequest {
	r.reservation = &reservation
	return r
}

// External system code.
func (r ApiPostCheckInRequest) XExternalsystem(xExternalsystem string) ApiPostCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostCheckInRequest) AcceptLanguage(acceptLanguage string) ApiPostCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostCheckInRequest) Execute() (*CheckedinReservation, *http.Response, error) {
	return r.ApiService.PostCheckInExecute(r)
}

/*
PostCheckIn Checks in a guest

Use this API to check in a guest reservation.Â  The reservation needs to be 'due in' status.Â  The API also provides an option to select an available room. <p><strong>OperationId:</strong>postCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is being booked
 @return ApiPostCheckInRequest
*/
func (a *FrontDeskOperationsApiService) PostCheckIn(ctx context.Context, reservationId string, hotelId string) ApiPostCheckInRequest {
	return ApiPostCheckInRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckedinReservation
func (a *FrontDeskOperationsApiService) PostCheckInExecute(r ApiPostCheckInRequest) (*CheckedinReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedinReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.PostCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.reservation == nil {
		return localVarReturnValue, nil, reportError("reservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRoomKeyRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomKey *PostRoomKeyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPostRoomKeyRequest) Authorization(authorization string) ApiPostRoomKeyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ApiPostRoomKeyRequest) XAppKey(xAppKey string) ApiPostRoomKeyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPostRoomKeyRequest) XHotelid(xHotelid string) ApiPostRoomKeyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for generation of room key.
func (r ApiPostRoomKeyRequest) RoomKey(roomKey PostRoomKeyRequest) ApiPostRoomKeyRequest {
	r.roomKey = &roomKey
	return r
}

// External system code.
func (r ApiPostRoomKeyRequest) XExternalsystem(xExternalsystem string) ApiPostRoomKeyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPostRoomKeyRequest) AcceptLanguage(acceptLanguage string) ApiPostRoomKeyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPostRoomKeyRequest) Execute() (*RoomKeyDetails, *http.Response, error) {
	return r.ApiService.PostRoomKeyExecute(r)
}

/*
PostRoomKey Requests room key(s)

You can use this API to create a room key request for a reservation to the active Door Locking System Property Interface. <p><strong>OperationId:</strong>postRoomKey</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return ApiPostRoomKeyRequest
*/
func (a *FrontDeskOperationsApiService) PostRoomKey(ctx context.Context, reservationId string, hotelId string) ApiPostRoomKeyRequest {
	return ApiPostRoomKeyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyDetails
func (a *FrontDeskOperationsApiService) PostRoomKeyExecute(r ApiPostRoomKeyRequest) (*RoomKeyDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.PostRoomKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.roomKey == nil {
		return localVarReturnValue, nil, reportError("roomKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
