/*
OPERA Cloud Customer Relationship Management Outbound API

APIs to cater for Customer Relationship Management external (outbound) functionality with OPERA. These APIs facilitate various operations related to getting data from an external system, and inserting it into OPERA.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProfileExternalApiService ProfileExternalApi service
type ProfileExternalApiService service

type ApiCheckIataNumberRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	iataNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xTransactionId *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiCheckIataNumberRequest) Authorization(authorization string) ApiCheckIataNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiCheckIataNumberRequest) XAppKey(xAppKey string) ApiCheckIataNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Transaction Id
func (r ApiCheckIataNumberRequest) XTransactionId(xTransactionId string) ApiCheckIataNumberRequest {
	r.xTransactionId = &xTransactionId
	return r
}

// Language code
func (r ApiCheckIataNumberRequest) AcceptLanguage(acceptLanguage string) ApiCheckIataNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiCheckIataNumberRequest) Execute() (*IataNumberDetails, *http.Response, error) {
	return r.ApiService.CheckIataNumberExecute(r)
}

/*
CheckIataNumber Validate IATA number.

This API will validate and check an IATA number. <p><strong>OperationId:</strong>checkIataNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param iataNumber IATA Number
 @param hotelId Hotel Id
 @return ApiCheckIataNumberRequest
*/
func (a *ProfileExternalApiService) CheckIataNumber(ctx context.Context, iataNumber string, hotelId string) ApiCheckIataNumberRequest {
	return ApiCheckIataNumberRequest{
		ApiService: a,
		ctx: ctx,
		iataNumber: iataNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return IataNumberDetails
func (a *ProfileExternalApiService) CheckIataNumberExecute(r ApiCheckIataNumberRequest) (*IataNumberDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IataNumberDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.CheckIataNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/travelAgents/{iataNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"iataNumber"+"}", url.PathEscape(parameterValueToString(r.iataNumber, "iataNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iataNumber) < 1 {
		return localVarReturnValue, nil, reportError("iataNumber must have at least 1 elements")
	}
	if strlen(r.iataNumber) > 2000 {
		return localVarReturnValue, nil, reportError("iataNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.xTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-transactionId", r.xTransactionId, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadExternalProfileRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	extSystemCode string
	chainCode string
	profileExternalId string
	authorization *string
	xAppKey *string
	externalDatabaseId *string
	hotelId *string
	xTransactionId *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDownloadExternalProfileRequest) Authorization(authorization string) ApiDownloadExternalProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDownloadExternalProfileRequest) XAppKey(xAppKey string) ApiDownloadExternalProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Profile will be downloaded from this External database.
func (r ApiDownloadExternalProfileRequest) ExternalDatabaseId(externalDatabaseId string) ApiDownloadExternalProfileRequest {
	r.externalDatabaseId = &externalDatabaseId
	return r
}

// Hotel Code, It is used to filter hotel specific children to this specific hotel code.
func (r ApiDownloadExternalProfileRequest) HotelId(hotelId string) ApiDownloadExternalProfileRequest {
	r.hotelId = &hotelId
	return r
}

// Transaction Id
func (r ApiDownloadExternalProfileRequest) XTransactionId(xTransactionId string) ApiDownloadExternalProfileRequest {
	r.xTransactionId = &xTransactionId
	return r
}

// Language code
func (r ApiDownloadExternalProfileRequest) AcceptLanguage(acceptLanguage string) ApiDownloadExternalProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDownloadExternalProfileRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.DownloadExternalProfileExecute(r)
}

/*
DownloadExternalProfile Download a Profile from external system

After searching for profiles in an external system using getExternalProfiles, proceed to use this API knowing the external profile ID in the path.  The result will be a new profile created in OPERA. <p><strong>OperationId:</strong>downloadExternalProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extSystemCode If supplied, profile will be downloaded from this External System, otherwise it will be decided automatically based on the configuration.
 @param chainCode Chain code from which the External Profiles will be downloaded.
 @param profileExternalId Unique Identifier of the Profile on the External System.
 @return ApiDownloadExternalProfileRequest
*/
func (a *ProfileExternalApiService) DownloadExternalProfile(ctx context.Context, extSystemCode string, chainCode string, profileExternalId string) ApiDownloadExternalProfileRequest {
	return ApiDownloadExternalProfileRequest{
		ApiService: a,
		ctx: ctx,
		extSystemCode: extSystemCode,
		chainCode: chainCode,
		profileExternalId: profileExternalId,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileExternalApiService) DownloadExternalProfileExecute(r ApiDownloadExternalProfileRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.DownloadExternalProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/chains/{chainCode}/externalProfiles/{profileExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileExternalId"+"}", url.PathEscape(parameterValueToString(r.profileExternalId, "profileExternalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if strlen(r.profileExternalId) < 1 {
		return localVarReturnValue, nil, reportError("profileExternalId must have at least 1 elements")
	}
	if strlen(r.profileExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("profileExternalId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	if r.externalDatabaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalDatabaseId", r.externalDatabaseId, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.xTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-transactionId", r.xTransactionId, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	extSystemCode string
	chainCode string
	authorization *string
	xAppKey *string
	externalDatabaseId *string
	hotelId *string
	profileType *string
	profileId *[]string
	profileIdType *[]string
	name *string
	givenName *string
	city *string
	postalCode *string
	state *string
	countryCode *string
	keyword *string
	communication *string
	membershipNumber *string
	membershipType *string
	arNumber *string
	birthDate *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExternalProfilesRequest) Authorization(authorization string) ApiGetExternalProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExternalProfilesRequest) XAppKey(xAppKey string) ApiGetExternalProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Profile will be fetched from this External database.
func (r ApiGetExternalProfilesRequest) ExternalDatabaseId(externalDatabaseId string) ApiGetExternalProfilesRequest {
	r.externalDatabaseId = &externalDatabaseId
	return r
}

// Hotel Code, It is used to filter hotel specific children to this specific hotel code.
func (r ApiGetExternalProfilesRequest) HotelId(hotelId string) ApiGetExternalProfilesRequest {
	r.hotelId = &hotelId
	return r
}

// The types of Profile handled by the web service.
func (r ApiGetExternalProfilesRequest) ProfileType(profileType string) ApiGetExternalProfilesRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetExternalProfilesRequest) ProfileId(profileId []string) ApiGetExternalProfilesRequest {
	r.profileId = &profileId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetExternalProfilesRequest) ProfileIdType(profileIdType []string) ApiGetExternalProfilesRequest {
	r.profileIdType = &profileIdType
	return r
}

// Family name, last name or Company Name.
func (r ApiGetExternalProfilesRequest) Name(name string) ApiGetExternalProfilesRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r ApiGetExternalProfilesRequest) GivenName(givenName string) ApiGetExternalProfilesRequest {
	r.givenName = &givenName
	return r
}

// City (e.g., Dublin), town, or postal station (i.e., a postal service territory, often used in a military address).
func (r ApiGetExternalProfilesRequest) City(city string) ApiGetExternalProfilesRequest {
	r.city = &city
	return r
}

// Post Office Code number.
func (r ApiGetExternalProfilesRequest) PostalCode(postalCode string) ApiGetExternalProfilesRequest {
	r.postalCode = &postalCode
	return r
}

// State or Province name (e.g., Texas).
func (r ApiGetExternalProfilesRequest) State(state string) ApiGetExternalProfilesRequest {
	r.state = &state
	return r
}

// Code for a country or a nationality.
func (r ApiGetExternalProfilesRequest) CountryCode(countryCode string) ApiGetExternalProfilesRequest {
	r.countryCode = &countryCode
	return r
}

// Keyword associated to the profile.
func (r ApiGetExternalProfilesRequest) Keyword(keyword string) ApiGetExternalProfilesRequest {
	r.keyword = &keyword
	return r
}

// Any communication method associated to the profile such as phone, fax, eMail id.
func (r ApiGetExternalProfilesRequest) Communication(communication string) ApiGetExternalProfilesRequest {
	r.communication = &communication
	return r
}

// Membership number associated to the profile.
func (r ApiGetExternalProfilesRequest) MembershipNumber(membershipNumber string) ApiGetExternalProfilesRequest {
	r.membershipNumber = &membershipNumber
	return r
}

// Member Type of searching profile.
func (r ApiGetExternalProfilesRequest) MembershipType(membershipType string) ApiGetExternalProfilesRequest {
	r.membershipType = &membershipType
	return r
}

// Account Receivable associated to the profile.
func (r ApiGetExternalProfilesRequest) ArNumber(arNumber string) ApiGetExternalProfilesRequest {
	r.arNumber = &arNumber
	return r
}

// Date of birth
func (r ApiGetExternalProfilesRequest) BirthDate(birthDate string) ApiGetExternalProfilesRequest {
	r.birthDate = &birthDate
	return r
}

// Language code
func (r ApiGetExternalProfilesRequest) AcceptLanguage(acceptLanguage string) ApiGetExternalProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExternalProfilesRequest) Execute() (*ExternalProfiles, *http.Response, error) {
	return r.ApiService.GetExternalProfilesExecute(r)
}

/*
GetExternalProfiles Retrieve profiles from external system

Use this API when you want to search for profiles in an external system. The response will include a list of profiles that exist in the external system, based on your search criteria.  For example, you want to see if the external system has a profile for Mr David Smith.  The GET API will send a request to external system, and the response will include a list of any profiles that exist for Mr Davis Smith in that system.  If a profile does exist, and the user would like to 'download' that profile into OPERA, you would then proceed to use the downlodExternalProfiles API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extSystemCode Profiles will be fetched from this External System.
 @param chainCode Chain code from which the External Profiles will be fetched.
 @return ApiGetExternalProfilesRequest
*/
func (a *ProfileExternalApiService) GetExternalProfiles(ctx context.Context, extSystemCode string, chainCode string) ApiGetExternalProfilesRequest {
	return ApiGetExternalProfilesRequest{
		ApiService: a,
		ctx: ctx,
		extSystemCode: extSystemCode,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ExternalProfiles
func (a *ProfileExternalApiService) GetExternalProfilesExecute(r ApiGetExternalProfilesRequest) (*ExternalProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.GetExternalProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/chains/{chainCode}/externalProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	if r.externalDatabaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalDatabaseId", r.externalDatabaseId, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.profileId != nil {
		t := *r.profileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", t, "multi")
		}
	}
	if r.profileIdType != nil {
		t := *r.profileIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", t, "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.membershipNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipNumber", r.membershipNumber, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.arNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arNumber", r.arNumber, "")
	}
	if r.birthDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "birthDate", r.birthDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGamingOffersRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	membershipNo string
	extSystemCode string
	authorization *string
	xAppKey *string
	hotelId *string
	startDate *string
	endDate *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGamingOffersRequest) Authorization(authorization string) ApiGetGamingOffersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGamingOffersRequest) XAppKey(xAppKey string) ApiGetGamingOffersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Hotel Code for which the offers will be fetched.
func (r ApiGetGamingOffersRequest) HotelId(hotelId string) ApiGetGamingOffersRequest {
	r.hotelId = &hotelId
	return r
}

func (r ApiGetGamingOffersRequest) StartDate(startDate string) ApiGetGamingOffersRequest {
	r.startDate = &startDate
	return r
}

func (r ApiGetGamingOffersRequest) EndDate(endDate string) ApiGetGamingOffersRequest {
	r.endDate = &endDate
	return r
}

// Language code
func (r ApiGetGamingOffersRequest) AcceptLanguage(acceptLanguage string) ApiGetGamingOffersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGamingOffersRequest) Execute() (*GamingOffers, *http.Response, error) {
	return r.ApiService.GetGamingOffersExecute(r)
}

/*
GetGamingOffers Get offers that can be attached for a profile

Use this API when you have a guest profile and you want to get the offers available from an external system. <p><strong>OperationId:</strong>getGamingOffers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipNo
 @param extSystemCode
 @return ApiGetGamingOffersRequest
*/
func (a *ProfileExternalApiService) GetGamingOffers(ctx context.Context, membershipNo string, extSystemCode string) ApiGetGamingOffersRequest {
	return ApiGetGamingOffersRequest{
		ApiService: a,
		ctx: ctx,
		membershipNo: membershipNo,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return GamingOffers
func (a *ProfileExternalApiService) GetGamingOffersExecute(r ApiGetGamingOffersRequest) (*GamingOffers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GamingOffers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.GetGamingOffers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/gamingOffers/{membershipNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipNo"+"}", url.PathEscape(parameterValueToString(r.membershipNo, "membershipNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipNo) < 1 {
		return localVarReturnValue, nil, reportError("membershipNo must have at least 1 elements")
	}
	if strlen(r.membershipNo) > 2000 {
		return localVarReturnValue, nil, reportError("membershipNo must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayerStatisticsRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	profileId string
	extSystemCode string
	authorization *string
	xAppKey *string
	playerId *string
	hotelId *string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPlayerStatisticsRequest) Authorization(authorization string) ApiGetPlayerStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPlayerStatisticsRequest) XAppKey(xAppKey string) ApiGetPlayerStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Unique Identifier for PlayerID.
func (r ApiGetPlayerStatisticsRequest) PlayerId(playerId string) ApiGetPlayerStatisticsRequest {
	r.playerId = &playerId
	return r
}

// Code of the Hotel.
func (r ApiGetPlayerStatisticsRequest) HotelId(hotelId string) ApiGetPlayerStatisticsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ApiGetPlayerStatisticsRequest) ReservationId(reservationId string) ApiGetPlayerStatisticsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ApiGetPlayerStatisticsRequest) ReservationIdContext(reservationIdContext string) ApiGetPlayerStatisticsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ApiGetPlayerStatisticsRequest) ReservationIdType(reservationIdType string) ApiGetPlayerStatisticsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Language code
func (r ApiGetPlayerStatisticsRequest) AcceptLanguage(acceptLanguage string) ApiGetPlayerStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPlayerStatisticsRequest) Execute() (*FetchPlayerStatisticsRS, *http.Response, error) {
	return r.ApiService.GetPlayerStatisticsExecute(r)
}

/*
GetPlayerStatistics Retrieve player statistics

Request for the fetch player statistics WS operation <p><strong>OperationId:</strong>getPlayerStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique Identifier for profile ID
 @param extSystemCode External System Code
 @return ApiGetPlayerStatisticsRequest
*/
func (a *ProfileExternalApiService) GetPlayerStatistics(ctx context.Context, profileId string, extSystemCode string) ApiGetPlayerStatisticsRequest {
	return ApiGetPlayerStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return FetchPlayerStatisticsRS
func (a *ProfileExternalApiService) GetPlayerStatisticsExecute(r ApiGetPlayerStatisticsRequest) (*FetchPlayerStatisticsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchPlayerStatisticsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.GetPlayerStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/playerStatistics/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetValidatedAddressRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	externalAddressId string
	authorization *string
	xAppKey *string
	timeoutSeconds *int32
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetValidatedAddressRequest) Authorization(authorization string) ApiGetValidatedAddressRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetValidatedAddressRequest) XAppKey(xAppKey string) ApiGetValidatedAddressRequest {
	r.xAppKey = &xAppKey
	return r
}

// Maximum time you are prepared to wait for a response.
func (r ApiGetValidatedAddressRequest) TimeoutSeconds(timeoutSeconds int32) ApiGetValidatedAddressRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Language code
func (r ApiGetValidatedAddressRequest) AcceptLanguage(acceptLanguage string) ApiGetValidatedAddressRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetValidatedAddressRequest) Execute() (*ValidatedAddress, *http.Response, error) {
	return r.ApiService.GetValidatedAddressExecute(r)
}

/*
GetValidatedAddress Get full Address information from third party system for a given external Address ID. The external Address ID is fetched from valdatedAddresses service.

Use this API when you want to fetch full address information for a given address Id. <p><strong>OperationId:</strong>getValidatedAddress</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalAddressId
 @return ApiGetValidatedAddressRequest
*/
func (a *ProfileExternalApiService) GetValidatedAddress(ctx context.Context, externalAddressId string) ApiGetValidatedAddressRequest {
	return ApiGetValidatedAddressRequest{
		ApiService: a,
		ctx: ctx,
		externalAddressId: externalAddressId,
	}
}

// Execute executes the request
//  @return ValidatedAddress
func (a *ProfileExternalApiService) GetValidatedAddressExecute(r ApiGetValidatedAddressRequest) (*ValidatedAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.GetValidatedAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validatedAddresses/{externalAddressId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalAddressId"+"}", url.PathEscape(parameterValueToString(r.externalAddressId, "externalAddressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalAddressId) < 1 {
		return localVarReturnValue, nil, reportError("externalAddressId must have at least 1 elements")
	}
	if strlen(r.externalAddressId) > 2000 {
		return localVarReturnValue, nil, reportError("externalAddressId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	if r.timeoutSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeoutSeconds", r.timeoutSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetValidatedAddressesRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	addressText *string
	country *string
	authorization *string
	xAppKey *string
	language *string
	timeoutSeconds *int32
	acceptLanguage *string
}

// The suggestion that should be presented to the user as a possible match to their input.
func (r ApiGetValidatedAddressesRequest) AddressText(addressText string) ApiGetValidatedAddressesRequest {
	r.addressText = &addressText
	return r
}

// The ID of the address recieved as part of an address search validation.
func (r ApiGetValidatedAddressesRequest) Country(country string) ApiGetValidatedAddressesRequest {
	r.country = &country
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetValidatedAddressesRequest) Authorization(authorization string) ApiGetValidatedAddressesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetValidatedAddressesRequest) XAppKey(xAppKey string) ApiGetValidatedAddressesRequest {
	r.xAppKey = &xAppKey
	return r
}

// The preferred language for results. This should be a 2 or 4 character language code.
func (r ApiGetValidatedAddressesRequest) Language(language string) ApiGetValidatedAddressesRequest {
	r.language = &language
	return r
}

// Maximum time you are prepared to wait for a response.
func (r ApiGetValidatedAddressesRequest) TimeoutSeconds(timeoutSeconds int32) ApiGetValidatedAddressesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Language code
func (r ApiGetValidatedAddressesRequest) AcceptLanguage(acceptLanguage string) ApiGetValidatedAddressesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetValidatedAddressesRequest) Execute() (*ValidatedAddresses, *http.Response, error) {
	return r.ApiService.GetValidatedAddressesExecute(r)
}

/*
GetValidatedAddresses Retrive valid addresses from a third party vendor.

Use this API when you want to validate address from a third party vendor. The response will be a list of addresses with its address ID based on the search criteria. <p><strong>OperationId:</strong>getValidatedAddresses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetValidatedAddressesRequest
*/
func (a *ProfileExternalApiService) GetValidatedAddresses(ctx context.Context) ApiGetValidatedAddressesRequest {
	return ApiGetValidatedAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidatedAddresses
func (a *ProfileExternalApiService) GetValidatedAddressesExecute(r ApiGetValidatedAddressesRequest) (*ValidatedAddresses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedAddresses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.GetValidatedAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validatedAddresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addressText == nil {
		return localVarReturnValue, nil, reportError("addressText is required and must be specified")
	}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "addressText", r.addressText, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.timeoutSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeoutSeconds", r.timeoutSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateMembershipNumberRequest struct {
	ctx context.Context
	ApiService *ProfileExternalApiService
	chainCode string
	extSystemCode string
	membershipNo *string
	membershipType *string
	authorization *string
	xAppKey *string
	hotelId *string
	acceptLanguage *string
}

// Indicates membership number of the guest
func (r ApiValidateMembershipNumberRequest) MembershipNo(membershipNo string) ApiValidateMembershipNumberRequest {
	r.membershipNo = &membershipNo
	return r
}

// Membership type for which point calculation process is to be run.
func (r ApiValidateMembershipNumberRequest) MembershipType(membershipType string) ApiValidateMembershipNumberRequest {
	r.membershipType = &membershipType
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiValidateMembershipNumberRequest) Authorization(authorization string) ApiValidateMembershipNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiValidateMembershipNumberRequest) XAppKey(xAppKey string) ApiValidateMembershipNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Hotel code from which the membership code belongs to
func (r ApiValidateMembershipNumberRequest) HotelId(hotelId string) ApiValidateMembershipNumberRequest {
	r.hotelId = &hotelId
	return r
}

// Language code
func (r ApiValidateMembershipNumberRequest) AcceptLanguage(acceptLanguage string) ApiValidateMembershipNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiValidateMembershipNumberRequest) Execute() (*ValidateMembershipNumber, *http.Response, error) {
	return r.ApiService.ValidateMembershipNumberExecute(r)
}

/*
ValidateMembershipNumber Validate Membership Number attached to a membership

Use this API when you want to validate membership numbers from external system. <p><strong>OperationId:</strong>validateMembershipNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainCode
 @param extSystemCode
 @return ApiValidateMembershipNumberRequest
*/
func (a *ProfileExternalApiService) ValidateMembershipNumber(ctx context.Context, chainCode string, extSystemCode string) ApiValidateMembershipNumberRequest {
	return ApiValidateMembershipNumberRequest{
		ApiService: a,
		ctx: ctx,
		chainCode: chainCode,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return ValidateMembershipNumber
func (a *ProfileExternalApiService) ValidateMembershipNumberExecute(r ApiValidateMembershipNumberRequest) (*ValidateMembershipNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateMembershipNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileExternalApiService.ValidateMembershipNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/chains/{chainCode}/validateMembershipNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if r.membershipNo == nil {
		return localVarReturnValue, nil, reportError("membershipNo is required and must be specified")
	}
	if r.membershipType == nil {
		return localVarReturnValue, nil, reportError("membershipType is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "membershipNo", r.membershipNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
